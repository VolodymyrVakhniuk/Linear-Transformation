// Hello,
// Please, don't make a full clone of this application for wide publishing purposes.
// Some of the code is shared, some parts have their own license linked in the comments.
// If you need something, you may contact matri-tri-ca@yandex.ru.
// Have a nice day!

"use strict"; // It will be in the beginning of a mjs.js.
/*jslint sloppy: true, indent: 2 */
/*global XMLHttpRequest, window, Node */

(function (global) {
  "use strict";

  var encodeURIComponentSafe = function (string) {
    //return encodeURIComponent(string.replace(/[\u{D800}-\u{DFFF}]/gu, '\uFFFD'));
    return encodeURIComponent(string.replace(/([^\uD800-\uDBFF])[\uDC00-\uDFFF]/g, '$1\uFFFD').replace(/[\uD800-\uDBFF](?![\uDC00-\uDFFF])/g, '\uFFFD'));
  };

  var sent = {};
  global.onerror = function (message, filename, lineno, colno, error) {
    message = message || "";
    filename = filename || "";
    lineno = lineno || 0;
    colno = colno || 0;
    error = error || undefined;
    var stack = error != undefined ? error.stack || "" : "";
    var data = "message=" + encodeURIComponentSafe(message.toString()) + "&" +
               "filename=" + encodeURIComponentSafe(filename.toString()) + "&" +
               "lineno=" + encodeURIComponentSafe(lineno.toString()) + "&" +
               "colno=" + encodeURIComponentSafe(colno.toString()) + "&" +
               "stack=" + encodeURIComponentSafe(stack.toString());
    if (sent[data] == undefined && window.location.protocol !== "file:") {
      sent[data] = data;
      var xhr = new XMLHttpRequest();
      xhr.open("POST", "https://matrixcalc.org/jserrors.php?error=1", true);
      xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
      xhr.send(data);
      if (error instanceof TypeError && lineno !== 1) {
        global.sendSnapshot();
      }
    }
  };

  var html2html = function (container) {
    var clone = container.cloneNode(true);
    var walk = function (node) {
      if (node.tagName.toLowerCase() === 'script' || node.tagName.toLowerCase() === 'iframe') {
        node.parentNode.removeChild(node);
      } else if (node.tagName.toLowerCase() === 'link') {
        if (node.getAttribute('rel') === 'stylesheet') {
          node.setAttribute('href', node.href); // set to an absolute URL
        } else {
          node.parentNode.removeChild(node);
        }
      } else if (node.tagName.toLowerCase() === 'input') {
        node.setAttribute('value', node.value);
      } else if (node.tagName.toLowerCase() === 'textarea') {
        node.textContent = node.value;
      }
      var next = node.firstElementChild;
      while (next != null) {
        var c = next;
        next = next.nextElementSibling; // as c could be removed
        walk(c);
      }
    };
    walk(clone);
    return new XMLSerializer().serializeToString(clone);
  };

  global.sendSnapshot = function () {
    if (global.document != undefined) {
      var activeElement = global.document.querySelector(":focus");
      if (activeElement != null) {
        activeElement.setAttribute("data-state", "focus");
        activeElement.setAttribute("autofocus", "autofocus"); // as huge snapshot may be truncated and style can be cutted out
      }
      var snapshot = html2html(global.document.documentElement);
      if (activeElement != null) {
        activeElement.removeAttribute("data-state");
        activeElement.removeAttribute("autofocus");
      }
      snapshot += "<style>[data-state=\"focus\"] { outline: 2px solid green; } </style>";
      var dataURL = "data:text/html;charset=utf-8," + snapshot.replace(/%/g, '%25').replace(/#/g, '%23');
      global.onerror(dataURL, "snapshot.js", 0, 0, undefined);
    }
  };

}(self));

/*global self*/

(function () { // to avoid global variables
"use strict";

  // Firefox < 4, Opera < 11.60, IE 8
  if (Object.create == undefined) {
    Object.create = function (prototype) {
      var F = function () {
      };
      F.prototype = prototype;
      return new F();
    };
  }

  // Opera 12
  if ((-2147483649).toString(16) === "-0" && (2147483649).toString(16) === "80000001") {
    var numberToString = Number.prototype.toString;
    Number.prototype.toString = function (radix) {
      "use strict";
      var value = 0 + this;
      return (value < 0 ? "-" : "") + numberToString.call(value < 0 ? 0 - value : value, radix);
    };
  }

  if (Object.assign == undefined) {
    Object.assign = function (target) {
      for (var i = 1; i < arguments.length; i += 1) {
        var source = arguments[i];
        if (source != undefined) {
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
      }
      return target;
    };
  }

  if (Object.getOwnPropertyDescriptor == undefined && Object.prototype.__lookupGetter__ != undefined && Object.prototype.__lookupSetter__ != undefined) {
    Object.getOwnPropertyDescriptor = function (object, property) {
      if (Object.prototype.hasOwnProperty.call(object, property)) {
        var getter = Object.prototype.__lookupGetter__.call(object, property);
        var setter = Object.prototype.__lookupSetter__.call(object, property);
        if (getter != undefined || setter != undefined) {
          return {
            get: getter,
            set: setter,
            enumerable: false,
            configurable: true
          };
        }
        return {
          value: object[property],
          writable: true,
          enumerable: true,
          configurable: true
        };
      }
      return undefined;
    };
  }

  // https://stackoverflow.com/a/15851520
  if (Object.getPrototypeOf == undefined) {
    Object.getPrototypeOf = function (object) {
      return object.__proto__ || object.constructor.prototype;
    };
  }

  if (String.prototype.trim == undefined) {
    String.prototype.trim = function () {
      "use strict";
      return String(this).replace(/^\s+|\s+$/g, '');
    };
  }

  if (String.prototype.repeat == undefined) {
    String.prototype.repeat = function (count) {
      "use strict";
      if (count < 0 || count % 1 !== 0 || count > 9007199254740991) {
        throw new TypeError();
      }
      var x = String(this);
      var accumulator = "";
      while (count > 0) {
        if (count % 2 === 1) {
          count -= 1;
          accumulator += x;
        } else {
          x += x;
          count /= 2;
        }
      }
      return accumulator;
    };
  }

  if (String.prototype.codePointAt == undefined) {
    String.prototype.codePointAt = function (index) {
      "use strict";
      var string = String(this);
      // https://github.com/mathiasbynens/String.prototype.codePointAt/blob/master/implementation.js
      // Get the first code unit
      var first = string.charCodeAt(index);
      if ( // check if it’s the start of a surrogate pair
        first >= 0xD800 && first <= 0xDBFF && // high surrogate
        string.length > index + 1 // there is a next code unit
      ) {
        var second = string.charCodeAt(index + 1);
        if (second >= 0xDC00 && second <= 0xDFFF) { // low surrogate
          // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
          return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
        }
      }
      return first;
    };
  }

  // from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCodePoint#Polyfill
  if (!String.fromCodePoint) (function(stringFromCharCode) {
    var fromCodePoint = function(_) {
      var codeUnits = [], codeLen = 0, result = "";
      for (var index=0, len = arguments.length; index !== len; ++index) {
        var codePoint = +arguments[index];
        // correctly handles all cases including `NaN`, `-Infinity`, `+Infinity`
        // The surrounding `!(...)` is required to correctly handle `NaN` cases
        // The (codePoint>>>0) === codePoint clause handles decimals and negatives
        if (!(codePoint < 0x10FFFF && (codePoint>>>0) === codePoint))
          throw RangeError("Invalid code point: " + codePoint);
        if (codePoint <= 0xFFFF) { // BMP code point
          codeLen = codeUnits.push(codePoint);
        } else { // Astral code point; split in surrogate halves
          // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
          codePoint -= 0x10000;
          codeLen = codeUnits.push(
            (codePoint >> 10) + 0xD800,  // highSurrogate
            (codePoint % 0x400) + 0xDC00 // lowSurrogate
          );
        }
        if (codeLen >= 0x3fff) {
          result += stringFromCharCode.apply(null, codeUnits);
          codeUnits.length = 0;
        }
      }
      return result + stringFromCharCode.apply(null, codeUnits);
    };
    try { // IE 8 only supports `Object.defineProperty` on DOM elements
      Object.defineProperty(String, "fromCodePoint", {
        "value": fromCodePoint, "configurable": true, "writable": true
      });
    } catch(e) {
      String.fromCodePoint = fromCodePoint;
    }
  }(String.fromCharCode));

  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith#Polyfill
  if (!String.prototype.endsWith) {
    String.prototype.endsWith = function(search, this_len) {
      if (this_len === undefined || this_len > this.length) {
        this_len = this.length;
      }
      return this.substring(this_len - search.length, this_len) === search;
    };
  }

  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith#Polyfill
  if (!String.prototype.startsWith) {
      String.prototype.startsWith = function(search, rawPos) {
          var pos = rawPos > 0 ? rawPos|0 : 0;
          return this.substring(pos, pos + search.length) === search;
      };
  }

  if (Array.prototype.map == undefined) {
    Array.prototype.map = function (f) {
      var x = new Array(this.length);
      for (var i = 0; i < this.length; i += 1) {
        x[i] = f(this[i], i);
      }
      return x;
    };
  }

  if (Array.prototype.filter == undefined) {
    Array.prototype.filter = function (f) {
      var x = [];
      for (var i = 0; i < this.length; i += 1) {
        var e = this[i];
        if (f(e, i)) {
          x.push(e)
        }
      }
      return x;
    };
  }

  if (Array.prototype.fill == undefined) {
    Array.prototype.fill = function (value, start, end) {
      var array = this;
      start = start || 0;
      if (start < 0) {
        start += array.length;
      }
      end = end == undefined ? array.length : end;
      if (end < 0) {
        end += array.length;
      }
      for (var i = start; i < end; i += 1) {
        array[i] = value;
      }
      return array;
    };
  }

  // IE < 9, Firefox < 4, Opera < 11.60
  if (Function.prototype.bind == undefined) {
    Function.prototype.bind = function (context) {
      var f = this;
      if (arguments.length === 1) {
        return function () {
          if (arguments.length === 0) {
            return f.call(context);
          }
          return f.apply(context, arguments);
        };
      } else {
        var args = Array.prototype.slice.call(arguments, 1);
        return function () {
          return f.apply(context, args.concat(Array.prototype.slice.call(arguments)));
        };
      }
    };
  }

  // IE < 9, Opera < 10.50
  if (Date.now == undefined) {
    Date.now = function () {
      return new Date().getTime();
    };
  }

  // Firefox < 4, Opera < 11.60
  if (Object.defineProperty == undefined && Object.prototype.__defineGetter__ != undefined && Object.prototype.__defineSetter__ != undefined) {
    Object.defineProperty = function (object, property, descriptor) {
      var getter = descriptor.get;
      if (getter != undefined) {
        object.__defineGetter__(property, getter);
      }
      var setter = descriptor.set;
      if (setter != undefined) {
        object.__defineSetter__(property, setter);
      }
    };
  }

  if (Number.parseFloat == undefined) {
    Number.parseFloat = parseFloat;
  }

  if (Number.isNaN == undefined) {
    Number.isNaN = function (x) {
      return typeof x === "number" && 0 + x !== 0 + x;
    };
  }

  if (Math.cbrt == undefined || Math.cbrt(64) !== 4) {
    Math.cbrt = function (x) {
      x = Number(x);
      // http://en.wikipedia.org/wiki/Cube_root#Numerical_methods
      if (x !== x || x === 0 || x === -1 / 0 || x === +1 / 0) {
        return x;
      }
      var a = Math.abs(x);
      var y0 = Math.exp(Math.log(a) / 3);
      return (x / a) * (y0 + (a / (y0 * y0) - y0) / 3);
    };
  }

  if (Math.log2 == undefined) {
    Math.log2 = function (x) {
      return Math.log(x) * Math.LOG2E;
    };
  }

  if (Math.log10 == undefined) {
    Math.log10 = function (x) {
      return Math.log(x) * Math.LOG10E;
    };
  }

  if (!Math.hypot) Math.hypot = function () {
    var max = 0;
    var s = 0;
    var containsInfinity = false;
    for (var i = 0; i < arguments.length; ++i) {
      var arg = Math.abs(Number(arguments[i]));
      if (arg === Infinity)
        containsInfinity = true
      if (arg > max) {
        s *= (max / arg) * (max / arg);
        max = arg;
      }
      s += arg === 0 && max === 0 ? 0 : (arg / max) * (arg / max);
    }
    return containsInfinity ? Infinity : (max === 1 / 0 ? 1 / 0 : max * Math.sqrt(s));
  };

  if (!Math.clz32) Math.clz32 = function(x) {
    x = x >>> 0;
    return x === 0 ? 32 : 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E);
  };

  if (!Math.sign) Math.sign = function (x) {
    return x < 0 ? -1 : (x > 0 ? +1 : x);
  };

// Firefox < 3.5, ...
if (self.JSON == undefined) {
  self.JSON = {
    parse: function (x) {
      return eval("(" + x + ")");
    },
    stringify: function (x) {
      var quote = function (string) {
        return "\"" + string.replace(/[\x00-\x1f\\"]/g, function (character) {
          return "\\u" + (0x10000 + character.charCodeAt(0)).toString(16).slice(1);
        }) + "\"";
      };
      if (typeof x === "object") {
        if (typeof x.toJSON === "function") {
          return quote(x.toJSON().toString());
        }
        var isArray = x.length != undefined;
        var f = false;
        var s = "";
        s += isArray ? "[" : "{";
        for (var i in x) {
          if (Object.prototype.hasOwnProperty.call(x, i)) {
            var v = x[i];
            if (v != undefined) {
              if (f) {
                s += ",";
              }
              f = true;
              s += (isArray ? "" : quote(i) + ":") + JSON.stringify(v);
            }
          }
        }
        s += isArray ? "]" : "}";
        return s;
      }
      if (typeof x === "number" || typeof x === "boolean") {
        return x.toString();
      }
      return x == undefined ? "null" : quote(x.toString());
    }
  };
}

if (!("globalThis" in self)) {
  self.globalThis = self;
}

if (globalThis.Symbol == null) {
  globalThis.Symbol = {};
  globalThis.Symbol.iterator = '@@iterator';
  Array.prototype[globalThis.Symbol.iterator] = function () {
    return this.values();
  };
}

if (Array.from == undefined) {
  Array.from = function (iterable, mapFn) {
    if (typeof iterable.next !== "function") { // this is wrong: instead it shoud text the Symbol.iterable
      var arrayLike = iterable;
      var result = new Array(arrayLike.length);
      for (var i = 0; i < arrayLike.length; i += 1) {
        result[i] = mapFn != undefined ? mapFn(arrayLike[i], i) : arrayLike[i];
      }
      return result;
    }
    var result = [];
    for (var i = iterable, x = i.next().value; x != undefined; x = i.next().value) {
      result.push(mapFn != undefined ? mapFn(x, result.length) : x);
    }
    return result;
  };
}

if (Array.prototype.values == undefined) {
  Array.prototype.values = function () {
    var array = this;
    var i = -1;
    var result = {
      value: undefined,
      done: false
    };
    return {
      next: function () {
        i += 1;
        result.value = i < array.length ? array[i] : undefined;
        result.done = i >= array.length;
        return result;
      }
    };
  };
}

if (Array.prototype.indexOf == undefined) {
  Array.prototype.indexOf = function (valueToFind, fromIndex) {
    for (var i = ((fromIndex || 0) + this.length) % this.length; i < this.length; i += 1) {
      if (this[i] === valueToFind) {
        return i;
      }
    }
    return -1;
  };
}

if (Array.prototype.includes == undefined) {
  Array.prototype.includes = function (valueToFind, fromIndex) {
    return this.indexOf(valueToFind, fromIndex) !== -1;
  };
}

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flat#Alternatives
if (Array.prototype.flat == undefined) {
  // to enable deep level flatten use recursion with reduce and concat
  var flatDeep = function (arr, d) {
     return d > 0 ? arr.reduce(function (acc, val) { return acc.concat(Array.isArray(val) ? flatDeep(val, d - 1) : val); }, [])
                  : arr.slice();
  };
  Array.prototype.flat = function (depth) {
    return flatDeep(this, depth == undefined ? 1 : depth);
  };
}

if (Object.freeze == undefined) {
  Object.freeze = function (x) {
    return x;
  };
  Object.seal = function (x) {
    return x;
  };
  Object.preventExtensions = function (x) {
    return x;
  };
}

try {
  Object.freeze(undefined);
} catch (error) {
  var wrap = function (nativeFunction) {
    return function (x) {
      return typeof x !== "object" ? x : nativeFunction(x);
    };
  };
  Object.freeze = wrap(Object.freeze);
  Object.seal = wrap(Object.seal);
  Object.preventExtensions = wrap(Object.preventExtensions);
}

//Note: Number#toLocaleString is slow, same bugs are not fixed for native Intl.NumberFormat
if ((1).toLocaleString() === '1.00' ||
    (1).toLocaleString() === '1,00' ||
    (9007199254740991).toLocaleString().slice(-1).localeCompare('0') === 0) { // IE 8 or IE 11 or Edge 17, Safari < 11 ?, Chrome < ?
  Number.prototype.toLocaleString = function () {
    "use strict";
    return Number(this).toString();
  };
}

if (Number.MAX_SAFE_INTEGER == undefined) {
  Number.MAX_SAFE_INTEGER = 9007199254740991;
}

if (String.prototype.replaceAll == undefined) {
  (function () {
    var replaceAllCache = Object.create(null);
    var cacheSize = 0;
    function getRegExp(source) {
      var escapeRegExp = function (source) {
        // "-" is not escaped
        return source.replace(/[\/\\^$*+?.()|[\]{}]/g, '\\$&');
      };
      var value = replaceAllCache[source];
      if (value == undefined) {
        value = new RegExp(escapeRegExp(a), 'g');
        if (cacheSize === 1000) {
          for (var i in replaceAllCache) {
            if (Object.prototype.hasOwnProperty.call(replaceAllCache, i)) {
              delete cacheSize[i];
            }
          }
        }
        replaceAllCache[source] = value;
        cacheSize += 1;
      }
      return value;
    }
    String.prototype.replaceAll = function (a, b) {
      "use strict";
      return String(this).replace(typeof a === "string" ? getRegExp(a) : a, b);
    };
  }());
}

}());


/*global document, window, Element, Event, Node, HTMLElement, DOMTokenList, Document, DocumentFragment, HTMLInputElement, HTMLTextAreaElement, TextRange, DOMParser, Window, Image, CSSRule */

(function () { // to avoid global variables
"use strict";

// IE < 9, Firefox < 3.5
if (!("firstElementChild" in document.documentElement)) {
  (function () {
    function f(property0, property1, property2) {
      if (!(property0 in document.documentElement)) {
        Object.defineProperty(Element.prototype, property0, {
          get: function () {
            var t = this[property1];
            while (t != undefined && t.nodeType !== Node.ELEMENT_NODE) {
              t = t[property2];
            }
            return t;
          }
        });
      }
    }
    f("previousElementSibling", "previousSibling", "previousSibling");
    f("nextElementSibling", "nextSibling", "nextSibling");
    f("firstElementChild", "firstChild", "nextSibling");
    f("lastElementChild", "lastChild", "previousSibling");
  }());
}


// IE 11, Edge < 17, Chrome < 29, Firefox < 25, Safari < 9
var tmpFragment = document.createDocumentFragment();
if (!("firstElementChild" in tmpFragment) ||
    !("lastElementChild" in tmpFragment)) {
  (function () {
    function f(property0, property1, property2) {
      Object.defineProperty(DocumentFragment.prototype, property0, {
        get: function () {
          var t = this[property1];
          while (t != undefined && t.nodeType !== Node.ELEMENT_NODE) {
            t = t[property2];
          }
          return t;
        }
      });
    }
    f("firstElementChild", "firstChild", "nextSibling");
    f("lastElementChild", "lastChild", "previousSibling");
  }());
}


// Firefox < 3.5
if (Element.prototype.querySelectorAll == undefined) {
  if (Element.prototype.matches == undefined) {
    Element.prototype.matches = function (selector) {
      if (selector === "*") {
        return true;
      }
      var selectorRegExp = /^([a-zA-Z\-]+)?(\.[a-zA-Z\-]+)?(?:\[([a-zA-Z\-]+)(?:\="?([a-zA-Z\{\}\(\)\|#]+)"?)?\])?$/;
      var tmp = selectorRegExp.exec(selector);
      if (tmp == null) {
        throw new TypeError("Unsupported selector: " + selector);
      }
      var tagName = null;
      var className = null;
      var attributeName = null;
      var attributeValue = null;
      if (tmp[1] != null) {
        tagName = tmp[1].toLowerCase();//!
      }
      if (tmp[2] != null) {
        className = tmp[2].slice(1);
      }
      if (tmp[3] != null) {
        attributeName = tmp[3];
      }
      if (tmp[4] != null) {
        attributeValue = tmp[4];
      }
      return (tagName == null || this.tagName.toLowerCase() === tagName) &&
             (className == null || this.classList.contains(className)) &&
             (attributeName == null || this.getAttribute(attributeName) != null) &&
             (attributeValue == null || this.getAttribute(attributeName) === attributeValue);
    };
  }
  Element.prototype.querySelectorAll = function (selector) {
    var results = [];
    var traverse = function (x) {
      // https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR)
      if (x.matches(selector)) {
        results.push(x);
      }
      var c = x.firstElementChild;
      while (c != null) {
        traverse(c);
        c = c.nextElementSibling;
      }
    };
    traverse(this);
    return results;
  };
}
if (Element.prototype.querySelector == undefined) {
  Element.prototype.querySelector = function (s) {
    var x = this.querySelectorAll(s);
    return x.length === 0 ? undefined : x[0];
  };
}
if (Document.prototype.querySelectorAll == undefined) {
  Document.prototype.querySelectorAll = function (s) {
    return this.documentElement.querySelectorAll(s);
  };
}
if (Document.prototype.querySelector == undefined) {
  Document.prototype.querySelector = function (s) {
    return this.documentElement.querySelector(s);
  };
}


// in Opera 12 a getter on Element.prototype somehow handles the access to html elements
if (!('classList' in HTMLElement.prototype) && Object.getOwnPropertyDescriptor(document.documentElement, 'classList') != null) {
	Object.defineProperty(HTMLElement.prototype, 'classList', Object.getOwnPropertyDescriptor(document.documentElement, 'classList'));
}

// HTMLELement#classList for (IE 8 - IE 9, Konqueror 4.13, Firefox < 3.6, Opera < 11.60)
// Object.defineProperty with DOM

if (!('classList' in Element.prototype)) {
  (function () {
    var update = function (cl) {
      for (var i = 0; i < cl.tokens.length; i += 1) {
        cl[i] = cl.tokens[i];
      }
      for (var j = cl.tokens.length; j < cl.length; j += 1) {
        cl[j] = null;
      }
      cl.length = cl.tokens.length;
    };

    function ClassList(element) {
      this.element = element;
      // Element#className is not supported on MathML elements in older browsers
      // Element#className is overriden for svg elements
      var s = (element.getAttribute('class') || '').replace(/^\s+|\s+$/g, '').replace(/\s+/g, ' ');
      this.tokens = s === '' ? [] : s.split(' ');
      this.length = 0;
      update(this);
    }

    //ClassList.prototype.item = function (index) {
    //  return index < this.tokens.length ? this.tokens[index] : null;
    //};
    ClassList.prototype.contains = function (className) {
      for (var i = 0; i < this.tokens.length; i += 1) {
        if (this.tokens[i] === className) {
          return true;
        }
      }
      return false;
    };
    ClassList.prototype.add = function (className) {
      for (var j = 0; j < this.tokens.length; j += 1) {
        if (this.tokens[j] === className) {
          return;
        }
      }
      this.tokens.push(className);
      update(this);
      this.element.setAttribute('class', this.tokens.join(' '));
    };
    ClassList.prototype.remove = function (className) {
      var k = 0;
      for (var i = 0; i < this.tokens.length; i += 1) {
        if (this.tokens[i] !== className) {
          this.tokens[k] = this.tokens[i];
          k += 1;
        }
      }
      if (k === this.tokens.length) {
        return;
      }
      this.tokens.length = k;
      update(this);
      this.element.setAttribute('class', this.tokens.join(' '));
    };
    ClassList.prototype.toggle = function (className, force) {
      force = force == undefined ? !this.contains(className) : force;
      if (force) {
        this.add(className);
      } else {
        this.remove(className);
      }
      return force;
    };
    ClassList.prototype.toString = function () {
      return this.tokens.join(' ');
    };

    if (!('classList' in document.documentElement)) {
      Object.defineProperty(HTMLElement.prototype, 'classList', {
        get: function () {
          return new ClassList(this);
        }
      });
      window.DOMTokenList = ClassList;
    }

    /*
    if (!('className' in Element.prototype) && document.createElementNS('http://www.w3.org/1998/Math/MathML', 'math').className == null) {
      Object.defineProperty(Element.prototype, 'className', {
        get: function () {
          return this.getAttribute('class') || '';
        },
        set: function (value) {
          this.setAttribute('class', value);
        }
      });
    }
    */

    // IE 11
    //TODO: mrow.far
    //TODO: !
    Object.defineProperty(Element.prototype, 'classList', {
      get: function () {
        return new ClassList(this);
      }
    });

  }());
}

// IE 10 - IE 11, Opera 11.50 - Opera 12.18, Firefox < 24, Chrome < 24, Safari < 7
if (document.documentElement.classList.toggle('test', false)) {
  DOMTokenList.prototype.toggle = function (token, force) {
    force = force == undefined ? !this.contains(token) : force;
    if (force) {
      this.add(token);
    } else {
      this.remove(token);
    }
    return force;
  };
}


// IE 8 - IE 9 Drag and Drop helper
if (window.XDomainRequest != undefined && !("draggable" in document.documentElement)) {
  document.addEventListener("selectstart", function (event) {
    if (!event.altKey) {
      var target = event.target;
      while (target != null && !(target.nodeType === Node.ELEMENT_NODE && target.getAttribute("draggable") != null)) {
        target = target.parentNode;
      }
      if (target != null) {
        event.preventDefault();
        target.dragDrop();
      }
    }
  }, false);
  //TODO:
  //document.documentElement.draggable = undefined; //Note: this will add the attribute "draggable" too in IE 8
}

// IE 8 does not support input event
// IE 9 does not fire input event sometimes
// Opera 12 does not fire input event after Drag and Drop (dragend)
// Opera 12 also does not fire input event when using "Undo" from the contextmenu
// Firefox 3.5 does not fire input event when drag and dropping text into an <input> element or a <textarea> element (see https://caniuse.com/input-event )
if (window.XDomainRequest != undefined || window.opera != undefined || window.FileReader == undefined) {
  (function () {
    document.addEventListener("input", function (event) {
      event.target.setAttribute("data-last-value", event.target.value);
    }, false);

    var fire = function (type, element) {
      window.setTimeout(function () {
        var event = document.createEvent("Event");
        event.initEvent(type, true, false);
        element.dispatchEvent(event);
      }, 0);
    };

    var check = function (elements) {
      for (var i = 0; i < elements.length; i += 1) {
        var e = elements[i];
        var lastValue = e.getAttribute("data-last-value");
        var value = String(e.value);
        if (lastValue !== value) {
          fire("input", e);
        }
      }
    };

    var inputs = document.getElementsByTagName("input");
    var textareas = document.getElementsByTagName("textarea");

    var checkElements = function (event) {
      window.setTimeout(function () {
        check(inputs);
        check(textareas);
      }, 0);
    };

    document.addEventListener("keydown", checkElements, false);
    document.addEventListener("keyup", checkElements, false);
    document.addEventListener("cut", checkElements, false);
    document.addEventListener("paste", checkElements, false);
    document.addEventListener("dragend", checkElements, false);
    document.addEventListener("drop", checkElements, false);
    document.addEventListener("mouseleave", checkElements, false); // Opera 12 Undo from Context Menu

    //var checkInputs = function () {
    //  check(inputs);
    //  check(textareas);
    //  window.setTimeout(checkInputs, 300);
    //};

    //window.setTimeout(checkInputs, 300);
  }());
}


// Chrome < 30, Firefox < 10, Safari < 7
if (!("onmouseenter" in document.documentElement)) {
  document.addEventListener("mouseover", function (event) {
    if (!event.target.contains(event.relatedTarget)) {
      var e = document.createEvent("MouseEvent");
      e.initMouseEvent("mouseenter", false, false, event.view, event.detail,  event.screenX, event.screenY, event.clientX, event.clientY, event.ctrlKey, event.altKey, event.shiftKey, event.metaKey, event.button, event.relatedTarget);
      event.target.dispatchEvent(e);
    }
  }, false);
  document.documentElement.onmouseenter = undefined;
}

// Chrome < 30, Firefox < 10, Safari < 7
if (!("onmouseleave" in document.documentElement)) {
  document.addEventListener("mouseout", function (event) {
    if (!event.target.contains(event.relatedTarget)) {
      var e = document.createEvent("MouseEvent");
      e.initMouseEvent("mouseleave", false, false, event.view, event.detail,  event.screenX, event.screenY, event.clientX, event.clientY, event.ctrlKey, event.altKey, event.shiftKey, event.metaKey, event.button, event.relatedTarget);
      event.target.dispatchEvent(e);
    }
  }, false);
  document.documentElement.onmouseleave = undefined;
}

// Firefox < 6, Opera 10, Chrome < 18
if (!("defaultPrevented" in Event.prototype) && !("defaultPrevented" in document.createEvent("Event"))) {
  var preventDefault = Event.prototype.preventDefault;
  Event.prototype.preventDefault = function () {
    this.defaultPrevented = true;
    preventDefault.call(this);
  };
}

// IE 8 - IE 11 (not Edge)
if (window.clipboardData != undefined) {
  Object.defineProperty(Event.prototype, "clipboardData", {
    get: function () {
      return window.clipboardData;
    }
  });
}

// IE 8 - IE 11, Edge < 17
// see notes at http://caniuse.com/#feat=clipboard
// only for IE? (Safari < 10 does not support `document.execCommand('copy')`, but works fine with `Ctrl+C`)
if (!("oncopy" in document)) {
  window.setTimeout(function () {
    var removeCopyFix = function () {
      var copyFix = document.getElementById("copy-fix");
      if (copyFix != undefined) {
        copyFix.parentNode.removeChild(copyFix);
      }
    };

    var addCopyFix = function () {
      var activeElement = document.activeElement;
      if (activeElement == undefined || activeElement.tagName.toLowerCase() !== 'input' && activeElement.tagName.toLowerCase() !== 'textarea') {
        var selection = window.getSelection();
        if (selection.isCollapsed) {
          var copyFix = document.createElement("div");
          copyFix.id = "copy-fix";
          copyFix.innerHTML = "&nbsp;";
          document.body.appendChild(copyFix);
          var focusedNode = document.activeElement; // IE 11
          selection.collapse(copyFix, 0);
          selection.selectAllChildren(copyFix);
          focusedNode.focus();
          window.setTimeout(function () {
            removeCopyFix();
          }, 0);
        }
      }
    };

    var addPasteFix = function () {
      var activeElement = document.activeElement;
      if (activeElement != undefined && activeElement.tagName.toLowerCase() !== 'input' && activeElement.tagName.toLowerCase() !== 'textarea') {
        var selection = window.getSelection();
        if (selection.isCollapsed) {
          var input = document.createElement('input');
          input.style.position = 'absolute';
          input.style.overflow = 'hidden';
          input.style.width = '0px';
          input.style.height = '0px';
          input.style.display = 'inline-block';
          activeElement.appendChild(input);
          input.focus();
          window.setTimeout(function () {
            input.parentNode.removeChild(input);
            activeElement.focus();
          }, 0);
        }
      }
    };

    document.addEventListener("keydown", function (event) {
      if (event.keyCode === "C".charCodeAt(0) && (event.ctrlKey || event.metaKey) && !event.altKey && !event.shiftKey && !event.defaultPrevented) {
        addCopyFix();
      }
      if (event.keyCode === "V".charCodeAt(0) && (event.ctrlKey || event.metaKey) && !event.altKey && !event.shiftKey && !event.defaultPrevented) {
        addPasteFix();
      }
    }, false);

    var nativeExecCommand = document.execCommand;
    document.execCommand = function (name, showDefaultUI, value) {
      if (name === "copy") {
        addCopyFix();
      }
      return nativeExecCommand.call(this, name, showDefaultUI, value);
    };

    document.addEventListener("copy", function (event) {
      removeCopyFix();
    }, false);
  }, 0);
}

// Chrome < 20, Safari < 6, Firefox < 5
if (HTMLElement.prototype.click == undefined) {
  HTMLElement.prototype.click = function (element) {
    var event = document.createEvent("MouseEvent");
    event.initMouseEvent("click", true, true, window, 1, 0, 0, 0, 0, false, false, false, false, 0, undefined);
    this.dispatchEvent(event);
  };
}

// Firefox < 9
if (Node.prototype.contains == undefined) {
  Node.prototype.contains = function (otherNode) {
    var x = otherNode;
    while (x != undefined && x !== this) {
      x = x.parentNode;
    }
    return x != undefined;
  };
}


// Scrolling while you're dragging
// Chrome 49 - OK, Opera 12 - OK, IE 8 - not OK, IE 11 - OK, Firefox < 53
// https://bugzilla.mozilla.org/show_bug.cgi?id=41708
// TypeError: Cannot use 'in' operator to search for 'mozCursor' in undefined in Safari
if ((window.DataTransfer != undefined && window.DataTransfer.prototype != undefined && "mozCursor" in window.DataTransfer.prototype && !("caretColor" in document.documentElement.style)) || window.XDomainRequest != undefined) {
  (function () {
    var getScrollDelta = function (distanceToStartEdge, distanceToEndEdge) {
      return distanceToStartEdge < 16 ? -Math.pow(16 - distanceToStartEdge, 2) : (distanceToEndEdge < 16 ? +Math.pow(distanceToEndEdge - 16, 2) : 0);
    };
    var lastScrollTop = 0;
    var lastScrollLeft = 0;
    document.addEventListener('dragover', function (event) {
      if (lastScrollTop === window.pageYOffset || lastScrollLeft === window.pageXOffset) { // The skip if the web browser has the support of this feature
        var dy = getScrollDelta(event.clientY, window.innerHeight - event.clientY);
        var dx = getScrollDelta(event.clientX, window.innerWidth - event.clientX);
        if (dy !== 0 || dx !== 0) {
          window.scrollBy(dx, dy);
        }
      }
      lastScrollTop = window.pageYOffset;
      lastScrollLeft = window.pageXOffset;
    }, false);
  }());
}

// https://bugzilla.mozilla.org/show_bug.cgi?id=688580 (Firefox < 31)
if ("MozBackgroundInlinePolicy" in document.documentElement.style && document.readyState === "interactive") {
  (function () {
    var contentLoadedTimeoutId = 0;
    var onTimeout = function () {
      contentLoadedTimeoutId = window.setTimeout(onTimeout, 10);
      if (document.readyState === "complete") {
        var event = document.createEvent("Event");
        event.initEvent("DOMContentLoaded", false, false);
        document.dispatchEvent(event);
      }
    };
    onTimeout();
    document.addEventListener("DOMContentLoaded", function (event) {
      window.clearTimeout(contentLoadedTimeoutId);
    }, false);
  }());
}

// Chrome < 4, Firefox < 4, IE < 9, Opera < 11, Safari < 5
if (!("head" in document)) {
  document.head = document.documentElement.firstElementChild;
}


// IE ? - IE 11
// Negative event.clientX and event.clientY when using "element.click()" or when a user presses Enter on <button>
if (window.clipboardData != undefined && window.MouseEvent != undefined) {
  var redefineClientXY = function (property) {
    var clinetXDescriptor = Object.getOwnPropertyDescriptor(window.MouseEvent.prototype, "clientX");
    var clinetYDescriptor = Object.getOwnPropertyDescriptor(window.MouseEvent.prototype, "clientY");
    Object.defineProperty(window.MouseEvent.prototype, property, {
      get: function () {
        if (this.screenX === 0 && this.screenY === 0) {
          return 0; // IE 11
        }
        var rect = this.target.getBoundingClientRect();
        var x = clinetXDescriptor.get.call(this);
        var y = clinetYDescriptor.get.call(this);
        return x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom ? (property === "clientX" ? x : y) : 0;
      }
    });
  };
  redefineClientXY("clientX");
  redefineClientXY("clientY");
}

//TODO: more simple test - ?
// IE 8 - IE 9
if (!("hidden" in document.documentElement)) {
  var tmp = document.createElement('div');
  tmp.innerHTML = '&ii;';
  if (tmp.textContent === '&ii;') {
    var innerHTML = Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'innerHTML');
    if (innerHTML != null) {
      Object.defineProperty(HTMLElement.prototype, 'innerHTML', {
        get: function () {
          return innerHTML.get.call(this);
        },
        set: function (value) {
          var s = value.replace(/&[a-zA-Z]+;/g, function (p) {
            switch (p) {
              case '&af;': return '&#x2061;';
              case '&it;': return '&#x2062;';
              case '&ic;': return '&#x2063;';
              case '&ii;': return '&#x2148;';
              case '&vellip;': return '&#x22EE;';
              case '&UnderBrace;': return '&#x23DF;';
            }
            return p;
          });
          innerHTML.set.call(this, s);
        }
      });
    }
  }
}

// Chrome < 6, Firefox < 4, IE < 11, Opera < 11, Safari < 5.1
// https://codepen.io/valtlai/pen/wKyodg
if (!("hidden" in document.documentElement)) {
  Object.defineProperty(HTMLElement.prototype, "hidden", {
    get: function () {
      return this.getAttribute("hidden") != undefined;
    },
    set: function (value) {
      if (value !== "hidden") {// IE 8
        if (value) {
          this.setAttribute("hidden", "hidden");
        } else {
          this.removeAttribute("hidden");
        }
      }
    }
  });
}

// IE ? - IE 11 - <math><mrow id="test"><mn>1</mn></mrow></math>
if (window.clipboardData != undefined) {
  document.nativeGetElementById = document.getElementById;
  document.getElementById = function (id) {
    return document.nativeGetElementById(id) || (/^[_a-zA-Z0-9\-]+$/.exec(id) != undefined ? document.querySelector("[id=\"" + id + "\"]") : undefined);
  };
}

// Edge < 18, Safari < 11, Chrome < 61, Firefox < 45, Opera 12
if (Element.prototype.getAttributeNames == undefined) {
  Element.prototype.getAttributeNames = function () {
    var attributes = this.attributes;
    var length = attributes.length;
    var result = new Array(length);
    for (var i = 0; i < length; i += 1) {
      result[i] = attributes[i].name;
    }
    return result;
  };
}

//? some strange browser (bot)
if (Element.prototype.hasAttributes == undefined) {
  Element.prototype.hasAttributes = function () {
    return this.attributes.length > 0;
  };
}

if (window.navigator != undefined) {
  var connection = window.navigator.connection;
  // Note: `"connection" in window.navigator` is true in SamsungBrowser/1.1 Mobile Safari/537.3
  if (connection != undefined) {
    if (!("effectiveType" in connection)) {
      var type = connection.type;
      if (typeof type === "number") {
        // Android 4.1 - 4.4, UC Browser for Android 10.10 - 11.3
        connection.effectiveType = (connection.type === connection.CELL_2G ? "2g" : "unknown");
      } else {
        if ("downlinkMax" in connection) {
          // Chrome Mobile <= 60
          connection.effectiveType = connection.downlinkMax <= 70 ? "2g" : "unknown";
        }
      }
    }
    if (!("saveData" in connection)) {
      if ("metered" in connection) {
        connection.saveData = connection.metered;
      }
    }
  }
}

// https://dev.to/corbindavenport/how-to-correctly-check-for-do-not-track-with-javascript-135d
// IE 11
if (window.navigator != undefined) {
  if ("doNotTrack" in window && !("doNotTrack" in window.navigator)) {
    Object.defineProperty(window.navigator, "doNotTrack", {
      get: function () {
        return window.doNotTrack;
      }
    });
  }
}

// Opera < 11.50, Firefox < 4, IE < 10
if (window.console == undefined) {
  var consoleLog = function (s) {
    if (window.opera != undefined && window.opera.postError != undefined) {
      window.opera.postError(s);
    }
  };
  window.console = {
    log: consoleLog,
    info: consoleLog,
    warn: consoleLog,
    error: consoleLog
  };
}

// Firefox < 5  - https://bugzilla.mozilla.org/show_bug.cgi?id=616742#c30
if (window.console.debug == undefined) {
  window.console.debug = function (x) {
    window.console.log(x);
  };
}

//?
if (window.console.assert == undefined) {
  window.console.assert = function (x) {
    if (!x) {
      window.console.error("assertion failed");
    }
  };
}

if (window.console.time == undefined) {
  window.console.time = function () {
  };
}
if (window.console.timeEnd == undefined) {
  window.console.timeEnd = function () {
  };
}
if (window.console.count == undefined) {
  window.console.count = function () {
  };
}


// IE < 10
if (window.DataTransfer != null && !("types" in window.DataTransfer.prototype)) {
  Object.defineProperty(window.DataTransfer.prototype, "types", {
    get: function () {
      return ["Text"];
    },
    configurable: true
  });
}

// IE 11, Edge < 17
if (window.DataTransfer != undefined && !("oncopy" in document)) {
  var nativeSetData = window.DataTransfer.prototype.setData;
  window.DataTransfer.prototype.setData = function (type, data) {
    try {
      nativeSetData.call(this, type === "text/plain" ? "Text" : type, data);
    } catch (error) {
      window.console.log(error);
    }
  };
  var nativeGetData = window.DataTransfer.prototype.getData;
  window.DataTransfer.prototype.getData = function (type) {
    try {
      return nativeGetData.call(this, type === "text/plain" ? "Text" : type);
    } catch (error) {
      window.console.log(error);
    }
    return null;
  };
}

// Opera 12, IE?, window.DataTransfer is not an object in Opera Mini Classic
if (window.DataTransfer != undefined && (!("oncopy" in document) || window.opera != null)) {
  var nativeTypes = Object.getOwnPropertyDescriptor(window.DataTransfer.prototype, "types");
  Object.defineProperty(window.DataTransfer.prototype, "types", {
    get: function () {
      var types = nativeTypes.get.call(this) || ["Text"]; // null in IE 11
      var t = new Array(types.length);
      for (var i = 0; i < types.length; i += 1) {
        var type = types[i];
        t[i] = type === "Text" ? "text/plain" : type;
      }
      return t;
    },
    configurable: true
  });
}

if (HTMLInputElement.prototype.setSelectionRange == undefined) { // Opera Mini
  HTMLInputElement.prototype.setSelectionRange = function (start, end) {
    this.selectionStart = start;
    this.selectionEnd = end;
  };
}
if (HTMLTextAreaElement.prototype.setSelectionRange == undefined) { // Opera Mini
  HTMLTextAreaElement.prototype.setSelectionRange = function (start, end) {
    this.selectionStart = start;
    this.selectionEnd = end;
  };
}

// IE 8 - IE 11
// "scrollIntoView" behaviour for setSelectionRange
if (Object.getOwnPropertyDescriptor != undefined && HTMLInputElement.prototype.createTextRange != undefined) {
  var fixSetSelectionRange = function (C) {
    var setSelectionRange = C.prototype.setSelectionRange;
    C.prototype.setSelectionRange = function (selectionStart, selectionEnd, selectionDirection) {
      setSelectionRange.call(this, selectionStart, selectionEnd, selectionDirection);
      var textRange = this.createTextRange();
      textRange.moveStart("character", this.selectionStart);
      textRange.moveEnd("character", this.selectionEnd - this.value.length);
      textRange.scrollIntoView(true);
    };
  };
  fixSetSelectionRange(HTMLInputElement);
  fixSetSelectionRange(HTMLTextAreaElement);
}

// IE 8 - IE 10
// see https://github.com/codemirror/CodeMirror/commit/63591907b0dcd51c2f64dc967143e044ecac6923
if (Object.getOwnPropertyDescriptor != undefined && HTMLInputElement.prototype.createTextRange != undefined && document.attachEvent != undefined) {
  var originalGetBoundingClientRect = TextRange.prototype.getBoundingClientRect;
  TextRange.prototype.getBoundingClientRect = function () {
    var zoomX = window.screen.logicalXDPI / window.screen.deviceXDPI;
    var zoomY = window.screen.logicalYDPI / window.screen.deviceYDPI;
    var rect = originalGetBoundingClientRect.call(this);
    return {
      top: rect.top * zoomY,
      right: rect.right * zoomX,
      bottom: rect.bottom * zoomY,
      left: rect.left * zoomX,
      height: (rect.bottom - rect.top) * zoomY,
      width: (rect.right - rect.left) * zoomX
    };
  };
}

// https://connect.microsoft.com/IE/feedback/details/1015764/ie11-scrollleft-for-text-input-elements-is-always-0
// IE 11, Edge has problems with input.scrollLeft (always 0)
// IE 10 - IE 11 - input.scrollWidth
// see also https://github.com/gregwhitworth/scrollWidthPolyfill/
if (Object.getOwnPropertyDescriptor != undefined && HTMLInputElement.prototype.createTextRange != undefined) {
  var fixScrollProperty = function (property) {
    var originalScrollProperty = Object.getOwnPropertyDescriptor(Element.prototype, property);
    if (originalScrollProperty != undefined) {
      Object.defineProperty(Element.prototype, property, {
        get: function () {
          if (this.tagName.toLowerCase() !== 'input') {
            return originalScrollProperty.get.call(this);
          }
          var inputElement = this;
          var textRange = inputElement.createTextRange();
          var inputStyle = window.getComputedStyle(inputElement, undefined);
          var paddingLeft = Number.parseFloat(inputStyle.paddingLeft);
          var paddingRight = Number.parseFloat(inputStyle.paddingRight);
          var rangeRect = textRange.getBoundingClientRect();
          var scrollLeft = inputElement.getBoundingClientRect().left + inputElement.clientLeft + paddingLeft - rangeRect.left;
          var clientWidth = inputElement.clientWidth;
          var contentWidth = paddingLeft + (rangeRect.right - rangeRect.left) + paddingRight;
          var scrollWidth = clientWidth > contentWidth ? clientWidth : contentWidth;
          return property === "scrollLeft" ? scrollLeft : scrollWidth;
        },
        set: function (value) { // Note: it is not possible to use `originalScrollProperty.set` here in IE 8-?
          return originalScrollProperty.set.call(this, value);
        }
      });
    }
    fixScrollProperty("scrollLeft");
    //fixScrollProperty("scrollWidth");
  };
}


// IE <= 11, Opera <= 12, Firefox < 20 (caretPositionFromPoint)
if (document.caretPositionFromPoint == undefined && document.caretRangeFromPoint == undefined) {
  document.caretRangeFromPoint = function (x, y) {
    var getBoundingClientRect = function (textNode, startOffset, endOffset) {
      // Firefox 3.6 does not support Range#getBoundingClientRect
      //var range = document.createRange();
      //range.setStart(textNode, startOffset);
      //range.setEnd(textNode, endOffset); // Opera 12 needs a not collapsed range, seems
      //return range.getBoundingClientRect();
      var span = document.createElement('span');
      textNode.parentNode.insertBefore(span, textNode);
      textNode.parentNode.removeChild(textNode);
      var a = document.createElement('span');
      a.textContent = textNode.data.slice(0, startOffset);
      var b = document.createElement('span');
      b.textContent = textNode.data.slice(startOffset, endOffset);
      var c = document.createElement('span');
      c.textContent = textNode.data.slice(endOffset);
      span.appendChild(a);
      span.appendChild(b);
      span.appendChild(c);
      var rect = b.getBoundingClientRect();
      span.parentNode.insertBefore(textNode, span);
      span.parentNode.removeChild(span);
      return rect;
    };
    var element = document.elementFromPoint(x, y);
    var walk = function (candidate, e, x, y) {
      var node = candidate;
      var c = e.firstChild;
      if (c == undefined && e.nodeType === Node.TEXT_NODE && e.parentNode.tagName.toLowerCase() !== 'textarea') {
        var rect = getBoundingClientRect(e, 0, e.data.length);
        if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {
          node = e;
        }
      }
      while (c != undefined) {
        node = walk(node, c, x, y);
        c = c.nextSibling;
      }
      return node;
    };
    var node = walk(element, element, x, y);
    var index = 0;
    var c = node.parentNode.firstChild;
    while (c !== node) {
      index += 1;
      c = c.nextSibling;
    }
    var resultContainer = node.parentNode;
    var resultOffset = index;
    if (node.nodeType === Node.TEXT_NODE) {
      var length = node.data.length;
      var min = 1 / 0;
      for (var i = 0; i < length; i += 1) {
        var rect = getBoundingClientRect(node, i, i + 1);
        var d = x - (rect.left + rect.right) / 2;
        var distance = d < 0 ? 0 - d : 0 + d;
        if (distance < min && y >= rect.top && y <= rect.bottom) { // && rect.right === rect.left
          resultContainer = node;
          resultOffset = i;
          min = distance;
        }
      }
    }
    return {
      startContainer: resultContainer,
      startOffset: resultOffset,
      endContainer: resultContainer,
      endOffset: resultOffset + 1,
      commonAncestorContainer: resultContainer
    };
  };
}

// Firefox does not support "contextMenu" on MathML elements
// HTMLElement#hasOwnProperty does not exist in IE 8
if (Object.prototype.hasOwnProperty.call(HTMLElement.prototype, 'contextMenu')) {
  document.addEventListener('contextmenu', function (event) {
    var target = event.target.closest('[contextmenu]');
    if (target != null) {
      document.documentElement.setAttribute('contextmenu', target.getAttribute('contextmenu'));
    } else {
      document.documentElement.removeAttribute('contextmenu');
    }
  }, false);
}

// TODO: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/4365703/
// IE 11
// The default value is 0 if the element is an a, area, button, frame, iframe, input, object, select, textarea, or SVG a element, or is a summary element that is a summary for its parent details. The default value is −1 otherwise.
if (document.createElement('div').tabIndex === 0) {
  delete HTMLElement.prototype.tabIndex;
  Object.defineProperty(Element.prototype, 'tabIndex', {
    get: function () {
      var tabIndex = this.getAttribute('tabindex');
      if (tabIndex != null) {
        if (this.namespaceURI === 'http://www.w3.org/1998/Math/MathML') {//TODO: ?
          return -1; // as we cannot polyfill Element#focus ...
        }
        return Number(tabIndex);
      }
      var tagName = this.tagName.toLowerCase();
      if (/^(?:a|button|input|select|textarea|summary)$/.test(tagName)) {
        return 0;
      }
      return -1;
    },
    set: function (value) {
      this.setAttribute('tabindex', value);
    }
  });
}



if ('MSBlobBuilder' in window) {
  // to fix an issue in Edge 18: enter key event is fired even when the user selects something from the datalist?/the list of previously enter values
  document.addEventListener('keydown', function (event) {
    var input = event.target;
    if (input.tagName.toLowerCase() === 'input' && input.getAttribute('list') == null) {
      var DOM_VK_DOWN = 40;
      if (event.keyCode === DOM_VK_DOWN) {
        input.setAttribute('data-disallow-enter', 'true');
      }
      var DOM_VK_ESCAPE = 27;
      if (event.keyCode === DOM_VK_ESCAPE) {
        input.removeAttribute('data-disallow-enter');
      }
      var DOM_VK_RETURN = 13;
      if (event.keyCode === DOM_VK_RETURN) {
        if (input.getAttribute('data-disallow-enter') != null) {
          input.removeAttribute('data-disallow-enter');
          event.stopImmediatePropagation();
        }
      }
    }
  }, true);
}

// in Opera 12 a getter on Element.prototype somehow handles the access to html elements
if (!("innerHTML" in HTMLElement.prototype) && Object.getOwnPropertyDescriptor(document.documentElement, 'innerHTML') != null) {
	Object.defineProperty(HTMLElement.prototype, 'innerHTML', Object.getOwnPropertyDescriptor(document.documentElement, 'innerHTML'));
}

//IE 11, Firefox 4 - ?, Safari 5.1 - ?, Chrome ?, Opera 12.18
if (!("innerHTML" in Element.prototype)) {
  Object.defineProperty(Element.prototype, 'innerHTML', {
    get: function () {
      var tmp = document.createElement('div');
      for (var child = this.firstChild; child != null; child = child.nextSibling) {
        tmp.appendChild(child.cloneNode(true));
      }
      return tmp.innerHTML;
    },
    set: function (value) {
      var xml = document.createElement('div');
      xml.innerHTML = value;
      while (this.firstChild != null) {
        this.firstChild.parentNode.removeChild(this.firstChild);
      }
      while (xml.firstChild != null) {
        this.appendChild(xml.firstChild);
      }
    },
    configurable: true
  });
}


// TODO: Firefox bug, Edge bug
// Firefox does not scroll while dragover for <input>
// IE does not scorll while dragover for <input>
if (!("webkitUserDrag" in document.documentElement.style)) { //TODO: proper detection
  var lastScrollLeft = 0;
  document.addEventListener('dragover', function (event) {
    var input = event.target;//document.elementFromPoint(event.clientX, event.clientY);
    if (input.tagName.toLowerCase() === 'input') {
      if (lastScrollLeft === input.scrollLeft) { // The skip if the web browser has the support of this feature
        var rect = input.getBoundingClientRect();
        var distanceToLeftEdge = event.clientX - rect.left;
        var distanceToRightEdge = input.clientWidth - (event.clientX - rect.left);
        var dx = distanceToLeftEdge < 9 ? -6 : (distanceToRightEdge < 9 ? +6 : 0);
        dx = Math.max(dx, -input.scrollLeft);
        //dx = Math.min(dx, input.scrollWidth - input.clientWidth);
        if (dx !== 0) {
          //input.scrollBy(dx, 0);
          input.scrollLeft = input.scrollLeft + dx;// input.scrollBy() is not supported in Edge 18
        }
      }
      lastScrollLeft = input.scrollLeft;
    }
  }, false);
}





if (!('enterKeyHint' in HTMLInputElement.prototype)) {
  Object.defineProperty(HTMLInputElement.prototype, 'enterKeyHint', {
    get: function (value) {
      return input.getAttribute('mozactionhint');
    },
    set: function (value) {
      var input = this;
      input.setAttribute('mozactionhint', value);//?
    }
  });
}




  if (window.fetch == null) {
    if (window.Promise == null) {
      window.Promise = function (f) {
        this._q = null;
        this._e = null;
        var that = this;
        f(function (result) {
          if (that._q != null) {
            that._q(result);
          }
        }, function (error) {
          if (that._e != null) {
            that._e(error);
          }
        });
      };
      window.Promise.prototype.then = function (c, e) {
        var that = this;
        return new window.Promise(function (resolve, reject) {
          that._q = function (result) {
            if (c != null) {
              window.Promise.resolve(c(result)).then(resolve, reject);
            } else {
              resolve(result);
            }
          };
          that._e = function (error) {
            if (e != null) {
              window.Promise.resolve(e(error)).then(resolve, reject);
            } else {
              reject(error);
            }
          };
        });
      };
      window.Promise.prototype["catch"] = function (onRejected) {
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch
        return this.then(undefined, onRejected);
      };
      window.Promise.resolve = function (value) {
        if (value != null && typeof value.then === "function") {
          return value;
        }
        return new window.Promise(function (resolve, reject) {
          window.setTimeout(function () {
            resolve(value);
          }, 0);
        });
      };
    }
    window.Response = function (xhr) {
      this.xhr = xhr;
    };
    window.Response.prototype.json = function () {
      var json = this.xhr.response;
      return Promise.resolve(json != null && typeof json !== "string" ? json : JSON.parse(json || this.xhr.responseText));
    };
    window.Response.prototype.text = function () {
      return Promise.resolve(this.xhr.response || this.xhr.responseText);
    };
    window.fetch = function (url) {
      return new Promise(function (resolve, reject) {
        var xhr = new window.XMLHttpRequest();
        xhr.open('GET', url, true);
        try {
          xhr.responseType = url.indexOf('.json') !== -1 ? 'json' : 'text';
        } catch (error) {
          // Safari 5.1.7 throws an error for "json" response type.
          //TODO: ??? add the note to MDN
        }
        xhr.onreadystatechange = function () {
          if (xhr.readyState === 4) {
            // XMLHttpRequest#responseText throws InvalidStateError in Opera 12 when XMLHttpRequest#responseType is used and has value "json"
            if (xhr.response != null || xhr.responseText !== '') {
              resolve(new window.Response(xhr));
            } else {
              reject(new Error());
            }
          }
        };
        xhr.send(null);
      });
    };
  }



// https://developer.mozilla.org/en-US/docs/Web/API/ParentNode/childElementCount#Polyfill_for_IE8_IE9_Safari
if (!('childElementCount' in Element.prototype)) {
  Object.defineProperty(Element.prototype, 'childElementCount', {
    get: function() {
      var count = 0;
      var child = this.firstElementChild;
      while (child != null) {
        count += 1;
        child = child.nextElementSibling;
      }
      return count;
    }
  });
}


/*
 * DOMParser HTML extension
 * 2019-11-13
 *
 * By Eli Grey, http://eligrey.com
 * Public domain.
 * NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.
 */

/*! @source https://gist.github.com/1129031 */

function isHTMLParsingSupported() {
	try {
		// WebKit returns null on unsupported types
		if (new DOMParser().parseFromString("", "text/html") != null) {
			// text/html parsing is natively supported
			return true;
		}
	} catch (exception) {
    // Firefox/Opera/IE throw errors on unsupported types
  }
  return false;
}

if (!isHTMLParsingSupported("")) {//TODO: optimize the check
	var nativeParseFromString = DOMParser.prototype.parseFromString;
  DOMParser.prototype.parseFromString = function (markup, type) {
    if (type === "text/html") {
      var doc = document.implementation.createHTMLDocument("");
      doc.documentElement.innerHTML = markup;
      return doc;
    }
    return nativeParseFromString.call(this, markup, type);
  };
}


// Firefox 2: https://javascript.ru/ui/offset
if (Element.prototype.getBoundingClientRect == null) {
  Element.prototype.getBoundingClientRect = function () {
    var top = 0;
    var left = 0;
    var x = this;
    while (x != null) {
      top += x.offsetTop;
      left += x.offsetLeft;
      x = x.offsetParent;
    }
    return {
      top: top,
      left: left,
      right: left + this.offsetWidth,
      bottom: top + this.offsetHeight
    };
  };
}

if ("msCSSOMElementFloatMetrics" in document) {
  document.msCSSOMElementFloatMetrics = true;
}

// https://developer.mozilla.org/en-US/docs/Web/API/Element/matches#Polyfill
if (!Element.prototype.matches) {
  Element.prototype.matches =
      Element.prototype.matchesSelector ||
      Element.prototype.mozMatchesSelector ||
      Element.prototype.msMatchesSelector ||
      Element.prototype.oMatchesSelector ||
      Element.prototype.webkitMatchesSelector ||
      function(s) {
        var matches = (this.document || this.ownerDocument).querySelectorAll(s),
            i = matches.length;
        while (--i >= 0 && matches.item(i) !== this) {}
        return i > -1;
      };
}

// https://developer.mozilla.org/en-US/docs/Web/API/Element/closest#Polyfill
if (!Element.prototype.closest) {
  Element.prototype.closest = function(s) {
    var el = this;

    do {
      if (el.matches(s)) { return el; }
      el = el.parentElement || el.parentNode;
    } while (el !== null && el.nodeType === 1);
    return null;
  };
}

if (document.queryCommandSupported == undefined) { // ... undefined in Opera Mini 35 - ?
  document.queryCommandSupported = function () {
    return false;
  };
}
if (document.queryCommandEnabled == undefined) { // ... undefined in Opera Mini 35 - ?
  document.queryCommandEnabled = function () {
    return false;
  };
}

if (typeof BigInt === "undefined") { // stip tests for modern browsers as they cause style recalcuation and relayout

var nativeQueryCommandSupported = document.queryCommandSupported;
var nativeQueryCommandEnabled = document.queryCommandEnabled;

try {
  // `document.queryCommandEnabled(command)` throws an error in Firefox ? - 4 - ?
  document.queryCommandSupported("copy"); // check if it throws
  document.queryCommandSupported("insertText"); // check if it throws
} catch (error) {
  document.queryCommandSupported = function (command) {
    try {
      return nativeQueryCommandSupported.call(document, command);
    } catch (error) {
    }
    return false;
  };
}

try {
  // `document.queryCommandEnabled(command)` throws an error in IE 8 - 11 - ?
  document.queryCommandEnabled("copy"); // check if it throws
  document.queryCommandEnabled("insertText"); // check if it throws
} catch (error) {
  document.queryCommandEnabled = function (command) {
    if (document.queryCommandSupported(command)) {
      try {
        return nativeQueryCommandEnabled.call(document, command);
      } catch (error) {
      }
    }
    return false;
  };
  // `document.queryCommandEnabled("copy")` throws an error in Firefox < 41 for "copy", but `document.queryCommandSupported("copy")` incorrectly returns true
  // Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:39.0) Gecko/20100101 Firefox/39.0 for "insertText"
  if (document.queryCommandSupported("copy")) {
    var nativeQueryCommandSupported1 = document.queryCommandSupported;
    document.queryCommandSupported = function (command) {
      if (nativeQueryCommandSupported1.call(document, command)) {
        try {
          nativeQueryCommandEnabled.call(document, command); // check if it throws
          return true;
        } catch (error) {
        }
      }
      return false;
    };
  }
}

var isInsertTextWorking = function () {
  var activeElement = document.activeElement;
  var input = document.createElement('input');
  input.style.position = 'fixed';
  input.style.top = '0';
  input.style.left = '0';
  document.body.appendChild(input);
  input.focus();
  var result = false;
  if (document.queryCommandEnabled('insertText')) {
    document.execCommand('insertText', false, 'test');
    result = document.queryCommandEnabled('undo');
    document.execCommand('undo', false, '');
  }
  input.parentNode.removeChild(input);
  activeElement.focus();
  return result;
};

if (document.queryCommandSupported("ms-beginUndoUnit") &&
    document.queryCommandSupported("ms-endUndoUnit") &&
    (!document.queryCommandSupported("insertText") || !isInsertTextWorking())) {
  // "insertText" is enabled for Edge 17, but "undo" does not work correctly with it, so let's try to use ms-beginUndoUnit+ms-endUndoUnit
  var nativeExecCommand2 = document.execCommand;
  document.execCommand = function (name, showDefaultUI, value) {
    var input = document.activeElement;
    if (name === "insertText" && input != null && (input.tagName.toLowerCase() === 'input' || input.tagName.toLowerCase() === 'textarea')) {
      var currentValue = input.value;
      var selectionStart = input.selectionStart;
      var selectionEnd = input.selectionEnd;
      document.execCommand("ms-beginUndoUnit", false, null);
      input.value = currentValue.slice(0, selectionStart) + value + currentValue.slice(selectionEnd);
      document.execCommand("ms-endUndoUnit", false, null);
      input.setSelectionRange(selectionStart + value.length, selectionStart + value.length);
      if (value !== "" || selectionStart !== selectionEnd) { // to match Chrome's behaviour
        var inputEvent = document.createEvent("Event");
        inputEvent.initEvent("input", false, false);
        input.dispatchEvent(inputEvent);
      }
      return undefined;
    }
    return nativeExecCommand2.call(this, name, showDefaultUI, value);
  };
  if (!document.queryCommandSupported("insertText")) {
    var nativeQueryCommandEnabled2 = document.queryCommandEnabled;
    var nativeQueryCommandSupported2 = document.queryCommandSupported;
    document.queryCommandEnabled = function (command) {
      if (command === "insertText") {
        return true;
      }
      return nativeQueryCommandEnabled2.call(document, command);
    };
    document.queryCommandSupported = function (command) {
      if (command === "insertText") {
        return true;
      }
      return nativeQueryCommandSupported2.call(document, command);
    };
  }
}

}

// Firefox < 7
// optional useCapture argument
//! The polyfill does not work as Firefox 3.6.28 has the functions on the objects as well as on the prototypes....
//! works fine in Firefox 4
var useCaptureSupported = true;
try {
  var useCaptureTest = function (event) {
  };
  document.addEventListener("abc", useCaptureTest);
  document.removeEventListener("abc", useCaptureTest);
} catch (error) {
  useCaptureSupported = false;
}

if (!useCaptureSupported) {
  (function () {
    var fix = function (object) {
      // in Firefox 3 document has own property addEventListener, but not removeEventListener
      if (Object.prototype.hasOwnProperty.call(object, "addEventListener")) {
        var addEventListener = object.addEventListener;
        object.addEventListener = function (type, listener, useCapture) {
          addEventListener.call(this, type, listener, useCapture == undefined ? false : useCapture);
        };
      }
      if (Object.prototype.hasOwnProperty.call(object, "removeEventListener")) {
        var removeEventListener = object.removeEventListener;
        object.removeEventListener = function (type, listener, useCapture) {
          removeEventListener.call(this, type, listener, useCapture == undefined ? false : useCapture);
        };
      }
    };
    var fixUseCapture = function (object) {
      while (object != undefined) {
        fix(object);
        object = Object.getPrototypeOf(object);
      }
    };
    fixUseCapture(document);
    fixUseCapture(window);
    // can be polyfilled in Firefox 4...
    fixUseCapture(HTMLInputElement.prototype);
    fixUseCapture(HTMLTextAreaElement.prototype);
  }());
}

/*
if (window.addEventListener.length !== 2) {//TODO: ?
  var nativeAddEventListener = window.addEventListener;
  window.addEventListener = function (type, callback, useCapture) {
    nativeAddEventListener.call(this, type, callback, useCapture || false);
  };
}
if (document.addEventListener.length !== 2) {//TODO: ?
  var nativeAddEventListener2 = document.addEventListener;
  document.addEventListener = function (type, callback, useCapture) {
    nativeAddEventListener2.call(this, type, callback, useCapture || false);
  };
}
*/

if (typeof DOMRect === "undefined") {
  globalThis.DOMRect = function (x, y, width, height) {
    return {
      x: x,
      y: y,
      width: width,
      height: height,
      top: y,
      right: x + width,
      bottom: y + height,
      left: x
    };
  };
}

if (!("parentElement" in Node.prototype)) { //!Note: the polyfill should work for MathML-elements as well.
  Object.defineProperty(Node.prototype, "parentElement", {
    get: function () {
      var parentNode = this.parentNode;
      return parentNode != null && parentNode.nodeType === Node.ELEMENT_NODE ? parentNode : null;
    }
  });
}

if (typeof CustomEvent !== 'function') { // Note: CustomEvent, not Event, as typeof Event === 'function' on Android 4.4 while the Event constructor does not work
  var nativeEventPrototype = Event.prototype;
  window.Event = function (type, options) {
    var event = document.createEvent("Event");
    event.initEvent(type, options != null && options.bubbles ? true : false, options != null && options.cancelable ? true : false);
    return event;
  };
  window.Event.prototype = nativeEventPrototype;
}

if (typeof CustomEvent !== 'function') { // IE 11
  window.CustomEvent = function (type, options) {
    var event = new Event(type, options);
    event.details = options.details;
    return event;
  };
  window.CustomEvent.prototype = Object.create(Event.prototype);
}

// IE 11
if (typeof Window !== "undefined" && Window.prototype.navigate != null && Window.prototype.navigate.length === 0 && window.opera == null) {
  delete Window.prototype.navigate;
}

if (true) {
  var img = new Image();
  img.onerror = function () {
    img.onerror = img.onload = null;
    // IE 11 does not support 22 3C 3E 5B 5C 5D 5E 60 7B 7C 7D 7F, Edge 12 does not support 22 5C 5E 60 7C 7F
    // https://stackoverflow.com/a/45517927/839199
    var iterateCSS = function (f) {
      var styleSheets = document.styleSheets;
      for (var i = 0; i < styleSheets.length; i += 1) {
        var styleSheet = styleSheets[i];
        var cssRules = styleSheet.cssRules;
        for (var j = 0; j < cssRules.length; j += 1) {
          var cssRule = cssRules[j];
          if (cssRule.type === CSSRule.STYLE_RULE) {
            var style = cssRule.style;
            var propertyValue = style.getPropertyValue('background-image');
            if (propertyValue !== '' && propertyValue !== 'none') {
              //console.log(propertyValue);
              var match = /^url\("data\:([^,]+),([\s\S]+)"\)$/.exec(propertyValue);
              if (match != null) {
                var mimeType = match[1];
                var data = match[2].replace(/\\"/g, '\"');
                var value = 'url("data:' + mimeType + ',' + encodeURIComponent(decodeURIComponent(data)) + '")';
                style.setProperty('background-image', value, '');
              }
            }
          }
        }
      }
    };
    iterateCSS();
  };
  img.onload = function () {
    img.onerror = img.onload = null;
  };
  img.src = 'data:image/svg+xml,<svg width="1" height="1" viewBox="0 0 1 1" xmlns="http://www.w3.org/2000/svg" data-x="|"></svg>';
}

if (!("requestAnimationFrame" in window)) {
  (function () {
    var queue = [];
    var k = 0;
    window.requestAnimationFrame = window.mozRequestAnimationFrame ||
                                   window.webkitRequestAnimationFrame || function (callback) {
      if (queue.length === k) {
        window.setTimeout(function () {
          k = queue.length;
          for (var i = 0; i < k; i += 1) {
            try {
              queue[i]();
            } catch (error) {
              window.setTimeout(function (error) {
                throw error;
              }.bind(null, error), 0);
            }
          }
          queue.splice(0, k);
          k = 0;
        }, k === 0 ? 0 : 1000 / 60);
      }
      queue.push(callback);
    };
  }());
}

if (window.history.replaceState == null) {
  if (window.History != null) {
    // Firefox 3.6
    window.History.prototype.replaceState = function (state, title, href) {
      window.location.replace(href + (href.indexOf('#') === -1 ? '#' : ''));
    };
  } else {
    window.history.replaceState = function (state, title, href) {
      window.location.replace(href + (href.indexOf('#') === -1 ? '#' : ''));
    };
  }
}

// Firefox 3.6
var tmp =  document.createElement('tmp');
tmp.innerHTML = '<math></math>';
if (tmp.firstElementChild != null && tmp.firstElementChild.namespaceURI !== 'http://www.w3.org/1998/Math/MathML') {
  Object.defineProperty(Element.prototype, "namespaceURI", {
    get: function () {
      return this.tagName.toLowerCase().charCodeAt(0) === "m".charCodeAt(0) && !/^(main|map|mark|menu|menuitem|meta|meter)$/.test(this.tagName.toLowerCase()) ? "http://www.w3.org/1998/Math/MathML" : "http://www.w3.org/1999/xhtml";
    }
  });
  // XMLSerializer - ?
}

// Opera 12
if (HTMLInputElement.prototype.setRangeText == null) {
  HTMLInputElement.prototype.setRangeText = function (text) {
    this.value = this.value.slice(0, this.selectionStart) + text + this.value.slice(this.selectionEnd);
  };
}

// Opera 12
if (HTMLTextAreaElement.prototype.setRangeText == null) {
  HTMLTextAreaElement.prototype.setRangeText = function (text) {
    this.value = this.value.slice(0, this.selectionStart) + text + this.value.slice(this.selectionEnd);
  };
}

function supportsMutilinePlaceholder() {
  // Firefox < 59 (according to https://bugzilla.mozilla.org/show_bug.cgi?id=1391044) - undetectable (as does not affect scrollHeight)
  if (!('overscrollBehavior' in document.documentElement.style)) {//Firefox 59?
    return false;
  }
  return window.opera == null;//TODO:
}

var placeholderListener = function (event) {
  var backgroundImage = event.target.value.length !== 0 ? 'none' : event.target.getAttribute('data-background-image');
  if (event.target.style.backgroundImage !== backgroundImage) {
    event.target.style.backgroundImage = backgroundImage;
  }
};

var property = Object.getOwnPropertyDescriptor(HTMLTextAreaElement.prototype, 'placeholder');
if (!supportsMutilinePlaceholder() && (property == null || property.configurable)) {
  // the placeholder property is not configurable on Safari 9
  Object.defineProperty(HTMLTextAreaElement.prototype, 'placeholder', {
    get: function () {
      return this.getAttribute('aria-placeholder') || '';
    },
    set: function (value) {
      this.removeEventListener('input', placeholderListener, false);
      this.addEventListener('input', placeholderListener, false);
      //var style = getComputedStyle(this, null);
      var fontSize = 15;//Number.parseFloat(style.fontSize);
      var lineHeight = 1.2 * fontSize;
      this.setAttribute('aria-placeholder', value);
      var lines = value.split('\n');
      var width = 0;
      for (var i = 0; i < lines.length; i += 1) {
        width = Math.max(width, lines[i].length);
      }
      var svg = '';
      svg += '<svg xmlns="http://www.w3.org/2000/svg" width="' + (width * fontSize) + '" height="' + (lineHeight * lines.length) + '" viewBox="0 0 ' + (width * fontSize) + ' ' + (lineHeight * lines.length) + '" font-size="' + fontSize + '" font-family="monospace" fill="silver">';
      for (var i = 0; i < lines.length; i += 1) {
        svg += '<text x="2" y="' + (lineHeight * (i + 0.5)) + '" dy="0.25em">';
        svg += lines[i].replace(/\s/g, '\xA0');
        svg += '</text>';
      }
      svg += '</svg>';
      //this.style.backgroundSize = (width * fontSize) + 'px' + ' ' + (lineHeight * lines.length) + 'px';
      this.style.backgroundImage = 'url(\'data:image/svg+xml,' + encodeURIComponent(svg) + '\')';
      this.style.backgroundRepeat = 'no-repeat';
      //this.style.backgroundOrigin = 'content-box';
      this.setAttribute('data-background-image', this.style.backgroundImage);
      placeholderListener.call(this, {target: this});
    }
  });
}

}());



//TODO: ?
if (window.matchMedia == undefined) {
  window.matchMedia = function () {
    return {matches: false, addListener: function () {}, removeListener: function () {}};
  };
}

//TODO: ?
if (window.matchMedia("(any-pointer: fine)").media !== "(any-pointer: fine)") {//TODO: ?
  var nativeMatchMedia = window.matchMedia;
  window.matchMedia = function (media) {
    media = media.replace(/^\s+|\s+$/g, '').replace(/\s+/g, '').replace(/\:/g , ': ');
    if (media === "(any-pointer: fine)" || media === "(pointer: fine)" || media === "(any-hover: hover)" || media === "(hover: hover)") {
      // https://stackoverflow.com/a/29509267/839199
      var isMobile = /iPhone|iPad|iPod|Android/i.test(window.navigator.userAgent);
      return {matches: !isMobile, addListener: function () {}, removeListener: function() {}};
    }
    return nativeMatchMedia.call(window, media);
  };
}

/*global IDBObjectStore*/

// Edge 18 - ?
// Safari < 10.1
if (typeof IDBObjectStore !== 'undefined' &&
    IDBObjectStore.prototype != undefined &&
    (IDBObjectStore.prototype.getAll == undefined || IDBObjectStore.prototype.getAllKeys == undefined || IDBObjectStore.prototype.openKeyCursor == undefined)) {
  var get = function (store, query, count, value) {
    'use strict';
    var request = {
      onsuccess: undefined
    };
    var result = [];
    var cursorRequest = query == undefined ? (value ? store.openCursor() : store.openKeyCursor()) : (value ? store.openCursor(query) : store.openKeyCursor(query));
    cursorRequest.onsuccess = function (event) {
      var cursor = event.target.result;
      if (cursor != undefined) {
        result.push(value ? cursor.value : cursor.key);
        if (count == undefined || result.length < count) {
          cursor['continue']();
        }
      } else {
        request.onsuccess({target: {result: result}});
      }
    };
    return request;
  };
  if (IDBObjectStore.prototype.getAll == undefined) {
    IDBObjectStore.prototype.getAll = function (query, count) {
      'use strict';
      return get(this, query, count, true);
    };
  }
  if (IDBObjectStore.prototype.getAllKeys == undefined) {
    IDBObjectStore.prototype.getAllKeys = function (query, count) {
      'use strict';
      return get(this, query, count, false);
    };
  }
  if (IDBObjectStore.prototype.openKeyCursor == undefined) {
    IDBObjectStore.prototype.openKeyCursor = function (range, direction) {
      'use strict';
      // Edge 17 throws an exception for "store.openCursor(undefined)"
      return range == undefined && direction == undefined ? this.openCursor() : (direction == undefined ? this.openCursor(range) : this.openCursor(range, direction));
    };
  }
}

/*global document, window, Element */

(function () {
  "use strict";

  var hasCompositeAddSupport = function () {
    if (true) {
      return typeof KeyframeEffect !== 'undefined' && 'composite' in KeyframeEffect.prototype;
      //return false;//! to not cause layout recalculation/rendering
    }
    var ok = false;
    if (document.body != undefined) {
      var tmp = document.createElement("div");
      tmp.style.position = "absolute";
      tmp.style.overflow = "hidden";
      tmp.style.width = "1px";
      tmp.style.height = "1px";
      document.body.appendChild(tmp);
      tmp.style.opacity = "0";
      try {
        for (var i = 0; i < 2; i += 1) {
          tmp.animate([
            {opacity: "0.25"},
            {opacity: "0.50"}
          ], {
            duration: 1000,
            composite: "add"
          });
        }
      } catch (error) {
        // an error in Chrome < ?
        window.console.log(error);
      }
      ok = window.getComputedStyle(tmp, undefined).opacity === "0.5";
      tmp.parentNode.removeChild(tmp);
    }
    return ok;
  };

  var nativeAnimate = Element.prototype.animate;
  var nativeAnimations = [];
  var setAnimationStyles = function (element, keyframes, options) {
    var k = 0;
    var oldAnimation = undefined;
    for (var i = 0; i < nativeAnimations.length; i += 1) {
      var x = nativeAnimations[i];
      if (x.element === element) {
        oldAnimation = x.animation;
      } else {
        nativeAnimations[k] = x;
        k += 1;
      }
    }
    while (nativeAnimations.length > k) {
      nativeAnimations.pop();
    }
    if (keyframes != undefined) {
      var newAnimation = nativeAnimate.call(element, keyframes, options);
      nativeAnimations.push({
        element: element,
        animation: newAnimation
      });
    }
    if (oldAnimation != undefined) {
      //Note: cancel is needed to remove the animation from the list of element's animations (especially, if `fill` is "both")
      oldAnimation.cancel();
    }
  };

  var cubicBezier = function (a, b, t) {
    return 3 * a * (1 - t) * (1 - t) * t + 3 * b * (1 - t) * t * t + t * t * t;
  };

  var cubic = function (x, error, a, b, c, d) {
    var start = 0;
    var end = 1;
    while (end - start > error) {
      var middle = (start + end) / 2;
      var e = cubicBezier(a, c, middle);
      if (e < x) {
        start = middle;
      } else {
        end = middle;
      }
    }
    return cubicBezier(b, d, start);
  };

  var easeInOut = function (x, error) {
    return cubic(x, error, 0.42, 0, 0.58, 1);
  };

  var animations = [];

  var interpolateValues = function (a, b, p) {
    return (1 - p) * a + p * b;
  };

  var addValues = function (a, b) {
    return a + b;
  };

  function Transform(name, arg) {
    this.name = name;
    this.arg = arg;
  }

  Transform.prototype.toString = function () {
    return this.name + "(" + this.arg.toString() + (this.name !== "scale" ? "px" : "") + ")";
  };

  Transform.parseTransform = function (transform) {
    var match = /^\s*([a-zA-Z]+)\(([^\),]+)\)\s*$/.exec(transform);
    if (match == undefined) {
      throw new Error();
    }
    var name = match[1];
    var arg = Number.parseFloat(match[2]);
    return new Transform(name, arg);
  };

  function Keyframe(opacity, transform) {
    this.opacity = opacity;
    this.transform = transform;
  }

  Keyframe.parseKeyframe = function (style) {
    var opacity = style.opacity == undefined || style.opacity === "" ? undefined : Number.parseFloat(style.opacity);
    var transform = style.transform == undefined || style.transform === "" ? undefined : Transform.parseTransform(style.transform);
    return new Keyframe(opacity, transform);
  };

  Keyframe.prototype.interpolate = function (keyframe, p) {
    var opacity = undefined;
    if (this.opacity != undefined || keyframe.opacity != undefined) {
      opacity = interpolateValues(this.opacity != undefined ? this.opacity : 1, keyframe.opacity != undefined ? keyframe.opacity : 1, p);
    }
    var transform = undefined;
    if (this.transform != undefined || keyframe.transform != undefined) {
      if (this.transform == undefined && keyframe.transform == undefined && this.transform.name !== keyframe.transform.name) {
        throw new Error();
      }
      var name = this.transform != undefined ? this.transform.name : keyframe.transform.name;
      transform = new Transform(name, interpolateValues(this.transform != undefined ? this.transform.arg : (name === "scale" ? 1 : 0), keyframe.transform != undefined ? keyframe.transform.arg : (name === "scale" ? 1 : 0), p));
    }
    return new Keyframe(opacity, transform);
  };

  Keyframe.prototype.add = function (keyframe, composite) {
    var opacity = keyframe.opacity == undefined ? this.opacity : (this.opacity == undefined || composite !== "add" ? keyframe.opacity : addValues(this.opacity, keyframe.opacity));
    var transform = keyframe.transform == undefined ? this.transform : (this.transform == undefined || composite !== "add" ? keyframe.transform : new Transform(this.transform.name, this.transform.name === "scale" ? this.transform.arg * keyframe.transform.arg : addValues(this.transform.arg, keyframe.transform.arg)));
    return new Keyframe(opacity, transform);
  };

  Keyframe.prototype.toJSON = function () {
    // no way to use undefined (Chrome) or "" (Firefox)
    if (this.opacity == undefined && this.transform != undefined) {
      return {
        transform: this.transform != undefined ? this.transform.toString() : ""
      };
    }
    if (this.opacity != undefined && this.transform == undefined) {
      return {
        opacity: this.opacity != undefined ? this.opacity.toString() : ""
      };
    }
    if (this.opacity != undefined && this.transform != undefined) {
      return {
        opacity: this.opacity != undefined ? this.opacity.toString() : "",
        transform: this.transform != undefined ? this.transform.toString() : ""
      };
    }
    return {};
  };

  var generateKeyframes = function (element, startTime, endTime) {
    var style = Keyframe.parseKeyframe(element.style);
    var keyframes = [];
    for (var time = startTime; time < endTime; time += 1000 / 60) {
      var value = style;
      for (var i = 0; i < animations.length; i += 1) {
        var a = animations[i];
        if (a.element === element) {
          var timeFraction = (time - a.startTime) / a.duration;
          if (timeFraction < 0) {
            timeFraction = 0;
          }
          if (timeFraction > 1) {
            timeFraction = 1;
          }
          var p = easeInOut(timeFraction, 1000 / 60 / a.duration / 32);
          var frame0 = value.add(a.keyframes[0], a.composite);
          var frame1 = value.add(a.keyframes[1], a.composite);
          value = frame0.interpolate(frame1, p);
        }
      }
      keyframes.push(value.toJSON());
    }
    return keyframes;
  };

  var startTime = 0;

  if (nativeAnimate != undefined && !hasCompositeAddSupport()) {
    Element.prototype.animate = function (frames, keyframeEffectOptions) {
      if (startTime === 0) {
        startTime = Date.now();
        window.setTimeout(function () {
          startTime = 0;
        }, 0);
      }
      var now = startTime;
      var keyframes = [];
      for (var j = 0; j < frames.length; j += 1) {
        keyframes.push(Keyframe.parseKeyframe(frames[j]));
      }
      var element = this;
      var animation = {
        element: element,
        keyframes: keyframes,
        duration: keyframeEffectOptions.duration,
        composite: keyframeEffectOptions.composite,
        startTime: now
      };
      animations.push(animation);
      var endTime = 0;
      for (var i = 0; i < animations.length; i += 1) {
        if (animations[i].element === element) {
          var animationEndTime = animations[i].startTime + animations[i].duration;
          if (endTime < animationEndTime) {
            endTime = animationEndTime;
          }
        }
      }
      var animationKeyframes = generateKeyframes(element, now, endTime);
      setAnimationStyles(element, animationKeyframes, {duration: endTime - now, easing: "linear"}); // fill: "both" - ?
      window.setTimeout(function () {
        var k = 0;
        var active = 0;
        for (var i = 0; i < animations.length; i += 1) {
          if (animations[i] !== animation) {
            if (animations[i].element === element) {
              active += 1;
            }
            animations[k] = animations[i];
            k += 1;
          }
        }
        animations.length = k;
        if (active === 0) {
          setAnimationStyles(element, undefined, undefined);
        }
      }, animation.duration);
      return animation;
    };
  }

}(this));

/*global document, window, Element, Event */

function hasDialogElementSupport() {
  "use strict";
  var dialog = document.createElement('dialog');
  return dialog.showModal != undefined;
}

if (!hasDialogElementSupport() && Element.prototype.initDialog == undefined) {
(function () {
  "use strict";

  function Inert() {
  }
  Inert.observers = [];
  Inert.dialogs = [];
  Inert.f = function (tabIndex) {
    return -42 - tabIndex;
  };
  Inert.toggleInert = function (node, dialog, value) {
    if (!dialog.contains(node)) {
      if ((value && node.tabIndex >= 0) || (!value && node.tabIndex <= Inert.f(0))) {
        node.tabIndex = Inert.f(node.tabIndex);
      }
      var c = node.firstElementChild;
      while (c != null) {
        Inert.toggleInert(c, dialog, value);
        c = c.nextElementSibling;
      }
    }
  };
  Inert.push = function (dialog) {
    Inert.toggleInert(document.body, dialog, true);
    if (window.MutationObserver != undefined) {
      var observer = new window.MutationObserver(function (mutations) {
        for (var i = 0; i < mutations.length; i += 1) {
          var mutation = mutations[i];
          var addedNodes = mutation.addedNodes;
          for (var j = 0; j < addedNodes.length; j += 1) {
            Inert.toggleInert(addedNodes[j], dialog, true);
          }
          var removedNodes = mutation.removedNodes;
          for (var k = 0; k < removedNodes.length; k += 1) {
            Inert.toggleInert(removedNodes[k], dialog, false);
          }
        }
      });
      observer.observe(document.body, {
        childList: true,
        characterData: false,
        subtree: true
      });
      Inert.observers.push(observer);
    }
    Inert.dialogs.push(dialog);
  };
  Inert.pop = function () {
    var dialog = Inert.dialogs.pop();
    if (window.MutationObserver != undefined) {
      var observer = Inert.observers.pop();
      observer.disconnect();
    }
    Inert.toggleInert(document.body, dialog, false);
  };

  var setFocus = function (dialog) {
    var autofocus = dialog.querySelector("[autofocus]");
    if (autofocus != null) {
      autofocus.focus();
    } else {
      dialog.focus(); // as in Chrome
    }
  };

  var show = function () {
    if (this.getAttribute("open") == null) {
      this.setAttribute("open", "open");
      setFocus(this);
    }
  };

  var showModal = function () {
    if (this.getAttribute("open") == null) {
      this.setAttribute("data-modal", "data-modal");
      this.setAttribute("open", "open");
      Inert.push(this);
      setFocus(this);
    }
  };

  var close = function (returnValue) {
    if (this.getAttribute("open") != null) {
      if (this.getAttribute("data-modal") != null) {
        this.removeAttribute("data-modal");
        Inert.pop();
      }
      this.removeAttribute("open");
      this.returnValue = returnValue;
      // bugs.chromium.org/p/chromium/issues/detail?id=380087 - close event was sync in Chrome 49 and is async now
      window.setTimeout(function () {
        this.dispatchEvent(new Event("close"));
      }, 0);
    }
  };

    Element.prototype.initDialog = function () {
      document.body.classList.toggle("no-dialog", true);//!
      var dialog = this;
      dialog.setAttribute("role", "dialog");
      dialog.show = show;
      dialog.showModal = showModal;
      dialog.close = close;
      dialog.returnValue = undefined;
      dialog.addEventListener("keydown", function (event) {
        var DOM_VK_ESCAPE = 27;
        if (event.keyCode === DOM_VK_ESCAPE && !event.ctrlKey && !event.altKey && !event.shiftKey && !event.metaKey && !event.defaultPrevented) {
          event.preventDefault();
          if (this.dispatchEvent(new Event("cancel", {cancelable: true}))) {
            this.close(undefined);
          }
        }
      }, false);
      dialog.addEventListener("submit", function (event) {
        event.preventDefault();
        this.close(event.target.getAttribute("value"));
      }, false);
    };

}());
}

/*global document, Element*/

(function () {
  "use strict";

  var details = document.createElement('details');
  var summary = document.createElement('summary');
  details.appendChild(summary);
  if (!("open" in details)) {
    document.addEventListener('DOMContentLoaded', function (event) { // document.body is null in Opera 12
      document.body.classList.toggle("no-details-summary", true);
    }, {once: true});
  }
  if ((!("open" in details) || !("ontoggle" in details) || summary.tabIndex === -1) && Element.prototype.initDetails == null) {
    Element.prototype.initDetails = function (summary) {
      var details = this;
      //var summary = details.firstElementChild;
      if (summary.tagName.toLowerCase() !== 'summary') {
        throw new RangeError("Unexpected " + summary.tagName.toLowerCase());
      }
      details.setAttribute("role", "group");
      summary.setAttribute("aria-expanded", "false");// Note: on <summary>
      summary.setAttribute("role", "button");
      summary.tabIndex = 0;
      summary.addEventListener("click", function (event) {
        var summary = this;
        var details = summary.parentNode;
        event.preventDefault();
        var isOpen = details.getAttribute("open") != undefined;
        if (!isOpen) {
          summary.setAttribute("aria-expanded", "true");// Note: on <summary>
          details.setAttribute("open", "open");
        } else {
          details.setAttribute("aria-expanded", "false");
          details.removeAttribute("open");
        }
        summary.focus();
        var e = document.createEvent("Event");
        e.initEvent("toggle", false, false);
        details.dispatchEvent(e);
      }, false);
      // role="button" => click should be fired with SPACE key too
      summary.addEventListener("keydown", function (event) {
        var DOM_VK_SPACE = 32;
        if (event.keyCode === DOM_VK_SPACE && !event.ctrlKey && !event.altKey && !event.shiftKey && !event.metaKey && !event.defaultPrevented) {
          event.preventDefault(); // scrolling
        }
        var DOM_VK_RETURN = 13;
        if (event.keyCode === DOM_VK_RETURN && !event.ctrlKey && !event.altKey && !event.shiftKey && !event.metaKey && !event.defaultPrevented) {
          event.preventDefault();
          this.click();
        }
      }, false);
      summary.addEventListener("keyup", function (event) {
        var DOM_VK_SPACE = 32;
        if (event.keyCode === DOM_VK_SPACE && !event.ctrlKey && !event.altKey && !event.shiftKey && !event.metaKey && !event.defaultPrevented) {
          event.preventDefault();
          this.click();
        }
      }, false);
    };
  }

}());

/*global document, window, Element, HTMLInputElement, CSS */

(function () {
  "use strict";

  // a bug in Chrome 47 on Windows - 67 - ?
  // Seems, it is not more reproduciable on Chrome >= 78
  // https://bugs.chromium.org/p/chromium/issues/detail?id=652102
  // window.devicePixelRatio - Firefox 3.6.28 throws on usage of the getter or setter(?)
  if (Object.getOwnPropertyDescriptor != undefined && window.devicePixelRatio != null) {
    var lastDevicePixelRatio = 0;
    var lastScrollLeftFix = 1;
    var originalScrollLeft = undefined;
    try {
      originalScrollLeft = Object.getOwnPropertyDescriptor(Element.prototype, "scrollLeft");
    } catch (error) {
      // NS_ERROR_XPC_BAD_CONVERT_JS: Could not convert JavaScript argument in Firefox 17
      window.console.log(error);
    }
    var isChrome78 = typeof CSS !== 'undefined' && CSS.supports != null && CSS.supports('(width: min(1px, 2px))');
    if (originalScrollLeft != undefined && originalScrollLeft.get != undefined && originalScrollLeft.set != undefined && !isChrome78) { // Safari < 10, Opera 12
      Object.defineProperty(HTMLInputElement.prototype, "scrollLeft", {
        get: function () {
          if (this.tagName.toLowerCase() !== 'input') {
            return originalScrollLeft.get.call(this);
          }
          if (lastDevicePixelRatio !== window.devicePixelRatio) {
            lastDevicePixelRatio = window.devicePixelRatio;
            var input = document.createElement("input");
            document.body.appendChild(input);
            input.style.position = "absolute";
            input.style.height = "1px";
            input.style.width = "1px";
            input.style.overflow = "hidden";
            input.value = "xxxxxxxxxxxxxxx";
            originalScrollLeft.set.call(input, 16383);
            var s = originalScrollLeft.get.call(input);
            if (s === 0) { // IE - Edge
              lastScrollLeftFix = 1;
            } else {
              lastScrollLeftFix = (input.scrollWidth - input.clientWidth) / s;
              if (lastScrollLeftFix === 0) { // Edge/18.18362 (input.scrollWidth === input.clientWidht)
                lastScrollLeftFix = 1;
              }
              if ((1 - lastScrollLeftFix) * (1 - lastScrollLeftFix) < 0.05 * 0.05) {
                lastScrollLeftFix = 1;
              }
            }
            input.parentNode.removeChild(input);
          }
          // lastScrollLeftFix equals window.devicePixelRatio in Chrome 49 - 53
          return lastScrollLeftFix * originalScrollLeft.get.call(this);
        },
        set: function (value) {
          originalScrollLeft.set.call(this, value);
        }
      });
    }
  }

}());

// Firefox < 20, Chrome, Edge, Opera, Safari
if (document.caretPositionFromPoint == undefined) {

  var createElementLikeInput = function (input, contentCallback, callback) {
    "use strict";
    var inputStyle = window.getComputedStyle(input, undefined);

    var scrollLeft = input.scrollLeft;
    var scrollTop = input.scrollTop;

    var inputRect = input.getBoundingClientRect();

    var div = document.createElement("div");
    contentCallback(div);
    div.style.position = "absolute";
    div.style.display = "inline-block";

    div.style.margin = "0px";
    div.style.border = "0px solid transparent";

    div.style.paddingLeft = inputStyle.paddingLeft;
    div.style.paddingRight = inputStyle.paddingRight;
    div.style.paddingTop = inputStyle.paddingTop;
    div.style.paddingBottom = inputStyle.paddingBottom;

    div.style.left = (inputRect.left + window.pageXOffset + input.clientLeft).toString() + "px";
    div.style.top = (inputRect.top + window.pageYOffset + input.clientTop).toString() + "px";
    div.style.width = input.clientWidth.toString() + "px";
    div.style.height = input.clientHeight.toString() + "px";

    if ("boxSizing" in div.style) {
      div.style.boxSizing = "border-box";
    }
    if ("MozBoxSizing" in div.style) {
      div.style.MozBoxSizing = "border-box";
    }
    if ("webkitBoxSizing" in div.style) {
      div.style.webkitBoxSizing = "border-box";
    }

    div.style.whiteSpace = input.tagName.toLowerCase() === 'input' ? 'nowrap' : 'pre';
    div.style.wordWrap = inputStyle.wordWrap;

    // Firefox does not like font
    div.style.fontSize = inputStyle.fontSize;
    div.style.fontFamily = inputStyle.fontFamily;
    div.style.overflow = "hidden";
    div.style.visibility = "visible"; // Opera 12 needs visible
    div.style.zIndex = "100000";//?

    document.body.appendChild(div);
    div.scrollLeft = scrollLeft;
    div.scrollTop = scrollTop;
    var result = callback(div);
    div.parentNode.removeChild(div);
    return result;
  };

  document.caretPositionFromPoint = function (x, y) {
    "use strict";
    var element = document.elementFromPoint(x, y);
    if (element.tagName.toLowerCase() !== 'input' &&
        element.tagName.toLowerCase() !== 'textarea') {
      var caretRange = document.caretRangeFromPoint(x, y);
      return {
        offsetNode: caretRange.startContainer,
        offset: caretRange.startOffset
      };
    }
    var input = element;
    var offset = createElementLikeInput(input, function (div) {
      var value = input.value.replace(/\r\n/g, "\n") + "\n"; // IE - \r\n
      div.textContent = value;
    }, function () {
      return document.caretRangeFromPoint(x, y).startOffset;
    });
    return {
      offsetNode: input,
      offset: offset
    };
  };

  var hasSetSelectionRangeScrollToVisibilityBug = function (callback) {
    var input = document.createElement('input');
    input.style.position = 'fixed';
    input.style.left = '-20px';
    input.style.top = '-2em';
    input.style.width = '10px';
    input.style.height = '1em';
    input.style.opacity = '0';
    input.style.overflow = 'hidden';
    input.value = 'x'.repeat(1000);
    document.documentElement.appendChild(input);
    window.requestAnimationFrame(function () {
      var activeElement = document.activeElement;
      input.focus();
      input.scrollLeft = 0;
      input.setSelectionRange(999, 1000);
      if (activeElement != null) {
        activeElement.focus();
      } else {
        input.blur();
      }
      window.setTimeout(function () {
        var ok = input.scrollLeft !== 0;
        callback(!ok);
        window.requestAnimationFrame(function () {
          document.documentElement.removeChild(input);
        });
      }, 1000);
    });
  };
  hasSetSelectionRangeScrollToVisibilityBug(function (x) {console.log(x);})

  // Chrome 80
  // https://bugs.chromium.org/p/chromium/issues/detail?id=331233
  if (HTMLInputElement.prototype.createTextRange == null &&
      HTMLInputElement.prototype.setSelectionRange != null) {
  hasSetSelectionRangeScrollToVisibilityBug(function () {
    // Range.prototype.getBoundingClientRect is null in Opera Mini
    // Range.prototype.getBoundingClientRect isnull in Firefox < 4
    // Range#getBoundingClientRect returns null on Android 4.4
    var nativeSetSelectionRange = HTMLInputElement.prototype.setSelectionRange;
    HTMLInputElement.prototype.setSelectionRange = function (selectionStart, selectionEnd) {
      "use strict";
      nativeSetSelectionRange.call(this, selectionStart, selectionEnd);
      //var position = selectionstart;
      var input = this;
      var result = createElementLikeInput(input, function (div) {
        var span1 = document.createElement('span');
        span1.textContent = input.value.slice(0, input.selectionStart);
        div.appendChild(span1);
        var span2 = document.createElement('span');
        span2.textContent = input.value.slice(input.selectionStart, input.selectionEnd);
        div.appendChild(span2);
        var span3 = document.createElement('span');
        span3.textContent = input.value.slice(input.selectionEnd);
        div.appendChild(span3);
      }, function (div) {
        var rect = div.firstElementChild.nextElementSibling.getBoundingClientRect();
        var inputClientRect = div.getBoundingClientRect();
        return {
          scrollLeft: rect.right - inputClientRect.right,
          scrollTop: rect.bottom - inputClientRect.bottom
        };
      });
      input.scrollLeft += result.scrollLeft;
      input.scrollTop += result.scrollTop;
    };
  });
  }

}

// IE, Edge, Firefox, Opera
if (Element.prototype.scrollIntoViewIfNeeded == undefined) {
  Element.prototype.scrollIntoViewIfNeeded = function () {
    "use strict";
    // `centerIfNeeded` is not implemented
    var rect = this.getBoundingClientRect();
    if (rect.left < 0 || document.documentElement.clientWidth < rect.right ||
        rect.top < 0 || document.documentElement.clientHeight < rect.bottom) {
      this.scrollIntoView(document.documentElement.clientHeight < rect.bottom - rect.top || rect.top < 0);
    }
  };
}


/*global window, document, HTMLElement, Element */

"use strict";

(function () {
  // Frédéric Wang - https://github.com/fred-wang/mathml.css/blob/master/mspace.js
  /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
   /*global document, Node*/

  // layout work (?)
  var getMathMLSupport = function () {
    var tmp = document.createElement("div");
    tmp.style.position = "fixed";
    tmp.style.top = "0px"; // affects layout root in Chrome
    tmp.style.left = "0px"; // affects layout root in Chrome
    tmp.style.whiteSpace = "nowrap";
    tmp.style.width = "0px";
    tmp.style.height = "0px";
    tmp.style.overflow = "hidden";
    tmp.style.visibility = "hidden";
    tmp.style.contain = "strict";//TODO: ?
    // helper function
    var tableBody = function (rows, cols) {
      return ('<mtr>' + '<mtd><mn>0</mn></mtd>'.repeat(cols) + '</mtr>').repeat(rows);
    };
    var table = '<math><mtable id="table-4-4">' + tableBody(4, 4) + '</mtable></math>';
    var mathTest = '<math><mtable id="table-1-4">' + tableBody(1, 4) + '</mtable></math>' +
                   '<math><mtable id="table-4-1">' + tableBody(4, 1) + '</mtable></math>';
    var columnspacingTest = '<math><mtable id="columnspacing-a">' + tableBody(1, 4) + '</mtable></math>' +
                            '<math><mtable id="columnspacing-b" columnspacing="0em">' + tableBody(1, 4) + '</mtable></math>';
    var columnlinesTest = '<math><mtable id="columnlines-a">' + tableBody(1, 4) + '</mtable></math>' +
                          '<math><mtable id="columnlines-b" columnlines="none solid none">' + tableBody(1, 4) + '</mtable></math>';
    // use long number to detect increase of the width:
    var mpaddedTest = '<math><mrow id="mpadded-a"><mn>1234567890</mn></mrow></math>' +
                      '<math><mpadded id="mpadded-b" width="+1em" lspace="+1em"><mn>1234567890</mn></mpadded></math>';
    var mencloseTest = '<math><mrow id="menclose-a"><mn>1</mn></mrow></math>' +
                       '<math><menclose id="menclose-b" notation="circle"><mn>1</mn></menclose></math>';
    var rowspacingTest = '<math><mtable id="rowspacing-a">' + tableBody(4, 1) + '</mtable></math>' +
                         '<math><mtable id="rowspacing-b" rowspacing="0ex">' + tableBody(4, 1) + '</mtable></math>';
    var lspaceRspaceTest = '<math><mrow><mo id="lspace-rspace-a">-</mo><mi>1</mi></mrow></math>' +
                           '<math><mrow><mi>x</mi><mo id="lspace-rspace-b">-</mo><mi>y</mi></mrow></math>';
    var msupMsubTest = '<math>' +
                       '<msup id="msup-a"><mrow><mtable>' + tableBody(2, 1) + '</mtable></mrow><mrow><mn>2</mn></mrow></msup>' +
                       '<msup id="msup-b"><mrow><mtable>' + tableBody(3, 1) + '</mtable></mrow><mrow><mn>2</mn></mrow></msup>' +
                       '</math>';
    var nonItalicTest = '<math><mrow><mi id="non-italic">sin</mi><mo>&#x2061;</mo><mi>x</mi></mrow></math>';
    tmp.innerHTML = table + mathTest + columnspacingTest + columnlinesTest + mpaddedTest + mencloseTest + rowspacingTest + lspaceRspaceTest + msupMsubTest + nonItalicTest;
    document.body.appendChild(tmp);
    var t = document.getElementById('table-4-4');
    // In IE the widths are almost equal
    var epsilon = 5e-5;
    var math = document.getElementById('table-1-4').getBoundingClientRect().width - epsilon > document.getElementById('table-4-1').getBoundingClientRect().width;
    var columnspacing = document.getElementById('columnspacing-a').getBoundingClientRect().width - epsilon > document.getElementById('columnspacing-b').getBoundingClientRect().width;
    var columnlines = document.getElementById('columnlines-a').getBoundingClientRect().width + epsilon < document.getElementById('columnlines-b').getBoundingClientRect().width;
    var mpadded = document.getElementById('mpadded-a').getBoundingClientRect().width + epsilon < document.getElementById('mpadded-b').getBoundingClientRect().width;
    var menclose = (function () {
      var a = document.getElementById('menclose-a').getBoundingClientRect();
      var b = document.getElementById('menclose-b').getBoundingClientRect();
      return a.width + a.height + 2 * epsilon < b.width + b.height;
    }());
    var rowspacing = document.getElementById('rowspacing-a').getBoundingClientRect().height - epsilon > document.getElementById('rowspacing-b').getBoundingClientRect().height;
    var lspaceRspace = document.getElementById('lspace-rspace-a').getBoundingClientRect().width + epsilon < document.getElementById('lspace-rspace-b').getBoundingClientRect().width;
    var msupMsub = document.getElementById('msup-a').lastElementChild.getBoundingClientRect().top - epsilon > document.getElementById('msup-b').lastElementChild.getBoundingClientRect().top;
    var tabIndex = t.tabIndex != null; //TODO: ?
    var draggable = t.draggable != null;
    var nonItalic = window.getComputedStyle(document.getElementById('non-italic'), null).fontStyle !== 'italic'; // Safari < 8
    window.requestAnimationFrame(function () {
      tmp.parentNode.removeChild(tmp);
    });
    return (math ? "" : "no-math ") +
           (columnspacing ? "" : "no-columnspacing ") +
           (mpadded ? "" : "no-mpadded ") +
           (columnlines ? "" : "no-columnlines ") +
           (menclose ? "" : "no-menclose ") +
           (rowspacing ? "" : "no-rowspacing ") +
           (lspaceRspace ? "" : "no-lspace-rspace ") +
           (msupMsub ? "" : "no-msup-msub ") +
           (tabIndex ? "" : "no-tabindex ") +
           (draggable ? "" : "no-draggable ") +
           (nonItalic ? "" : "no-non-italic");
  };

  var q = [];
  var queue = function (callback) {
    // otherwise too slow even for small number of elements
    // window.requestAnimationFrame is a little better that window.setTimeout, as it avoids flickering
    if (q.length === 0) {
      var c = function () {
        for (var i = 0; i < q.length; i += 1) {
          q[i]();
        }
        q.length = 0;
      };
      window.requestAnimationFrame(c);
    }
    q.push(callback);
  };

  var styleableElement = document.createElement('div');
  var updateStyleAttribute = function (node, cssText) {
    if (cssText !== '') {
      if (node.getAttribute('style') !== cssText) { // avoid the MutationRecord when no changes
        node.setAttribute('style', cssText);
      }
    } else {
      node.removeAttribute('style'); // slightly faster in Chrome
    }
  };
  
  function CSSStyleDeclarationPolyfill(node) {
    this.node = node;
  }

  CSSStyleDeclarationPolyfill.prototype.getPropertyValue = function (name) {
    updateStyleAttribute(styleableElement, this.node.getAttribute('style') || '');
    var value = styleableElement.style.getPropertyValue(name);
    return value;
  };

  CSSStyleDeclarationPolyfill.prototype.setProperty = function (name, value, priority) {
    updateStyleAttribute(styleableElement, this.node.getAttribute('style') || '');
    // priority argument is not optional in older browsers
    styleableElement.style.setProperty(name, value, priority || '');
    var cssText = styleableElement.style.cssText;
    updateStyleAttribute(this.node, cssText);
    if (window.opera != null) {
      // Opera 12.18 needs namespace to apply styles
      if (cssText === '') {
        this.node.removeAttributeNS('http://www.w3.org/1999/xhtml', 'style');
      } else {
        if (this.node.getAttributeNS('http://www.w3.org/1999/xhtml', 'style', cssText) !== cssText) {
          this.node.setAttributeNS('http://www.w3.org/1999/xhtml', 'style', cssText);
        }
      }
    }
  };

  // PERFORMANCE TEST:
  //var tmp = document.createElementNS('http://www.w3.org/1998/Math/MathML', 'math');
  //tmp.innerHTML = '<mn>0</mn><mo>+</mo>'.repeat(10**5) + '<mn>1</mn>';
  //console.time();
  //for (var c = tmp.firstElementChild; c != null; c = c.nextElementSibling) {
  //  new CSSStyleDeclarationPolyfill(c).setProperty('padding', '0em 1em', '');
  //}
  //console.timeEnd();
  // 1900 ms


  // in Opera 12 a getter on Element.prototype somehow handles the access to html elements
  if (!('style' in HTMLElement.prototype) && Object.getOwnPropertyDescriptor(document.documentElement, 'style') != null) {
    Object.defineProperty(HTMLElement.prototype, 'style', Object.getOwnPropertyDescriptor(document.documentElement, 'style'));
  }

  // Chrome 76
  if (!('style' in document.createElementNS('http://www.w3.org/1998/Math/MathML', 'math'))) {
    Object.defineProperty(Element.prototype, 'style', {
      get: function () {
        return new CSSStyleDeclarationPolyfill(this);
      }
    });
  }

  // no way to polyfill the Element#style in Chrome <= 44 (?) and in old WebKit-based browsers (?) as it returns null for MathML/SVG elements (?)
  // the own property is not configurable
  // https://developers.google.com/web/updates/2015/04/DOM-attributes-now-on-the-prototype-chain
  function getStyle(element) {
    return element.style || new CSSStyleDeclarationPolyfill(element);
  }

  function filterOutContainedNodes(nodes) {
    if (globalThis.Set != null) {//TODO: !?
      var newNodes = new Set();
      for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        newNodes.add(node);
      }
      for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        for (var p = node.parentNode; p != null; p = p.parentNode) {
          if (newNodes.has(p)) {
            newNodes["delete"](node);
          }
        }
      }
      var tmp = [];
      newNodes.forEach(function (node) {
        tmp.push(node);
      });
      return tmp;
    }
    // Note: this code is very slow for big arrays
    var newNodes = [];
    for (var i = 0; i < nodes.length; i++) {
      var node = nodes[i];
      var skip = false;
      for (var j = 0; j < newNodes.length; j++) {
        if (newNodes[j].contains(node)) {
          skip = true;
        } else if (node.contains(newNodes[j])) {
          var tmp = newNodes[j];
          newNodes[j] = node;
          node = tmp;
          skip = true;
        }
      }
      if (!skip) {
        newNodes.push(node);
      }
    }
    return newNodes;
  }

  //var tmp = document.createElement('div');
  //tmp.innerHTML = '<div><a></a></div><div></div>';
  //console.log(filterOutContainedNodes(tmp.querySelectorAll('*')).map(x => x.tagName.toLowerCase()));

  //var tmp = document.createElement('div');
  //tmp.innerHTML = '<div></div>'.repeat(1024 * 1024);
  //console.time();
  //filterOutContainedNodes(tmp.querySelectorAll('*'));
  //console.timeEnd();

  document.addEventListener("DOMContentLoaded", function (event) {
    if (window.opera != undefined) {
      document.body.classList.toggle("css-profile", true);
      //document.body.classList.toggle("no-draggable", true);
    }
    //if (window.XDomainRequest == undefined && !("draggable" in document.documentElement) && !()) {
    //  document.body.classList.toggle("no-draggable", true);
    //}

    //tmp.innerHTML = "<math><mrow mathcolor=\"#FF0000\"><mn>1</mn></mrow></math>";
    //var ok = window.getComputedStyle(tmp.firstElementChild.firstElementChild, undefined).color.indexOf("255") !== -1;
    //var c = ok ? getMathMLSupport(tmp) : "math ";
    // Mi Browser in Night Mode changes color to rgba(255, 255, 255, 0.5)
    //TODO: fix math -> no-math
    var c = window.opera != undefined ? 'math no-columnspacing no-mpadded no-columnlines no-menclose no-rowspacing no-lspace-rspace no-msup-msub no-tabindex no-draggable no-non-italic ' : getMathMLSupport().replace(/^no\-math /g, "math ");
    if (c !== "") {
      var classes = c.replace(/^\s+|\s+$/g, "").split(" ");
      for (var i = 0; i < classes.length; i += 1) {
        document.body.classList.toggle(classes[i], true);
      }
    }
    // I want to have focusable and draggable element, mrow[href="#"] can be used, but I need to prevent the navigation.
    if (c !== "math " || window.opera != undefined) {
      // Opera supports MathML links too with some special CSS
      var preventNavigation = function (event) {
        if (event.button === 0 || event.button === 1) {
          var target = event.target.closest('[href]');
          if (target != null && target.getAttribute('href') === '#') {
            var tagName = target.tagName.toLowerCase();
            if (tagName === 'mrow' || tagName === 'mtd') {
              event.preventDefault();
            }
          }
        }
      };
      document.addEventListener("click", preventNavigation, false);
      document.addEventListener("auxclick", preventNavigation, false);
    }

    var checks = [];
    function walk(element) {
      for (var i = 0; i < checks.length; i += 1) {
        checks[i](element);
      }
      var firstElementChild = element.firstElementChild;
      while (firstElementChild != undefined) {
        walk(firstElementChild);
        firstElementChild = firstElementChild.nextElementSibling;
      }
    }

    if (c.indexOf('no-lspace-rspace ') !== -1) { // no lspace+rspace support based on The operator dictionary
      checks.push(function (target) {
        if (target.tagName.toLowerCase() === 'mo' &&
            target.getAttribute('form') !== 'infix' &&
            !(target.getAttribute('lspace') === '0' && target.getAttribute('rspace') === '0')) {
          var c = target.textContent;
          if (c === '' ||
              c === '\u2061' || c === '\u2062' || c === '\u2063' ||
              c === '(' || c === ')' || c === '|' || c === '{' || c === '}' ||
              (target.nextElementSibling == null && target.previousElementSibling != null) ||
              (target.previousElementSibling == null && target.nextElementSibling != null) ||
              c === ',' || c === '⋅' || target.getAttribute('lspace') != null || target.getAttribute('rspace') != null) {
            queue(function () {
              var paddingLeft = target.getAttribute('lspace') || (c !== '⋅' ? '0em' : (1/6) + 'em');
              var paddingRight = target.getAttribute('rspace') || (c === ',' || c === '⋅' ? (1 / 6) + 'em' : '0em');
              //getStyle(target).setProperty('padding-left', paddingLeft, '');
              //getStyle(target).setProperty('padding-right', paddingRight, '');
              getStyle(target).setProperty('padding', '0 ' + paddingRight + ' 0 ' + paddingLeft, ''); // faster
            });
          }
        }
      });
    }

    if (c.indexOf('no-columnlines ') !== -1) {
      checks.push(function (target) {
        if (target.tagName.toLowerCase() === 'mtable') {
          var columnlines = (target.getAttribute('columnlines') || '').replace(/^\s+|\s+$/g, '').split(/\s+/g);
          queue(function () {
            for (var row = target.firstElementChild; row != null; row = row.nextElementSibling) {
              for (var cell = row.firstElementChild, index = 0; cell != null; cell = cell.nextElementSibling, index += 1) {
                if (index > 0) {
                  var linestyle = columnlines[Math.min(index - 1, columnlines.length - 1)];
                  if (linestyle === 'solid' || linestyle === 'dashed') {
                    getStyle(cell).setProperty('border-left-style', linestyle, '');
                    getStyle(cell).setProperty('border-left-width', '1px', '');
                  }
                }
              }
            }
          });
        }
      });
    }
    var flag0 = false;
    var fireResize = function () {
      if (!flag0) {
        flag0 = true;
        window.requestAnimationFrame(function () {
          flag0 = false;
          document.dispatchEvent(new Event('resize', {bubbles: true}));//!?
        });
      }
    };
    if (c.indexOf('math ') !== -1) {
      checks.push(function (target) {
        if (target.tagName.toLowerCase() === 'mo') {
          var c = target.textContent;
          if (c === '(' || c === ')' || c === '|' || c === '{' || c === '}' || target.previousElementSibling == null || target.nextElementSibling == null) {
            // <mrow><mo>(</mo><mrow>...</mrow><mo>)</mo></mrow>
            queue(function () {
              if (target.parentNode != null && getStyle(target.parentNode).getPropertyValue('white-space') === '') {
                getStyle(target.parentNode).setProperty('white-space', 'nowrap', '');
                for (var child = target.parentNode.firstElementChild; child != null; child = child.nextElementSibling) {
                  if (child.tagName.toLowerCase() !== 'mo') {
                    getStyle(child).setProperty('white-space', 'normal', '');
                  }
                }
                fireResize();
              }
            });
          }
        }
      });
      var propertyName = 'transform';
      if (!('transform' in document.documentElement.style)) {
        var properties = {
          '-o-transform': 'OTransform',
          '-ms-transform': 'msTransform',
          '-moz-transform': 'MozTransform',
          '-webkit-transform': 'webkitTransform'
        };
        for (var property in properties) {
          if (Object.prototype.hasOwnProperty.call(properties, property)) {
            if (properties[property] in document.documentElement.style) {
              propertyName = property;
            }
          }
        }
      }
      var stretchMO = function (target) {
        var c = target.textContent;
        if ((c === '(' || c === ')' || c === '|' || c === '{' || c === '}') && target.getAttribute('stretchy') !== 'false') {
          var fontSize = Number.parseFloat(window.getComputedStyle(target, null).fontSize);

          var height = target.parentNode.clientHeight; // Element#offsetHeight is not here in Chrome
          var scaleY = Math.max(height / fontSize - 0.1875, 0);
          if (scaleY === 0 || Math.abs(scaleY - 1) < 0.05) { // 0 when the element is not rendered
            scaleY = 1;
          }
          var scaleX = Math.sqrt(Math.sqrt(scaleY));

          var style = scaleX === 1 && scaleY === 1 ? '' : 'scale(' + scaleX + ', ' + scaleY + ')';
          if (style !== (getStyle(target).getPropertyValue(propertyName) || '')) {
            queue(function () {
              getStyle(target).setProperty(propertyName, style, '');
            });
          }
        }
        if (c === '¯') {
          var scaleX = target.parentNode.clientWidth / target.clientWidth;
          if (scaleX === 0 || Math.abs(scaleX - 1) < 0.05) { // 0 when the element is not rendered
            scaleX = 1;
          }
          var scaleY = 1;

          var style = scaleX === 1 && scaleY === 1 ? '' : 'scale(' + scaleX + ', ' + scaleY + ')';
          if (getStyle(target).getPropertyValue('margin-bottom') !== '-1em') {
            queue(function () {
              getStyle(target).setProperty(propertyName, style, '');
              getStyle(target).setProperty('margin-bottom', '-1em', '');
              fireResize();
            });
          }
        }
      };
      checks.push(function (target) {
        if (target.tagName.toLowerCase() === 'mo') {
          stretchMO(target);
        }
      });
      window.addEventListener('resize', function (event) {
        var elements = document.getElementsByTagName('mo');
        for (var i = 0; i < elements.length; i += 1) {
          stretchMO(elements[i]);
        }
      }, false);
      /*if (window.ResizeObserver != null) {
        //TODO: fix
        var resizeObserver = new window.ResizeObserver(function () {
          window.requestAnimationFrame(function () {
            var es = document.documentElement.querySelectorAll('mo');
            for (var i = 0; i < es.length; i += 1) {
              stretchMO(es[i]);
            }
          });
        });
        resizeObserver.observe(document.documentElement);
      }*/
    }
    // https://stackoverflow.com/a/26633844
    var browserCanUseCssVariables = function () {
      return window.CSS && CSS.supports('color', 'var(--fake-var)');
    };
    if (c.indexOf('math ') !== -1 && browserCanUseCssVariables()) {
      var stretchRadicalSymbol = function (target) {
        var fontSize = Number.parseFloat(window.getComputedStyle(target, null).fontSize);
        var height = target.firstElementChild.clientHeight;
        var scaleY = (height - fontSize / 8) / fontSize;
        if (scaleY === 0 || Math.abs(scaleY - 1) < 0.05) { // 0 when the element is not rendered
          scaleY = 1;
        }
        if (scaleY !== 1) {
          queue(function () {
            getStyle(target).setProperty('--size', scaleY, '');
          });
        }
      };
      checks.push(function (target) {
        if (target.tagName.toLowerCase() === 'msqrt' || target.tagName.toLowerCase() === 'mroot') {
          stretchRadicalSymbol(target);
        }
      });
      window.addEventListener('resize', function (event) {
        var elements = document.getElementsByTagName('msqrt');
        for (var i = 0; i < elements.length; i += 1) {
          stretchRadicalSymbol(elements[i]);
        }
        var elements = document.getElementsByTagName('mroot');
        for (var i = 0; i < elements.length; i += 1) {
          stretchRadicalSymbol(elements[i]);
        }
      }, false);
    }
    if (c.indexOf('no-draggable ') !== -1) {
      if (!('webkitUserDrag' in document.documentElement.style)) {
        checks.push(function (target) {
          if (target.tagName.toLowerCase() === 'mrow' && target.getAttribute('draggable') != null) {
            queue(function () {
              target.setAttribute('href', '#');
            });
          }
        });
      }
    }
    if (c.indexOf('no-tabindex ') !== -1) {
      checks.push(function (target) {
        if (target.tagName.toLowerCase() === 'mrow' && target.getAttribute('tabindex') != null) {
          queue(function () {
            target.setAttribute('href', '#');
          });
        }
      });
    }
    if (c.indexOf('math ') !== -1 || c.indexOf('no-non-italic ') !== -1) {
      checks.push(function (target) {
        if (target.tagName.toLowerCase() === 'mi') {
          var c = target.textContent;
          if (c.length > 1) {
            queue(function () {
              getStyle(target).setProperty('font-style', 'normal', '');
            });
          }
        }
      });
    }
    if (c.indexOf('math ') !== -1) {
      // https://stackoverflow.com/questions/22475157/is-there-any-unicode-character-whos-glyph-is-missing-in-all-fonts/22636426#22636426
      // https://stackoverflow.com/questions/23876361/codepoint-of-the-missing-glyph-box
      var MISSED_GLYPH = '\uF8FF';
      var getImageData = function (character) {
        //var bodyStyle = window.getComputedStyle(document.body, null);
        //var fontSize = Number.parseFloat(bodyStyle.fontSize);
        // Firefox does not like font
        //var font = bodyStyle.fontSize + " " + bodyStyle.fontFamily;
        var fontSize = 16;
        var font = '16px serif';
        var canvas = document.createElement('canvas');
        canvas.width = fontSize;
        canvas.height = fontSize;

        if (canvas.getContext == null) {
          return null; // IE 8
        }
        var ctx = canvas.getContext('2d');
        ctx.font = font;
        ctx.textBaseline = 'top';
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = 'black';
        if (typeof ctx.fillText !== 'function') {
          return null; // Firefox 3
        }
        ctx.fillText(character, 0, 0);

        var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
        return typeof Uint32Array !== 'undefined' ? new Uint32Array(imageData) : imageData;
      };
      var missedGlyphData = null;
      var isCharacterSupported = function (character) {
        var x = getImageData(character);
        if (missedGlyphData == null) {
          missedGlyphData = getImageData(MISSED_GLYPH);
        }
        var y = missedGlyphData;
        if (x == null || y == null) {
          return false;
        }
        if (x.length !== y.length) {
          throw new TypeError();
        }
        for (var i = 0; i < x.length; i += 1) {
          if (x[i] !== y[i]) {
            return true;
          }
        }
        return false;
      };
      var cache = {};
      var isCharacterSupported2 = function (character) {
        if (cache[character] == null) {
          cache[character] = isCharacterSupported(character);
        }
        return cache[character];
      };
      var replacements = {
        '\u2061': '',
        '\u2062': '',
        '\u2063': '',
        '\u2147': 'e',
        '\u2148': 'i',
        '⇒': '=>',
        '⏟': '(-)'
      };
      checks.push(function (target) {
        if (target.tagName.toLowerCase() === 'mi' ||
            target.tagName.toLowerCase() === 'mo') {
          var c = target.textContent;
          var replacement = replacements[c];
          if (replacement != null && !isCharacterSupported2(c)) {
            queue(function () {
              target.textContent = replacement;
              getStyle(target).setProperty('-webkit-text-fill-color', 'transparent', '');
              getStyle(target).setProperty('-webkit-text-stroke', 'thin currentColor', '');
              target.setAttribute('aria-label', c);
            });
          }
        }
      });
    }
    if (checks.length !== 0) {
      if (window.MutationObserver != null) {
        // with "animationstart" there is some flickering...
        // ... trying to use MutationObserver
        var observer = new MutationObserver(function (mutationList) {
          var nodes = [];
          for (var i = 0; i < mutationList.length; i += 1) {
            var mutation = mutationList[i];
            if (mutation.type === 'attributes') {
              var math = mutation.target.closest('math');
              if (math != null) {
                nodes.push(math);
              } else {
                nodes.push(mutation.target);
              }
            } else {
              var addedNodes = mutation.addedNodes;
              if (addedNodes != null) {
                for (var j = 0; j < addedNodes.length; j += 1) {
                  var node = addedNodes[j];
                  if (node.nodeType === Node.ELEMENT_NODE) {
                    nodes.push(node);
                  }
                }
              }
              var math = mutation.target.closest('math');
              if (math != null) {
                nodes.push(math);
              }
            }
          }
          var newNodes = mutationList.length > 1 ? filterOutContainedNodes(nodes) : nodes;
          for (var i = 0; i < newNodes.length; i++) {
            walk(newNodes[i]);
          }
        });
        //TODO: it is too slow to monitor style attribute changes
        observer.observe(document.body, {
          attributes: true,
          attributeFilter: ['open',/* 'style',*/ 'hidden'],
          childList: true,
          characterData: false,
          subtree: true
        });
      } else {
        //document.addEventListener('animationstart', function (event) {
        //  walk(event.target);
        //}, false);
      }
    }
  }, {once: true});

//if ('webkitUserDrag' in document.documentElement.style) {//? Chrome, Safari
    var timeoutId = 0;
      var toggleDraggable = function () {
        if (timeoutId === 0) {
          //document.body.classList.toggle("altKey", true);
          var elements = document.querySelectorAll('[draggable="true"]');
          for (var i = 0; i < elements.length; i += 1) {
            elements[i].setAttribute('draggable', 'false');
          }
        } else {
          window.clearTimeout(timeoutId);
        }
        // autorepeat of Alt key does not work sometimes (?), but no way to get the Alt state(?)
        timeoutId = window.setTimeout(function () {
          timeoutId = 0;
          //document.body.classList.toggle("altKey", false);
          var elements = document.querySelectorAll('[draggable="false"]');
          for (var i = 0; i < elements.length; i += 1) {
            elements[i].setAttribute('draggable', 'true');
          }
        }, 600);
      };
    window.addEventListener("keydown", function (event) {
      var DOM_VK_ALT = 18;
      if (event.keyCode === DOM_VK_ALT) {
        toggleDraggable();
      }
    }, false);
    window.addEventListener("mousedown", function (event) {
      if (event.altKey) {
        toggleDraggable();
      }
    }, false);
//}

//!new 2019-11-13
if ('webkitUserDrag' in document.documentElement.style) {
  document.addEventListener("DOMContentLoaded", function (event) {
    document.body.classList.toggle('userSelect', true); // help Caret Browsing mode
  }, {once: true});
  window.addEventListener('mousedown', function (event) {
    var target = event.target.closest('[draggable]');
    document.body.classList.toggle('userSelect', target == null || event.altKey);
  }, false);
  window.addEventListener('mouseup', function (event) {
    document.body.classList.toggle('userSelect', true);
  }, false);
}

// in Opera 12 a getter on Element.prototype somehow handles the access to html elements
if (!('tabIndex' in HTMLElement.prototype) && Object.getOwnPropertyDescriptor(document.documentElement, 'tabIndex') != null) {
	Object.defineProperty(HTMLElement.prototype, 'tabIndex', Object.getOwnPropertyDescriptor(document.documentElement, 'tabIndex'));
}

if (!('tabIndex' in document.createElementNS('http://www.w3.org/1998/Math/MathML', 'math'))) {
  Object.defineProperty(Element.prototype, 'tabIndex', {
    get: function () {
      return Number(this.getAttribute('tabindex') || '-1');
    },
    set: function (value) {
      this.setAttribute('tabindex', (Number(value) || 0).toString());
    }
  });
}

if (document.createElementNS('http://www.w3.org/1998/Math/MathML', 'math').focus == undefined) {
  // does not work in IE 11
  // focus method polyfill for MathML elements in Chrome:
  Element.prototype.focus = function () {
    console.assert(this.id !== '' && this.getAttribute('tabindex') === '0', 'the element should have id attribute and tabindex=0');
    var state = window.history.state;
    var href = window.location.href;
    window.location.replace(window.location.href.replace(/#[^#]*$/g, '') + '#' + this.id); //! this will focus the element
    window.scrollBy(0, 0);
    window.history.replaceState(state, document.title, href);
  };
}

}());

/*global window*/
"use strict";

// https://caniuse.com/#feat=mdn-javascript_builtins_intl_numberformat

//var hasNativeSupport = globalThis.Intl != null;

function IntlNumberFormatPolyfill(locale, options) {
  if (options == undefined ||
      options.localeMatcher != undefined ||
      options.numberingSystem != undefined ||
      options.style != undefined ||
      options.useGrouping !== false ||
      options.minimumIntegerDigits != undefined) {
    throw new RangeError("Unsupported options");
  }
  // https://stackoverflow.com/questions/33159354/how-do-i-find-the-decimal-separator-for-current-locale-in-javascript#answer-51411310
  function minusOneAndHalf(locale) {
    //if (hasNativeSupport) {//TODO: ?
    //  return (-1.5).toLocaleString(locale);
    //}
    locale = locale || window.navigator.language;
    if (/^ar(?![a-z])(?!\-TN|\-DZ|\-LY|\-MA)/i.test(locale)) {
      return "؜-١٫٥";
    }
    if (/^fa(?![a-z])/.test(locale)) {
      return "‎−۱٫۵";
    }
    if (/^bn(?![a-z])/.test(locale)) {
      return "-১.৫";
    }
    if (/^mr(?![a-z])/.test(locale)) {
      return "-१.५";
    }
    return /^(?:en|ja|ko|zh)(?![a-z])/.test(locale) ? "-1.5" : "-1,5";
  }
  function isDecimalZero(codePoint) {
    return "0٠۰߀०০੦૦୦௦౦೦൦෦๐໐༠၀႐០᠐᥆᧐᪀᪐᭐᮰᱀᱐꘠꣐꤀꧐꧰꩐꯰０𐒠𐴰𑁦𑃰𑄶𑇐𑋰𑑐𑓐𑙐𑛀𑜰𑣠𑥐𑱐𑵐𑶠𖩠𖭐𝟎𝟘𝟢𝟬𝟶𞅀𞋰𞥐🯰".indexOf(String.fromCodePoint(codePoint)) !== -1;
  }
  var minusSign = /^[\u200E\u061C]?[\u2212\-]/g;
  var test = minusOneAndHalf(locale);
  var absolute = test.replace(minusSign, '');
  if (absolute === test) {
    console.debug(locale);
  }
  var decimalSeparator = '.';
  var tmp = /[٫,\.]/.exec(absolute);
  if (tmp != undefined) {
    decimalSeparator = tmp[0];
  }
  var decimalZero = absolute.codePointAt(0) - 1;
  if (!isDecimalZero(decimalZero)) {
    decimalZero = '0'.codePointAt(0);
  }
  this._decimalZero = decimalZero;
  this._decimalSeparator = decimalSeparator;
  this._minusSign = test.slice(0, -absolute.length);
  this._options = options;
  //this._locale = locale;
}

IntlNumberFormatPolyfill.prototype.format = function (value) {
  var replaceDigits = function (s, decimalZero) {
    if (decimalZero === "0".charCodeAt(0)) {
      return s;
    }
    var result = "";
    for (var i = 0; i < s.length; i += 1) {
      var code = s.charCodeAt(i);
      if (code >= "0".charCodeAt(0) && code <= "9".charCodeAt(0)) {
        result += String.fromCodePoint(decimalZero + (code - "0".charCodeAt(0)));
      } else {
        throw new RangeError();
      }
    }
    return result;
  };
  var applyLocale = function (s, minusSign, decimalSeparator, decimalZero) {
    var a = s.indexOf("-", 0);
    var b = s.indexOf(".", a === -1 ? 0 : a);
    return (a !== -1 ? minusSign : "") + replaceDigits(s.slice(a === -1 ? 0 : a + 1, b === -1 ? s.length : b), decimalZero) + (b !== -1 ? decimalSeparator : "") + replaceDigits(s.slice(b === -1 ? s.length : b + 1), decimalZero);
  };
  return applyLocale(String(value), this._minusSign, this._decimalSeparator, this._decimalZero);
};

//! https://github.com/tc39/ecma402/issues/334
function canFormatStrings() {
  try {
    return new globalThis.Intl.NumberFormat('en-US', {useGrouping: false}).format("1000000000000000000000000000000000000001") === "1000000000000000000000000000000000000001";
  } catch (error) {
    return false;
  }
}

if (globalThis.Intl == null) {
  globalThis.Intl = {};
}

// TypeError: Cannot assign to read only property 'Intl' of [object global]
// Mozilla/5.1 (Linux; U; Android 5.1; es-mx; Bmobile_AX1055) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30

if (globalThis.Intl.NumberFormat == null) {
  globalThis.Intl.NumberFormat = IntlNumberFormatPolyfill;
}
//if (!canFormatStrings()) {
//  globalThis.Intl.NumberFormat = IntlNumberFormatPolyfill;
//}

/*global document, window, Element, Event*/

if (window.MutationObserver == undefined && window.WebKitMutationObserver != undefined) {
  window.MutationObserver = window.WebKitMutationObserver;
}

// 1) DOMNodeInserted does not work in Konqueror 4.13
// 2) setAttribute and removeAttribute crash Konqueror 4.13

(function () {
  "use strict";

  if (window.MutationEvent == undefined) {
    var createEvent = document.createEvent;
    document.createEvent = function (type) {
      return createEvent.call(document, type === "MutationEvent" ? "Event" : type);
    };
    Event.prototype.initMutationEvent = function (type, bubbles, cancelable, relatedNode, prevValue, newValue, attrName, attrChange) {
      this.type = type;
      this.bubbles = bubbles;
      this.cancelable = cancelable;
      this.relatedNode = relatedNode;
      this.prevValue = prevValue;
      this.newValue = newValue;
      this.attrName = attrName;
      this.attrChange = attrChange;
    };
  }

  var isDOMNodeInsertedSupported = function () {
    var a = document.createElement("a");
    var flag = false;
    a.addEventListener("DOMNodeInserted", function (event) {
      flag = true;
    }, false);
    a.innerHTML = "data-test";
    return flag;
  };

  // IE 8
  if (window.MutationObserver == undefined && !isDOMNodeInsertedSupported()) {
    var tmpElement = document.createElement("div");
    var innerHTML = Object.getOwnPropertyDescriptor(Element.prototype, "innerHTML");
    Object.defineProperty(Element.prototype, "innerHTML", {
      get: function () {
        return innerHTML.get.call(this);
      },
      set: function (value) {
        while (this.firstChild != undefined) {
          this.firstChild.parentNode.removeChild(this.firstChild);
        }
        innerHTML.set.call(tmpElement, value);
        while (tmpElement.firstChild != undefined) {
          this.appendChild(tmpElement.firstChild);
        }
      }
    });
    var appendChild = Element.prototype.appendChild;
    Element.prototype.appendChild = function (node) {
      if (node.parentNode != undefined) {
        node.parentNode.removeChild(node);
      }
      appendChild.call(this, node);
      var event = document.createEvent("MutationEvent");
      event.initMutationEvent("DOMNodeInserted", true, false, this, "", "", "", 0);
      node.dispatchEvent(event);
    };
    var removeChild = Element.prototype.removeChild;
    Element.prototype.removeChild = function (node) {
      var event = document.createEvent("MutationEvent");
      event.initMutationEvent("DOMNodeRemoved", true, false, this, "", "", "", 0);
      node.dispatchEvent(event);
      removeChild.call(this, node);
    };
    var insertBefore = Element.prototype.insertBefore;
    Element.prototype.insertBefore = function (node, referenceNode) {
      if (node.parentNode != undefined) {
        node.parentNode.removeChild(node);
      }
      insertBefore.call(this, node, referenceNode);
      var event = document.createEvent("MutationEvent");
      event.initMutationEvent("DOMNodeInserted", true, false, this, "", "", "", 0);
      node.dispatchEvent(event);
    };
  }

  var isDOMAttrModifiedSupported = function () {
    var a = document.createElement("a");
    var flag = false;
    a.addEventListener("DOMAttrModified", function (event) {
      flag = true;
    }, false);
    a.setAttribute("data-test", "data-test");
    return flag;
  };

  // Chrome < 18, Safari < 6
  // Firefox and Opera should support although caniuse.com says some older version do not support it
  if (window.MutationObserver == undefined && !isDOMAttrModifiedSupported() && !/Konqueror/.test(window.navigator.userAgent)) {
    var setAttribute = Element.prototype.setAttribute;
    Element.prototype.setAttribute = function (name, value) {
      var event = document.createEvent("MutationEvent");
      event.initMutationEvent("DOMAttrModified", true, false, this, this.getAttribute(name), value, name, 2);
      this.dispatchEvent(event);
      setAttribute.call(this, name, value);
    };
    var removeAttribute = Element.prototype.removeAttribute;
    Element.prototype.removeAttribute = function (name) {
      var event = document.createEvent("MutationEvent");
      event.initMutationEvent("DOMAttrModified", true, false, this, this.getAttribute(name), "", name, 3);
      this.dispatchEvent(event);
      removeAttribute.call(this, name);
    };
  }

}());

(function () {
  "use strict";

  function MutationObserver(callback) {
    this.callback = callback;
    this.listeners = [];
  }

  MutationObserver.prototype.observe = function (target, options) {
    var observer = this;
    var callback = this.callback;
    var attributeFilter = options.attributeFilter == undefined ? "" : options.attributeFilter.join(" ");
    var handler = function (event) {
      if ((event.attrName == undefined || event.attrName === "" || attributeFilter.indexOf(event.attrName) !== -1) && ((event.type === "DOMAttrModified" || event.type === "DOMCharacterDataModified" ? event.target : event.relatedNode) === event.currentTarget || options.subtree)) {
        callback([{
          type: event.type === "DOMAttrModified" ? "attributes" : (event.type === "DOMCharacterDataModified" ? "characterData" : "childList"),
          target: event.type === "DOMAttrModified" || event.type === "DOMCharacterDataModified" ? event.target : event.relatedNode,
          addedNodes: event.type === "DOMNodeInserted" ? [event.target] : [],
          removedNodes: event.type === "DOMNodeRemoved" ? [event.target] : [],
          previousSibling: event.target.previousSibling,
          nextSibling: event.target.nextSibling,
          attributeName: event.attrName,
          attributeNamespace: undefined,
          oldValue: event.prevValue
        }], observer);
      }
    };
    this.listeners.push({
      target: target,
      handler: handler,
      options: options
    });
    if (options.attributes) {
      target.addEventListener("DOMAttrModified", handler, false);
    }
    if (options.characterData) {
      target.addEventListener("DOMCharacterDataModified", handler, false);
    }
    if (options.childList) {
      target.addEventListener("DOMNodeInserted", handler, false);
    }
    if (options.childList) {
      target.addEventListener("DOMNodeRemoved", handler, false);
    }
  };

  MutationObserver.prototype.disconnect = function () {
    while (this.listeners.length !== 0) {
      var listener = this.listeners.pop();
      var target = listener.target;
      var handler = listener.handler;
      var options = listener.options;
      if (options.attributes) {
        target.removeEventListener("DOMAttrModified", handler, false);
      }
      if (options.characterData) {
        target.removeEventListener("DOMCharacterDataModified", handler, false);
      }
      if (options.childList) {
        target.removeEventListener("DOMNodeInserted", handler, false);
      }
      if (options.childList) {
        target.removeEventListener("DOMNodeRemoved", handler, false);
      }
    }
  };

  MutationObserver.prototype.takeRecords = function() {
    return [];
  };

  if (window.MutationObserver == undefined) {
    window.MutationObserver = MutationObserver;
  }

}());

/*global document*/

(function () {
"use strict";

function round(v) {
  return (Math.floor(Math.pow(10, 6) * v + 0.5) / Math.pow(10, 6)).toString();
}

// see https://github.com/gliffy/canvas2svg/blob/master/canvas2svg.js
// canvas like API
function SVGRenderingContext2D(svg) {
  // public
  this.font = "normal 10px sans-serif";
  this.textBaseline = "alphabetic";
  this.textAlign = "start";
  // private
  this.svg = svg;
  this.svg.setAttribute("font-size", "16");//?
  this.svg.setAttribute("text-anchor", "middle");
  this.svg.setAttribute("fill", "currentColor");
  this.x = 0;
  this.y = 0;
  this.sx = 1;
  this.sy = 1;
  this.px = 0;
  this.py = 0;
}
SVGRenderingContext2D.prototype.translate = function (dx, dy) {
  this.x += dx;
  this.y += dy;
};
SVGRenderingContext2D.prototype.scale = function (sx, sy) {
  this.sx *= sx;
  this.sy *= sy;
  this.x /= sx;
  this.y /= sy;
};
SVGRenderingContext2D.prototype.fillText = function (text, dx, dy) {
  if (this.textBaseline !== "middle" || this.textAlign !== "center") {
    throw new RangeError();
  }
  var match = /^(italic|normal)\s(\d+(?:\.\d+)?)px\s(serif)$/.exec(this.font);
  if (match == null) {
    throw new RangeError();
  }
  var fontStyle = match[1];
  var fontSize = Number.parseFloat(match[2]);
  var e = document.createElementNS("http://www.w3.org/2000/svg", "text");
  e.setAttribute("x", round(this.x + dx));
  e.setAttribute("y", round(this.y + dy));
  if (round(this.sx) !== round(1) || round(this.sy) !== round(1)) {
    e.setAttribute("transform", "scale(" + round(this.sx) + ", " + round(this.sy) + ")");
    //e.setAttribute("dominant-baseline", "middle");//!TODO: FIX!
  }
  if (fontStyle !== "normal") {
    e.setAttribute("font-style", fontStyle);
  }
  if (fontSize !== 16) {
    e.setAttribute("font-size", round(fontSize));
  }
  e.setAttribute("dy", "0.25em"); //TODO: FIX
  //e.setAttribute("text-anchor", "middle");
  //e.setAttribute("dominant-baseline", "central");
  // not supported in Opera, in Edge, in IE, in Safari (no "text-after-edge")
  //e.setAttribute("dominant-baseline", "text-after-edge");
  e.textContent = text;
  this.svg.appendChild(e);
};

SVGRenderingContext2D.prototype.measureText = function (text) {
  // TODO: performance
  // http://wilsonpage.co.uk/introducing-layout-boundaries/
  var tmp = document.getElementById("measure-text-element");
  if (tmp == null) {
    tmp = document.createElement("div");
    tmp.id = "measure-text-element";
    tmp.style.position = "fixed";
    tmp.style.top = "0px"; // affects layout root in Chrome
    tmp.style.left = "0px"; // affects layout root in Chrome
    tmp.style.whiteSpace = "nowrap";
    tmp.style.width = "0px";
    tmp.style.height = "0px";
    tmp.style.overflow = "hidden";
    tmp.style.visibility = "hidden";
    tmp.style.contain = "strict";//TODO: ?
    var span = document.createElement("span");
    span.style.font = "normal 16px serif";
    span.textContent = " ";
    tmp.appendChild(span);
    document.body.appendChild(tmp);
  }
  var span = tmp.querySelector("span");
  span.style.font = this.font;
  span.firstChild.textContent = text; //Note: on the TextNode
  var rect = span.getBoundingClientRect();
  var width = rect.right - rect.left;
  //tmp.parentNode.removeChild(tmp);
  return {
    width: width
  };
};

SVGRenderingContext2D.prototype.beginPath = function () {
};
SVGRenderingContext2D.prototype.moveTo = function (x, y) {
  this.px = x;
  this.py = y;
};
SVGRenderingContext2D.prototype.lineTo = function (x, y) {
  var e = document.createElementNS("http://www.w3.org/2000/svg", "line");
  e.setAttribute("x1", round(this.x + this.px));
  e.setAttribute("y1", round(this.y + this.py));
  e.setAttribute("x2", round(this.x + x));
  e.setAttribute("y2", round(this.y + y));
  e.setAttribute("stroke", "currentColor");
  this.svg.appendChild(e);
};
SVGRenderingContext2D.prototype.ellipse = function (cx, cy, rx, ry) {
  var e = document.createElementNS("http://www.w3.org/2000/svg", "ellipse");
  e.setAttribute("cx", round(this.x + cx));
  e.setAttribute("cy", round(this.y + cy));
  e.setAttribute("rx", round(rx));
  e.setAttribute("ry", round(ry));
  e.setAttribute("stroke", "currentColor");
  e.setAttribute("fill", "none");
  this.svg.appendChild(e);
};
SVGRenderingContext2D.prototype.stroke = function () {
};

globalThis.SVGRenderingContext2D = SVGRenderingContext2D;

}());

/*global SVGRenderingContext2D, console, document, XMLSerializer*/

(function () {
"use strict";

// see https://github.com/ForbesLindesay-Unmaintained/mathml-to-svg/pulls
function MathMLToSVG() {
}

MathMLToSVG.getFontSize = function (scriptlevel) {
  return Math.floor(16 * Math.pow(0.8, scriptlevel) + 0.5);
};

MathMLToSVG.makeFont = function (fontSize, fontStyle) {
  return fontStyle + " " + fontSize + "px" + " " + "serif";
};

MathMLToSVG.measure = function (context, node, scriptlevel) {
  var tagName = node.tagName.toLowerCase();
  var f = MathMLToSVG[tagName];
  if (f == null) {
    console.warn(tagName);
    f = MathMLToSVG["mrow"];
  }
  return f(context, node, scriptlevel);
};

var MI_MN_MO_MTEXT = function (context, node, scriptlevel) {
  var text = node.textContent.replace(/^\s+|\s+$/g, "");
  var fontSize = MathMLToSVG.getFontSize(scriptlevel);
  var font = MathMLToSVG.makeFont(fontSize, node.tagName.toLowerCase() === "mi" && node.textContent.length === 1 ? "italic" : "normal");
  context.font = font;
  var textWidth = context.measureText(text).width;
  var lspace = 0;
  var rspace = 0;
  // MathML3 spec has "Operator dictionary entries" with lspace+rspace table
  if (node.tagName.toLowerCase() === "mo") {
    var c = text;
    if (c === '\u2061' || c === '\u2062' || c === '\u2063' ||
        c === '(' || c === ')' || c === '|' || c === '{' || c === '}' ||
        node.nextElementSibling == null || node.previousElementSibling == null ||
        c === ',') {
      lspace = 0;
      rspace = 0;
    } else if (c === "\u00D7" || c === "+") {
      lspace = 4;
      rspace = 4;
    } else {
      lspace = 4;
      rspace = 4;
      console.warn(c);
    }
    //if (c === "\u2212" || c === "~") {
    //  space = 0;
    //}
    if (node.getAttribute("lspace") != null) {
      lspace = Number.parseFloat(node.getAttribute("lspace"));
    }
    if (node.getAttribute("rspace") != null) {
      rspace = Number.parseFloat(node.getAttribute("rspace"));
    }
  }
  lspace = fontSize * lspace / 18;
  rspace = fontSize * rspace / 18;
  return {
    baseline: 0,
    width: lspace + textWidth + rspace,
    height: fontSize,
    render: function () {
      context.translate(lspace, 0);
      context.font = font;
      context.textBaseline = "middle";
      context.textAlign = "center";
      context.fillText(text, textWidth / 2, fontSize / 2);
      context.translate(-lspace, 0);
    }
  };
};

MathMLToSVG.mi = MI_MN_MO_MTEXT;
MathMLToSVG.mn = MI_MN_MO_MTEXT;
MathMLToSVG.mo = MI_MN_MO_MTEXT;
MathMLToSVG.mtext = MI_MN_MO_MTEXT;

MathMLToSVG.mtable = function (context, node, scriptlevel) {
  var sizesByRow = [];
  for (var row = node.firstElementChild; row != null; row = row.nextElementSibling) {
    if (row.tagName.toLowerCase() === "mtr") {
      var rowCellSizes = [];
      for (var cell = row.firstElementChild; cell != null; cell = cell.nextElementSibling) {
        if (cell.tagName.toLowerCase() === "mtd") {
          var sizes = MathMLToSVG.measure(context, cell, scriptlevel);
          rowCellSizes.push(sizes);
        }
      }
      sizesByRow.push(rowCellSizes);
    }
  }
  var rows = sizesByRow.length;
  var cols = 0;
  for (var i = 0; i < rows; i += 1) {
    cols = Math.max(cols, sizesByRow[i].length);
  }

  var columnlines = (node.getAttribute("columnlines") || "none").split(" ");
  var fontSize = MathMLToSVG.getFontSize(scriptlevel);
  var columnspacing = Number.parseFloat(node.getAttribute("columnspacing") || "0.8em") * fontSize;
  var rowBaselines = [];
  for (var i = 0; i < rows; i += 1) {
    rowBaselines.push(0);
  }
  var rowHeights = [];
  for (var i = 0; i < rows; i += 1) {
    rowHeights.push(0);
  }
  var columnWidths = [];
  for (var i = 0; i < cols; i += 1) {
    columnWidths.push(0);
  }
  for (var i = 0; i < rows; i += 1) {
    var row = sizesByRow[i];
    var largestHeightAboveBaseline = 0;
    for (var j = 0; j < row.length; j += 1) {
      var sizes = row[j];
      largestHeightAboveBaseline = Math.max(largestHeightAboveBaseline, sizes.height - sizes.baseline);
    }
    for (var j = 0; j < row.length; j += 1) {
      var sizes = row[j];
      rowHeights[i] = Math.max(rowHeights[i], largestHeightAboveBaseline + sizes.baseline);
      columnWidths[j] = Math.max(columnWidths[j], sizes.width + columnspacing);
    }
    rowBaselines[i] = largestHeightAboveBaseline;
  }

  var height = 0;
  for (var i = 0; i < rowHeights.length; i += 1) {
    height += rowHeights[i];
  }
  var width = 0;
  for (var i = 0; i < columnWidths.length; i += 1) {
    width += columnWidths[i];
    width += columnlines[i % columnlines.length] === "none" ? 0 : 1;
  }

  return {
    baseline: height / 2 - fontSize / 2,
    width: width,
    height: height,
    render: function () {

      var y = 0;
      for (var i = 0; i < sizesByRow.length; i += 1) {
        var row = sizesByRow[i];
        var x = 0;
        for (var j = 0; j < row.length; j += 1) {
          var sizes = row[j];

          var ax = (columnWidths[j] - sizes.width) / 2;
          var ay = rowBaselines[i] - (sizes.height - sizes.baseline); // rowalign="baseline"

          context.translate(x + ax, y + ay);
          sizes.render();
          context.translate(-x - ax, -y - ay);

          x += columnWidths[j];
          var cl = columnlines[j % columnlines.length];
          if (cl !== "none") {
            context.beginPath();
            context.moveTo(x, y);
            context.lineTo(x, y + rowHeights[i]);
            context.stroke();
            x += 1;
          }
        }
        y += rowHeights[i];
      }
    }
  };
};

MathMLToSVG.mfenced = function (context, node, scriptlevel) {
  var fontSize = MathMLToSVG.getFontSize(scriptlevel);
  var font = MathMLToSVG.makeFont(fontSize, "normal");
  var measureFence = function (font, text) {
    context.font = font;
    return context.measureText(text).width;
  };
  var drawFence = function (font, text, textWidth, scaleX, scaleY, fontSize) {
    context.scale(scaleX, scaleY);
    context.font = font;
    context.textBaseline = "middle";
    context.textAlign = "center";
    context.fillText(text, textWidth / 2, fontSize / 2);
    context.scale(1 / scaleX, 1 / scaleY);
  };
  var open = node.getAttribute("open") || "(";
  var close = node.getAttribute("close") || ")";
  var child = node.firstElementChild;
  var sizes = MathMLToSVG.measure(context, child, scriptlevel);
  var openWidth = measureFence(font, open);
  var closeWidth = measureFence(font, close);
  var scaleY = sizes.height / fontSize;
  var scaleX = Math.sqrt(Math.sqrt(scaleY));
  return {
    baseline: sizes.baseline,
    width: openWidth + sizes.width + closeWidth + (scaleX - 1) * openWidth + (scaleX - 1) * closeWidth,
    height: sizes.height,
    render: function () {
      drawFence(font, open, openWidth, scaleX, scaleY, fontSize);
      context.translate(openWidth * scaleX, 0);
      sizes.render();
      context.translate(sizes.width, 0);
      drawFence(font, close, closeWidth, scaleX, scaleY, fontSize);
      context.translate(-sizes.width, 0);
      context.translate(-openWidth * scaleX, 0);
    }
  };
};

function isStretchyOperator(text) {
  return text === '(' || text === ')' || text === '{' || text === '}' || text === '|';
}

function isStretchy(node) {
  return node.tagName.toLowerCase() === 'mo' && isStretchyOperator(node.textContent);
}

var MATH_MROW = function (context, node, scriptlevel) {
  var baseline = 0;
  var width = 0;
  var height = 0;
  var childSizes = [];
  var child = node.firstElementChild;
  while (child != null) {
    var sizes = MathMLToSVG.measure(context, child, scriptlevel);
    baseline = Math.max(baseline, sizes.baseline);
    width += sizes.width;
    height = Math.max(height, sizes.height - sizes.baseline);
    var stretchy = isStretchy(child);
    childSizes.push({
      sizes: sizes,
      stretchy: stretchy
    });
    child = child.nextElementSibling;
  }

  var fontSize = MathMLToSVG.getFontSize(scriptlevel);
  var scaleY = (height + baseline) / fontSize;
  var scaleX = Math.sqrt(Math.sqrt(scaleY));
  for (var i = 0; i < childSizes.length; i += 1) {
    var sizes = childSizes[i].sizes;
    var stretchy = childSizes[i].stretchy;
    if (stretchy) {
      width += (scaleX - 1) * sizes.width;
    }
  }

  return {
    baseline: baseline,
    width: width,
    height: height + baseline,
    render: function () {
      var x = 0;
      for (var i = 0; i < childSizes.length; i += 1) {
        var sizes = childSizes[i].sizes;
        var stretchy = childSizes[i].stretchy;
        var ay = height - (sizes.height - sizes.baseline);
        context.translate(x, 0);
        if (stretchy) {
          context.scale(scaleX, scaleY);
        } else {
          context.translate(0, ay);
        }
        sizes.render();
        if (stretchy) {
          context.scale(1 / scaleX, 1 / scaleY);
        } else {
          context.translate(0, -ay);
        }
        context.translate(-x, 0);
        if (stretchy) {
          x += (scaleX - 1) * sizes.width;
        }
        x += sizes.width;
      }
    }
  };
};

MathMLToSVG.math = MATH_MROW;
MathMLToSVG.mrow = MATH_MROW;
MathMLToSVG.mtd = MATH_MROW;

MathMLToSVG.mstyle = function (context, node, scriptlevel) {
  //TODO: font-weight
  var sizes = MATH_MROW(context, node, scriptlevel);
  return {
    baseline: sizes.baseline,
    width: sizes.width,
    height: sizes.height,
    render: function () {
      sizes.render();
    }
  };
};

MathMLToSVG.mpadded = function (context, node, scriptlevel) {
  var fontSize = MathMLToSVG.getFontSize(scriptlevel);
  var width = Number.parseFloat(node.getAttribute("width")) * fontSize;
  var lspace = Number.parseFloat(node.getAttribute("lspace")) * fontSize;
  var sizes = MATH_MROW(context, node, scriptlevel);
  return {
    baseline: sizes.baseline,
    width: width + sizes.width,
    height: sizes.height,
    render: function () {
      context.translate(lspace, 0);
      sizes.render();
      context.translate(-lspace, 0);
    }
  };
};

MathMLToSVG.mfrac = function (context, node, scriptlevel) {
  var top = node.firstElementChild;
  var bottom = top.nextElementSibling;
  var topSizes = MathMLToSVG.measure(context, top, scriptlevel + 1);
  var bottomSizes = MathMLToSVG.measure(context, bottom, scriptlevel + 1);
  var width = Math.max(topSizes.width, bottomSizes.width);
  var height = 1 + topSizes.height + bottomSizes.height;
  var fontSize = MathMLToSVG.getFontSize(scriptlevel + 1);
  return {
    baseline: 0.5 + bottomSizes.height - 0.5 * fontSize,
    width: width,
    height: height,
    render: function () {
      context.translate((width - topSizes.width) / 2, 0);
      topSizes.render();
      context.translate(-(width - topSizes.width) / 2, 0);

      var middle = topSizes.height - 0.5;
      context.beginPath();
      context.moveTo(0, middle);
      context.lineTo(width, middle);
      context.stroke();

      context.translate((width - bottomSizes.width) / 2, 1 + topSizes.height);
      bottomSizes.render();
      context.translate(-(width - bottomSizes.width) / 2, -1 - topSizes.height);
    }
  };
};

var MSUP_MSUB = function (context, node, scriptlevel) {
  var base = node.firstElementChild;
  var exponent = base.nextElementSibling;
  var baseSizes = MathMLToSVG.measure(context, base, scriptlevel);
  var exponentSizes = MathMLToSVG.measure(context, exponent, scriptlevel + 1);
  var width = baseSizes.width + exponentSizes.width;
  var fontSize = MathMLToSVG.getFontSize(scriptlevel + 1);
  var height = baseSizes.height + exponentSizes.height - 0.5 * fontSize;
  var isMSUP = node.tagName.toLowerCase() === "msup";
  return {
    baseline: isMSUP ? 0 : 0.5 * fontSize,
    width: width,
    height: height,
    render: function () {
      if (isMSUP) {
        context.translate(0, 0.5 * fontSize);
      }
      baseSizes.render();
      if (isMSUP) {
        context.translate(0, -0.5 * fontSize);
      }
      if (!isMSUP) {
        context.translate(0, baseSizes.height - 0.5 * fontSize);
      }
      context.translate(baseSizes.width, 0);
      exponentSizes.render();
      context.translate(-baseSizes.width, 0);
      if (!isMSUP) {
        context.translate(0, -baseSizes.height + 0.5 * fontSize);
      }
    }
  };
};

MathMLToSVG.msup = MSUP_MSUB;
MathMLToSVG.msub = MSUP_MSUB;

MathMLToSVG.menclose = function (context, node, scriptlevel) {
  var sizes = MATH_MROW(context, node, scriptlevel); // 1*
  var notation = node.getAttribute("notation").split(" ");
  return {
    baseline: sizes.baseline,
    width: sizes.width,
    height: sizes.height,
    render: function () {
      sizes.render();
      var width = sizes.width;
      var height = sizes.height;
      for (var i = 0; i < notation.length; i += 1) {
        var n = notation[i];
        if (n !== "") {
          context.beginPath();
          if (n === "circle") {
            context.ellipse(width / 2, height / 2, width / 2, height / 2, 0, 0, 2 * Math.PI, true);
          } else if (n === "verticalstrike") {
            context.moveTo(width / 2, 0);
            context.lineTo(width / 2, height);
          } else if (n === "horizontalstrike") {
            context.moveTo(0, height / 2);
            context.lineTo(width, height / 2);
          }
          context.stroke();
        }
      }
    }
  };
};

var MSQRT_MROOT = function (context, node, scriptlevel) {
  var isMSQRT = node.tagName.toLowerCase() === "msqrt";
  var surd = "\u221A";
  var fontSize = MathMLToSVG.getFontSize(scriptlevel);
  var font = MathMLToSVG.makeFont(fontSize, "normal");
  context.font = font;
  var surdWidth = context.measureText(surd).width;
  var h = 1;
  var base = isMSQRT ? node : node.firstElementChild;
  var index = isMSQRT ? undefined : base.nextElementSibling;
  // 1* for msqrt
  var baseSizes = isMSQRT ? MATH_MROW(context, base, scriptlevel) : MathMLToSVG.measure(context, base, scriptlevel);
  var indexSizes = isMSQRT ? undefined : MathMLToSVG.measure(context, index, scriptlevel + 2);
  return {
    baseline: baseSizes.baseline,
    width: baseSizes.width + surdWidth,
    height: baseSizes.height + h + 2,
    render: function () {
      context.translate(0, (baseSizes.height - fontSize) / 2 + 2);
      context.font = font;
      context.textBaseline = "middle";
      context.textAlign = "center";
      context.fillText(surd, surdWidth / 2, fontSize / 2);
      context.translate(0, -(baseSizes.height - fontSize) / 2 - 2);
      context.beginPath();
      context.moveTo(surdWidth, 0);
      context.lineTo(surdWidth + baseSizes.width, 0);
      context.stroke();
      context.translate(surdWidth, h + 2);
      baseSizes.render();
      context.translate(-surdWidth, -h - 2);
      if (!isMSQRT) {
        context.translate(0, -0.25 * fontSize + 2);
        indexSizes.render();
        context.translate(0, 0.25 * fontSize - 2);
      }
    }
  };
};

MathMLToSVG.msqrt = MSQRT_MROOT;
MathMLToSVG.mroot = MSQRT_MROOT;

MathMLToSVG.munder = function (context, node, scriptlevel) {
  var first = node.firstElementChild;
  var second = first.nextElementSibling;
  var firstSizes = MathMLToSVG.measure(context, first, scriptlevel);
  var secondSizes = MathMLToSVG.measure(context, second, scriptlevel);
  var width = Math.max(firstSizes.width, secondSizes.width);
  var height = firstSizes.height + secondSizes.height;
  return {
    baseline: secondSizes.height,
    width: width,
    height: height,
    render: function () {
      context.translate((width - firstSizes.width) / 2, 0);
      firstSizes.render();
      context.translate(-(width - firstSizes.width) / 2, 0);
      context.translate(0, firstSizes.height);
      secondSizes.render();
      context.translate(0, -firstSizes.height);
    }
  };
};

//?
MathMLToSVG.drawMathMLElement = function (element) {
  var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  var svgContext = new SVGRenderingContext2D(svg);
  var sizes = MathMLToSVG.measure(svgContext, element, 0);
  var width = sizes.width;
  var height = sizes.height;
  svg.setAttribute("width", width + "px");
  svg.setAttribute("height", height + "px");
  svg.setAttribute("viewBox", "0 0 " + width + " " + height);
  sizes.render();
  var data = (new XMLSerializer()).serializeToString(svg);
  var src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(data);
  return {
    src: src,
    width: width,
    height: height
  };
};

globalThis.MathMLToSVG = MathMLToSVG;

}());


(function () {
"use strict";

//TODO:
//? "≠": {replacement: "=", precedence: 2, isRightToLeftAssociative: false}

var operators = {
  ",": {replacement: ",", precedence: -10, isRightToLeftAssociative: false},//?
  "\u2192": {replacement: "->", precedence: -9, isRightToLeftAssociative: false},//? &rarr;
  "\u2194": {replacement: "<->", precedence: -9, isRightToLeftAssociative: false},//? &harr;
  ".^": {replacement: ".^", precedence: 7, isRightToLeftAssociative: true},
  "^": {replacement: "^", precedence: 6, isRightToLeftAssociative: true},
  "\u00D7": {replacement: "*", precedence: 5, isRightToLeftAssociative: false},// &times;
  "\u22C5": {replacement: "*", precedence: 5, isRightToLeftAssociative: false},// &sdot;
  "\u2061": {replacement: "", precedence: 5, isRightToLeftAssociative: false},// &af;
  //TODO: ? cosx
  "\u2062": {replacement: "*", precedence: 5, isRightToLeftAssociative: false},// &it;
  "\u2063": {replacement: ",", precedence: -10, isRightToLeftAssociative: false},// &ic;
  "/": {replacement: "/", precedence: 5, isRightToLeftAssociative: false},
  "\u2215": {replacement: "/", precedence: 5, isRightToLeftAssociative: false},
  "\u2212": {replacement: "-", precedence: 3, isRightToLeftAssociative: false}, // &minus;
  "+": {replacement: "+", precedence: 2, isRightToLeftAssociative: false}
};

var brackets = {
  '(': true,
  '{': true,
  ')': true,
  '}': true,
  '|': true
};

var fence = function (x, operator, left, format) {
  return (x.precedence < operators[operator].precedence || (x.precedence === operators[operator].precedence && (left && operators[operator].isRightToLeftAssociative || !left && !operators[operator].isRightToLeftAssociative))) ? (format === "LaTeX" ? "\\left(" : "(") + x.string + (format === "LaTeX" ? "\\right)" : ")") : x.string;
};

var transformMTABLE = function (node, format) {
  function isStrikedRow(node) {
    return node.firstElementChild != null &&
           node.firstElementChild.tagName.toLowerCase() === 'mtd' &&
           node.firstElementChild.childElementCount === 1 &&
           node.firstElementChild.firstElementChild.tagName.toLowerCase() === 'menclose' &&
           (node.firstElementChild.firstElementChild.getAttribute('notation') === 'horizontalstrike' || (node.firstElementChild.firstElementChild.getAttribute('notation') || '').indexOf('horizontalstrike') !== -1); // TODO: remove
  }
  function isStrikedColumn(node) {
    return node.childElementCount === 1 &&
           node.firstElementChild.tagName.toLowerCase() === 'menclose' &&
           node.firstElementChild.getAttribute('notation') === 'verticalstrike';
  }
  var childNode = node.firstElementChild;
  var rows = "";
  rows += (format === "LaTeX" ? "\\begin{matrix}\n" : "{");
  var isFirstRow = true;
  while (childNode != undefined) {
    if (childNode.tagName.toLowerCase() === 'mtr' && !isStrikedRow(childNode)) {
      var c = childNode.firstElementChild;
      var row = "";
      while (c != undefined) {
        if (c.tagName.toLowerCase() === 'mtd' && !isStrikedColumn(c)) {
          row += (row !== "" ? (format === "LaTeX" ? " & " : ", ") : "") + fence(transformMathML(c, format), ",", true, format);
        }
        c = c.nextElementSibling;
      }
      rows += (!isFirstRow ? (format === "LaTeX" ? " \\\\\n" : ", ") : "") + (format === "LaTeX" ? "" : "{") + row + (format === "LaTeX" ? "" : "}");
      isFirstRow = false;
    }
    childNode = childNode.nextElementSibling;
  }
  rows += (format === "LaTeX" ? "\n\\end{matrix}" : "}");
  return rows; // "(" + ... + ")" ?
};

function TransformResult(string, precedence) {
  this.string = string;
  this.precedence = precedence;
}

var transformMathML = function (node, format, inferredMROW) {
  inferredMROW = inferredMROW != undefined ? inferredMROW : false;
  if (format !== "AsciiMath" && format !== "LaTeX") {
    throw new RangeError(format);
  }
  var tagName = inferredMROW ? "mrow" : node.tagName.toLowerCase();
  if (tagName === "math" ||
      tagName === "munder" ||
      tagName === "mover" ||
      tagName === "munderover" || //TODO:
      tagName === "mtr" ||
      tagName === "mtd" ||
      tagName === "mrow" ||
      tagName === "mfenced" ||
      tagName === "menclose" ||
      tagName === "mpadded" ||
      tagName === "mstyle" ||
      tagName === "mo" ||
      tagName === "mi" ||
      tagName === "mn") {
    var s = "";
    var p = 42;
    if (tagName === "mi" || tagName === "mn" || tagName === "mo") {
      // Google Translate inserts <font> tags
      s = node.textContent;
    } else {
      var childNode = node.firstElementChild;
      while (childNode != undefined) {
        var tmp = transformMathML(childNode, format);
        if (tagName === "munder" && (s === "=" || s === "~" || s.length === 1) && tmp.string !== "") {//!
          s = s + "[" + tmp.string + "]" + s;
        } else if (tagName === "munderover") {
          if (childNode === node.firstElementChild.nextElementSibling) {
            s += "_(" + tmp.string + ")";
          } else if (childNode === node.firstElementChild.nextElementSibling.nextElementSibling) {
            s += "^(" + tmp.string + ")";
          } else {
            s += tmp.string;
          }
        } else {
          s += tmp.string;
        }
        if (p > tmp.precedence) {
          p = tmp.precedence;
        }
        childNode = childNode.nextElementSibling;
      }
    }
    if (node.firstElementChild != null && node.firstElementChild.tagName.toLowerCase() === 'mo' && brackets[node.firstElementChild.textContent] != null &&
        node.lastElementChild != null && node.lastElementChild.tagName.toLowerCase() === 'mo' && brackets[node.lastElementChild.textContent] != null) {
      if (format === "LaTeX") {
        s = '\\left' + s.slice(0, -1) + '\\right' + s.slice(-1);
      }
      p = 42;
    }
    if (tagName === "mo") {
      var o = operators[s];
      var precedence = o == undefined ? 0 : o.precedence;
      if (p > precedence) {
        p = precedence;
      }
      s = o == undefined ? s : o.replacement;
    }
    if (tagName === 'mi') {
      if (s === '\u2147') {
        s = 'e';
      } else if (s === '\u2148') {
        s = 'i';
      }
      if (format === "LaTeX") {
        if (s.length === 1 && s.charCodeAt(0) >= 0x03B1 && s.charCodeAt(0) <= 0x03B1 + 24) {
          var greek = " alpha beta gamma delta epsilon zeta eta theta iota kappa lambda mu nu xi omicron pi rho varsigma sigma tau upsilon phi chi psi omega ";
          s = greek.split(' ')[s.charCodeAt(0) - 0x03B1 + 1];
        }
      }
    }
    //TODO: fix
    if (tagName === "mi" && s.length > 1) {
      s = (format === "LaTeX" ? "\\" : "") + s;
    }
    //
    if (tagName === "mn" && s.indexOf(",") !== -1) {
      p = -10 - 1;
    }
    if (tagName === "mo" && s === "," && (node.getAttribute("rspace") != null || node.closest('msub') == null)) {//TODO: ?
      s += " ";
    }
    return tagName === "mfenced" ? new TransformResult((format === "LaTeX" ? "\\left" : "") + (node.getAttribute("open") || "(") + s + (format === "LaTeX" ? "\\right" : "") + (node.getAttribute("close") || ")"), 42) : new TransformResult(s, p);
  }
  if (tagName === "msup") {
    return new TransformResult(fence(transformMathML(node.firstElementChild, format), "^", true, format) + "^" + fence(transformMathML(node.firstElementChild.nextElementSibling, format), "^", false, format), operators["^"].precedence);
  }
  if (tagName === "msub") {
    //TODO: fix a_(1,2) ?
    var b = transformMathML(node.firstElementChild, format).string;
    var x = transformMathML(node.firstElementChild.nextElementSibling, format).string;
    return new TransformResult(b + "_" + (format === "LaTeX" ? (x.length > 1 ? '{' + x + '}' : x) : (x.indexOf(",") !== -1 ? "(" + x + ")" : x)), 42); // "(" + ... + ")" ?
  }
  if (tagName === "mfrac") {
    var n = transformMathML(node.firstElementChild, format);
    var d = transformMathML(node.firstElementChild.nextElementSibling, format);
    if (format === "LaTeX") {
      return new TransformResult("\\frac" + "{" + n.string + "}" + "{" + d.string + "}", 42);
    }
    // https://www.unicode.org/notes/tn28/UTN28-PlainTextMath-v3.1.pdf
    return new TransformResult(fence(n, "/", true, format) + (node.getAttribute("linethickness") === "0" ? "¦" : "/") + fence(d, "/", false, format), operators["/"].precedence);
  }
  if (tagName === "msqrt") {
    return new TransformResult((format === "LaTeX" ? "\\" : "") + "sqrt" + (format === "LaTeX" ? "{" : "(") + transformMathML(node, format, true).string + (format === "LaTeX" ? "}" : ")"), 42);
  }
  if (tagName === "mroot") {
    return new TransformResult(fence(transformMathML(node.firstElementChild, format), "^", true, format) + "^" + "(" + "1" + "/" + transformMathML(node.firstElementChild.nextElementSibling, format).string + ")", operators["^"].precedence);
  }
  if (tagName === "mtable") {
    return new TransformResult(transformMTABLE(node, format), 42);
  }
  if (tagName === "mtext") {//?
    //return new TransformResult("", 42);
    var length = 0;
    var child = node.firstChild;
    while (child != null) {
      length += 1;
      child = child.nextSibling;
    }
    var range = {
      startContainer: node,
      startOffset: 0,
      endContainer: node,
      endOffset: length,
      commonAncestorContainer: node
    };
    var ss = window.serializeAsPlainText(range);
    ss = ss.trim();
    if (ss === "(?)" || ss === "?") {//TODO: ?
      ss = "";
    }
    return new TransformResult(ss === "" ? "" : (format === "LaTeX" ? "text(" : "\"") + ss + (format === "LaTeX" ? ")" : "\""), 42);
  }
  if (tagName === "maction") {
    console.info('only first child is handled for <maction>');
    return transformMathML(node.firstElementChild, format);
  }
  throw new TypeError("transformMathML:" + tagName);
};

globalThis.transformMathML = transformMathML;

}());

/*global transformMathML, XMLSerializer, DOMParser */

(function () {
  "use strict";

// TODO: remove?
// an array of array of strings -> string
var toMultilineString = function (array) {
  var table = new Array(array.length);
  for (var i = 0; i < array.length; i += 1) {
    var elements = array[i];
    var row = new Array(elements.length);
    for (var j = 0; j < elements.length; j += 1) {
      row[j] = elements[j].toString().replace(/^\s+|\s+$/g, '');
    }
    table[i] = row;
  }
  var columns = 0;
  for (var i = 0; i < array.length; i += 1) {
    columns = Math.max(columns, array[i].length);
  }
  var columnWidths = new Array(columns);
  for (var i = 0; i < columns; i += 1) {
    columnWidths[i] = 0;
  }
  for (var i = 0; i < table.length; i += 1) {
    var row = table[i];
    for (var j = 0; j < row.length; j += 1) {
      columnWidths[j] = Math.max(columnWidths[j], row[j].length);
    }
  }
  var result = '';
  for (var i = 0; i < table.length; i += 1) {
    var row = table[i];
    result += (i !== 0 ? '\n' : '');
    for (var j = 0; j < columns; j += 1) {
      var e = j < row.length ? row[j] : '';
      result += (j !== 0 ? '\t' : '');
      for (var padding = columnWidths[j] - e.length; padding > 0; padding -= 1) {
        result += ' ';
      }
      result += e;
    }
  }
  return result;
};

//=getMatrix4
//?
var getTableFromAsciiMathMatrix = function (input) {
  // return RPN(s).matrix.getElements();
  var rows = [[]];
  var cellStart = 0;
  var b = 0;
  for (var i = 0; i < input.length; i += 1) {
    var c = input.charCodeAt(i);
    if (c === "{".charCodeAt(0)) {
      b += 1;
      if (b === 2) {
        cellStart = i + 1;
      }
    } else if (c === "}".charCodeAt(0)) {
      if (b === 2) {
        rows[rows.length - 1].push(input.slice(cellStart, i));
      } else if (b === 0) {
        return null;
      }
      b -= 1;
    } else if (c === ",".charCodeAt(0)) {
      if (b === 2) {
        rows[rows.length - 1].push(input.slice(cellStart, i));
        cellStart = i + 1;
      } else if (b === 1) {
        rows.push([]);
      } else if (b === 0) {
        return null;
      }
    } else if (c === "(".charCodeAt(0)) {
      if (b < 2) {
        return null;
      }
      b += 1;
    } else if (c === ")".charCodeAt(0)) {
      if (b < 3) {
        return null;
      }
      b -= 1;
    } else if (/[^\s]/.test(String.fromCharCode(c))) {
      if (b < 2) {
        return null;
      }
    }
  }
  return rows;
};

var serializeMathML = function (element) {
  var mathml = new XMLSerializer().serializeToString(element).replace(/\sxmlns="[^"]+"/g, '');
  mathml = mathml.replace(/[\u2061]/g, '&#x2061;'); // &af; or &ApplyFunction; are not supported when pasting XML into Word
  mathml = '<math xmlns="http://www.w3.org/1998/Math/MathML">' + mathml + '</math>';
  return formatXml(mathml);
};

var parseMathML = function (mathml) {
  mathml = mathml.replace(/&times;/g, "\u00D7");
  mathml = mathml.replace(/&af;/g, "\u2061");
  mathml = mathml.replace(/&minus;/g, "\u2212");
  mathml = mathml.replace(/&ii;/g, "\u2148");
  return new DOMParser().parseFromString(mathml, "text/xml").firstChild;
};

var mathmlToLaTeX = function (element) {
  return transformMathML(element, "LaTeX").string;
};

// TODO: remove "matrix containers" ({useMatrixContainer: false})
var serializeMatrixContainer = function (matrixContainer) {
  if (matrixContainer.getAttribute('data-matrix') != null && matrixContainer.firstElementChild.nextElementSibling === null) {
    matrixContainer = matrixContainer.firstElementChild;
    matrixContainer = matrixContainer.cloneNode(true);
    // Removal of extra attributes added by "MathML polyfill":
    //TODO: href, draggable, tabindex - ?
    matrixContainer.removeAttribute('style');
    matrixContainer.removeAttribute('class');
    var es = matrixContainer.querySelectorAll('*');
    for (var i = 0; i < es.length; i += 1) {
      es[i].removeAttribute('style');//TODO: remove
      es[i].removeAttribute('class');//TODO: remove
    }
  }

  // TODO: https://www.w3.org/TR/clipboard-apis/#writing-to-clipboard
  return serializeMathML(matrixContainer);
};

var formatXml = function (xml) {
  // https://stackoverflow.com/questions/376373/pretty-printing-xml-with-javascript
  // Note: /.<\/\w[^>]*>$ is faster than /.+<\/\w[^>]*>$
  var formatted = '';
  var padding = '';
  var nodes = xml.replace(/></g, '>\n<').split('\n');
  for (var i = 0; i < nodes.length; i += 1) {
    var node = nodes[i];
    var indent = '';
    if (!/.<\/\w[^>]*>$/.test(node)) {
      if (/^<\/\w/.test(node)) {
        padding = padding.slice(0, 0 - '  '.length);
      } else {
        if (/^<\w[^>]*[^\/]>.*$/.test(node)) {
          indent = '  ';
        }
      }
    }
    formatted += padding + node + '\n';
    padding += indent;
  }
  return formatted;
};

var getMatrixFromTextBlocks = function (textBlocks) {
  //! no new lines, no spaces

  function splitBlocks(textBlocks, type) {
    function m(text) {
      return type === "rows" ? text.boundingBox.y + text.boundingBox.height / 2 : text.boundingBox.x + text.boundingBox.width / 2;
    }
    function rowMiddle(row) {
      var result = 0;
      for (var j = 0; j < row.length; j += 1) {
        result = (result * j + m(row[j])) / (j + 1);
      }
      return result;
    }
    var rows = [];
    for (var n = 0; n < textBlocks.length; n += 1) {
      var text = textBlocks[n];
      var middle = m(text);
      var rowIndex = -1;
      for (var i = 0; i < rows.length; i += 1) {
        var row = rows[i];
        if (Math.abs((rowMiddle(row) - middle) / (type === "rows" ? text.boundingBox.height : text.boundingBox.width)) < 0.75) {
          rowIndex = i;
        }
      }
      if (rowIndex === -1) {
        rows.push([]);
        rowIndex = rows.length - 1;
      }
      rows[rowIndex].push(text);
    }
    rows.sort(function (a, b) {
      return rowMiddle(a) - rowMiddle(b);
    });
    return rows;
  }

  textBlocks = textBlocks.filter(function (textBlock) {
    return /[^\(\)\[\]\|]/.test(textBlock.rawValue);//TODO: ?
  });
  var rows = splitBlocks(textBlocks, "rows");
  var cols = splitBlocks(textBlocks, "cols");

  var table = new Array(rows.length);
  for (var i = 0; i < rows.length; i += 1) {
    table[i] = new Array(cols.length);
    for (var j = 0; j < cols.length; j += 1) {
      table[i][j] = '';
    }
  }

  for (var n = 0; n < textBlocks.length; n += 1) {
    var text = textBlocks[n];
    var rowIndex = -1;
    for (var i = 0; i < rows.length; i += 1) {
      if (rows[i].indexOf(text) !== -1) {
        rowIndex = i;
      }
    }
    var colIndex = -1;
    for (var i = 0; i < cols.length; i += 1) {
      if (cols[i].indexOf(text) !== -1) {
        colIndex = i;
      }
    }
    table[rowIndex][colIndex] += text.rawValue;
  }

  return table.map(function (x) {
    return x.join(' ');
  }).join('\n');
};

  globalThis.getTableFromAsciiMathMatrix = getTableFromAsciiMathMatrix;
  //globalThis.serializeMathML = serializeMathML;
  globalThis.parseMathML = parseMathML;
  globalThis.formatXml = formatXml;
  globalThis.toMultilineString = toMultilineString;
  globalThis.mathmlToLaTeX = mathmlToLaTeX;
  globalThis.serializeMatrixContainer = serializeMatrixContainer;
  globalThis.getMatrixFromTextBlocks = getMatrixFromTextBlocks;

}());

/*global window, document, Node, XMLSerializer, transformMathML */

(function () {
"use strict";

var isBlock = function (display) {
  switch (display) {
    case "inline":
    case "inline-block":
    case "inline-flex":
    case "inline-grid":
    case "inline-table":
    case "none":
    case "table-column":
    case "table-column-group":
    case "table-cell":
      return false;
  }
  return true;
};

var getNodeLength = function (container) {
  if (container.nodeType === Node.TEXT_NODE) {
    return container.data.length;
  }
  if (container.nodeType === Node.ELEMENT_NODE) {
    var count = 0;
    var child = container.firstChild;
    while (child != null) {
      child = child.nextSibling;
      count += 1;
    }
    return count;
  }
  return undefined;
};

var isBoundaryPoint = function (container, offset, which, node) {
  if (which === "end" && offset !== getNodeLength(container) || which === "start" && offset !== 0) {
    return false;
  }
  for (var x = container; x !== node; x = x.parentNode) {
    var y = which === "end" ? x.nextSibling : (which === "start" ? x.previousSibling : null);
    // https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace#Whitespace_helper_functions
    while (y != null && y.nodeType !== Node.ELEMENT_NODE && (y.nodeType !== Node.TEXT_NODE || /^[\t\n\f\r\u0020]*$/.test(y.data))) {
      y = which === "end" ? y.nextSibling : (which === "start" ? y.previousSibling : null);
    }
    if (y != null) {
      return false;
    }
  }
  return true;
};

var getChildNode = function (container, offset, which, node) {
  var child = null;
  var x = container;
  while (x !== node) {
    child = x;
    x = x.parentNode;
  }
  if (child != null) {
    child = which === "end" ? child.nextSibling : (which === "start" ? child : null);
  } else {
    var i = -1;
    child = container.firstChild; // node === container
    while (++i < offset) {
      child = child.nextSibling;
    }
  }
  return child;
};

var serialize = function (range, isLineStart) {
  // big thanks to everyone
  // see https://github.com/timdown/rangy/blob/master/src/modules/rangy-textrange.js
  // see https://github.com/WebKit/webkit/blob/ec2f4d46b97bb20fd0877b1f4b5ec50f7b9ec521/Source/WebCore/editing/TextIterator.cpp#L1188
  // see https://github.com/jackcviers/Rangy/blob/master/spec/innerText.htm

  var node = range.commonAncestorContainer;
  var startContainer = range.startContainer;
  var startOffset = range.startOffset;
  var endContainer = range.endContainer;
  var endOffset = range.endOffset;

  if (node.nodeType === Node.TEXT_NODE) {
    if (node !== startContainer || node !== endContainer) {
      throw new TypeError();
    }
    var data = node.data.slice(startOffset, endOffset);
    var whiteSpace = window.getComputedStyle(node.parentNode, null).whiteSpace;
    if (whiteSpace !== 'pre') {
      data = data.replace(/[\t\n\f\r\u0020]+/g, " ");
      if (isLineStart) {
        data = data.replace(/^[\t\n\f\r\u0020]/g, "");
      }
    }
    return data;
  }
  if (node.nodeType === Node.ELEMENT_NODE) {
    var display = window.getComputedStyle(node, null).display;
    if (display === "none") {
      return "";
    }
    var result = "";
    if (isBlock(display) && !isLineStart) {
      result += "\n";
      isLineStart = true;
    }
    var x = undefined;
    if (isBoundaryPoint(startContainer, startOffset, "start", node) &&
        isBoundaryPoint(endContainer, endOffset, "end", node)) {
      var tagName = node.tagName.toLowerCase();
      if (tagName === "math" || (tagName !== "mtext" && node.namespaceURI === "http://www.w3.org/1998/Math/MathML")) {
        x = transformMathML(node, "AsciiMath").string;
      }
      if (tagName === "br") {
        x = "\n";
      }
    }
    if (x != undefined) {
      result += x;
    } else {
      var startChildNode = getChildNode(startContainer, startOffset, "start", node);
      var endChildNode = getChildNode(endContainer, endOffset, "end", node);
      var childNode = startChildNode;
      while (childNode !== endChildNode) {
        var childNodeRange = {
          startContainer: childNode === startChildNode && startContainer !== node ? startContainer : childNode,
          startOffset: childNode === startChildNode && startContainer !== node ? startOffset : 0,
          endContainer: childNode.nextSibling === endChildNode && endContainer !== node ? endContainer : childNode,
          endOffset: childNode.nextSibling === endChildNode && endContainer !== node ? endOffset : getNodeLength(childNode),
          commonAncestorContainer: childNode
        };
        var y = serialize(childNodeRange, isLineStart);
        isLineStart = y === "" && isLineStart || y.slice(-1) === "\n";
        result += y;
        childNode = childNode.nextSibling;
      }
    }
    if (display === "table-cell") {
      result += "\t";
    }
    if (isBlock(display) && !isLineStart) {
      result = result.replace(/[\t\n\f\r\u0020]$/g, "");
      result += "\n";
      isLineStart = true;
    }
    return result;
  }
  return "";
};

var serializeAsPlainText = function (range) {
  var isLineStart = range.startContainer.nodeType !== Node.TEXT_NODE || /^[\t\n\f\r\u0020]*$/.test(range.startContainer.data.slice(0, range.startOffset));
  var isLineEnd = range.endContainer.nodeType !== Node.TEXT_NODE || /^[\t\n\f\r\u0020]*$/.test(range.endContainer.data.slice(range.endOffset));
  var staticRange = {
    startContainer: range.startContainer,
    startOffset: range.startOffset,
    endContainer: range.endContainer,
    endOffset: range.endOffset,
    commonAncestorContainer: range.commonAncestorContainer
  };
  var value = serialize(staticRange, false);
  if (isLineStart) {
    value = value.replace(/^[\t\n\f\r\u0020]/g, "");
  }
  if (isLineEnd) {
    value = value.replace(/[\t\n\f\r\u0020]$/g, "");
  }
  return value;
};

var serializeAsHTML = function (range) {
  var fragment = range.cloneContents();
  if (range.commonAncestorContainer.nodeType === Node.ELEMENT_NODE && range.commonAncestorContainer.namespaceURI === "http://www.w3.org/1998/Math/MathML") {//?
    var math = document.createElementNS("http://www.w3.org/1998/Math/MathML", "math");
    math.appendChild(fragment);
    fragment = math;
  }
  return new XMLSerializer().serializeToString(fragment); // to have the xmlns for <math> elements
};

var onCopyOrDragStart = function (event) {
  var dataTransfer = event.type === "copy" ? event.clipboardData : event.dataTransfer;
  var tagName = event.target.nodeType === Node.ELEMENT_NODE ? event.target.tagName.toLowerCase() : "";
  if (tagName !== "input" && tagName !== "textarea" && (tagName !== "a" || event.type === "copy") && tagName !== "img") {
    //! dataTransfer.effectAllowed throws an exception in FireFox if tagName is INPUT or TEXTAREA
    if ((event.type === "copy" || dataTransfer.effectAllowed === "uninitialized") && !event.defaultPrevented) {
      var selection = window.getSelection();
      var rangeCount = selection.rangeCount;
      if (rangeCount !== 0 && !selection.isCollapsed) {
        var i = -1;
        var plainText = "";
        var htmlText = "";
        while (++i < rangeCount) {
          //TODO: Firefox makes multiple selection when some <button> elements are selected ...
          var range = selection.getRangeAt(i);
          htmlText += serializeAsHTML(range);
          plainText += serializeAsPlainText(range);
        }
        // see also https://github.com/w3c/clipboard-apis/issues/48
        dataTransfer.setData("text/html", htmlText);
        dataTransfer.setData("text/plain", plainText);
        if (event.type === "copy") {
          event.preventDefault();
        } else {
          dataTransfer.effectAllowed = "copy";
        }
      }
    }
  }
};

if (typeof document !== "undefined") {
  document.addEventListener("copy", onCopyOrDragStart, false);
  document.addEventListener("dragstart", onCopyOrDragStart, false);
}

//!
// rangeInnerText
globalThis.serializeAsHTML = serializeAsHTML;
globalThis.serializeAsPlainText = serializeAsPlainText;

}());

(function () {
"use strict";
/*jslint plusplus: true, vars: true, indent: 2*/

(function (global) {
  "use strict";

  // BigInteger.js
  // Available under Public Domain
  // https://github.com/Yaffle/BigInteger/

  // For implementation details, see "The Handbook of Applied Cryptography"
  // http://www.cacr.math.uwaterloo.ca/hac/about/chap14.pdf

  var parseInteger = function (s, from, to, radix) {
    var i = from - 1;
    var n = 0;
    var y = radix < 10 ? radix : 10;
    while (++i < to) {
      var code = s.charCodeAt(i);
      var v = code - "0".charCodeAt(0);
      if (v < 0 || y <= v) {
        v = 10 - "A".charCodeAt(0) + code;
        if (v < 10 || radix <= v) {
          v = 10 - "a".charCodeAt(0) + code;
          if (v < 10 || radix <= v) {
            throw new RangeError();
          }
        }
      }
      n = n * radix + v;
    }
    return n;
  };

  var createArray = function (length) {
    var x = new Array(length);
    var i = -1;
    while (++i < length) {
      x[i] = 0;
    }
    return x;
  };

  var epsilon = 2 / (9007199254740991 + 1);
  while (1 + epsilon / 2 !== 1) {
    epsilon /= 2;
  }
  var BASE = 2 / epsilon;
  var s = 134217728;
  while (s * s < 2 / epsilon) {
    s *= 2;
  }
  var SPLIT = s + 1;
  var BASELOG2 = Math.ceil(Math.log(BASE) / Math.log(2));

  // Veltkamp-Dekker's algorithm
  // see http://web.mit.edu/tabbott/Public/quaddouble-debian/qd-2.3.4-old/docs/qd.pdf
  var fma = function (a, b, product) {
    var at = SPLIT * a;
    var ahi = at - (at - a);
    var alo = a - ahi;
    var bt = SPLIT * b;
    var bhi = bt - (bt - b);
    var blo = b - bhi;
    var error = ((ahi * bhi + product) + ahi * blo + alo * bhi) + alo * blo;
    return error;
  };

  var fastTrunc = function (x) {
    var v = (x - BASE) + BASE;
    return v > x ? v - 1 : v;
  };

  var performMultiplication = function (carry, a, b) {
    var product = a * b;
    var error = fma(a, b, -product);

    var hi = (product / BASE) - BASE + BASE;
    var lo = product - hi * BASE + error;

    if (lo >= 0) {
      lo -= BASE;
      hi += 1;
    }

    lo += carry;
    if (lo < 0) {
      lo += BASE;
      hi -= 1;
    }

    return {lo: lo, hi: hi};
  };

  var performDivision = function (a, b, divisor) {
    if (a >= divisor) {
      throw new RangeError();
    }
    var p = a * BASE;
    var q = fastTrunc(p / divisor);

    var r = 0 - fma(q, divisor, -p);
    if (r < 0) {
      q -= 1;
      r += divisor;
    }

    r += b - divisor;
    if (r < 0) {
      r += divisor;
    } else {
      q += 1;
    }
    var y = fastTrunc(r / divisor);
    r -= y * divisor;
    q += y;
    return {q: q, r: r};
  };

  function BigIntegerInternal(sign, magnitude, length) {
    this.sign = sign;
    this.magnitude = magnitude;
    this.length = length;
  }

  var createBigInteger = function (sign, magnitude, length) {
    return new BigIntegerInternal(sign, magnitude, length);
  };

  var fromNumber = function (n) {
    if (n >= BASE || 0 - n >= BASE) {
      throw new RangeError();
    }
    var a = createArray(1);
    a[0] = n < 0 ? 0 - n : 0 + n;
    return createBigInteger(n < 0 ? 1 : 0, a, n === 0 ? 0 : 1);
  };

  var fromString = function (s) {
    var length = s.length;
    if (length === 0) {
      throw new RangeError();
    }
    var sign = 0;
    var signCharCode = s.charCodeAt(0);
    var from = 0;
    if (signCharCode === "+".charCodeAt(0)) {
      from = 1;
    }
    if (signCharCode === "-".charCodeAt(0)) {
      from = 1;
      sign = 1;
    }
    var radix = 10;
    if (from === 0 && length >= 2 && s.charCodeAt(0) === "0".charCodeAt(0)) {
      if (s.charCodeAt(1) === "b".charCodeAt(0)) {
        radix = 2;
        from = 2;
      } else if (s.charCodeAt(1) === "o".charCodeAt(0)) {
        radix = 8;
        from = 2;
      } else if (s.charCodeAt(1) === "x".charCodeAt(0)) {
        radix = 16;
        from = 2;
      }
    }
    length -= from;
    if (length === 0) {
      throw new RangeError();
    }

    var groupLength = 0;
    var groupRadix = 1;
    var limit = fastTrunc(BASE / radix);
    while (groupRadix <= limit) {
      groupLength += 1;
      groupRadix *= radix;
    }

    var size = Math.floor((length - 1) / groupLength) + 1;
    var magnitude = createArray(size);
    var start = from + 1 + (length - 1 - (size - 1) * groupLength) - groupLength;

    var j = -1;
    while (++j < size) {
      var groupStart = start + j * groupLength;
      var c = parseInteger(s, (groupStart >= from ? groupStart : from), groupStart + groupLength, radix);
      var l = -1;
      while (++l < j) {
        var tmp = performMultiplication(c, magnitude[l], groupRadix);
        var lo = tmp.lo;
        var hi = tmp.hi;
        magnitude[l] = lo;
        c = hi;
      }
      magnitude[j] = c;
    }

    while (size > 0 && magnitude[size - 1] === 0) {
      size -= 1;
    }

    return createBigInteger(size === 0 ? 0 : sign, magnitude, size);
  };

  // Math.pow(2, n) is slow in Chrome 93
  function exp(x, n) {
    var a = 1;
    while (n !== 0) {
      var q = (n >> 1);
      if (n !== (q << 1)) {
        a *= x;
      }
      n = q;
      x *= x;
    }
    return a;
  }

  BigIntegerInternal.BigInt = function (x) {
    if (typeof x === "number") {
      return fromNumber(x);
    }
    if (typeof x === "string") {
      return fromString(x);
    }
    if (typeof x === "bigint") {
      return fromString(x.toString());
    }
    if (x instanceof BigIntegerInternal) {
      return x;
    }
    throw new RangeError();
  };

  BigIntegerInternal.asUintN = function (bits, bigint) {
    if (bits < 0) {
      throw new RangeError();
    }
    var n = Math.ceil(bits / BASELOG2);
    bits -= BASELOG2 * n;
    if (bigint.sign === 1) {
      throw new RangeError("not implemented");
    }
    if (n > bigint.length) {
      return bigint;
    }
    var array = createArray(n);
    for (var i = 0; i < n; i += 1) {
      array[i] = bigint.magnitude[i];
    }
    var m = exp(2, BASELOG2 + bits);
    array[n - 1] = array[n - 1] - Math.floor(array[n - 1] / m) * m;
    while (n >= 0 && array[n - 1] === 0) {
      n -= 1;
    }
    return createBigInteger(0, array, n);
  };

  BigIntegerInternal.toNumber = function (a) {
    if (a.length === 0) {
      return 0;
    }
    if (a.length === 1) {
      return a.sign === 1 ? 0 - a.magnitude[0] : a.magnitude[0];
    }
    if (BASE + 1 !== BASE) {
      throw new RangeError();
    }
    var x = a.magnitude[a.length - 1];
    var y = a.magnitude[a.length - 2];
    var i = a.length - 3;
    while (i >= 0 && a.magnitude[i] === 0) {
      i -= 1;
    }
    if (i >= 0 && y % 2 === 1) {
      y += 1;
    }
    var z = (x * BASE + y) * exp(BASE, a.length - 2);
    return a.sign === 1 ? 0 - z : z;
  };

  var compareMagnitude = function (a, b) {
    if (a === b) {
      return 0;
    }
    var c1 = a.length - b.length;
    if (c1 !== 0) {
      return c1 < 0 ? -1 : +1;
    }
    var i = a.length;
    while (--i >= 0) {
      var c = a.magnitude[i] - b.magnitude[i];
      if (c !== 0) {
        return c < 0 ? -1 : +1;
      }
    }
    return 0;
  };

  var compareTo = function (a, b) {
    var c = a.sign === b.sign ? compareMagnitude(a, b) : 1;
    return a.sign === 1 ? 0 - c : c; // positive zero will be returned for c === 0
  };

  var addAndSubtract = function (a, b, isSubtraction) {
    var z = compareMagnitude(a, b);
    var resultSign = z < 0 ? (isSubtraction !== 0 ? 1 - b.sign : b.sign) : a.sign;
    var min = z < 0 ? a : b;
    var max = z < 0 ? b : a;
    // |a| <= |b|
    if (min.length === 0) {
      return createBigInteger(resultSign, max.magnitude, max.length);
    }
    var subtract = 0;
    var resultLength = max.length;
    if (a.sign !== (isSubtraction !== 0 ? 1 - b.sign : b.sign)) {
      subtract = 1;
      if (min.length === resultLength) {
        while (resultLength > 0 && min.magnitude[resultLength - 1] === max.magnitude[resultLength - 1]) {
          resultLength -= 1;
        }
      }
      if (resultLength === 0) { // a === (-b)
        return createBigInteger(0, createArray(0), 0);
      }
    }
    // result !== 0
    var result = createArray(resultLength + (1 - subtract));
    var i = -1;
    var c = 0;
    while (++i < min.length) {
      var aDigit = min.magnitude[i];
      c += max.magnitude[i] + (subtract !== 0 ? 0 - aDigit : aDigit - BASE);
      if (c < 0) {
        result[i] = BASE + c;
        c = 0 - subtract;
      } else {
        result[i] = c;
        c = 1 - subtract;
      }
    }
    i -= 1;
    while (++i < resultLength) {
      c += max.magnitude[i] + (subtract !== 0 ? 0 : 0 - BASE);
      if (c < 0) {
        result[i] = BASE + c;
        c = 0 - subtract;
      } else {
        result[i] = c;
        c = 1 - subtract;
      }
    }
    if (subtract === 0) {
      result[resultLength] = c;
      resultLength += c !== 0 ? 1 : 0;
    } else {
      while (resultLength > 0 && result[resultLength - 1] === 0) {
        resultLength -= 1;
      }
    }
    return createBigInteger(resultSign, result, resultLength);
  };

  BigIntegerInternal.add = function (a, b) {
    return addAndSubtract(a, b, 0);
  };

  BigIntegerInternal.subtract = function (a, b) {
    return addAndSubtract(a, b, 1);
  };

  BigIntegerInternal.multiply = function (a, b) {
    if (a.length < b.length) {
      var tmp = a;
      a = b;
      b = tmp;
    }
    var alength = a.length;
    var blength = b.length;
    var am = a.magnitude;
    var bm = b.magnitude;
    var asign = a.sign;
    var bsign = b.sign;
    if (alength === 0 || blength === 0) {
      return createBigInteger(0, createArray(0), 0);
    }
    if (alength === 1 && am[0] === 1) {
      return createBigInteger(asign === 1 ? 1 - bsign : bsign, bm, blength);
    }
    if (blength === 1 && bm[0] === 1) {
      return createBigInteger(asign === 1 ? 1 - bsign : bsign, am, alength);
    }
    var astart = 0;
    while (am[astart] === 0) { // to optimize multiplications of a power of BASE
      astart += 1;
    }
    var resultSign = asign === 1 ? 1 - bsign : bsign;
    var resultLength = alength + blength;
    var result = createArray(resultLength);
    var i = -1;
    while (++i < blength) {
      var digit = bm[i];
      if (digit !== 0) { // to optimize multiplications by a power of BASE
        var c = 0;
        var j = astart - 1;
        while (++j < alength) {
          var carry = 1;
          c += result[j + i] - BASE;
          if (c < 0) {
            c += BASE;
            carry = 0;
          }
          var tmp = performMultiplication(c, am[j], digit);
          var lo = tmp.lo;
          var hi = tmp.hi;
          result[j + i] = lo;
          c = hi + carry;
        }
        result[alength + i] = c;
      }
    }
    if (result[resultLength - 1] === 0) {
      resultLength -= 1;
    }
    return createBigInteger(resultSign, result, resultLength);
  };

  var divideAndRemainder = function (a, b, isDivision) {
    if (b.length === 0) {
      throw new RangeError();
    }
    if (a.length === 0) {
      return createBigInteger(0, createArray(0), 0);
    }
    var quotientSign = a.sign === 1 ? 1 - b.sign : b.sign;
    if (b.length === 1 && b.magnitude[0] === 1) {
      if (isDivision !== 0) {
        return createBigInteger(quotientSign, a.magnitude, a.length);
      }
      return createBigInteger(0, createArray(0), 0);
    }

    var divisorOffset = a.length + 1; // `+ 1` for extra digit in case of normalization
    var divisorAndRemainder = createArray(divisorOffset + b.length + 1); // `+ 1` to avoid `index < length` checks
    var divisor = divisorAndRemainder;
    var remainder = divisorAndRemainder;
    var n = -1;
    while (++n < a.length) {
      remainder[n] = a.magnitude[n];
    }
    var m = -1;
    while (++m < b.length) {
      divisor[divisorOffset + m] = b.magnitude[m];
    }

    var top = divisor[divisorOffset + b.length - 1];

    // normalization
    var lambda = 1;
    if (b.length > 1) {
      lambda = fastTrunc(BASE / (top + 1));
      if (lambda > 1) {
        var carry = 0;
        var l = -1;
        while (++l < divisorOffset + b.length) {
          var tmp = performMultiplication(carry, divisorAndRemainder[l], lambda);
          var lo = tmp.lo;
          var hi = tmp.hi;
          divisorAndRemainder[l] = lo;
          carry = hi;
        }
        divisorAndRemainder[divisorOffset + b.length] = carry;
        top = divisor[divisorOffset + b.length - 1];
      }
      // assertion
      if (top < fastTrunc(BASE / 2)) {
        throw new RangeError();
      }
    }

    var shift = a.length - b.length + 1;
    if (shift < 0) {
      shift = 0;
    }
    var quotient = undefined;
    var quotientLength = 0;

    // to optimize divisions by a power of BASE
    var lastNonZero = 0;
    while (divisor[divisorOffset + lastNonZero] === 0) {
      lastNonZero += 1;
    }

    var i = shift;
    while (--i >= 0) {
      var t = b.length + i;
      var q = BASE - 1;
      if (remainder[t] !== top) {
        var tmp2 = performDivision(remainder[t], remainder[t - 1], top);
        var q2 = tmp2.q;
        //var r2 = tmp2.r;
        q = q2;
      }

      var ax = 0;
      var bx = 0;
      var j = i - 1 + lastNonZero;
      while (++j <= t) {
        var tmp3 = performMultiplication(bx, q, divisor[divisorOffset + j - i]);
        var lo3 = tmp3.lo;
        var hi3 = tmp3.hi;
        bx = hi3;
        ax += remainder[j] - lo3;
        if (ax < 0) {
          remainder[j] = BASE + ax;
          ax = -1;
        } else {
          remainder[j] = ax;
          ax = 0;
        }
      }
      while (ax !== 0) {
        q -= 1;
        var c = 0;
        var k = i - 1 + lastNonZero;
        while (++k <= t) {
          c += remainder[k] - BASE + divisor[divisorOffset + k - i];
          if (c < 0) {
            remainder[k] = BASE + c;
            c = 0;
          } else {
            remainder[k] = c;
            c = +1;
          }
        }
        ax += c;
      }
      if (isDivision !== 0 && q !== 0) {
        if (quotientLength === 0) {
          quotientLength = i + 1;
          quotient = createArray(quotientLength);
        }
        quotient[i] = q;
      }
    }

    if (isDivision !== 0) {
      if (quotientLength === 0) {
        return createBigInteger(0, createArray(0), 0);
      }
      return createBigInteger(quotientSign, quotient, quotientLength);
    }

    var remainderLength = a.length + 1;
    if (lambda > 1) {
      var r = 0;
      var p = remainderLength;
      while (--p >= 0) {
        var tmp4 = performDivision(r, remainder[p], lambda);
        var q4 = tmp4.q;
        var r4 = tmp4.r;
        remainder[p] = q4;
        r = r4;
      }
      if (r !== 0) {
        // assertion
        throw new RangeError();
      }
    }
    while (remainderLength > 0 && remainder[remainderLength - 1] === 0) {
      remainderLength -= 1;
    }
    if (remainderLength === 0) {
      return createBigInteger(0, createArray(0), 0);
    }
    var result = createArray(remainderLength);
    var o = -1;
    while (++o < remainderLength) {
      result[o] = remainder[o];
    }
    return createBigInteger(a.sign, result, remainderLength);
  };

  BigIntegerInternal.divide = function (a, b) {
    return divideAndRemainder(a, b, 1);
  };

  BigIntegerInternal.remainder = function (a, b) {
    return divideAndRemainder(a, b, 0);
  };

  BigIntegerInternal.unaryMinus = function (a) {
    return createBigInteger(a.length === 0 ? a.sign : 1 - a.sign, a.magnitude, a.length);
  };

  BigIntegerInternal.equal = function (a, b) {
    return compareTo(a, b) === 0;
  };
  BigIntegerInternal.lessThan = function (a, b) {
    return compareTo(a, b) < 0;
  };
  BigIntegerInternal.greaterThan = function (a, b) {
    return compareTo(a, b) > 0;
  };
  BigIntegerInternal.notEqual = function (a, b) {
    return compareTo(a, b) !== 0;
  };
  BigIntegerInternal.lessThanOrEqual = function (a, b) {
    return compareTo(a, b) <= 0;
  };
  BigIntegerInternal.greaterThanOrEqual = function (a, b) {
    return compareTo(a, b) >= 0;
  };

  BigIntegerInternal.exponentiate = function (a, b) {
    var n = BigIntegerInternal.toNumber(b);
    if (n < 0) {
      throw new RangeError();
    }
    if (n > 9007199254740991) {
      var y = BigIntegerInternal.toNumber(a);
      if (y === 0 || y === -1 || y === +1) {
        return y === -1 && BigIntegerInternal.toNumber(BigIntegerInternal.remainder(b, BigIntegerInternal.BigInt(2))) === 0 ? BigIntegerInternal.unaryMinus(a) : a;
      }
      throw new RangeError();
    }
    if (n === 0) {
      return BigIntegerInternal.BigInt(1);
    }
    if (a.length === 1 && (a.magnitude[0] === 2 || a.magnitude[0] === 16)) {
      var bits = Math.floor(Math.log(BASE) / Math.log(2) + 0.5);
      var abits = Math.floor(Math.log(a.magnitude[0]) / Math.log(2) + 0.5);
      var nn = abits * n;
      var q = Math.floor(nn / bits);
      var r = nn - q * bits;
      var array = createArray(q + 1);
      array[q] = Math.pow(2, r);
      return createBigInteger(a.sign === 0 || n % 2 === 0 ? 0 : 1, array, q + 1);
    }
    var x = a;
    while (n % 2 === 0) {
      n = Math.floor(n / 2);
      x = BigIntegerInternal.multiply(x, x);
    }
    var accumulator = x;
    n -= 1;
    if (n >= 2) {
      while (n >= 2) {
        var t = Math.floor(n / 2);
        if (t * 2 !== n) {
          accumulator = BigIntegerInternal.multiply(accumulator, x);
        }
        n = t;
        x = BigIntegerInternal.multiply(x, x);
      }
      accumulator = BigIntegerInternal.multiply(accumulator, x);
    }
    return accumulator;
  };

  BigIntegerInternal.prototype.toString = function (radix) {
    if (radix == undefined) {
      radix = 10;
    }
    if (radix !== 10 && (radix < 2 || radix > 36 || radix !== Math.floor(radix))) {
      throw new RangeError("radix argument must be an integer between 2 and 36");
    }

    // console.time(); var n = BigInteger.exponentiate(Math.pow(2, 4), Math.pow(2, 16)); console.timeEnd(); console.time(); n.toString(16).length; console.timeEnd();
    if (this.length > 8 && true) { // https://github.com/GoogleChromeLabs/jsbi/blob/c9b179a4d5d34d35dd24cf84f7c1def54dc4a590/jsbi.mjs#L880
      if (this.sign === 1) {
        return '-' + BigIntegerInternal.unaryMinus(this).toString(radix);
      }
      var s = Math.floor(this.length * Math.log(BASE) / Math.log(radix) / 2 + 0.5 - 1);
      var split = BigIntegerInternal.exponentiate(BigIntegerInternal.BigInt(radix), BigIntegerInternal.BigInt(s));
      var q = BigIntegerInternal.divide(this, split);
      var r = BigIntegerInternal.subtract(this, BigIntegerInternal.multiply(q, split));
      var a = r.toString(radix);
      return q.toString(radix) + '0'.repeat(s - a.length) + a;
    }

    var a = this;
    var result = a.sign === 1 ? "-" : "";

    var remainderLength = a.length;
    if (remainderLength === 0) {
      return "0";
    }
    if (remainderLength === 1) {
      result += a.magnitude[0].toString(radix);
      return result;
    }
    var groupLength = 0;
    var groupRadix = 1;
    var limit = fastTrunc(BASE / radix);
    while (groupRadix <= limit) {
      groupLength += 1;
      groupRadix *= radix;
    }
    // assertion
    if (groupRadix * radix <= BASE) {
      throw new RangeError();
    }
    var size = remainderLength + Math.floor((remainderLength - 1) / groupLength) + 1;
    var remainder = createArray(size);
    var n = -1;
    while (++n < remainderLength) {
      remainder[n] = a.magnitude[n];
    }

    var k = size;
    while (remainderLength !== 0) {
      var groupDigit = 0;
      var i = remainderLength;
      while (--i >= 0) {
        var tmp = performDivision(groupDigit, remainder[i], groupRadix);
        var q = tmp.q;
        var r = tmp.r;
        remainder[i] = q;
        groupDigit = r;
      }
      while (remainderLength > 0 && remainder[remainderLength - 1] === 0) {
        remainderLength -= 1;
      }
      k -= 1;
      remainder[k] = groupDigit;
    }
    result += remainder[k].toString(radix);
    while (++k < size) {
      var t = remainder[k].toString(radix);
      result += "0".repeat(groupLength - t.length) + t;
    }
    return result;
  };
  var signedRightShift = function (x, n) {
    // (!) it should work fast if n ~ size(x) - 53
    if (x.length === 0) {
      return x;
    }
    var shift = Math.floor(n / BASELOG2);
    var length = x.length - shift;
    if (length <= 0) {
      if (x.sign === 1) {
        var minusOne = createArray(1);
        minusOne[0] = 1;
        return createBigInteger(1, minusOne, 1);
      }
      return createBigInteger(0, createArray(0), 0);
    }
    var digits = createArray(length + (x.sign === 1 ? 1 : 0));
    for (var i = 0; i < length; i += 1) {
      digits[i] = i + shift < 0 ? 0 : x.magnitude[i + shift];
    }
    n -= shift * BASELOG2;
    var s = exp(2, n);
    var s1 = Math.floor(BASE / s);
    var pr = 0;
    for (var i = length - 1; i >= 0; i -= 1) {
      var q = Math.floor(digits[i] / s);
      var r = digits[i] - q * s;
      digits[i] = q + pr * s1;
      pr = r;
    }
    if (length >= 1 && digits[length - 1] === 0) {
      length -= 1;
    }
    if (x.sign === 1) {
      var hasRemainder = pr > 0;
      for (var i = 0; i < shift && !hasRemainder; i += 1) {
        hasRemainder = x.magnitude[i] !== 0;
      }
      if (hasRemainder) {
        if (length === 0) {
          length += 1;
          digits[0] = 1;
        } else {
          // subtract one
          var i = 0;
          while (i < length && digits[i] === BASE - 1) {
            digits[i] = 0;
            i += 1;
          }
          if (i < length) {
            digits[i] += 1;
          } else {
            length += 1;
            digits[i] = 1;
          }
        }
      }
    }
    return createBigInteger(x.sign, digits, length);
  };
  BigIntegerInternal.signedRightShift = function (x, n) {
    return signedRightShift(x, BigIntegerInternal.toNumber(n));
  };
  BigIntegerInternal.leftShift = function (x, n) {
    return signedRightShift(x, 0 - BigIntegerInternal.toNumber(n));
  };
  BigIntegerInternal.prototype.valueOf = function () {
    //throw new TypeError();
    console.error('BigIntegerInternal#valueOf is called');
    return this;
  };

  var Internal = BigIntegerInternal;

  // noinline
  var n = function (f) {
    return function (x, y) {
      return f(x, y);
    };
  };

  var cache = new Array(16 * 2 + 1);
  for (var i = 0; i < cache.length; i += 1) {
    cache[i] = undefined;
  }
  function LastTwoMap() {
    this.a = undefined;
    this.aKey = 0;
    this.b = undefined;
    this.bKey = 0;
    this.last = 0;
  }
  LastTwoMap.prototype.get = function (key) {
    if (this.aKey === key) {
      this.last = 0;
      return this.a;
    }
    if (this.bKey === key) {
      this.last = 1;
      return this.b;
    }
    return undefined;
  };
  LastTwoMap.prototype.set = function (key, value) {
    if (this.last === 0) {
      this.bKey = key;
      this.b = value;
      this.last = 1;
    } else {
      this.aKey = key;
      this.a = value;
      this.last = 0;
    }
  };
  var map = new LastTwoMap(); // to optimize when some number is multiplied by few numbers sequencely
  var toNumber = n(function (a) {
    return Internal.toNumber(a);
  });
  var valueOf = function (x) {
    if (typeof x === "number") {
      if (x >= -16 && x <= +16) {
        var value = cache[x + 16];
        if (value == undefined) {
          value = Internal.BigInt(x);
          cache[x + 16] = value;
        }
        return value;
      }
      var value = map.get(x);
      if (value == undefined) {
        value = Internal.BigInt(x);
        map.set(x, value);
      }
      return value;
    }
    return x;
  };
  var toResult = function (x) {
    var value = Internal.toNumber(x);
    if (value >= -9007199254740991 && value <= +9007199254740991) {
      return value;
    }
    return x;
  };
  var add = n(function (x, y) {
    if (typeof x === "number" && x === 0) {
      return y;
    }
    if (typeof y === "number" && y === 0) {
      return x;
    }
    var a = valueOf(x);
    var b = valueOf(y);
    var sum = Internal.add(a, b);
    return typeof x === "number" && typeof y === "number" ? sum : toResult(sum);
  });
  var subtract = n(function (x, y) {
    if (typeof x === "number" && x === 0) {
      return unaryMinus(y);
    }
    // quite good optimization for comparision of big integers
    if (typeof y === "number" && y === 0) {
      return x;
    }
    var a = valueOf(x);
    var b = valueOf(y);
    var difference = Internal.subtract(a, b);
    return typeof x === "number" && typeof y === "number" ? difference : toResult(difference);
  });
  var multiply = n(function (x, y) {
    if (typeof x === "number" && x === 0) {
      return 0;
    }
    if (typeof x === "number" && x === 1) {
      return y;
    }
    if (typeof x === "number" && x === -1) {
      return Internal.unaryMinus(y);
    }
    if (typeof y === "number" && y === 0) {
      return 0;
    }
    if (typeof y === "number" && y === 1) {
      return x;
    }
    if (typeof y === "number" && y === -1) {
      return Internal.unaryMinus(x);
    }
    var a = valueOf(x);
    var b = valueOf(y);
    return Internal.multiply(a, b);
  });
  var divide = n(function (x, y) {
    if (typeof x === "number") {
      return 0;
    }
    if (typeof y === "number" && y === 1) {
      return x;
    }
    if (typeof y === "number" && y === -1) {
      return Internal.unaryMinus(x);
    }
    var a = valueOf(x);
    var b = valueOf(y);
    return toResult(Internal.divide(a, b));
  });
  var remainder = n(function (x, y) {
    if (typeof x === "number") {
      return x;
    }
    if (typeof y === "number" && y === 1) {
      return 0;
    }
    if (typeof y === "number" && y === -1) {
      return 0;
    }
    var a = valueOf(x);
    var b = valueOf(y);
    return toResult(Internal.remainder(a, b));
  });
  var exponentiate = n(function (x, y) {
    if (typeof y === "number") {
      if (y === 0) {
        return 1;
      }
      if (y === 1) {
        return x;
      }
      if (y === 2) {
        return multiply(x, x);
      }
      if (typeof x === "number" && Math.abs(x) > 2 && y >= 0) {
        if (y > 42 && x % 2 === 0) {//TODO: ?
          return multiply(exponentiate(2, y), exponentiate(x / 2, y));
        }
        var k = Math.floor(Math.log(9007199254740991) / Math.log(Math.abs(x) + 0.5));
        if (k >= 2) {
          return multiply(Math.pow(x, y % k), exponentiate(Math.pow(x, k), Math.floor(y / k)));
        }
      }
    }
    var a = valueOf(x);
    var b = valueOf(y);
    var power = Internal.exponentiate(a, b);
    return typeof x === "number" && Math.abs(x) <= 1 ? toResult(power) : power;
  });
  var unaryMinus = n(function (x) {
    var a = valueOf(x);
    return Internal.unaryMinus(a);
  });
  var equal = n(function (x, y) {
    if (typeof x === "number") {
      return false;
    }
    if (typeof y === "number") {
      return false;
    }
    return Internal.equal(x, y);
  });
  var lessThan = n(function (x, y) {
    if (typeof x === "number") {
      return x < Internal.toNumber(y);
    }
    if (typeof y === "number") {
      return Internal.toNumber(x) < y;
    }
    return Internal.lessThan(x, y);
  });
  var greaterThan = n(function (x, y) {
    if (typeof x === "number") {
      return x > Internal.toNumber(y);
    }
    if (typeof y === "number") {
      return Internal.toNumber(x) > y;
    }
    return Internal.greaterThan(x, y);
  });

  function BigInteger() {
  }

  // Conversion from String:
  // Conversion from Number:
  BigInteger.BigInt = function (x) {
    if (typeof x === "number" || typeof x === "string" || typeof x === "bigint") {
      var value = 0 + (typeof x === "number" ? x : Number(x));
      if (value >= -9007199254740991 && value <= +9007199254740991) {
        return value;
      }
    }
    return toResult(Internal.BigInt(x));
  };
  BigInteger.asUintN = function (n, x) {
    if (typeof x === "number" && x >= 0 && n >= 0 && n <= 53) {
      var m = exp(2, n);
      return x - Math.floor(x / m) * m;
    }
    return toResult(Internal.asUintN(n, Internal.BigInt(x)));
  };
  // Conversion to Number:
  BigInteger.toNumber = function (x) {
    if (typeof x === "number") {
      return x;
    }
    return toNumber(x);
  };

  // Arithmetic:
  BigInteger.add = function (x, y) {
    if (typeof x === "string" || typeof y === "string") {
      return x + y;
    }
    if (typeof x === "number" && typeof y === "number") {
      var value = x + y;
      if (value >= -9007199254740991 && value <= +9007199254740991) {
        return value;
      }
    }
    return add(x, y);
  };
  BigInteger.subtract = function (x, y) {
    if (typeof x === "number" && typeof y === "number") {
      var value = x - y;
      if (value >= -9007199254740991 && value <= +9007199254740991) {
        return value;
      }
    }
    return subtract(x, y);
  };
  BigInteger.multiply = function (x, y) {
    if (typeof x === "number" && typeof y === "number") {
      var value = 0 + x * y;
      if (value >= -9007199254740991 && value <= +9007199254740991) {
        return value;
      }
    }
    return multiply(x, y);
  };
  BigInteger.divide = function (x, y) {
    if (typeof x === "number" && typeof y === "number") {
      if (y !== 0) {
        return x === 0 ? 0 : (x > 0 && y > 0) || (x < 0 && y < 0) ? 0 + Math.floor(x / y) : 0 - Math.floor((0 - x) / y);
      }
    }
    return divide(x, y);
  };
  BigInteger.remainder = function (x, y) {
    if (typeof x === "number" && typeof y === "number") {
      if (y !== 0) {
        return 0 + x % y;
      }
    }
    return remainder(x, y);
  };
  BigInteger.unaryMinus = function (x) {
    if (typeof x === "number") {
      return 0 - x;
    }
    return unaryMinus(x);
  };

  // Comparison:
  BigInteger.equal = function (x, y) {
    if (typeof x === "number" && typeof y === "number") {
      return x === y;
    }
    return equal(x, y);
  };
  BigInteger.lessThan = function (x, y) {
    if (typeof x === "number" && typeof y === "number") {
      return x < y;
    }
    return lessThan(x, y);
  };
  BigInteger.greaterThan = function (x, y) {
    if (typeof x === "number" && typeof y === "number") {
      return x > y;
    }
    return greaterThan(x, y);
  };
  BigInteger.notEqual = function (x, y) {
    return !BigInteger.equal(x, y);
  };
  BigInteger.lessThanOrEqual = function (x, y) {
    return !BigInteger.greaterThan(x, y);
  };
  BigInteger.greaterThanOrEqual = function (x, y) {
    return !BigInteger.lessThan(x, y);
  };

  BigInteger.exponentiate = function (x, y) {
    if (typeof x === "number" && typeof y === "number") {
      if (y >= 0 && (y < 53 || x >= -1 && x <= 1)) { // 53 === log2(9007199254740991 + 1)
        var value = 0 + Math.pow(x, y);
        if (value >= -9007199254740991 && value <= 9007199254740991) {
          return value;
        }
      }
    }
    return exponentiate(x, y);
  };
  BigInteger.signedRightShift = function (x, n) {
    return toResult(Internal.signedRightShift(valueOf(x), valueOf(n)));
  };
  BigInteger.leftShift = function (x, n) {
    return toResult(Internal.leftShift(valueOf(x), valueOf(n)));
  };

  (global || globalThis).BigInteger = BigInteger;
  BigInteger._getInternal = function () {
    return Internal;
  };
  BigInteger._setInternal = function (newInternal) {
    Internal = newInternal;
  };

}(this));

})();
(function () {
"use strict";


  function BigIntWrapper() {
  }
  //var BigIntWrapper = typeof BigInt !== 'undefined' ? BigInt : function () {};
  BigIntWrapper.BigInt = function (x) {
    if (typeof x === "number" && Math.abs(x) > Number.MAX_SAFE_INTEGER) { // as Chrome 67 does not support this
      throw new RangeError();
    }
    if (typeof x === "bigint") {
      return x;
    }
    var result = BigInt(x);
    if (typeof x === "string") {
      logSizes(size(result), "BigInt");
    }
    return result;
  };
  BigIntWrapper.asUintN = function (bits, bigint) {
    return BigInt.asUintN(bits, bigint);
  };
  globalThis.c1 = 0;
  BigIntWrapper.toNumber = function (bigint) {
    return Number(bigint);
  };
  BigIntWrapper.add = function (a, b) {
    return a + b;
  };
  BigIntWrapper.subtract = function (a, b) {
    return a - b;
  };

  var lastMaxSize = {};
  var size = function (a) {
    if (true) {
      return 0;
    }
    //TODO: bitLength
    return Math.abs(Number(a)) < 1/0 ? 0 : a.toString(16).length * 4;
  };
  var logSizes = function (size, operation) {//TODO: REMOVE
    if (size >= 64 * 1024) {
      size = Math.pow(2, Math.floor(Math.log2(size + 0.5)));
      if (size > (lastMaxSize[operation] || 0)) {
        lastMaxSize[operation] = size;
        if (globalThis.onerror != null) {
          var error = new TypeError("big size of " + operation + " " + size);
          globalThis.onerror(error.message, "", 0, 0, error);
        }
      }
    }
  };
  if (typeof globalThis.BigInt === "function") {
    var nativeBigIntToString = BigInt.prototype.toString;
    BigInt.prototype.toString = function (radix) {
      "use strict";
      radix = radix || 10;
      if ((radix & (radix - 1)) !== 0) {
        logSizes(size(this), "BigInt#toString");
      }
      return nativeBigIntToString.call(this, radix);
    };
  }

  BigIntWrapper.multiply = function (a, b) {
    logSizes(Math.min(size(a), size(b)), '*');
    return a * b;
  };
  BigIntWrapper.divide = function (a, b) {
    logSizes(Math.min(size(a) - size(b), size(b)), '/');
    return a / b;
  };
  BigIntWrapper.remainder = function (a, b) {
    logSizes(Math.min(size(a) - size(b), size(b)), '%');
    return a % b;
  };
  BigIntWrapper.unaryMinus = function (a) {
    return -a;
  };
  BigIntWrapper.equal = function (a, b) {
    return a === b;
  };
  BigIntWrapper.lessThan = function (a, b) {
    return a < b;
  };
  BigIntWrapper.greaterThan = function (a, b) {
    return a > b;
  };
  BigIntWrapper.notEqual = function (a, b) {
    return a !== b;
  };
  BigIntWrapper.lessThanOrEqual = function (a, b) {
    return a <= b;
  };
  BigIntWrapper.greaterThanOrEqual = function (a, b) {
    return a >= b;
  };
  BigIntWrapper.exponentiate = function (a, b) { // a**b
    if (typeof a !== "bigint" || typeof b !== "bigint") {
      throw new TypeError();
    }
    var n = Number(b);
    if (n < 0) {
      throw new RangeError();
    }
    if (n > 9007199254740991) {
      var y = Number(a);
      if (y === 0 || y === -1 || y === +1) {
        return y === -1 && Number(b % BigInt(2)) === 0 ? -a : a;
      }
      throw new RangeError();
    }
    if (a === BigInt(2)) {
      return BigInt(1) << b;
    }
    if (n === 0) {
      return BigInt(1);
    }
    var x = a;
    while (n % 2 === 0) {
      n = Math.floor(n / 2);
      x *= x;
    }
    var accumulator = x;
    n -= 1;
    if (n >= 2) {
      while (n >= 2) {
        var t = Math.floor(n / 2);
        if (t * 2 !== n) {
          accumulator *= x;
        }
        n = t;
        x *= x;
      }
      accumulator *= x;
    }
    logSizes(Math.floor(size(accumulator) / 3), '**');
    return accumulator;
  };
  BigIntWrapper.signedRightShift = function (a, n) {
    return a >> n;
  };
  BigIntWrapper.leftShift = function (a, n) {
    return a << n;
  };

  var supportsBigInt = typeof BigInt !== "undefined" && BigInt(9007199254740991) + BigInt(2) - BigInt(2) === BigInt(9007199254740991);

  if (supportsBigInt) {
    // https://twitter.com/mild_sunrise/status/1339174371550760961
    if (((-BigInt('0xffffffffffffffffffffffffffffffff')) >> BigInt(0x40)).toString() !== '-18446744073709551616') { // ((-(Math.pow(2, 128) - 1)) >> 64) !== -1 * 2**64
      supportsBigInt = false;
    }
  }

  //supportsBigInt = false;//!!!
  if (supportsBigInt) {
    globalThis.JSBI = BigIntWrapper;//!!!
    globalThis.BigInteger._setInternal(BigIntWrapper);
  } else if (globalThis.JSBI == null) {
    globalThis.JSBI = globalThis.BigInteger._getInternal();
  } else {
    globalThis.BigInteger._setInternal(JSBI);
  }

  var SmallBigInt = globalThis.BigInteger;
  self.SmallBigInt = SmallBigInt;
  //self.BigIntWrapper = BigIntWrapper;


})();
var maybeJSBI = {
  toNumber: function toNumber(a) {
    return typeof a === "object" ? JSBI.toNumber(a) : Number(a);
  },
  add: function add(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.add(a, b) : a + b;
  },
  subtract: function subtract(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.subtract(a, b) : a - b;
  },
  multiply: function multiply(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.multiply(a, b) : a * b;
  },
  divide: function divide(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.divide(a, b) : a / b;
  },
  remainder: function remainder(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.remainder(a, b) : a % b;
  },
  exponentiate: function exponentiate(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.exponentiate(a, b) : typeof a === "bigint" && typeof b === "bigint" ? new Function("a**b", "a", "b")(a, b) : Math.pow(a, b);
  },
  leftShift: function leftShift(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.leftShift(a, b) : a << b;
  },
  signedRightShift: function signedRightShift(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.signedRightShift(a, b) : a >> b;
  },
  bitwiseAnd: function bitwiseAnd(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.bitwiseAnd(a, b) : a & b;
  },
  bitwiseOr: function bitwiseOr(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.bitwiseOr(a, b) : a | b;
  },
  bitwiseXor: function bitwiseXor(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.bitwiseXor(a, b) : a ^ b;
  },
  lessThan: function lessThan(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.lessThan(a, b) : a < b;
  },
  greaterThan: function greaterThan(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.greaterThan(a, b) : a > b;
  },
  lessThanOrEqual: function lessOrEqualThan(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.lessThanOrEqual(a, b) : a <= b;
  },
  greaterThanOrEqual: function greaterOrEqualThan(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.greaterThanOrEqual(a, b) : a >= b;
  },
  equal: function equal(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.equal(a, b) : a === b;
  },
  notEqual: function notEqual(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.notEqual(a, b) : a !== b;
  },
  unaryMinus: function unaryMinus(a) {
    return typeof a === "object" ? JSBI.unaryMinus(a) : -a;
  },
  bitwiseNot: function bitwiseNot(a) {
    return typeof a === "object" ? JSBI.bitwiseNot(a) : ~a;
  }
};


(function () {
  "use strict";

  function nthRootSmall(A, n) {
    var x = Math.exp(Math.log(A) / n); // https://en.wikipedia.org/wiki/Nth_root_algorithm

    x = x + (A / Math.pow(x, n - 1) - x) / n;
    return x;
  } // floor(S**(1/n)), S >= 1, n >= 2
  // https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method
  // https://stackoverflow.com/a/15979957/839199y


  function nthRoot(S, n) {
    if (n < 1) {
      throw new RangeError();
    }

    var s = maybeJSBI.toNumber(S);

    if (s < 0) {
      if (n % 2 === 0) {
        throw new RangeError();
      }

      return maybeJSBI.unaryMinus(nthRoot(maybeJSBI.unaryMinus(S), n));
    }

    if (n === 1) {
      return S;
    }

    if (s < (Number.MAX_SAFE_INTEGER + 1) / (8 * n)) {
      // var i = 1; while (Math.floor(Math.sqrt(i**2 - 1 + 0.5)) < i) { i++; } console.log(i**2);
      // var i = 1; while (Math.floor(Math.cbrt(i**3 - 1 + 0.5)) < i && Math.cbrt(i**3 + 0.5) >= i) { i++; } console.log(i**3);
      // for (var n = 2; n <= 53; n++) { var i = 1; while (Math.floor(nthRootSmall(i**n - 1 + 0.5, n)) < i) { i++; } console.log(i**n); }
      var g = n === 2 ? Math.floor(Math.sqrt(s + 0.5)) : n === 3 ? Math.floor(Math.cbrt(s + 0.5)) : Math.floor(nthRootSmall(s + 0.5, n));
      return JSBI.BigInt(g);
    }

    var g = n === 2 ? Math.sqrt(s) : n === 3 ? Math.cbrt(s) : nthRootSmall(s, n);

    if (g < (Number.MAX_SAFE_INTEGER + 1) / 8) {
      if (n === 3) {
        g = g + (s / (g * g) - g) / 3;
      }

      if ((n === 2 || n === 3) && Math.floor(g) !== g) {
        return JSBI.BigInt(Math.floor(g));
      }

      var y = JSBI.BigInt(Math.floor(g + 0.5));

      if (JSBI.lessThan(S, JSBI.exponentiate(y, JSBI.BigInt(n)))) {
        y = JSBI.subtract(y, JSBI.BigInt(1));
      }

      return y;
    }

    var e = primeFactor._bitLength(S);

    if (maybeJSBI.lessThanOrEqual(e, n)) {
      return JSBI.BigInt(1);
    }

    var f = Math.floor(maybeJSBI.add(e, n) / (2 * n));
    var x = JSBI.leftShift(JSBI.add(nthRoot(JSBI.signedRightShift(S, JSBI.BigInt(f * n)), n), JSBI.BigInt(1)), JSBI.BigInt(f));
    var xprev = JSBI.add(x, JSBI.BigInt(1));

    while (maybeJSBI.lessThan(x, xprev)) {
      xprev = x;
      x = JSBI.divide(JSBI.add(JSBI.multiply(JSBI.BigInt(n - 1), x), JSBI.divide(S, JSBI.exponentiate(x, JSBI.BigInt(n - 1)))), JSBI.BigInt(n));
    }

    return xprev;
  }

  self.nthRoot = nthRoot;
})();
var maybeJSBI = {
  toNumber: function toNumber(a) {
    return typeof a === "object" ? JSBI.toNumber(a) : Number(a);
  },
  add: function add(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.add(a, b) : a + b;
  },
  subtract: function subtract(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.subtract(a, b) : a - b;
  },
  multiply: function multiply(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.multiply(a, b) : a * b;
  },
  divide: function divide(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.divide(a, b) : a / b;
  },
  remainder: function remainder(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.remainder(a, b) : a % b;
  },
  exponentiate: function exponentiate(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.exponentiate(a, b) : typeof a === "bigint" && typeof b === "bigint" ? new Function("a**b", "a", "b")(a, b) : Math.pow(a, b);
  },
  leftShift: function leftShift(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.leftShift(a, b) : a << b;
  },
  signedRightShift: function signedRightShift(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.signedRightShift(a, b) : a >> b;
  },
  bitwiseAnd: function bitwiseAnd(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.bitwiseAnd(a, b) : a & b;
  },
  bitwiseOr: function bitwiseOr(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.bitwiseOr(a, b) : a | b;
  },
  bitwiseXor: function bitwiseXor(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.bitwiseXor(a, b) : a ^ b;
  },
  lessThan: function lessThan(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.lessThan(a, b) : a < b;
  },
  greaterThan: function greaterThan(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.greaterThan(a, b) : a > b;
  },
  lessThanOrEqual: function lessOrEqualThan(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.lessThanOrEqual(a, b) : a <= b;
  },
  greaterThanOrEqual: function greaterOrEqualThan(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.greaterThanOrEqual(a, b) : a >= b;
  },
  equal: function equal(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.equal(a, b) : a === b;
  },
  notEqual: function notEqual(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.notEqual(a, b) : a !== b;
  },
  unaryMinus: function unaryMinus(a) {
    return typeof a === "object" ? JSBI.unaryMinus(a) : -a;
  },
  bitwiseNot: function bitwiseNot(a) {
    return typeof a === "object" ? JSBI.bitwiseNot(a) : ~a;
  }
};


(function () {
  "use strict"; //TODO: https://en.wikipedia.org/wiki/Euclidean_algorithm#Method_of_least_absolute_remainders

  function numbersGCD(a, b) {
    while (b > 0) {
      var q = Math.floor(maybeJSBI.divide(a, b));
      var r = a - q * b;
      a = b;
      b = r;
    }

    return a;
  }

  function EuclidsGCD(a, b) {
    while (maybeJSBI.toNumber(b) > Number.MAX_SAFE_INTEGER) {
      var r = maybeJSBI.remainder(a, b);
      a = b;
      b = r;
    }

    var nb = maybeJSBI.toNumber(b);

    if (nb > 0) {
      var na = maybeJSBI.toNumber(a);

      if (maybeJSBI.greaterThan(na, Number.MAX_SAFE_INTEGER)) {
        var r = JSBI.toNumber(JSBI.remainder(a, JSBI.BigInt(nb)));
        na = nb;
        nb = r;
      }

      return numbersGCD(na, nb);
    }

    return a;
  } // https://github.com/tc39/proposal-bigint/issues/205
  // https://github.com/tc39/ecma262/issues/1729
  // floor(log2(a)) + 1 if a > 0


  function bitLength(a) {
    var s = a.toString(16);
    var c = maybeJSBI.subtract(s.charCodeAt(0), '0'.charCodeAt(0));

    if (c <= 0) {
      throw new RangeError();
    }

    return (s.length - 1) * 4 + (32 - Math.clz32(Math.min(c, 8)));
  } // 1 + floor(log2(x))


  function log2(x) {
    var e = 0;

    while (x > 1 << 30) {
      x = Math.floor(x / (1 << 30));
      e += 30;
    }

    e += 32 - Math.clz32(x);
    return e;
  }

  var LOG2MAX = Math.floor(Math.log2(Number.MAX_SAFE_INTEGER + 1));
  var previousValue = -1; // some terrible optimization as bitLength is slow

  function bitLength2(a) {
    if (previousValue === -1) {
      previousValue = bitLength(a);
      return previousValue;
    }

    if (previousValue <= 1024) {
      var n = maybeJSBI.toNumber(a);
      var x = Math.log2(n) + 1024 * 4 - 1024 * 4;
      var y = Math.ceil(x);

      if (x !== y) {
        previousValue = y;
        return y;
      }
    }

    var n = JSBI.toNumber(JSBI.signedRightShift(a, JSBI.BigInt(previousValue - LOG2MAX)));

    if (n < 1 || n >= Number.MAX_SAFE_INTEGER + 1) {
      previousValue = -1;
      return bitLength2(a);
    }

    previousValue = previousValue - LOG2MAX + log2(n);
    return previousValue;
  }

  var p53 = JSBI.BigInt(LOG2MAX);

  function significand(value, doubleDigit) {
    if (!doubleDigit) {
      return [maybeJSBI.toNumber(value), 0];
    }

    var lo = maybeJSBI.toNumber(JSBI.asUintN(LOG2MAX, value)); //var hi = Number(value >> p53);
    // Instead doing something to save one BigInt operation:

    var tmp = maybeJSBI.toNumber(value);
    var hi = Math.floor(tmp / (Number.MAX_SAFE_INTEGER + 1));

    if (Math.floor(tmp - (Number.MAX_SAFE_INTEGER + 1) * hi) === 0) {
      if (lo > (Number.MAX_SAFE_INTEGER + 1) / 2) {
        hi -= 1;
      }

      if (lo === (Number.MAX_SAFE_INTEGER + 1) / 2) {
        hi = maybeJSBI.toNumber(maybeJSBI.signedRightShift(value, p53));
      }
    }

    return [hi, lo]; // 53 bits in hi, 53 bits in lo
  } // 2**n


  function exp2(n) {
    var result = 1;

    while (n > 30) {
      n -= 30;
      result *= 1 << 30;
    }

    result *= 1 << n;
    return result;
  }

  var doubleDigitMethod = true;

  function helper(xx, yy) {
    var $tmpx_xlo = significand(xx, doubleDigitMethod);
    var x = $tmpx_xlo[0];
    var xlo = $tmpx_xlo[1];
    var $tmpy_ylo = significand(yy, doubleDigitMethod);
    var y = $tmpy_ylo[0];
    var ylo = $tmpy_ylo[1]; // computes the transformation matrix, which is the product of all {{0, 1}, {1, -q}} matrices,
    // where q is the quotient produced by Euclid's algorithm for any pair of integers (a, b),
    // where a within [xx; xx + 1) and b within [yy; yy + 1)

    var A = 1,
        B = 0,
        C = 0,
        D = 1; // 2x2-matrix transformation matrix of (x_initial, y_initial) into (x, y)

    var lobits = LOG2MAX;

    for (var i = doubleDigitMethod ? 0 : 3; i < 4; i++) {
      var sameQuotient = y !== 0;

      while (sameQuotient) {
        //console.assert(y >= 0);
        var q = Math.floor(maybeJSBI.divide(x, y));
        var C1 = A - q * C,
            D1 = B - q * D,
            y1 = x - q * y;
        sameQuotient = y1 + C1 >= 0 && y1 + C1 < y + C && y1 + D1 >= 0 && y1 + D1 < y + D;

        if (sameQuotient) {
          // Quotient(T.transformPoint(x_initial + 1, y_initial)) === Quotient(T.transformPoint(x_initial, y_initial + 1))
          // Multiply matrix agumented by column (x, y) by {{0, 1}, {1, -q}} from the right:
          A = C;
          B = D;
          x = y;
          C = C1;
          D = D1;
          y = y1; //gcd.debug(q);
        }
      }

      if (i < 3) {
        var bits = Math.min(LOG2MAX - 1 - log2(Math.max(x, y)), lobits); // assuming that max(x, y) > max(abs(A), abs(B), abs(C), abs(D))

        var d = exp2(lobits - bits);
        var xlo1 = Math.floor(xlo / d);
        var ylo1 = Math.floor(ylo / d);
        xlo -= xlo1 * d;
        ylo -= ylo1 * d;
        lobits -= bits;
        var p = exp2(bits);
        x = A * xlo1 + B * ylo1 + x * p;
        y = C * xlo1 + D * ylo1 + y * p;
      }
    }

    return [A, B, C, D];
  }

  var SUBQUADRATIC_HALFGCD_THRESHOLD = 4096;

  function halfgcd(a, b, small) {
    //console.assert(a >= b && b >= 0n);
    // the function calculates the transformation matrix for numbers (x, y), where a <= x < a + 1 and b <= y < b + 1
    // seems, this definition is not the same as in https://mathworld.wolfram.com/Half-GCD.html
    // floor((a + 1) / b) < q = floor(a / b) < floor(a / (b + 1))
    // ([A, B], [C, D]) * (a + x, b + y) = (A*(a+x)+B*(b+y), C*(a+x)+D*(b+y)) = (A*a+B*b, C*a+D*b) + (A*x+B*y, C*x+D*y)
    //Note: for debugging it is useful to compare quotients in simple Euclidean algorithms vs quotients here
    if (small) {
      var $tmpA_B_C_D = helper(a, b);
      var A = $tmpA_B_C_D[0];
      var B = $tmpA_B_C_D[1];
      var C = $tmpA_B_C_D[2];
      var D = $tmpA_B_C_D[3];
      return [JSBI.BigInt(A), JSBI.BigInt(B), JSBI.BigInt(C), JSBI.BigInt(D), JSBI.BigInt(0), JSBI.BigInt(0)];
    }

    var size = bitLength(a);
    var isSmall = size <= SUBQUADRATIC_HALFGCD_THRESHOLD;
    var $newA = JSBI.BigInt(1);
    var $newB = JSBI.BigInt(0);
    var $newC = JSBI.BigInt(0);
    var $newD = JSBI.BigInt(1);
    var A = $newA;
    var B = $newB;
    var C = $newC;
    var D = $newD; // 2x2 matrix

    var step = 0;

    while (true) {
      // Q(T, a + 1n, b) === Q(T, a, b + 1n)
      step += 1; //console.assert(A * D >= 0 && B * C >= 0 && A * B <= 0 && D * C <= 0);//TODO: why - ?
      // A*(X+Y) = A*X+A*Y
      //var $newa1 = a + A; var $newb1 =  b + C; var a1 = $newa1; var b1 = $newb1; // T * (a_initial + 1n, b_initial);
      //var $newa2 = a + B; var $newb2 =  b + D; var a2 = $newa2; var b2 = $newb2; // T * (a_initial, b_initial + 1n);

      var n = step === 1 ? size : isSmall ? bitLength2(a) : bitLength(a); //if (!isSmall && n <= size * (2 / 3)) { // TODO: ?, the constant is based on some testing with some example
      //  return [A, B, C, D, a, b];
      //}

      var m = JSBI.BigInt(isSmall ? Math.max(0, n - LOG2MAX * (doubleDigitMethod ? 2 : 1)) : n - Math.floor(size / 2));

      if (step !== 1
      /* && m1 < size / 2*/
      ) {
          //?
          if (maybeJSBI.notEqual(maybeJSBI.signedRightShift(maybeJSBI.add(a, A), m), maybeJSBI.signedRightShift(maybeJSBI.add(a, B), m)) || maybeJSBI.notEqual(maybeJSBI.signedRightShift(maybeJSBI.add(b, C), m), maybeJSBI.signedRightShift(maybeJSBI.add(b, D), m))) {
            return [A, B, C, D, a, b];
          }
        }

      var $tmpA1_B1_C1_D1_transformedAhi_transformedBhi = halfgcd(maybeJSBI.signedRightShift(a, m), maybeJSBI.signedRightShift(b, m), isSmall);
      var A1 = $tmpA1_B1_C1_D1_transformedAhi_transformedBhi[0];
      var B1 = $tmpA1_B1_C1_D1_transformedAhi_transformedBhi[1];
      var C1 = $tmpA1_B1_C1_D1_transformedAhi_transformedBhi[2];
      var D1 = $tmpA1_B1_C1_D1_transformedAhi_transformedBhi[3];
      var transformedAhi = $tmpA1_B1_C1_D1_transformedAhi_transformedBhi[4];
      var transformedBhi = $tmpA1_B1_C1_D1_transformedAhi_transformedBhi[5];

      if (step === 1) {
        var $newA = A1;
        var $newB = B1;
        var $newC = C1;
        var $newD = D1;
        A = $newA;
        B = $newB;
        C = $newC;
        D = $newD;
      } else {
        // T = T1 * T:
        var $newA = maybeJSBI.add(maybeJSBI.multiply(A1, A), maybeJSBI.multiply(B1, C));
        var $newB = maybeJSBI.add(maybeJSBI.multiply(A1, B), maybeJSBI.multiply(B1, D));
        var $newC = maybeJSBI.add(maybeJSBI.multiply(C1, A), maybeJSBI.multiply(D1, C));
        var $newD = maybeJSBI.add(maybeJSBI.multiply(C1, B), maybeJSBI.multiply(D1, D));
        A = $newA;
        B = $newB;
        C = $newC;
        D = $newD;
      }

      if (isSmall) {
        var $newa = maybeJSBI.add(maybeJSBI.multiply(A1, a), maybeJSBI.multiply(B1, b));
        var $newb = maybeJSBI.add(maybeJSBI.multiply(C1, a), maybeJSBI.multiply(D1, b));
        a = $newa;
        b = $newb; // T1 * (a, b)
      } else {
        var alo = JSBI.asUintN(maybeJSBI.toNumber(m), a);
        var blo = JSBI.asUintN(maybeJSBI.toNumber(m), b);
        var $newa = maybeJSBI.add(maybeJSBI.add(maybeJSBI.multiply(A1, alo), maybeJSBI.multiply(B1, blo)), maybeJSBI.leftShift(transformedAhi, m));
        var $newb = maybeJSBI.add(maybeJSBI.add(maybeJSBI.multiply(C1, alo), maybeJSBI.multiply(D1, blo)), maybeJSBI.leftShift(transformedBhi, m));
        a = $newa;
        b = $newb; // T * (alo, blo) + T * (ahi, bhi) * 2**m
      }

      console.assert(JSBI.greaterThan(a, JSBI.BigInt(0)) && JSBI.greaterThanOrEqual(b, JSBI.BigInt(0)));

      if (JSBI.equal(B1, JSBI.BigInt(0))) {
        console.assert(JSBI.equal(A1, JSBI.BigInt(1)) && JSBI.equal(B1, JSBI.BigInt(0)) && JSBI.equal(C1, JSBI.BigInt(0)) && JSBI.equal(D1, JSBI.BigInt(1)));

        if (JSBI.notEqual(b, JSBI.BigInt(0))) {
          //TODO: ?
          var q = maybeJSBI.divide(a, b);
          var C2 = maybeJSBI.subtract(A, maybeJSBI.multiply(q, C)),
              D2 = maybeJSBI.subtract(B, maybeJSBI.multiply(q, D)),
              b1 = maybeJSBI.subtract(a, maybeJSBI.multiply(q, b));
          var sameQuotient = JSBI.greaterThanOrEqual(maybeJSBI.add(b1, C2), JSBI.BigInt(0)) && maybeJSBI.lessThan(maybeJSBI.add(b1, C2), maybeJSBI.add(b, C)) && JSBI.greaterThanOrEqual(maybeJSBI.add(b1, D2), JSBI.BigInt(0)) && maybeJSBI.lessThan(maybeJSBI.add(b1, D2), maybeJSBI.add(b, D));

          if (!sameQuotient) {
            return [A, B, C, D, a, b];
          }

          var $newA = C;
          var $newB = D;
          var $newC = C2;
          var $newD = D2;
          A = $newA;
          B = $newB;
          C = $newC;
          D = $newD; // {{0, 1}, {1, -q}} * T

          var $newa = b;
          var $newb = b1;
          a = $newa;
          b = $newb; // {{0, 1}, {1, -q}} * (a, b)
          //gcd.debug(q);
        } else {
          return [A, B, C, D, a, b];
        }
      }
    } // see "2. General structure of subquadratic gcd algorithms" in “On Schönhage’s algorithm and subquadratic integer GCD computation” by Möller


    return [A, B, C, D, a, b]; // for performance transformedA and transformedB are returned
  }

  var SUBQUADRATIC_GCD_THRESHOLD = 32 * 1024;
  var lastMaxSize = -1; // https://en.wikipedia.org/wiki/Lehmer%27s_GCD_algorithm
  // https://www.imsc.res.in/~kapil/crypto/notes/node11.html
  // this implementation is good after ~80 bits (?)

  function LehmersGCD(a, b) {
    if (maybeJSBI.lessThan(a, b)) {
      var tmp = a;
      a = b;
      b = tmp;
    } // Subquadratic Lehmer's algorithm:


    while (maybeJSBI.toNumber(b) >= 1 / 0 && maybeJSBI.lessThan(JSBI.asUintN(SUBQUADRATIC_GCD_THRESHOLD, b), b)) {
      //console.assert(a >= b);
      var n = bitLength2(a);
      var m = Math.floor(n / 2);
      var m1 = JSBI.BigInt(m);
      var $tmpA_B_C_D_transformedAhi_transformedBhi = halfgcd(maybeJSBI.signedRightShift(a, m1), maybeJSBI.signedRightShift(b, m1), false);
      var A = $tmpA_B_C_D_transformedAhi_transformedBhi[0];
      var B = $tmpA_B_C_D_transformedAhi_transformedBhi[1];
      var C = $tmpA_B_C_D_transformedAhi_transformedBhi[2];
      var D = $tmpA_B_C_D_transformedAhi_transformedBhi[3];
      var transformedAhi = $tmpA_B_C_D_transformedAhi_transformedBhi[4];
      var transformedBhi = $tmpA_B_C_D_transformedAhi_transformedBhi[5];

      if (JSBI.equal(B, JSBI.BigInt(0))) {
        //console.assert(A === 1n && B === 0n && C === 0n && D === 1n);
        //gcd.debug(a / b);
        var r = maybeJSBI.remainder(a, b);
        a = b;
        b = r;
      } else {
        var alo = JSBI.asUintN(m, a);
        var blo = JSBI.asUintN(m, b);
        var $newa = maybeJSBI.add(maybeJSBI.add(maybeJSBI.multiply(A, alo), maybeJSBI.multiply(B, blo)), maybeJSBI.leftShift(transformedAhi, m1));
        var $newb = maybeJSBI.add(maybeJSBI.add(maybeJSBI.multiply(C, alo), maybeJSBI.multiply(D, blo)), maybeJSBI.leftShift(transformedBhi, m1));
        a = $newa;
        b = $newb; // T * (alo, blo) + T * (ahi, bhi) * 2**m
      }
    } // Lehmer's algorithm:


    while (maybeJSBI.toNumber(b) >= Math.sqrt(Math.pow(Number.MAX_SAFE_INTEGER + 1, 3))) {
      //console.assert(a >= b);
      var n = bitLength2(a);
      var m = Math.max(0, n - LOG2MAX * (doubleDigitMethod ? 2 : 1));
      var $tmpA_B_C_D = helper(JSBI.signedRightShift(a, JSBI.BigInt(m)), JSBI.signedRightShift(b, JSBI.BigInt(m)));
      var A = $tmpA_B_C_D[0];
      var B = $tmpA_B_C_D[1];
      var C = $tmpA_B_C_D[2];
      var D = $tmpA_B_C_D[3];

      if (B === 0) {
        //console.assert(A === 1 && B === 0 && C === 0 && D === 1);
        //gcd.debug(a / b);
        var r = maybeJSBI.remainder(a, b);
        a = b;
        b = r;
      } else {
        var $newa = JSBI.add(JSBI.multiply(JSBI.BigInt(A), a), JSBI.multiply(JSBI.BigInt(B), b));
        var $newb = JSBI.add(JSBI.multiply(JSBI.BigInt(C), a), JSBI.multiply(JSBI.BigInt(D), b));
        a = $newa;
        b = $newb; // T * (a, b)
      }
    }

    return EuclidsGCD(a, b);
  }

  function abs(a) {
    return JSBI.lessThan(a, JSBI.BigInt(0)) ? maybeJSBI.unaryMinus(a) : a;
  }

  function ctz(a) {
    // https://en.wikipedia.org/wiki/Find_first_set#Properties_and_relations
    //return bitLength(a & (-a)) - 1;
    var s = a.toString(16);
    var n = s.length - 1;

    while (maybeJSBI.equal(s.charCodeAt(n), '0'.charCodeAt(0))) {
      n -= 1;
    }

    var x = s.charCodeAt(n);

    if (maybeJSBI.lessThan(x, 'a'.charCodeAt(0))) {
      x = maybeJSBI.subtract(x, '0'.charCodeAt(0));
    } else {
      x = maybeJSBI.subtract(x, 'a'.charCodeAt(0));
      x += 10;
    } //var e = (31 - Math.clz32(x & -x));


    var e = 0;

    while (x % 2 === 0) {
      x /= 2;
      e += 1;
    }

    return (s.length - 1 - n) * 4 + e;
  }

  function bigIntGCD(a, b) {
    var na = Math.abs(maybeJSBI.toNumber(a));
    var nb = Math.abs(maybeJSBI.toNumber(b));

    if (na < nb) {
      var tmp = a;
      a = b;
      b = tmp;
      var tmp1 = na;
      na = nb;
      nb = tmp1;
    }

    if (na <= Number.MAX_SAFE_INTEGER) {
      return numbersGCD(na, nb);
    }

    if (nb <= Number.MAX_SAFE_INTEGER) {
      if (nb === 0) {
        return abs(JSBI.BigInt(a));
      }

      if (nb === 1) {
        return 1;
      }

      return numbersGCD(nb, Math.abs(JSBI.toNumber(JSBI.remainder(JSBI.BigInt(a), JSBI.BigInt(b)))));
    }

    a = abs(JSBI.BigInt(a));
    b = abs(JSBI.BigInt(b));

    if (nb > (Number.MAX_SAFE_INTEGER + 1) * (1 << 11)) {
      var c1 = ctz(a);
      var c2 = ctz(b);

      if (c1 > 4 || c2 > 4) {
        var g = LehmersGCD(c1 === 0 ? a : JSBI.signedRightShift(a, JSBI.BigInt(c1)), c2 === 0 ? b : JSBI.signedRightShift(b, JSBI.BigInt(c2)));
        var c = Math.min(c1, c2);
        return c === 0 ? g : JSBI.leftShift(JSBI.BigInt(g), JSBI.BigInt(c));
      }
    }

    return LehmersGCD(a, b);
  }

  self.bigIntGCD = bigIntGCD;
})();
var maybeJSBI = {
  toNumber: function toNumber(a) {
    return typeof a === "object" ? JSBI.toNumber(a) : Number(a);
  },
  add: function add(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.add(a, b) : a + b;
  },
  subtract: function subtract(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.subtract(a, b) : a - b;
  },
  multiply: function multiply(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.multiply(a, b) : a * b;
  },
  divide: function divide(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.divide(a, b) : a / b;
  },
  remainder: function remainder(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.remainder(a, b) : a % b;
  },
  exponentiate: function exponentiate(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.exponentiate(a, b) : typeof a === "bigint" && typeof b === "bigint" ? new Function("a**b", "a", "b")(a, b) : Math.pow(a, b);
  },
  leftShift: function leftShift(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.leftShift(a, b) : a << b;
  },
  signedRightShift: function signedRightShift(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.signedRightShift(a, b) : a >> b;
  },
  bitwiseAnd: function bitwiseAnd(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.bitwiseAnd(a, b) : a & b;
  },
  bitwiseOr: function bitwiseOr(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.bitwiseOr(a, b) : a | b;
  },
  bitwiseXor: function bitwiseXor(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.bitwiseXor(a, b) : a ^ b;
  },
  lessThan: function lessThan(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.lessThan(a, b) : a < b;
  },
  greaterThan: function greaterThan(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.greaterThan(a, b) : a > b;
  },
  lessThanOrEqual: function lessOrEqualThan(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.lessThanOrEqual(a, b) : a <= b;
  },
  greaterThanOrEqual: function greaterOrEqualThan(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.greaterThanOrEqual(a, b) : a >= b;
  },
  equal: function equal(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.equal(a, b) : a === b;
  },
  notEqual: function notEqual(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.notEqual(a, b) : a !== b;
  },
  unaryMinus: function unaryMinus(a) {
    return typeof a === "object" ? JSBI.unaryMinus(a) : -a;
  },
  bitwiseNot: function bitwiseNot(a) {
    return typeof a === "object" ? JSBI.bitwiseNot(a) : ~a;
  }
};


(function () {
  "use strict"; //
  // https://github.com/tc39/proposal-bigint/issues/205
  // https://github.com/tc39/ecma262/issues/1729
  // bitLength(a) = floor(log2(a)) + 1 if a > 0

  function bitLength(a) {
    var s = a.toString(16);
    var c = maybeJSBI.subtract(s.charCodeAt(0), '0'.charCodeAt(0));

    if (c <= 0) {
      throw new RangeError();
    }

    return (s.length - 1) * 4 + (32 - Math.clz32(Math.min(c, 8)));
  } //self.bitLength = bitLength;
  //function min(a, b) {
  //  return a < b ? a : b;
  //}


  var SPLIT = Math.pow(2, Math.ceil(Math.log2((Number.MAX_SAFE_INTEGER + 1) * 2) / 2)) + 1;

  function fma(a, b, p) {
    var at = SPLIT * a;
    var ahi = at - (at - a);
    var alo = a - ahi;
    var bt = SPLIT * b;
    var bhi = bt - (bt - b);
    var blo = b - bhi;
    var e = ahi * bhi + p + ahi * blo + alo * bhi + alo * blo;
    return e;
  }

  function modMultiplySmall(a, b, m) {
    if (!(a >= 0 && b >= 0 && maybeJSBI.lessThan(a, m) && maybeJSBI.lessThan(b, m) && maybeJSBI.lessThanOrEqual(m, Number.MAX_SAFE_INTEGER))) {
      throw new RangeError();
    }

    var p = maybeJSBI.multiply(a, b);

    if (maybeJSBI.lessThanOrEqual(p, Number.MAX_SAFE_INTEGER)) {
      return p - Math.floor(maybeJSBI.divide(p, m)) * m;
    }

    var r1 = fma(a, b, maybeJSBI.unaryMinus(p));
    var q = maybeJSBI.divide(p, m) - (1 + Number.MAX_SAFE_INTEGER) + (1 + Number.MAX_SAFE_INTEGER); // note: this is a confusing line because of the double rounding

    var r2 = 0 - fma(q, m, maybeJSBI.unaryMinus(p));

    if (r1 > 0) {
      r1 -= m;
    }

    if (r2 < 0) {
      r2 += m;
    }

    var r = r1 + r2;

    if (r < 0) {
      r += m;
    }

    return r;
  }

  function modMultiplyN(N, a, b, mod) {
    if (N) {
      return modMultiplySmall(a, b, mod);
    }

    return maybeJSBI.remainder(maybeJSBI.multiply(a, b), mod);
  }

  function modPowN(N, base, exponent, modulus) {
    var one = vN(N, 1);
    var zero = vN(N, 0);
    var two = vN(N, 2); // exponent can be huge, use non-recursive variant

    var accumulator = one;

    while (maybeJSBI.notEqual(exponent, zero)) {
      var q = divideN(N, exponent, two);

      if (maybeJSBI.notEqual(exponent, maybeJSBI.add(q, q))) {
        accumulator = modMultiplyN(N, accumulator, base, modulus);
      }

      exponent = q;
      base = modMultiplyN(N, base, base, modulus);
    }

    return accumulator;
  } // isPrime implementation is stolen from:
  // https://github.com/peterolson/BigInteger.js
  // https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test#Deterministic_variants


  function isPrime(n) {
    var number = maybeJSBI.toNumber(n);
    var N = false;

    if (maybeJSBI.lessThanOrEqual(number, Number.MAX_SAFE_INTEGER)) {
      N = true;
      n = number;
    } else {
      N = false;
      n = JSBI.BigInt(n);
    }

    var zero = vN(N, 0);
    var one = vN(N, 1);
    var two = vN(N, 2);

    if (maybeJSBI.lessThan(n, two)) {
      throw new RangeError();
    }

    if (maybeJSBI.lessThan(primeFactorUsingWheelN(N, n, 1000), n)) {
      return false;
    }

    if (N && n < Math.pow(1000, 2)) {
      return true;
    }

    var r = 0;
    var d = maybeJSBI.subtract(n, one);

    while (maybeJSBI.equal(maybeJSBI.remainder(d, two), zero)) {
      d = maybeJSBI.divide(d, two);
      r += 1;
    } // https://en.wikipedia.org/wiki/Miller–Rabin_primality_test#Testing_against_small_sets_of_bases


    var bases = null;

    if (N) {
      bases = [2, 3, 5, 7, 11, 13, 17, 19, 23];
    } else {
      if (JSBI.lessThan(n, JSBI.BigInt("3317044064679887385961981"))) {
        bases = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41];
      } else {
        var lnN = bitLength(n) * Math.log(2);
        var max = Math.floor(2 * lnN * Math.log(lnN));
        var range = new Array(max - 2 + 1);

        for (var i = 2; i <= max; i += 1) {
          range[i - 2] = i;
        }

        bases = range;
      }
    }

    console.assert(maybeJSBI.greaterThan(n, bases[bases.length - 1]));

    for (var iteratora = bases[globalThis.Symbol.iterator](), a = iteratora.next().value; a != null; a = iteratora.next().value) {
      var adn = modPowN(N, N ? a : JSBI.BigInt(a), d, n);

      if (maybeJSBI.notEqual(adn, one)) {
        for (var i = 0, x = adn; maybeJSBI.notEqual(x, maybeJSBI.subtract(n, one)); i += 1, x = modMultiplyN(N, x, x, n)) {
          if (i === r - 1) {
            return false;
          }
        }
      }
    }

    return true;
  }

  function vN(N, i) {
    return N ? i : i === 0 ? JSBI.BigInt(0) : i === 1 ? JSBI.BigInt(1) : i === 2 ? JSBI.BigInt(2) : JSBI.BigInt(i);
  }

  function divideN(N, a, b) {
    return N ? Math.floor(maybeJSBI.divide(a, b)) : maybeJSBI.divide(a, b);
  }

  function abs(a) {
    return maybeJSBI.lessThan(a, maybeJSBI.subtract(a, a)) ? maybeJSBI.unaryMinus(a) : a;
  } // https://cp-algorithms.com/algebra/factorization.html#toc-tgt-9


  function brentN(N, n, x0, c) {
    var zero = vN(N, 0);
    var one = vN(N, 1);

    function gcd(a, b) {
      while (maybeJSBI.notEqual(b, zero)) {
        var r = maybeJSBI.remainder(a, b);
        a = b;
        b = r;
      }

      return a;
    }

    function f(x, c, mod) {
      var y = maybeJSBI.subtract(modMultiplyN(N, x, x, mod), c);
      return maybeJSBI.lessThan(y, zero) ? maybeJSBI.add(y, mod) : y;
    }

    function brent(n, x0, c) {
      var x = x0;
      var g = one;
      var q = one;
      var xs = zero,
          y = zero;
      var m = 128;
      var l = 1;

      while (maybeJSBI.equal(g, one)) {
        y = x;

        for (var i = 1; i < l; i++) {
          x = f(x, c, n);
        }

        var k = 0;

        while (k < l && maybeJSBI.equal(g, one)) {
          xs = x;

          for (var i = 0; i < m && i < l - k; i++) {
            x = f(x, c, n);
            q = modMultiplyN(N, q, abs(maybeJSBI.subtract(y, x)), n);
          }

          g = gcd(q, n);
          k += m;
        }

        l *= 2;
      }

      if (maybeJSBI.equal(g, n)) {
        do {
          xs = f(xs, c, n);
          g = gcd(abs(maybeJSBI.subtract(xs, y)), n);
        } while (maybeJSBI.equal(g, one));
      }

      return g;
    }

    return brent(n, x0, c);
  }

  function brentSmall(n, x0, c) {
    x0 = x0 == undefined ? 2 : x0;
    c = c == undefined ? 1 : c;
    return brentN(true, n, x0, c);
  }

  function brentBig(n, x0, c) {
    x0 = x0 == undefined ? JSBI.BigInt(2) : x0;
    c = c == undefined ? JSBI.BigInt(1) : c;
    return brentN(false, n, x0, c);
  } // Pollard's rho implementation is stolen from:
  // https://github.com/jiggzson/nerdamer/blob/master/nerdamer.core.js
  // https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm#C_code_sample

  /*
  function factorByPollardRho(n, x0, c) {
  x0 = x0 == undefined ?  2n : x0;
  c = c == undefined ?  1n : c;
  
      var factor = n;
      if (n % x0 === 0n) {//?
        return x0;
      }
      var xFixed = x0;
      var cycleSize = 2;
      var x = x0;
      factor = 1n;
      while (factor === 1n) {
        var test = 1n;
        var testStart = x;
        var found = false;
        for (var count = 1; count <= cycleSize && factor === 1n; count += 1) {
          x = (x * x + c) % n;
          //factor = gcd(abs(x - xFixed), n);
          test = (test * abs(x - xFixed)) % n;
          if (found || count === cycleSize || count % 16 === 0) {
            // https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm#Variants
            factor = gcd(test, n);
            if (!found && factor !== 1n) {
              cycleSize *= 2;
              factor = 1n;
              x = testStart;
              found = true;
            }
            test = 1n;
            testStart = x;
          }
        }
        cycleSize *= 2;
        xFixed = x;
      }
      return factor;
  }
  */


  var WHEEL3 = [1, 2, 2, 4, 2, 4, 2, 4, 6, 2, 6];

  function remainder(n, i) {
    // `n % i` is slower in Chrome and Firefox ...
    return n - Math.floor(maybeJSBI.divide(n, i)) * i;
  }

  function primeFactorUsingWheelN(N, n, max) {
    max = max == undefined ? undefined : max;

    function isDivisibleBy(n, i) {
      if (N) {
        return remainder(n, i) === 0;
      }

      return JSBI.equal(JSBI.remainder(n, JSBI.BigInt(i)), JSBI.BigInt(0));
    }

    var steps = WHEEL3;
    var cycle = 3;

    if (max == undefined) {
      max = Math.floor(Math.sqrt(maybeJSBI.toNumber(n) + 0.5));
    }

    var i = 2;
    var s = 0;

    while (i <= max) {
      if (isDivisibleBy(n, i)) {
        return i;
      }

      i += steps[s];
      s += 1;

      if (s === steps.length) {
        s = cycle;
      }
    }

    return n;
  }

  function primeFactorUsingWheel(n, max) {
    return primeFactorUsingWheelN(true, n, max);
  }

  function primeFactorUsingWheelBig(n, max) {
    return primeFactorUsingWheelN(false, n, max);
  }

  function someFactor(n) {
    var x = maybeJSBI.toNumber(n);

    if (x < 1) {
      throw new TypeError("primeFactor cannot be called for numbers less than 2");
    }

    if (x === 1) {
      return n;
    } //var s = gcd(BigInt(n), BigInt(304250263527210)); // a primorial - https://en.wikipedia.org/wiki/Primorial
    //if (s > 1n) {
    //TODO: use-cases - ?
    //  return s === n ? BigInt(primeFactorUsingWheel(Number(s))) : s;
    //}


    if (maybeJSBI.lessThanOrEqual(x, Number.MAX_SAFE_INTEGER)) {
      var pf = primeFactorUsingWheel(x, 1000);

      if (maybeJSBI.lessThan(pf, x)) {
        return JSBI.BigInt(pf);
      }

      if (x <= 1000 * 1000) {
        return JSBI.BigInt(pf);
      }

      if (x % 2 === 0) {
        return JSBI.BigInt(2);
      }
    } //! optimize n = f**2


    var squareRoot = nthRoot(n, 2);

    if (JSBI.equal(JSBI.exponentiate(squareRoot, JSBI.BigInt(2)), n)) {
      return squareRoot;
    }

    if (x > 5) {
      // https://en.wikipedia.org/wiki/Fermat%27s_factorization_method
      var a = JSBI.add(squareRoot, JSBI.BigInt(1));
      var b2 = JSBI.subtract(maybeJSBI.multiply(a, a), JSBI.BigInt(n));
      var b = nthRoot(b2, 2);

      if (maybeJSBI.equal(maybeJSBI.multiply(b, b), b2)) {
        //console.debug("Fermat's method", n, a - b);
        return maybeJSBI.subtract(a, b);
      }
    } //! optimize n = f**3


    var cubicRoot = nthRoot(n, 3);

    if (JSBI.equal(JSBI.exponentiate(cubicRoot, JSBI.BigInt(3)), n)) {
      return cubicRoot;
    }

    if (maybeJSBI.lessThanOrEqual(x, Number.MAX_SAFE_INTEGER)) {
      if (isPrime(x)) {
        return JSBI.BigInt(x);
      } //return BigInt(primeFactorUsingWheel(x));


      var number = x;
      var x0 = 2 - 1;
      var g = number;

      do {
        x0 += 1;
        g = brentSmall(number, x0);
      } while (maybeJSBI.equal(g, number));

      return g;
    }

    if (isPrime(n)) {
      return n;
    }

    var x0 = 2 - 1;
    var gbig = n;

    do {
      x0 += 1;
      gbig = brentBig(n, JSBI.BigInt(x0));
    } while (maybeJSBI.equal(gbig, n));

    return gbig;
  } // https://en.wikipedia.org/wiki/Find_first_set#CTZ


  function countTrailingZeros(x, base) {
    //console.log(x, base);
    x = JSBI.BigInt(x);
    base = JSBI.BigInt(base);

    if (JSBI.lessThan(x, JSBI.BigInt(0)) || JSBI.lessThan(base, JSBI.BigInt(0))) {
      throw new RangeError();
    }

    if (maybeJSBI.equal(x, base)) {
      return 1;
    } //if (base == 2 && typeof x === "bigint") { return bitLength(x & -x) - 1; } //TODO: ?


    if (JSBI.equal(x, JSBI.BigInt(0))) {
      throw new TypeError();
    }

    if (JSBI.equal(base, JSBI.BigInt(2))) {
      var k = 32;

      while (JSBI.equal(JSBI.asUintN(k, x), JSBI.BigInt(0))) {
        k *= 2;
      }

      var n = 0;

      for (var i = Math.floor(k / 2); i >= 32; i = Math.floor(i / 2)) {
        if (JSBI.equal(JSBI.asUintN(i, x), JSBI.BigInt(0))) {
          n += i;
          x = JSBI.signedRightShift(x, JSBI.BigInt(i));
        }
      }

      function ctz4(x) {
        return 32 - (Math.clz32(maybeJSBI.bitwiseAnd(x, maybeJSBI.unaryMinus(x))) + 1);
      }

      n += ctz4(maybeJSBI.toNumber(JSBI.asUintN(32, x)));
      return n;
    }

    var k = 1;

    while (JSBI.equal(JSBI.remainder(x, JSBI.exponentiate(base, JSBI.BigInt(k))), JSBI.BigInt(0))) {
      k *= 2;
    }

    var n = 0;

    for (var i = k / 2; i >= 1; i /= 2) {
      var v = JSBI.exponentiate(base, JSBI.BigInt(i));
      var q = maybeJSBI.divide(x, v);
      var r = maybeJSBI.subtract(x, maybeJSBI.multiply(q, v));

      if (JSBI.equal(r, JSBI.BigInt(0))) {
        n += i;
        x = q;
      }
    }

    return n;
  }

  primeFactor._rationalNumberToDecimalString = function (n, d, rounding) {
    // 1 / denominator
    var getPeriodOfRepeatingDecimalSegment = function (denominator, limit) {
      // https://softwareengineering.stackexchange.com/a/192081
      // https://en.wikipedia.org/wiki/Repeating_decimal#Other_properties_of_repetend_lengths
      // "If k = Math.pow(2, a)*5**b*n where n > 1 and n is not divisible by 2 or 5, then the length of the transient of 1/k is max(a, b), and the period equals r, where r is the smallest integer such that 10r ≡ 1 (mod n)."
      denominator = JSBI.BigInt(denominator);

      if (JSBI.equal(JSBI.remainder(denominator, JSBI.BigInt(2)), JSBI.BigInt(0)) || JSBI.equal(JSBI.remainder(denominator, JSBI.BigInt(5)), JSBI.BigInt(0))) {
        throw new RangeError("should be called with denominator not divible by 2 or 5");
      }

      var n = denominator;
      var period = 0;

      if (JSBI.notEqual(n, JSBI.BigInt(1))) {
        var z = JSBI.BigInt(1);

        do {
          period += 1;
          z = JSBI.remainder(JSBI.multiply(JSBI.BigInt(10), z), n);
        } while (period <= limit && JSBI.notEqual(z, JSBI.BigInt(1)));
      }

      return period;
    };

    var bigDecimalToPlainString = function (significand, exponent, minFraction, minSignificant) {
      var e = maybeJSBI.add(exponent, significand.length) - 1;
      significand = significand.replace(/0+$/g, '');
      var zeros = Math.max(0, Math.max(e + 1, minSignificant) - significand.length);

      if (e <= -1) {
        significand = maybeJSBI.add("0".repeat(0 - e), significand);
        e = 0;
      }

      significand = maybeJSBI.add(significand, "0".repeat(zeros));
      significand = maybeJSBI.add(significand, "0".repeat(Math.max(minFraction - (significand.length - (e + 1)), 0)));
      return significand.slice(0, e + 1) + (significand.length > e + 1 ? "." + significand.slice(e + 1) : "");
    }; // Something like Number#toPrecision: when value is between 10**-6 and Math.pow(10, p)? - to fixed, otherwise - to exponential:


    var toPrecision = function (significand, exponent, minSignificant) {
      var e = maybeJSBI.add(exponent, significand.length) - 1;

      if (e < -6 || e >= minSignificant) {
        return bigDecimalToPlainString(significand, -(significand.length - 1), 0, minSignificant) + 'e' + (e < 0 ? '-' : '') + Math.abs(e).toString();
      }

      return bigDecimalToPlainString(significand, exponent, 0, minSignificant);
    };

    var toFixed = function (significand, exponent, minFraction) {
      return bigDecimalToPlainString(significand, exponent, minFraction, 0);
    };

    var digitsToDecimalNumber = function (significand, exponent, rounding) {
      // significand * 10**exponent
      if (rounding.significantDigits != undefined) {
        return toPrecision(significand, exponent, rounding.significantDigits);
      }

      return toFixed(significand, exponent, rounding.fractionDigits);
    };

    n = JSBI.BigInt(n);
    d = JSBI.BigInt(d);
    var sign = +1;

    if (JSBI.lessThan(d, JSBI.BigInt(0))) {
      d = maybeJSBI.unaryMinus(d);
      sign = -sign;
    }

    if (JSBI.lessThan(n, JSBI.BigInt(0))) {
      n = maybeJSBI.unaryMinus(n);
      sign = -sign;
    }

    var floorOfLog10 = function (n, d) {
      //TODO: optimize - ?
      var guess = Math.floor((bitLength(n) - 1 - bitLength(d)) / Math.log2(10));

      while (maybeJSBI.greaterThanOrEqual(guess < 0 ? JSBI.multiply(JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(-guess)), n) : n, guess > 0 ? JSBI.multiply(JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(guess)), d) : d)) {
        guess += 1;
      }

      return guess - 1;
    };

    var a = primeFactor._countTrailingZeros(d, 2);

    var b = primeFactor._countTrailingZeros(d, 5);

    if (a > 0 && JSBI.equal(JSBI.remainder(n, JSBI.BigInt(2)), JSBI.BigInt(0))) {
      throw new RangeError("not implemented");
    }

    if (b > 0 && JSBI.equal(JSBI.remainder(n, JSBI.BigInt(5)), JSBI.BigInt(0))) {
      throw new RangeError("not implemented");
    }

    var d1 = JSBI.divide(d, JSBI.multiply(JSBI.exponentiate(JSBI.BigInt(2), JSBI.BigInt(a)), JSBI.exponentiate(JSBI.BigInt(5), JSBI.BigInt(b))));

    if ((rounding.fractionDigits != undefined && Math.max(a, b) <= rounding.fractionDigits || rounding.significantDigits != undefined && Math.max(a, b) + (floorOfLog10(n, d) + 1) - primeFactor._countTrailingZeros(n, 10) <= rounding.significantDigits) && JSBI.equal(maybeJSBI.remainder(n, d1), JSBI.BigInt(0))) {
      // exact result
      var scaling = Math.max(a, b);
      var result = JSBI.divide(JSBI.multiply(JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(scaling)), n), d).toString(); //TODO: optimize - ?

      var minRounding = rounding.fractionDigits != undefined ? {
        fractionDigits: Math.max(a, b)
      } : {
        significantDigits: Math.max(a, b) + (floorOfLog10(n, d) + 1) <= rounding.significantDigits ? Math.max(a, b) + (floorOfLog10(n, d) + 1) : Math.max(a, b) + (floorOfLog10(n, d) + 1) - primeFactor._countTrailingZeros(n, 10)
      };
      var f = (sign < 0 ? '-' : '') + digitsToDecimalNumber(result, -scaling, minRounding);
      return f;
    } else {
      var scaling = rounding.fractionDigits != undefined ? rounding.fractionDigits : rounding.significantDigits - (floorOfLog10(n, d) + 1);
      var sn = scaling > 0 ? JSBI.multiply(JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(scaling)), n) : n;
      var sd = scaling < 0 ? JSBI.multiply(JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(-scaling)), d) : d;
      var result = JSBI.divide(JSBI.add(sn, JSBI.divide(sd, JSBI.BigInt(2))), sd).toString();
      var f = (sign < 0 ? '-' : '') + digitsToDecimalNumber(result, -scaling, rounding);
      var lengthOfTransient = Math.max(a, b);
      var period = getPeriodOfRepeatingDecimalSegment(d1, f.length); ///^0\.(\d+?)(\d*?)(?:\1\2)*\1$/.exec('0.123123')

      if (period !== 0 && maybeJSBI.lessThanOrEqual(period, f.length)) {
        // a repeating decimal, the result is not exact
        var j = f.indexOf('.'); //?

        var offset = j + 1 + lengthOfTransient - (f.indexOf('e') !== -1 ? -maybeJSBI.toNumber(f.slice(f.indexOf('e') + 1)) - 0 : 0) - primeFactor._countTrailingZeros(n, 10);

        if (offset < j + 1) {
          //TODO: fix
          offset = j + 1; //!?
        }

        var lastFractionDigit = f.indexOf('e') !== -1 ? f.indexOf('e') : f.length;

        if (j !== -1 && (offset + period < lastFractionDigit || offset + period === lastFractionDigit && maybeJSBI.lessThan(f.charCodeAt(offset), '5'.charCodeAt(0)))) {
          f = f.slice(0, offset) + '(' + f.slice(offset, offset + period) + ')' + f.slice(offset + period);
        }
      }

      if (!/[^0\.]/.test(f) && sign >= 0 && JSBI.notEqual(n, JSBI.BigInt(0))) {
        f = '+' + f;
      }

      return f;
    }
  };

  function primeFactor(n) {
    n = JSBI.BigInt(n);
    var factor = JSBI.BigInt(someFactor(n));

    if (maybeJSBI.equal(factor, n)) {
      return factor;
    } //var otherFactor = n / factor**BigInt(countTrailingZeros(n, factor));
    //if (otherFactor === 1n) {
    //  return primeFactor(factor);
    //}
    //TODO: divide by gcd (?)
    //if (otherFactor < factor) {
    //  var tmp = factor;
    //  factor = otherFactor;
    //  otherFactor = tmp;
    //}


    var a = primeFactor(factor); //var b = a > nthRoot(nthRoot(otherFactor, 2), 2) || a > 1e9 ? primeFactor(otherFactor) : primeFactorUsingWheelBig(otherFactor, a);
    //return min(a, b);

    return a;
  } // from https://github.com/juanelas/bigint-mod-arith/blob/master/lib/index.browser.mod.js :
  // x * a + y * b = gcd(a, b)


  function eGCD_N(N, a, b) {
    var zero = vN(N, 0);
    var one = vN(N, 1);
    var $newoldR = abs(a);
    var $newr = abs(b);
    var oldR = $newoldR;
    var r = $newr;
    var $newoldX = one;
    var $newx = zero;
    var oldX = $newoldX;
    var x = $newx;
    var $newoldY = zero;
    var $newy = one;
    var oldY = $newoldY;
    var y = $newy;

    while (maybeJSBI.notEqual(r, zero)) {
      var q = divideN(N, oldR, r);
      var $newoldR = r;
      var $newr = maybeJSBI.subtract(oldR, maybeJSBI.multiply(q, r));
      oldR = $newoldR;
      r = $newr;
      var $newoldX = x;
      var $newx = maybeJSBI.subtract(oldX, maybeJSBI.multiply(q, x));
      oldX = $newoldX;
      x = $newx;
      var $newoldY = y;
      var $newy = maybeJSBI.subtract(oldY, maybeJSBI.multiply(q, y));
      oldY = $newoldY;
      y = $newy;

      if (maybeJSBI.greaterThan(r, maybeJSBI.subtract(oldR, r))) {
        // increase q by 1 and negate coefficients
        r = maybeJSBI.subtract(oldR, r);
        x = maybeJSBI.subtract(oldX, x);
        y = maybeJSBI.subtract(oldY, y);
      }
    }

    return {
      gcd: oldR,
      x: oldX,
      y: oldY
    };
  }

  function modInverseN(N, a, m) {
    var zero = vN(N, 0);
    console.assert(maybeJSBI.greaterThanOrEqual(a, zero));
    console.assert(maybeJSBI.greaterThan(m, zero));

    if (maybeJSBI.greaterThan(a, m)) {
      a = maybeJSBI.remainder(a, m);
    }

    var inv = eGCD_N(N, a, m).x;
    inv = maybeJSBI.lessThan(inv, zero) ? maybeJSBI.add(inv, m) : inv;
    console.assert(maybeJSBI.greaterThanOrEqual(inv, zero) && maybeJSBI.lessThan(inv, m));
    return inv;
  }

  function modInverseSmall(a, m) {
    return modInverseN(true, a, m);
  }

  function modInverseBig(a, m) {
    return modInverseN(false, a, m);
  }

  function modInverse(a, m) {
    if (typeof m === "number") {
      if (typeof a === "number") {
        return modInverseSmall(a, m);
      }

      return modInverseSmall(JSBI.toNumber(JSBI.remainder(JSBI.BigInt(a), JSBI.BigInt(m))), m);
    }

    return modInverseBig(JSBI.BigInt(a), JSBI.BigInt(m));
  }

  function nextPrime(n) {
    var i = maybeJSBI.toNumber(n);
    i += 1;

    while (maybeJSBI.lessThan(i, Number.MAX_SAFE_INTEGER) && !isPrime(i)) {
      i += 1;
    }

    if (maybeJSBI.lessThan(i, Number.MAX_SAFE_INTEGER)) {
      return i;
    }

    n = JSBI.BigInt(n);
    n = JSBI.add(n, JSBI.BigInt(1));

    if (JSBI.lessThan(n, JSBI.BigInt(i))) {
      n = JSBI.BigInt(i);
    }

    while (!isPrime(n)) {
      n = JSBI.add(n, JSBI.BigInt(1));
    }

    return n;
  }

  primeFactor._bitLength = bitLength;
  primeFactor._isPrime = isPrime;
  primeFactor._countTrailingZeros = countTrailingZeros;
  primeFactor._someFactor = someFactor;
  primeFactor._modInverse = modInverse;
  primeFactor._nextPrime = nextPrime;
  primeFactor._modMultiplySmall = modMultiplySmall;

  primeFactor._modPowSmall = function (a, n, m) {
    return modPowN(true, a, n, m);
  };

  self.primeFactor = primeFactor;
})();
var maybeJSBI = {
  toNumber: function toNumber(a) {
    return typeof a === "object" ? JSBI.toNumber(a) : Number(a);
  },
  add: function add(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.add(a, b) : a + b;
  },
  subtract: function subtract(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.subtract(a, b) : a - b;
  },
  multiply: function multiply(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.multiply(a, b) : a * b;
  },
  divide: function divide(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.divide(a, b) : a / b;
  },
  remainder: function remainder(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.remainder(a, b) : a % b;
  },
  exponentiate: function exponentiate(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.exponentiate(a, b) : typeof a === "bigint" && typeof b === "bigint" ? new Function("a**b", "a", "b")(a, b) : Math.pow(a, b);
  },
  leftShift: function leftShift(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.leftShift(a, b) : a << b;
  },
  signedRightShift: function signedRightShift(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.signedRightShift(a, b) : a >> b;
  },
  bitwiseAnd: function bitwiseAnd(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.bitwiseAnd(a, b) : a & b;
  },
  bitwiseOr: function bitwiseOr(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.bitwiseOr(a, b) : a | b;
  },
  bitwiseXor: function bitwiseXor(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.bitwiseXor(a, b) : a ^ b;
  },
  lessThan: function lessThan(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.lessThan(a, b) : a < b;
  },
  greaterThan: function greaterThan(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.greaterThan(a, b) : a > b;
  },
  lessThanOrEqual: function lessOrEqualThan(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.lessThanOrEqual(a, b) : a <= b;
  },
  greaterThanOrEqual: function greaterOrEqualThan(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.greaterThanOrEqual(a, b) : a >= b;
  },
  equal: function equal(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.equal(a, b) : a === b;
  },
  notEqual: function notEqual(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.notEqual(a, b) : a !== b;
  },
  unaryMinus: function unaryMinus(a) {
    return typeof a === "object" ? JSBI.unaryMinus(a) : -a;
  },
  bitwiseNot: function bitwiseNot(a) {
    return typeof a === "object" ? JSBI.bitwiseNot(a) : ~a;
  }
};


(function () {
  "use strict";
  /*jslint bigint: true, vars: true, indent: 2*/
  // https://github.com/tc39/proposal-decimal
  // https://en.wikipedia.org/wiki/Floating-point_arithmetic
  // https://en.wikipedia.org/wiki/Fixed-point_arithmetic
  // Usage:
  // BigDecimal.BigDecimal(bigint)
  // BigDecimal.BigDecimal(string)
  // BigDecimal.BigDecimal(number) (only integers)
  // BigDecimal.toBigInt(a) (not in the spec)
  // BigDecimal.toNumber(a) (not in the spec, only integers)
  // BigDecimal.unaryMinus(a)
  // BigDecimal.add(a, b[, rounding])
  // BigDecimal.subtract(a, b[, rounding])
  // BigDecimal.multiply(a, b[, rounding])
  // BigDecimal.divide(a, b, rounding)
  // BigDecimal.lessThan(a, b)
  // BigDecimal.greaterThan(a, b)
  // BigDecimal.equal(a, b)
  // BigDecimal.round(a, rounding)
  // a.toString()
  // a.toFixed(fractionDigits[, roundingMode = "half-up"])
  // a.toPrecision(precision[, roundingMode = "half-up"])
  // a.toExponential(fractionDigits[, roundingMode = "half-up"])
  // Math: (not in the spec)
  // BigDecimal.log(a, rounding)
  // BigDecimal.exp(a, rounding)
  // BigDecimal.sin(a, rounding)
  // BigDecimal.cos(a, rounding)
  // BigDecimal.atan(a, rounding)
  // BigDecimal.sqrt(a, rounding)
  // BigDecimal.cbrt(a, rounding)
  // "simple" Math functions:
  // BigDecimal.abs(a)
  // BigDecimal.sign(a)
  // BigDecimal.max(a, b)
  // BigDecimal.min(a, b)
  // (!) Note: consider to use only "half-even" rounding mode and rounding to a maximum number of significant digits for floating-point arithmetic,
  // or only "floor" rounding to a maximum number of fraction digits for fixed-point arithmetic.
  // BigFloat may have better performance.

  var factory = function (BASE) {
    var BIGINT_BASE = JSBI.BigInt(BASE);

    function BigDecimal(significand, exponent) {
      this.significand = significand;
      this.exponent = exponent;
    }

    BigDecimal.BigFloat = BigDecimal.BigDecimal = function (value) {
      if (value instanceof BigDecimal) {
        return value;
      }

      if (typeof value === "string") {
        if (BASE !== 10) {
          throw new Error();
        }

        var match = /^\s*([+\-])?(\d+)?\.?(\d+)?(?:e([+\-]?\d+))?\s*$/.exec(value);

        if (match == null) {
          throw new RangeError(value);
        }

        var exponent = Number(match[4] || "0");
        return create(JSBI.BigInt((match[1] || "") + (match[2] || "") + (match[3] || "")), diff(Math.abs(exponent) < Number.MAX_SAFE_INTEGER ? exponent : JSBI.BigInt(match[4] || "0"), (match[3] || "").length));
      }

      if (typeof value === "number" && Math.floor(value) !== value) {
        if (BASE === 2) {
          var e = getExponent(value);
          var f = value / Math.pow(2, e);
          var significand = f * (Number.MAX_SAFE_INTEGER + 1) / 2;
          var exponent = e - (Math.floor(Math.log2(Number.MAX_SAFE_INTEGER + 1)) - 1);
          return create(JSBI.BigInt(significand), exponent); //TODO: ?
        }
      }

      var a = create(JSBI.BigInt(value), 0); // `normalize` will change the exponent which is not good for fixed-point arithmetic (?)
      //var b = normalize(a, null);
      //while (a !== b) {
      //  a = b;
      //  b = normalize(a, null);
      //}

      return a;
    };

    BigDecimal.toNumber = function (a) {
      return maybeJSBI.toNumber(BigDecimal.toBigInt(a));
    };

    BigDecimal.toBigInt = function (a) {
      var exponent = maybeJSBI.toNumber(a.exponent);

      if (exponent === 0) {
        return a.significand;
      }

      if (exponent < 0) {
        var result = bigIntUnscale(a.significand, maybeJSBI.unaryMinus(exponent));

        if (maybeJSBI.notEqual(bigIntScale(result, maybeJSBI.unaryMinus(exponent)), a.significand)) {
          throw new RangeError("The BigDecimal " + a.toString() + " cannot be converted to a BigInt because it is not an integer");
        }

        return result;
      }

      return bigIntScale(a.significand, exponent);
    };

    function create(significand, exponent) {
      return (
        /*Object.freeze(*/
        new BigDecimal(significand, exponent)
        /*)*/

      );
    }

    function bigIntMax(a, b) {
      return maybeJSBI.lessThan(a, b) ? b : a;
    }

    function bigIntMin(a, b) {
      return maybeJSBI.lessThan(a, b) ? a : b;
    }

    function bigIntAbs(a) {
      return JSBI.lessThan(a, JSBI.BigInt(0)) ? maybeJSBI.unaryMinus(a) : a;
    } // https://github.com/tc39/proposal-bigint/issues/205
    // https://github.com/tc39/ecma262/issues/1729
    // floor(log2(a)) + 1 if a > 0


    function bitLength(a) {
      var s = a.toString(16);
      var c = maybeJSBI.subtract(s.charCodeAt(0), "0".charCodeAt(0));

      if (c <= 0) {
        throw new RangeError();
      }

      return (s.length - 1) * 4 + (32 - Math.clz32(Math.min(c, 8)));
    }

    function bigIntLog2(n) {
      var k = bitLength(n) - Math.floor(Math.log2(Number.MAX_SAFE_INTEGER + 1));
      var leadingDigits = JSBI.toNumber(JSBI.signedRightShift(n, JSBI.BigInt(k)));
      return Math.log2(leadingDigits) + k;
    }

    function digits(a) {
      // floor(log(abs(a)) / log(BASE)) + 1
      a = bigIntAbs(a);

      if (BASE === 2) {
        return bitLength(a);
      }

      var number = maybeJSBI.toNumber(a);

      if (number < (Number.MAX_SAFE_INTEGER + 1) / 16) {
        return Math.floor(Math.log2(number + 0.5) / Math.log2(BASE)) + 1;
      }

      var e = (number < 1 / 0 ? Math.log2(number) : bigIntLog2(a)) / Math.log2(BASE);

      if (Math.floor(e * (1 - 32 / (Number.MAX_SAFE_INTEGER + 1))) === Math.floor(e) && Math.floor(e * (1 + 32 / (Number.MAX_SAFE_INTEGER + 1))) === Math.floor(e)) {
        return Math.floor(e) + 1;
      }

      var i = Math.floor(e + 0.5);
      return maybeJSBI.greaterThanOrEqual(a, cachedPower(i)) ? i + 1 : i;
    }

    function sum(a, b) {
      if (typeof a === "number" && typeof b === "number") {
        var value = a + b;

        if (value >= maybeJSBI.unaryMinus(Number.MAX_SAFE_INTEGER) && value <= +Number.MAX_SAFE_INTEGER) {
          return value;
        }
      }

      var v = JSBI.add(JSBI.BigInt(a), JSBI.BigInt(b));
      var nv = maybeJSBI.toNumber(v);

      if (maybeJSBI.greaterThanOrEqual(nv, maybeJSBI.unaryMinus(Number.MAX_SAFE_INTEGER)) && nv <= +Number.MAX_SAFE_INTEGER) {
        return nv;
      }

      return v;
    }

    function diff(a, b) {
      return sum(a, maybeJSBI.unaryMinus(b));
    }

    var E = Math.ceil(0.5 * Math.log2(Number.MAX_SAFE_INTEGER + 1) / Math.log2(BASE) - 1);
    var N = JSBI.BigInt(Math.pow(BASE, E));

    function normalize(a, rounding) {
      if (rounding == null || rounding.maximumSignificantDigits != null) {
        if (JSBI.equal(a.significand, JSBI.BigInt(0))) {
          return a.exponent === 0 ? a : create(JSBI.BigInt(0), 0);
        }

        var dividend = a.significand;
        var e = E;
        var divisor = N;

        if (JSBI.equal(maybeJSBI.remainder(dividend, divisor), JSBI.BigInt(0))) {
          while (JSBI.equal(maybeJSBI.remainder(dividend, maybeJSBI.multiply(divisor, divisor)), JSBI.BigInt(0))) {
            divisor = maybeJSBI.multiply(divisor, divisor);
            e *= 2;
          }

          var quotient = maybeJSBI.divide(dividend, divisor);
          return create(quotient, sum(a.exponent, e));
        }
      }

      return a;
    }

    function cachedFunction(f) {
      var cache = {};
      var cacheSize = 0;
      return function (k) {
        var lastValue = cache[k];

        if (lastValue == null) {
          if (cacheSize > 100) {
            cache = {};
            cacheSize = 0;
          }

          lastValue = f(k);
          cache[k] = lastValue;
          cacheSize += 1;
        }

        return lastValue;
      };
    }

    var cachedBigInt = cachedFunction(function (k) {
      // k === maximumFractionDigits
      return JSBI.BigInt(k);
    });
    var cachedPower = cachedFunction(function (k) {
      return JSBI.exponentiate(BIGINT_BASE, JSBI.BigInt(k));
    });

    function round(a, rounding) {
      if (rounding != null) {
        var k = 0;
        var dividend = a.significand;
        var exponent = a.exponent;
        var maximumSignificantDigits = rounding.maximumSignificantDigits;

        if (maximumSignificantDigits != null) {
          if (!(maximumSignificantDigits > 0)) {
            throw new RangeError("maximumSignificantDigits should be positive");
          }

          if (JSBI.equal(dividend, JSBI.BigInt(0))) {
            return create(JSBI.BigInt(0), 0);
          }

          k = digits(dividend) - maximumSignificantDigits;
        }

        var maximumFractionDigits = rounding.maximumFractionDigits;

        if (maximumFractionDigits != null) {
          if (!(maximumFractionDigits >= 0)) {
            throw new RangeError("maximumFractionDigits should be non-negative");
          }

          k = 0 - maybeJSBI.toNumber(sum(exponent, maximumFractionDigits)); //k = Math.min(k, digits(a.significand) + 1);
          //if (k < 0 && k >= -1024 && BASE === 2) {
          //  return create(a.significand << BigInt(-k), 0 - maximumFractionDigits);
          //}
        }

        if (k > 0) {
          var roundingMode = rounding.roundingMode;
          var quotient = JSBI.BigInt(0);

          if (roundingMode === "floor") {
            if (BASE === 2) {
              quotient = maybeJSBI.signedRightShift(dividend, cachedBigInt(k));
            } else {
              if (JSBI.greaterThanOrEqual(dividend, JSBI.BigInt(0))) {
                quotient = maybeJSBI.divide(dividend, cachedPower(k));
              } else {
                quotient = JSBI.subtract(JSBI.divide(JSBI.add(dividend, JSBI.BigInt(1)), cachedPower(k)), JSBI.BigInt(1));
              }
            }
          } else if (roundingMode === "ceil") {
            if (BASE === 2) {
              quotient = maybeJSBI.unaryMinus(maybeJSBI.signedRightShift(maybeJSBI.unaryMinus(dividend), cachedBigInt(k)));
            } else {
              if (JSBI.lessThan(dividend, JSBI.BigInt(0))) {
                quotient = maybeJSBI.divide(dividend, cachedPower(k));
              } else {
                quotient = JSBI.add(JSBI.divide(JSBI.subtract(dividend, JSBI.BigInt(1)), cachedPower(k)), JSBI.BigInt(1));
              }
            }
          } else {
            var divisor = BASE === 2 ? JSBI.leftShift(JSBI.BigInt(1), cachedBigInt(k)) : cachedPower(k);
            quotient = maybeJSBI.divide(dividend, divisor);
            var twoRemainders = JSBI.multiply(maybeJSBI.subtract(dividend, maybeJSBI.multiply(divisor, quotient)), JSBI.BigInt(2));

            if (JSBI.notEqual(twoRemainders, JSBI.BigInt(0))) {
              if (roundingMode === "half-up") {
                twoRemainders = maybeJSBI.add(twoRemainders, JSBI.lessThan(twoRemainders, JSBI.BigInt(0)) ? JSBI.unaryMinus(JSBI.BigInt(1)) : JSBI.BigInt(1));
              } else if (roundingMode === "half-down") {
                twoRemainders = JSBI.add(twoRemainders, JSBI.BigInt(0));
              } else if (roundingMode === "half-even") {
                twoRemainders = JSBI.add(twoRemainders, JSBI.remainder(quotient, JSBI.BigInt(2)));
              } else {
                throw new RangeError("supported roundingMode (floor/ceil/half-even/half-up/half-down) is not given");
              }

              if (maybeJSBI.greaterThan(twoRemainders, divisor)) {
                quotient = JSBI.add(quotient, JSBI.BigInt(1));
              }

              if (maybeJSBI.greaterThan(maybeJSBI.unaryMinus(twoRemainders), divisor)) {
                quotient = JSBI.subtract(quotient, JSBI.BigInt(1));
              }
            }
          }

          return create(quotient, sum(exponent, k));
        }
      }

      return a;
    }

    BigDecimal.unaryMinus = function (a) {
      return create(maybeJSBI.unaryMinus(a.significand), a.exponent);
    };

    BigDecimal.add = function (a, b, rounding) {
      rounding = rounding == undefined ? null : rounding;
      var bd = diff(a.exponent, b.exponent);
      var d = maybeJSBI.toNumber(bd);

      if (d !== 0) {
        // optimization
        if (JSBI.equal(a.significand, JSBI.BigInt(0))) {
          return round(b, rounding);
        }

        if (JSBI.equal(b.significand, JSBI.BigInt(0))) {
          return round(a, rounding);
        }

        if (d > 0) {
          if (rounding != null && rounding.maximumSignificantDigits != null && d > digits(b.significand) + (rounding.maximumSignificantDigits + 1)) {
            return round(create(maybeJSBI.add(bigIntScale(a.significand, rounding.maximumSignificantDigits + 1), JSBI.lessThan(b.significand, JSBI.BigInt(0)) ? JSBI.unaryMinus(JSBI.BigInt(1)) : JSBI.BigInt(1)), diff(a.exponent, rounding.maximumSignificantDigits + 1)), rounding);
          }

          return round(create(maybeJSBI.add(bigIntScale(a.significand, bd), b.significand), b.exponent), rounding);
        }

        if (d < 0) {
          if (rounding != null && rounding.maximumSignificantDigits != null && 0 - d > digits(a.significand) + (rounding.maximumSignificantDigits + 1)) {
            return round(create(maybeJSBI.add(JSBI.lessThan(a.significand, JSBI.BigInt(0)) ? JSBI.unaryMinus(JSBI.BigInt(1)) : JSBI.BigInt(1), bigIntScale(b.significand, rounding.maximumSignificantDigits + 1)), diff(b.exponent, rounding.maximumSignificantDigits + 1)), rounding);
          }

          return round(create(maybeJSBI.add(a.significand, bigIntScale(b.significand, maybeJSBI.unaryMinus(bd))), a.exponent), rounding);
        }
      }

      return round(create(maybeJSBI.add(a.significand, b.significand), a.exponent), rounding);
    };

    BigDecimal.subtract = function (a, b, rounding) {
      rounding = rounding == undefined ? null : rounding;
      return BigDecimal.add(a, BigDecimal.unaryMinus(b), rounding);
    };

    BigDecimal.multiply = function (a, b, rounding) {
      rounding = rounding == undefined ? null : rounding;
      return normalize(round(create(maybeJSBI.multiply(a.significand, b.significand), sum(a.exponent, b.exponent)), rounding), rounding);
    };

    function bigIntScale(a, scaling) {
      return BASE === 2 ? maybeJSBI.leftShift(a, cachedBigInt(scaling)) : maybeJSBI.multiply(cachedPower(scaling), a);
    }

    function bigIntUnscale(a, unscaling) {
      return BASE === 2 ? maybeJSBI.signedRightShift(a, cachedBigInt(unscaling)) : maybeJSBI.divide(a, cachedPower(unscaling));
    }

    BigDecimal.divide = function (a, b, rounding) {
      rounding = rounding == undefined ? null : rounding;

      if (JSBI.equal(a.significand, JSBI.BigInt(0))) {
        return a;
      }

      var exponent = diff(a.exponent, b.exponent);
      var scaling = 0;

      if (rounding != null && rounding.maximumSignificantDigits != null) {
        scaling = rounding.maximumSignificantDigits + (digits(b.significand) - digits(a.significand));
      } else if (rounding != null && rounding.maximumFractionDigits != null) {
        //scaling = BigInt(rounding.maximumFractionDigits) + bigIntMax(a.exponent, 0n) + bigIntMax(0n - b.exponent, 0n) - bigIntMin(a.exponent - b.exponent + BigInt(digits(a.significand) - digits(b.significand)), 0n);
        scaling = sum(rounding.maximumFractionDigits, exponent);
      } else {
        // Try to do exact division:
        scaling = Math.ceil(digits(b.significand) * Math.log2(BASE)) + 1;
      }

      var dividend = scaling > 0 ? bigIntScale(a.significand, scaling) : a.significand;
      var divisor = scaling < 0 ? bigIntScale(b.significand, -scaling) : b.significand;

      if (JSBI.lessThan(divisor, JSBI.BigInt(0))) {
        dividend = maybeJSBI.unaryMinus(dividend);
        divisor = maybeJSBI.unaryMinus(divisor);
      }

      var quotient = JSBI.BigInt(0);

      if (rounding != null && rounding.roundingMode === "floor") {
        if (JSBI.greaterThanOrEqual(dividend, JSBI.BigInt(0))) {
          quotient = maybeJSBI.divide(dividend, divisor);
        } else {
          quotient = JSBI.subtract(JSBI.divide(JSBI.add(dividend, JSBI.BigInt(1)), divisor), JSBI.BigInt(1));
        }
      } else if (rounding != null && rounding.roundingMode === "ceil") {
        if (JSBI.lessThanOrEqual(dividend, JSBI.BigInt(0))) {
          quotient = maybeJSBI.divide(dividend, divisor);
        } else {
          quotient = JSBI.add(JSBI.divide(JSBI.subtract(dividend, JSBI.BigInt(1)), divisor), JSBI.BigInt(1));
        }
      } else {
        if (JSBI.lessThan(dividend, JSBI.BigInt(0))) {
          quotient = JSBI.subtract(JSBI.divide(JSBI.add(dividend, JSBI.BigInt(1)), divisor), JSBI.BigInt(1));
        } else {
          quotient = maybeJSBI.divide(dividend, divisor);
        }

        var remainder = maybeJSBI.subtract(dividend, maybeJSBI.multiply(divisor, quotient));
        console.assert(JSBI.greaterThanOrEqual(remainder, JSBI.BigInt(0)));

        if (JSBI.notEqual(remainder, JSBI.BigInt(0))) {
          if (rounding == null) {
            throw new RangeError("rounding is not given for inexact operation");
          }

          quotient = JSBI.multiply(quotient, JSBI.exponentiate(BIGINT_BASE, JSBI.BigInt(2)));
          scaling = sum(scaling, 2);

          if (JSBI.lessThan(JSBI.multiply(remainder, JSBI.BigInt(2)), divisor)) {
            quotient = JSBI.add(quotient, JSBI.BigInt(1));
          } else if (JSBI.equal(JSBI.multiply(remainder, JSBI.BigInt(2)), divisor)) {
            quotient = JSBI.add(quotient, JSBI.divide(JSBI.exponentiate(BIGINT_BASE, JSBI.BigInt(2)), JSBI.BigInt(2)));
          } else {
            quotient = JSBI.add(quotient, JSBI.add(JSBI.divide(JSBI.exponentiate(BIGINT_BASE, JSBI.BigInt(2)), JSBI.BigInt(2)), JSBI.BigInt(1)));
          }
        }
      }

      return round(create(quotient, diff(exponent, scaling)), rounding);
    };

    function compare(a, b) {
      if (maybeJSBI.equal(a.exponent, b.exponent)) {
        return maybeJSBI.lessThan(a.significand, b.significand) ? -1 : maybeJSBI.greaterThan(a.significand, b.significand) ? +1 : 0;
      }

      if (JSBI.lessThanOrEqual(a.significand, JSBI.BigInt(0)) && JSBI.greaterThanOrEqual(b.significand, JSBI.BigInt(0))) {
        return !(JSBI.equal(a.significand, JSBI.BigInt(0)) && JSBI.equal(b.significand, JSBI.BigInt(0))) ? -1 : 0;
      }

      if (JSBI.greaterThanOrEqual(a.significand, JSBI.BigInt(0)) && JSBI.lessThanOrEqual(b.significand, JSBI.BigInt(0))) {
        return JSBI.equal(a.significand, JSBI.BigInt(0)) && JSBI.equal(b.significand, JSBI.BigInt(0)) ? 0 : +1;
      }

      if (BASE !== 2) {
        var differenceOfLogarithms = maybeJSBI.toNumber(sum(diff(a.exponent, b.exponent), digits(a.significand) - digits(b.significand)));

        if (differenceOfLogarithms !== 0) {
          return JSBI.lessThan(a.significand, JSBI.BigInt(0)) && JSBI.lessThan(b.significand, JSBI.BigInt(0)) ? differenceOfLogarithms > 0 ? -1 : +1 : differenceOfLogarithms < 0 ? -1 : +1;
        }
      } else {
        //TODO: remove when bitLength is fast
        var x = maybeJSBI.greaterThanOrEqual(a.exponent, b.exponent) ? a.significand : maybeJSBI.signedRightShift(a.significand, cachedBigInt(diff(b.exponent, a.exponent)));
        var y = maybeJSBI.greaterThanOrEqual(b.exponent, a.exponent) ? b.significand : maybeJSBI.signedRightShift(b.significand, cachedBigInt(diff(a.exponent, b.exponent)));

        if (maybeJSBI.lessThan(x, y)) {
          return -1;
        }

        if (maybeJSBI.lessThan(y, x)) {
          return +1;
        } //return x < y ? -1 : (x > y ? +1 : 0);

      }

      var x = maybeJSBI.lessThanOrEqual(a.exponent, b.exponent) ? a.significand : bigIntScale(a.significand, diff(a.exponent, b.exponent));
      var y = maybeJSBI.lessThanOrEqual(b.exponent, a.exponent) ? b.significand : bigIntScale(b.significand, diff(b.exponent, a.exponent));
      return maybeJSBI.lessThan(x, y) ? -1 : maybeJSBI.greaterThan(x, y) ? +1 : 0;
    }

    BigDecimal.lessThan = function (a, b) {
      return compare(a, b) < 0;
    };

    BigDecimal.greaterThan = function (a, b) {
      return compare(a, b) > 0;
    };

    BigDecimal.equal = function (a, b) {
      return compare(a, b) === 0;
    };

    BigDecimal.round = function (a, rounding) {
      //TODO: quick round algorithm (?)
      return round(a, rounding);
    };

    BigDecimal.prototype.toString = function () {
      //! https://tc39.es/ecma262/#sec-number.prototype.tostring
      if (BASE !== 10) {
        throw new Error();
      }

      if (arguments.length !== 0) {
        throw new RangeError("not implemented");
      }

      var x = BigDecimal.BigDecimal(this); //! https://tc39.es/ecma262/#sec-numeric-types-number-tostring

      if (BigDecimal.equal(x, BigDecimal.BigDecimal(0))) {
        return "0";
      }

      var sign = "";

      if (BigDecimal.lessThan(x, BigDecimal.BigDecimal(0))) {
        x = BigDecimal.unaryMinus(x);
        sign = "-";
      }

      var getSignificand = function (a, log10) {
        //var s = BigDecimal.multiply(exponentiate(10, -log10), a);
        //var m = BigDecimal.BigDecimal(Math.pow(10, 15));
        //while (!BigDecimal.equal(BigDecimal.round(BigDecimal.multiply(s, m), {maximumFractionDigits: 0, roundingMode: "half-even"}), BigDecimal.multiply(s, m))) {
        //  m = BigDecimal.multiply(m, m);
        //}
        //return BigDecimal.toBigInt(BigDecimal.multiply(s, m)).toString().replace(/0+$/g, "") || "0";
        return a.significand.toString().replace(/0+$/g, "") || "0";
      };

      var e = getCountOfDigits(x);
      var significand = getSignificand(x, e);

      if (!BigDecimal.greaterThan(exponentiate(10, JSBI.unaryMinus(JSBI.BigInt(6))), x) && BigDecimal.lessThan(x, exponentiate(10, JSBI.BigInt(21)))) {
        return sign + bigDecimalToPlainString(significand, JSBI.toNumber(JSBI.subtract(e, JSBI.BigInt(significand.length))), 0, 0);
      }

      return sign + bigDecimalToPlainString(significand, -(significand.length - 1), 0, 0) + "e" + (JSBI.greaterThanOrEqual(JSBI.subtract(e, JSBI.BigInt(1)), JSBI.BigInt(0)) ? "+" : "") + JSBI.subtract(e, JSBI.BigInt(1)).toString();
    };

    function bigDecimalToPlainString(significand, exponent, minFraction, minSignificant) {
      var e = maybeJSBI.add(exponent, significand.length) - 1;
      var i = significand.length - 1;

      while (i >= 0 && maybeJSBI.equal(significand.charCodeAt(i), "0".charCodeAt(0))) {
        i -= 1;
      }

      significand = significand.slice(0, i + 1);
      var zeros = Math.max(0, Math.max(e + 1, minSignificant) - significand.length);

      if (e <= -1) {
        significand = maybeJSBI.add("0".repeat(0 - e), significand);
        e = 0;
      }

      significand = maybeJSBI.add(significand, "0".repeat(zeros));
      significand = maybeJSBI.add(significand, "0".repeat(Math.max(minFraction - (significand.length - (e + 1)), 0)));
      return significand.slice(0, e + 1) + (significand.length > e + 1 ? "." + significand.slice(e + 1) : "");
    } // Something like Number#toPrecision: when value is between 10**-6 and Math.pow(10, p)? - to fixed, otherwise - to exponential:


    function toPrecision(significand, exponent, minSignificant) {
      var e = JSBI.add(exponent, JSBI.BigInt(significand.length - 1));

      if (JSBI.lessThan(e, JSBI.unaryMinus(JSBI.BigInt(6))) || JSBI.greaterThanOrEqual(e, JSBI.BigInt(minSignificant))) {
        return bigDecimalToPlainString(significand, -(significand.length - 1), 0, minSignificant) + "e" + (JSBI.lessThan(e, JSBI.BigInt(0)) ? "-" : "+") + bigIntAbs(e).toString();
      }

      return bigDecimalToPlainString(significand, maybeJSBI.toNumber(exponent), 0, minSignificant);
    }

    function toFixed(significand, exponent, minFraction) {
      return bigDecimalToPlainString(significand, exponent, minFraction, 0);
    }

    function toExponential(significand, exponent, minFraction) {
      var e = JSBI.add(exponent, JSBI.BigInt(significand.length - 1));
      return bigDecimalToPlainString(significand, -(significand.length - 1), 0, minFraction + 1) + "e" + (JSBI.lessThan(e, JSBI.BigInt(0)) ? "-" : "+") + bigIntAbs(e).toString();
    }

    BigDecimal.prototype.toFixed = function (fractionDigits, roundingMode) {
      roundingMode = roundingMode == undefined ? "half-up" : roundingMode;
      var value = BigDecimal.multiply(BigDecimal.BigDecimal(JSBI.exponentiate(JSBI.BigInt(10), JSBI.BigInt(fractionDigits))), this);
      var sign = BigDecimal.lessThan(value, BigDecimal.BigDecimal(0)) ? "-" : "";
      var rounded = BigDecimal.round(value, {
        maximumFractionDigits: 0,
        roundingMode: roundingMode
      });
      var a = BigDecimal.abs(rounded);
      return sign + toFixed(BigDecimal.toBigInt(a).toString(), maybeJSBI.unaryMinus(fractionDigits), fractionDigits);
    };

    function getDecimalSignificantAndExponent(value, precision, roundingMode) {
      //TODO: fix performance, test
      var exponentiate = function (x, n, rounding) {
        if (JSBI.lessThan(n, JSBI.BigInt(0))) {
          return BigDecimal.divide(BigDecimal.BigDecimal(1), exponentiate(x, maybeJSBI.unaryMinus(n), rounding), rounding);
        }

        var y = undefined;

        while (JSBI.greaterThanOrEqual(n, JSBI.BigInt(1))) {
          if (JSBI.equal(JSBI.remainder(n, JSBI.BigInt(2)), JSBI.BigInt(0))) {
            x = BigDecimal.multiply(x, x, rounding);
            n = JSBI.divide(n, JSBI.BigInt(2));
          } else {
            y = y == undefined ? x : BigDecimal.multiply(x, y, rounding);
            n = JSBI.subtract(n, JSBI.BigInt(1));
          }
        }

        return y == undefined ? BigDecimal.BigDecimal(1) : y;
      };

      var logarithm = function (x, b, rounding) {
        if (!BigDecimal.greaterThan(x, BigDecimal.BigDecimal(0))) {
          throw new RangeError();
        }

        if (BigDecimal.lessThan(x, BigDecimal.BigDecimal(1))) {
          return maybeJSBI.unaryMinus(logarithm(BigDecimal.divide(BigDecimal.BigDecimal(1), x, rounding), b, rounding));
        }

        var digits = getCountOfDigits(x);
        var v = JSBI.BigInt(bitLength(digits) - Math.floor(Math.log2(Number.MAX_SAFE_INTEGER + 1)));
        var log = JSBI.leftShift(JSBI.BigInt(Math.floor(maybeJSBI.toNumber(maybeJSBI.signedRightShift(digits, v)) / Math.log2(b) * Math.log2(BASE))), v);
        /*var ten = BigDecimal.BigDecimal(10);
        var b = 1n;
        while (!BigDecimal.lessThan(x, exponentiate(ten, b, rounding))) {
          b *= 2n;
        }
        var e = 0n;
        while (b >= 1n) {
          var u = exponentiate(ten, b, rounding);
          if (!BigDecimal.lessThan(x, u)) {
            e += b;
            x = BigDecimal.divide(x, u, rounding);
          }
          b /= 2n;
        }
        return e;*/

        if (JSBI.lessThan(log, JSBI.BigInt(3))) {
          return log;
        }

        return maybeJSBI.add(log, logarithm(BigDecimal.divide(x, exponentiate(BigDecimal.BigDecimal(b), log, rounding), rounding), b, rounding));
      };

      var sign = BigDecimal.lessThan(value, BigDecimal.BigDecimal(0)) ? -1 : +1;

      var roundToInteger = function (a) {
        if (BigDecimal.greaterThan(a, BigDecimal.BigDecimal(0)) && BigDecimal.lessThan(a, BigDecimal.BigDecimal(1)) && BigDecimal.greaterThan(BigDecimal.multiply(BigDecimal.subtract(BigDecimal.BigDecimal(1), a), BigDecimal.BigDecimal(2 * 10)), BigDecimal.BigDecimal(1))) {
          return BigDecimal.BigDecimal(0);
        }

        return BigDecimal.round(sign >= 0 ? a : BigDecimal.unaryMinus(a), {
          maximumFractionDigits: 0,
          roundingMode: roundingMode
        });
      };

      if (BigDecimal.equal(value, BigDecimal.BigDecimal(0))) {
        return {
          significand: "0",
          exponent: JSBI.BigInt(0)
        };
      }

      var ten = BigDecimal.BigDecimal(10);
      var minimumSignificantDigits = Math.pow(2, Math.ceil(Math.log2(bitLength(JSBI.add(bigIntAbs(JSBI.BigInt(value.exponent)), JSBI.BigInt(1))) / Math.log2(BASE))));
      var rounding = {
        maximumSignificantDigits: Math.max(minimumSignificantDigits, 8),
        roundingMode: "half-even"
      };
      var result = undefined;
      var fd = JSBI.BigInt(0);

      do {
        var x = BigDecimal.abs(value);
        fd = JSBI.subtract(JSBI.BigInt(0), logarithm(x, 10, rounding));
        x = BigDecimal.multiply(exponentiate(ten, fd, rounding), x, rounding);

        if (!BigDecimal.lessThan(x, ten)) {
          fd = JSBI.subtract(fd, JSBI.BigInt(1));
          x = BigDecimal.divide(x, ten, rounding);
        }

        if (BigDecimal.lessThan(x, BigDecimal.BigDecimal(1))) {
          fd = JSBI.add(fd, JSBI.BigInt(1));
          x = BigDecimal.multiply(x, ten, rounding);
        }

        if (!BigDecimal.lessThan(x, BigDecimal.BigDecimal(1)) && BigDecimal.lessThan(x, ten)) {
          fd = JSBI.subtract(fd, JSBI.BigInt(1));
          fd = JSBI.add(fd, JSBI.BigInt(precision));
          x = BigDecimal.multiply(exponentiate(ten, fd, rounding), value, rounding);
          x = BigDecimal.abs(x); //x = BigDecimal.multiply(x, exponentiate(ten, BigInt(precision - 1), rounding), rounding);

          var error = BigDecimal.multiply(BigDecimal.multiply(BigDecimal.BigDecimal(JSBI.add(bigIntAbs(fd), JSBI.BigInt(precision))), exponentiate(BigDecimal.BigDecimal(BASE), JSBI.unaryMinus(JSBI.BigInt(rounding.maximumSignificantDigits)))), x); //TODO: ?

          if (rounding.maximumSignificantDigits > (Math.abs(maybeJSBI.toNumber(fd)) + precision) * Math.log2(10) + digits(value.significand) || BigDecimal.equal(roundToInteger(BigDecimal.add(x, error)), roundToInteger(BigDecimal.subtract(x, error)))) {
            result = BigDecimal.toBigInt(BigDecimal.abs(roundToInteger(x))).toString();
          }
        }

        rounding = {
          maximumSignificantDigits: rounding.maximumSignificantDigits * 2,
          roundingMode: "half-even"
        };
      } while (result == undefined);

      return {
        significand: result,
        exponent: maybeJSBI.unaryMinus(fd)
      };
    }

    BigDecimal.prototype.toPrecision = function (precision, roundingMode) {
      roundingMode = roundingMode == undefined ? "half-up" : roundingMode;
      var tmp = getDecimalSignificantAndExponent(this, precision, roundingMode);
      return (BigDecimal.lessThan(this, BigDecimal.BigDecimal(0)) ? "-" : "") + toPrecision(tmp.significand, tmp.exponent, precision);
    };

    BigDecimal.prototype.toExponential = function (fractionDigits, roundingMode) {
      roundingMode = roundingMode == undefined ? "half-up" : roundingMode;
      var tmp = getDecimalSignificantAndExponent(this, fractionDigits + 1, roundingMode);
      return (BigDecimal.lessThan(this, BigDecimal.BigDecimal(0)) ? "-" : "") + toExponential(tmp.significand, tmp.exponent, fractionDigits);
    };

    function exponentiate(a, n) {
      if (maybeJSBI.notEqual(a, BASE)) {
        throw new RangeError("a should be BASE"); //?
      }

      return create(JSBI.BigInt(1), n);
    }

    function getCountOfDigits(a) {
      // floor(log(abs(a))/log(BASE)) + 1
      if (JSBI.equal(a.significand, JSBI.BigInt(0))) {
        throw new RangeError();
      }

      return JSBI.add(JSBI.BigInt(digits(a.significand)), JSBI.BigInt(a.exponent));
    }

    BigDecimal.abs = function (a) {
      return BigDecimal.lessThan(a, BigDecimal.BigDecimal(0)) ? BigDecimal.unaryMinus(a) : a;
    };

    BigDecimal.sign = function (a) {
      var zero = BigDecimal.BigDecimal(0);
      return BigDecimal.lessThan(a, zero) ? -1 : BigDecimal.greaterThan(a, zero) ? +1 : 0;
    };

    BigDecimal.max = function (a, b) {
      if (arguments.length > 2) {
        throw new RangeError("not implemented");
      }

      return BigDecimal.lessThan(a, b) ? b : a;
    };

    BigDecimal.min = function (a, b) {
      if (arguments.length > 2) {
        throw new RangeError("not implemented");
      }

      return BigDecimal.greaterThan(a, b) ? b : a;
    };

    function significandDigits(a) {
      var maximumSignificantDigits = 1;

      while (!BigDecimal.equal(BigDecimal.round(a, {
        maximumSignificantDigits: maximumSignificantDigits,
        roundingMode: "half-even"
      }), a)) {
        maximumSignificantDigits *= 2;
      }

      var from = maximumSignificantDigits / 2;
      var to = maximumSignificantDigits;

      while (to - 1 > from) {
        var middle = from + Math.floor((to - from) / 2);

        if (!BigDecimal.equal(BigDecimal.round(a, {
          maximumSignificantDigits: middle,
          roundingMode: "half-even"
        }), a)) {
          from = middle;
        } else {
          to = middle;
        }
      }

      return to;
    }

    function getExponent(number) {
      var e = Math.floor(Math.log(Math.abs(number)) / Math.log(2)) - 1;
      return Math.abs(number) / Math.pow(2, e) >= 2 ? e + 1 : e;
    }

    function tryToMakeCorrectlyRounded(specialValue, f, name) {
      function getExpectedResultIntegerDigits(x) {
        if (name === "exp") {
          // e**x <= Math.pow(BASE, k)
          // k >= x / log(BASE)
          return Math.ceil(maybeJSBI.toNumber(BigDecimal.toBigInt(BigDecimal.round(x, {
            maximumFractionDigits: 0,
            roundingMode: "half-even"
          }))) / Math.log(BASE));
        }

        if (name === "log") {
          // log(x) <= Math.pow(BASE, k)
          // log(log(x))/log(BASE) <= k
          return Math.ceil(Math.log2(Math.ceil(Math.max(maybeJSBI.toNumber(getCountOfDigits(x)), 1) * Math.log(BASE))) / Math.log2(BASE));
        }

        return 1;
      } // (?) https://en.wikipedia.org/wiki/Rounding#Table-maker's_dilemma


      return function (x, rounding) {
        if (BigDecimal.equal(x, BigDecimal.BigDecimal(specialValue))) {
          return f(x, {
            maximumSignificantDigits: 1,
            roundingMode: "half-even"
          });
        }

        var result = BigDecimal.BigDecimal(0);
        var i = 0;
        var error = BigDecimal.BigDecimal(0);

        do {
          if (i > 4 * ((9 + 1) / BASE) && rounding.maximumSignificantDigits != null && rounding.roundingMode === "half-even" && name !== "sin" && name !== "cos") {
            console.error(x, rounding);
            throw new Error();
          }

          i += 1;
          var internalRounding = {
            maximumSignificantDigits: Math.ceil(Math.max(rounding.maximumSignificantDigits || rounding.maximumFractionDigits + 1 + getExpectedResultIntegerDigits(x) - 1, significandDigits(x)) * Math.cbrt(Math.pow(2, i - 1))) + 2 + (BASE === 2 ? 1 : 0),
            roundingMode: "half-even"
          };
          result = undefined;

          if (Math.max(internalRounding.maximumSignificantDigits + 2, significandDigits(x) + 1) <= Math.log2(Number.MAX_SAFE_INTEGER + 1) && BASE === 2) {
            // Hm... https://www.gnu.org/software/libc/manual/html_node/Errors-in-Math-Functions.html
            var exponent = maybeJSBI.toNumber(x.exponent);
            var v = maybeJSBI.toNumber(x.significand) * Math.pow(BASE, exponent); // some browsers have inaccurate results for Math.sin, Math.cos, Math.tan outside of [-pi/4;pi/4] range

            if (name !== "sin" && name !== "cos" && name !== "tan" || Math.abs(v) <= Math.PI / 4) {
              var numberValue = Math[name](v);
              var MIN_NORMALIZED_VALUE = (Number.MIN_VALUE * 1.25 > Number.MIN_VALUE ? Number.MIN_VALUE : Number.MIN_VALUE * (Number.MAX_SAFE_INTEGER + 1) / 2) || Math.pow(2, -1022);
              var a = Math.abs(numberValue);

              if (a < 1 / 0 && a > MIN_NORMALIZED_VALUE) {
                var e = getExponent(a);
                var s = numberValue / Math.pow(2, e);
                var e1 = getExponent(Number.MAX_SAFE_INTEGER + 1) - 1;
                result = create(JSBI.BigInt(s * Math.pow(2, e1)), e - e1); //TODO: ?
              }
            }
          }

          if (result == undefined) {
            result = f(x, internalRounding);
          } // round(result - error) === round(result + error)


          error = BigDecimal.multiply(exponentiate(BASE, JSBI.unaryMinus(JSBI.BigInt(internalRounding.maximumSignificantDigits))), BigDecimal.abs(result)); //if (i > 0) {
          //console.log(i, f.name, x + "", result + "", error + "", BigDecimal.round(BigDecimal.subtract(result, error), rounding) + "", BigDecimal.round(BigDecimal.add(result, error), rounding) + "");
          //}
        } while (!BigDecimal.equal(BigDecimal.round(BigDecimal.subtract(result, error), rounding), BigDecimal.round(BigDecimal.add(result, error), rounding)));

        if (i > 1) {//console.debug(i, name);
        }

        return BigDecimal.round(result, rounding);
      };
    }

    function sqrt(x, rounding) {
      // from https://en.wikipedia.org/wiki/Square_root#Computation
      var lastResult = BigDecimal.add(x, BigDecimal.BigDecimal(1));
      var result = x;

      while (BigDecimal.lessThan(result, lastResult)) {
        lastResult = result;
        result = BigDecimal.divide(BigDecimal.add(BigDecimal.divide(x, result, rounding), result), BigDecimal.BigDecimal(2), rounding);
      }

      return result;
    }

    BigDecimal.log = tryToMakeCorrectlyRounded(1, function log(x, rounding) {
      if (!BigDecimal.greaterThan(x, BigDecimal.BigDecimal(0))) {
        throw new RangeError();
      } // https://ru.wikipedia.org/wiki/Логарифм#Разложение_в_ряд_и_вычисление_натурального_логарифма


      var internalRounding = {
        maximumSignificantDigits: rounding.maximumSignificantDigits + Math.ceil(Math.log2(rounding.maximumSignificantDigits + 0.5) / Math.log2(BASE)),
        roundingMode: "half-even"
      };

      if (true) {
        //! ln(f * Math.pow(BASE, k)) = ln(f) + k * ln(BASE), where (1/BASE) <= f <= BASE
        var k = JSBI.subtract(getCountOfDigits(x), JSBI.BigInt(1));
        var f = BigDecimal.multiply(exponentiate(BASE, maybeJSBI.unaryMinus(k)), x);
        var ff = BigDecimal.round(BigDecimal.multiply(f, f), {
          maximumSignificantDigits: 3,
          roundingMode: "half-even"
        });

        if (BigDecimal.greaterThan(ff, exponentiate(BASE, JSBI.BigInt(1)))) {
          k = JSBI.add(k, JSBI.BigInt(1));
          f = BigDecimal.multiply(exponentiate(BASE, JSBI.unaryMinus(JSBI.BigInt(1))), f);
        }

        if (BigDecimal.lessThan(ff, exponentiate(BASE, JSBI.unaryMinus(JSBI.BigInt(1))))) {
          k = JSBI.subtract(k, JSBI.BigInt(1));
          f = BigDecimal.multiply(exponentiate(BASE, JSBI.BigInt(1)), f);
        }

        if (JSBI.notEqual(k, JSBI.BigInt(0))) {
          return BigDecimal.add(BigDecimal.log(f, internalRounding), BigDecimal.multiply(BigDecimal.BigDecimal(JSBI.multiply(JSBI.BigInt(2), k)), BigDecimal.log(sqrt(BigDecimal.BigDecimal(BASE), internalRounding), internalRounding)));
        }
      } //! log(x) = log((1 + g) / (1 - g)) = 2*(g + g**3/3 + g**5/5 + ...)


      var g = BigDecimal.divide(BigDecimal.subtract(x, BigDecimal.BigDecimal(1)), BigDecimal.add(x, BigDecimal.BigDecimal(1)), internalRounding);
      var n = 1;
      var term = BigDecimal.BigDecimal(1);
      var sum = term;
      var lastSum = BigDecimal.BigDecimal(0);
      var gg = BigDecimal.multiply(g, g, internalRounding);

      while (!BigDecimal.equal(lastSum, sum)) {
        n += 2;
        term = BigDecimal.multiply(term, BigDecimal.BigDecimal(n - 2));
        term = BigDecimal.multiply(term, gg);
        term = BigDecimal.divide(term, BigDecimal.BigDecimal(n), internalRounding);
        lastSum = sum;
        sum = BigDecimal.add(sum, term, internalRounding);
      }

      return BigDecimal.multiply(BigDecimal.multiply(BigDecimal.BigDecimal(2), g), sum);
    }, "log");
    BigDecimal.exp = tryToMakeCorrectlyRounded(0, function exp(x, rounding) {
      //! k = round(x / ln(BASE));
      //! exp(x) = exp(x - k * ln(BASE) + k * ln(BASE)) = exp(x - k * ln(BASE)) * BASE**k
      var internalRounding = {
        maximumSignificantDigits: rounding.maximumSignificantDigits + Math.ceil(Math.log2(rounding.maximumSignificantDigits + 0.5) / Math.log2(BASE)),
        roundingMode: "half-even"
      };

      if (!BigDecimal.equal(x, BigDecimal.BigDecimal(0))) {
        var logBASEApproximate = BigDecimal.divide(BigDecimal.BigDecimal(Math.log(BASE) * (Number.MAX_SAFE_INTEGER + 1)), BigDecimal.add(BigDecimal.BigDecimal(Number.MAX_SAFE_INTEGER), BigDecimal.BigDecimal(1)), internalRounding);
        var kApproximate = BigDecimal.round(BigDecimal.divide(x, logBASEApproximate, {
          maximumSignificantDigits: Math.max(maybeJSBI.toNumber(getCountOfDigits(x)), 1),
          roundingMode: "half-even"
        }), {
          maximumFractionDigits: 0,
          roundingMode: "half-even"
        });

        if (!BigDecimal.equal(kApproximate, BigDecimal.BigDecimal(0))) {
          var logBASE = BigDecimal.log(BigDecimal.BigDecimal(BASE), {
            maximumSignificantDigits: internalRounding.maximumSignificantDigits + maybeJSBI.toNumber(getCountOfDigits(kApproximate)),
            roundingMode: "half-even"
          });
          var k = BigDecimal.round(BigDecimal.divide(x, logBASE, {
            maximumSignificantDigits: Math.max(maybeJSBI.toNumber(getCountOfDigits(x)), 1),
            roundingMode: "half-even"
          }), {
            maximumFractionDigits: 0,
            roundingMode: "half-even"
          });

          if (!BigDecimal.equal(k, BigDecimal.BigDecimal(0))) {
            var r = BigDecimal.subtract(x, BigDecimal.multiply(k, logBASE));
            return BigDecimal.multiply(exponentiate(BASE, BigDecimal.toBigInt(k)), BigDecimal.exp(r, internalRounding));
          }
        }
      } // https://en.wikipedia.org/wiki/Exponential_function#Computation


      var n = 0;
      var term = BigDecimal.BigDecimal(1);
      var sum = term;
      var lastSum = BigDecimal.BigDecimal(0);

      while (!BigDecimal.equal(lastSum, sum)) {
        n += 1;
        term = BigDecimal.multiply(term, x);
        term = BigDecimal.divide(term, BigDecimal.BigDecimal(n), internalRounding);
        lastSum = sum;
        sum = BigDecimal.add(sum, term, internalRounding);
      }

      return sum;
    }, "exp");

    function divideByHalfOfPI(x, rounding) {
      // x = k*pi/2 + r + 2*pi*n, where |r| < pi/4
      if (BigDecimal.lessThan(x, BigDecimal.BigDecimal(0))) {
        throw new RangeError();
      }

      if (BigDecimal.greaterThan(x, BigDecimal.divide(BigDecimal.BigDecimal(Math.floor(Math.PI / 4 * (Number.MAX_SAFE_INTEGER + 1) + 0.5)), BigDecimal.add(BigDecimal.BigDecimal(Number.MAX_SAFE_INTEGER), BigDecimal.BigDecimal(1)), rounding))) {
        //TODO: FIX
        var halfOfPi = BigDecimal.multiply(BigDecimal.BigDecimal(2), BigDecimal.atan(BigDecimal.BigDecimal(1), {
          maximumSignificantDigits: rounding.maximumSignificantDigits + significandDigits(x) + maybeJSBI.toNumber(getCountOfDigits(x)) + 1 + Math.ceil(42 / Math.log2(BASE)),
          roundingMode: "half-even"
        }));
        var i = BigDecimal.round(BigDecimal.divide(x, halfOfPi, {
          maximumSignificantDigits: Math.max(maybeJSBI.toNumber(getCountOfDigits(x)), 1),
          roundingMode: "half-even"
        }), {
          maximumFractionDigits: 0,
          roundingMode: "half-even"
        });
        var remainder = BigDecimal.subtract(x, BigDecimal.multiply(i, halfOfPi));
        return {
          remainder: remainder,
          k: (JSBI.toNumber(JSBI.remainder(BigDecimal.toBigInt(i), JSBI.BigInt(4))) + 4) % 4
        };
      }

      return {
        remainder: x,
        k: 0
      };
    }

    BigDecimal.sin = tryToMakeCorrectlyRounded(0, function (x, rounding) {
      if (BigDecimal.lessThan(x, BigDecimal.BigDecimal(0))) {
        return BigDecimal.unaryMinus(BigDecimal.sin(BigDecimal.unaryMinus(x), rounding));
      }

      var tmp = divideByHalfOfPI(x, rounding);
      var a = tmp.remainder;
      var k = tmp.k;

      if (k === 1) {
        return BigDecimal.cos(a, rounding);
      }

      if (k === 2) {
        return BigDecimal.unaryMinus(BigDecimal.sin(a, rounding));
      }

      if (k === 3) {
        return BigDecimal.unaryMinus(BigDecimal.cos(a, rounding));
      } // https://en.wikipedia.org/wiki/Lookup_table#Computing_sines


      var internalRounding = {
        maximumSignificantDigits: rounding.maximumSignificantDigits + Math.ceil(Math.log2(rounding.maximumSignificantDigits + 0.5) / Math.log2(BASE)),
        roundingMode: "half-even"
      };
      var n = 1;
      var term = BigDecimal.BigDecimal(1);
      var sum = term;
      var lastSum = BigDecimal.BigDecimal(0);
      var aa = BigDecimal.multiply(a, a);

      while (!BigDecimal.equal(lastSum, sum)) {
        n += 2;
        term = BigDecimal.multiply(term, aa);
        term = BigDecimal.divide(term, BigDecimal.BigDecimal(-n * (n - 1)), internalRounding);
        lastSum = sum;
        sum = BigDecimal.add(sum, term, internalRounding);
      }

      return BigDecimal.multiply(a, sum);
    }, "sin");
    BigDecimal.cos = tryToMakeCorrectlyRounded(0, function (x, rounding) {
      if (BigDecimal.lessThan(x, BigDecimal.BigDecimal(0))) {
        return BigDecimal.cos(BigDecimal.unaryMinus(x), rounding);
      }

      var tmp = divideByHalfOfPI(x, rounding);
      var a = tmp.remainder;
      var k = tmp.k;

      if (k === 1) {
        return BigDecimal.unaryMinus(BigDecimal.sin(a, rounding));
      }

      if (k === 2) {
        return BigDecimal.unaryMinus(BigDecimal.cos(a, rounding));
      }

      if (k === 3) {
        return BigDecimal.sin(a, rounding);
      } // https://en.wikipedia.org/wiki/Trigonometric_functions#Power_series_expansion


      var internalRounding = {
        maximumSignificantDigits: rounding.maximumSignificantDigits + Math.ceil(Math.log2(rounding.maximumSignificantDigits + 0.5) / Math.log2(BASE)),
        roundingMode: "half-even"
      };
      var n = 0;
      var term = BigDecimal.BigDecimal(1);
      var sum = term;
      var lastSum = BigDecimal.BigDecimal(0);
      var aa = BigDecimal.multiply(a, a);

      while (!BigDecimal.equal(lastSum, sum)) {
        n += 2;
        term = BigDecimal.multiply(term, aa);
        term = BigDecimal.divide(term, BigDecimal.BigDecimal(-n * (n - 1)), internalRounding);
        lastSum = sum;
        sum = BigDecimal.add(sum, term, internalRounding);
      }

      return sum;
    }, "cos");
    BigDecimal.atan = tryToMakeCorrectlyRounded(0, function (x, rounding) {
      if (BigDecimal.greaterThan(BigDecimal.abs(x), BigDecimal.BigDecimal(1))) {
        //Note: rounding to maximumFractionDigits
        var internalRounding = {
          maximumFractionDigits: rounding.maximumSignificantDigits + 1,
          roundingMode: "half-even"
        };
        var halfOfPi = BigDecimal.multiply(BigDecimal.atan(BigDecimal.BigDecimal(1), internalRounding), BigDecimal.BigDecimal(2));
        return BigDecimal.multiply(BigDecimal.BigDecimal(BigDecimal.lessThan(x, BigDecimal.BigDecimal(0)) ? -1 : +1), BigDecimal.subtract(halfOfPi, BigDecimal.atan(BigDecimal.divide(BigDecimal.BigDecimal(1), BigDecimal.abs(x), internalRounding), internalRounding)));
      } // https://en.wikipedia.org/wiki/Inverse_trigonometric_functions#:~:text=Alternatively,%20this%20can%20be%20expressed%20as


      var internalRounding = {
        maximumSignificantDigits: rounding.maximumSignificantDigits + Math.ceil(Math.log2(rounding.maximumSignificantDigits + 0.5) / Math.log2(BASE)),
        roundingMode: "half-even"
      };
      var n = 0;
      var xx = BigDecimal.multiply(x, x);
      var xxplus1 = BigDecimal.add(BigDecimal.BigDecimal(1), xx);
      var term = BigDecimal.divide(BigDecimal.BigDecimal(1), xxplus1, internalRounding);
      var sum = term;
      var lastSum = BigDecimal.BigDecimal(0);

      while (!BigDecimal.equal(lastSum, sum)) {
        n += 1;
        term = BigDecimal.multiply(term, BigDecimal.multiply(BigDecimal.BigDecimal(2 * n), xx));
        term = BigDecimal.divide(term, BigDecimal.multiply(BigDecimal.BigDecimal(2 * n + 1), xxplus1), internalRounding);
        lastSum = sum;
        sum = BigDecimal.add(sum, term, internalRounding);
      }

      return BigDecimal.multiply(x, sum);
    }, "atan");

    function nthRoot(x, n, rounding) {
      var exponentiateX = function (x, n) {
        return n === 1 ? x : n % 2 === 0 ? exponentiateX(BigDecimal.multiply(x, x), n / 2) : BigDecimal.multiply(x, exponentiate(x, n - 1));
      };

      if (BigDecimal.lessThan(x, BigDecimal.BigDecimal(0))) {
        if (n % 2 === 0) {
          throw new RangeError();
        }
      }

      if (BigDecimal.equal(x, BigDecimal.BigDecimal(0))) {
        return x;
      } // https://en.wikipedia.org/wiki/Nth_root#Using_Newton's_method


      var e = JSBI.divide(getCountOfDigits(x), JSBI.BigInt(n));
      var t = exponentiate(BASE, e);
      var y = BigDecimal.multiply(x, exponentiate(BASE, JSBI.unaryMinus(JSBI.multiply(JSBI.BigInt(n), e))));
      var k = Math.floor(Math.log2(Number.MAX_SAFE_INTEGER + 1) / Math.log2(BASE)) - 1;
      var xn = BigDecimal.toNumber(BigDecimal.round(BigDecimal.multiply(y, exponentiate(BASE, k)), {
        maximumFractionDigits: 0,
        roundingMode: 'half-even'
      })) / Math.pow(BASE, k);
      var r = n === 2 ? Math.sqrt(xn) : n === 3 ? Math.cbrt(xn) : Math.exp(Math.log(xn) / n);
      var resultSignificantDigits = 8 * (rounding.maximumSignificantDigits || rounding.maximumFractionDigits + Math.ceil(significandDigits(x) / n) || 1);
      var result = BigDecimal.multiply(BigDecimal.BigDecimal(Math.sign(r) * Math.floor(Math.abs(r) * Math.pow(BASE, k) + 0.5)), exponentiate(BASE, -k));

      var iteration = function (result, rounding) {
        var resultInNm1 = exponentiateX(result, n - 1);
        return BigDecimal.divide(BigDecimal.add(y, BigDecimal.multiply(BigDecimal.BigDecimal(n - 1), BigDecimal.multiply(result, resultInNm1))), BigDecimal.multiply(BigDecimal.BigDecimal(n), resultInNm1), rounding);
      };

      for (var i = Math.max(k - (n - 1), 1); i < resultSignificantDigits; i *= 2) {
        var internalRounding = {
          maximumSignificantDigits: i,
          roundingMode: "half-even"
        };
        result = iteration(result, internalRounding);
      }

      result = iteration(result, rounding);
      return BigDecimal.multiply(result, t);
    }

    BigDecimal.sqrt = function (x, rounding) {
      return nthRoot(x, 2, rounding);
    };

    BigDecimal.cbrt = function (x, rounding) {
      return nthRoot(x, 3, rounding);
    };

    return BigDecimal;
  };

  var BigDecimal = factory(10);
  var BigFloat = factory(2);
  self.BigDecimal = BigDecimal;
  self.BigFloat = BigFloat;
})();
var maybeJSBI = {
  toNumber: function toNumber(a) {
    return typeof a === "object" ? JSBI.toNumber(a) : Number(a);
  },
  add: function add(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.add(a, b) : a + b;
  },
  subtract: function subtract(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.subtract(a, b) : a - b;
  },
  multiply: function multiply(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.multiply(a, b) : a * b;
  },
  divide: function divide(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.divide(a, b) : a / b;
  },
  remainder: function remainder(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.remainder(a, b) : a % b;
  },
  exponentiate: function exponentiate(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.exponentiate(a, b) : typeof a === "bigint" && typeof b === "bigint" ? new Function("a**b", "a", "b")(a, b) : Math.pow(a, b);
  },
  leftShift: function leftShift(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.leftShift(a, b) : a << b;
  },
  signedRightShift: function signedRightShift(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.signedRightShift(a, b) : a >> b;
  },
  bitwiseAnd: function bitwiseAnd(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.bitwiseAnd(a, b) : a & b;
  },
  bitwiseOr: function bitwiseOr(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.bitwiseOr(a, b) : a | b;
  },
  bitwiseXor: function bitwiseXor(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.bitwiseXor(a, b) : a ^ b;
  },
  lessThan: function lessThan(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.lessThan(a, b) : a < b;
  },
  greaterThan: function greaterThan(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.greaterThan(a, b) : a > b;
  },
  lessThanOrEqual: function lessOrEqualThan(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.lessThanOrEqual(a, b) : a <= b;
  },
  greaterThanOrEqual: function greaterOrEqualThan(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.greaterThanOrEqual(a, b) : a >= b;
  },
  equal: function equal(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.equal(a, b) : a === b;
  },
  notEqual: function notEqual(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.notEqual(a, b) : a !== b;
  },
  unaryMinus: function unaryMinus(a) {
    return typeof a === "object" ? JSBI.unaryMinus(a) : -a;
  },
  bitwiseNot: function bitwiseNot(a) {
    return typeof a === "object" ? JSBI.bitwiseNot(a) : ~a;
  }
};


(function () {
  "use strict"; // Example:
  // var N = NewtonInterpolation();
  // N.next();
  // console.log(N.next([1,1]).value); // y = 1
  // console.log(N.next([2,4]).value); // y = 3x - 2
  // console.log(N.next([3,9]).value); // y = x^2

  var DefaultYField = {
    ONE: 1,
    sub: function (a, b) {
      return maybeJSBI.subtract(a, b);
    },
    mul: function (a, b) {
      return maybeJSBI.multiply(a, b);
    },
    scale: function (a, s) {
      return a * maybeJSBI.toNumber(s);
    },
    unscale: function (a, s) {
      return a / maybeJSBI.toNumber(s);
    }
  };
  var yField = DefaultYField; // An iterator which returns an updated Newton interpolation polynomial
  // Polynomial is returned as an array of coefficients

  function NewtonInterpolation() {
    var coefficients = function () {
      var x = [];
      var diagonal = []; // [y_k], [y_(k-1), y_k], ..., [y_0, y_1, ..., y_k]

      var equidistantly = true;
      var hInKTimeskFactorial = JSBI.BigInt(1); // h**k * k!

      var c = yField.ONE;
      var firstTime = true;
      var iterator = {
        next: function (point) {
          while (true) {
            if (firstTime) {
              firstTime = false;
              return {
                value: c,
                done: false
              };
            }

            var $tmpxi_yi = point;
            var xi = $tmpxi_yi[0];
            var yi = $tmpxi_yi[1];

            if (equidistantly && x.length >= 2 && maybeJSBI.notEqual(maybeJSBI.subtract(x[x.length - 1], x[x.length - 2]), maybeJSBI.subtract(xi, x[x.length - 1]))) {
              // https://en.wikipedia.org/wiki/Divided_differences#:~:text=The%20relationship%20between%20divided%20differences%20and%20forward%20differences%20is[4]
              var h = maybeJSBI.subtract(x[x.length - 1], x[x.length - 2]);
              hInKTimeskFactorial = JSBI.BigInt(1);

              for (var k = 1; k < diagonal.length; k += 1) {
                diagonal[k] = yField.unscale(diagonal[k], hInKTimeskFactorial);
                hInKTimeskFactorial = JSBI.multiply(hInKTimeskFactorial, JSBI.multiply(JSBI.BigInt(h), JSBI.BigInt(k)));
              }

              equidistantly = false;
            }

            var value = yi;

            for (var i = 0; i < diagonal.length; i += 1) {
              // https://en.wikipedia.org/wiki/Divided_differences#Example
              var difference = yField.sub(value, diagonal[i]);

              if (!equidistantly) {
                difference = yField.unscale(difference, maybeJSBI.subtract(xi, x[x.length - 1 - i]));
              }

              diagonal[i] = value;
              value = difference;
            }

            diagonal.push(value);
            x.push(xi);
            c = diagonal[diagonal.length - 1];

            if (equidistantly && x.length >= 2) {
              var k = diagonal.length - 1;
              var h = maybeJSBI.subtract(x[x.length - 1], x[x.length - 2]);
              hInKTimeskFactorial = JSBI.multiply(hInKTimeskFactorial, JSBI.multiply(JSBI.BigInt(h), JSBI.BigInt(k)));
              c = yField.unscale(c, hInKTimeskFactorial);
            }

            return {
              value: c,
              done: false
            };
          }
        }
      };

      iterator[globalThis.Symbol.iterator] = function () {
        return this;
      };

      return iterator;
    };

    var yZERO = yField.sub(yField.ONE, yField.ONE);
    var yONE = yField.ONE;
    var a = coefficients();
    a.next(); // https://en.wikipedia.org/wiki/Newton_polynomial#Definition

    var basisPolynomial = [yONE]; // n_j(x)

    var N = [];
    var firstTime = true;
    var iterator = {
      next: function (point) {
        while (true) {
          if (firstTime) {
            firstTime = false;
            return {
              value: N,
              done: false
            };
          }

          var $tmpxi_yi = point;
          var xi = $tmpxi_yi[0];
          var yi = $tmpxi_yi[1];
          var c = yField.sub(yZERO, a.next([xi, yi]).value); // N = N + c * basisPolynomial

          N.push(yZERO);

          for (var i = basisPolynomial.length - 1; i >= 0; i -= 1) {
            N[i] = yField.sub(N[i], yField.mul(basisPolynomial[i], c));
          } //console.log(N.join(" "));
          // basisPolynomial = basisPolynomial * (x - xi)


          basisPolynomial.push(yZERO);

          for (var i = basisPolynomial.length - 1; i >= 0; i -= 1) {
            basisPolynomial[i] = yField.sub(i >= 1 ? basisPolynomial[i - 1] : yZERO, yField.scale(basisPolynomial[i], xi));
          }

          return {
            value: N,
            done: false
          };
        }
      }
    };

    iterator[globalThis.Symbol.iterator] = function () {
      return this;
    };

    return iterator;
  }

  NewtonInterpolation.setField = function (newYField) {
    yField = newYField || DefaultYField;
  };

  self.NewtonInterpolation = NewtonInterpolation;
})();
(function () {
"use strict";
/*jslint plusplus: true, vars: true, indent: 2 */

// Thanks to Eduardo Cavazos
// see also https://github.com/dharmatech/Symbolism/blob/master/Symbolism/Symbolism.cs
// see also "Computer Algebra and Symbolic Computation: Elementary Algorithms" by Joel S. Cohen

// public API:
// Expression.prototype.add
// Expression.prototype.subtract
// Expression.prototype.multiply
// ...
// protected API:
// Expression.prototype.addExpression
// Expression.prototype.addInteger

  //
  
  
  
  
  

  
  
  

  Math.gcd = function (a, b) {
    while (b != 0) {
      var t = a % b;
      a = b;
      b = t;
    }
    return a;
  };

  var pow = function (x, count, accumulator) {
    if (!(count >= 0)) {
      throw new RangeError();
    }
    if (count > Number.MAX_SAFE_INTEGER) {
      throw new RangeError("NotSupportedError");
    }
    return (count < 1 ? accumulator : (2 * Math.floor(count / 2) !== count ? pow(x, count - 1, accumulator.multiply(x)) : pow(x.multiply(x), Math.floor(count / 2), accumulator)));
  };

  // https://stackoverflow.com/a/15302448/839199
  var binomialCoefficient = function (n, k) { // binomail coefficient
    return k === 0 ? Expression.ONE : n.multiply(binomialCoefficient(n.subtract(Expression.ONE), k - 1)).divide(Integer.fromNumber(k));
  };

/*
  var powerOfJordanForm = function (J, N) {
    return J.map(function (e, i, j) {
      if (i > j) {
        return Expression.ZERO;
      }
      if (i === j) {
        return J.e(i, i).equals(Expression.ZERO) ? Expression.ZERO : J.e(i, i).pow(N);
      }
      if (J.e(i, i + 1).equals(Expression.ZERO)) {
        return Expression.ZERO;
      }
      var m = j - i;
      for (var k = 0; k < m; k += 1) {
        if (!J.e(j - 1 - k, j - k).equals(Expression.ONE)) { // outside of a block
          return Expression.ZERO;
        }
      }
      return J.e(i, i).equals(Expression.ZERO) ? Expression.ZERO : binomialCoefficient(N, m).multiply(J.e(i, i).pow(N.subtract(Expression.Integer.fromNumber(m))));
    });
  };
*/

  var matrixInN = function (matrix, n) {
    var condition = -1;
    /*
    if (matrix.isDiagonal()) {
      for (var i = 0; i < matrix.cols(); i += 1) {
        if (matrix.e(i, i).equals(Expression.ZERO)) {
          condition = 0;//?
        }
      }
      var result = matrix.map(function (e, i, j) {
        return i === j ? (e.equals(Expression.ZERO) ? Expression.ZERO : e.pow(n)) : Expression.ZERO;
      });
      var an = new Expression.Matrix(result);
      return condition !== -1 ? new ExpressionWithCondition(an, Condition.TRUE.andGreaterZero(n.subtract(Expression.Integer.fromNumber(condition)))) : an;
    }
    */
    /*
    if (matrix.isJordanMatrix()) {
      for (var i = 0; i < matrix.cols(); i += 1) {
        if (matrix.e(i, i).equals(Expression.ZERO)) {
          condition = Math.max(condition, 0);
          // should be Jordan block size minus one (?)
          for (var j = 0; i + j + 1 < matrix.cols(); j += 1) {
            if (matrix.e(i + j, i + j + 1).equals(Expression.ONE)) {
              condition = Math.max(condition, j + 1);
            }
          }
        }
      }
      var an = new Expression.Matrix(powerOfJordanForm(matrix, n));
      if (condition > 0) {//TODO: remove(merge)
        var cases = [];
        cases.push(new ExpressionWithCondition(an, Condition.TRUE.andGreaterZero(n.subtract(Integer.fromNumber(condition)))));
        for (var i = 1; i <= condition; i += 1) {
          cases.push(new ExpressionWithCondition(new Expression.Matrix(matrix.pow(i)), Condition.TRUE.andZero(n.subtract(Integer.fromNumber(i)))));
        }
        return new Expression.Cases(cases);
      }
      return condition !== -1 ? new ExpressionWithCondition(an, Condition.TRUE.andGreaterZero(n.subtract(Integer.fromNumber(condition)))) : an;
    }
    */
    //!
    var D = matrix.map(function (e, i, j) {
      return i === j ? e : Expression.ZERO;
    });
    var N = matrix.subtract(D);
    if (N.isNilpotent()) {//TODO: fix Matrix#isNilpotent
      if (D.multiply(N).eql(N.multiply(D))) {// D and N commute
        //Note: covers diagonal matrices and Jordan matrices
        for (var k = 0; k < D.cols(); k += 1) {
          if (D.e(k, k).equals(Expression.ZERO)) {
            var index = 1;
            while (!N.pow(index).map(function (e, i, j) { return i !== k ? Expression.ZERO : e; }).isZero()) {
              if (index >= N.cols()) {
                throw new TypeError("assertion");
              }
              index += 1;
            }
            condition = Math.max(condition, index - 1);//?
          }
        }
        var result = Matrix.Zero(N.cols(), N.cols());
        for (var k = 0; k < N.cols(); k += 1) {
          var Dnmk = D.map(function (e, i, j) {
            return i === j ? (e.equals(Expression.ZERO) ? Expression.ZERO : e.pow(n.subtract(Expression.Integer.fromNumber(k)))) : Expression.ZERO;
          });
          result = result.add(Dnmk.multiply(N.pow(k)).scale(binomialCoefficient(n, k)));
        }
        var an = new Expression.Matrix(result);
        if (condition > 0) {//TODO: remove(merge)
          var cases = [];
          cases.push(new ExpressionWithCondition(an, Condition.TRUE.andGreaterZero(n.subtract(Integer.fromNumber(condition)))));
          for (var i = 1; i <= condition; i += 1) {
            cases.push(new ExpressionWithCondition(new Expression.Matrix(matrix.pow(i)), Condition.TRUE.andZero(n.subtract(Integer.fromNumber(i)))));
          }
          return new Expression.Cases(cases);
        }
        return condition !== -1 ? new ExpressionWithCondition(an, Condition.TRUE.andGreaterZero(n.subtract(Integer.fromNumber(condition)))) : an;
      }
    }
    //!
    var canExponentiate = function (k) {
      if (enableAN && k instanceof Expression.Symbol) {
        return true;
      }
      if (k instanceof Exponentiation && getBase(k) instanceof Integer && getBase(k).compareTo(Expression.ONE) > 0 && isIntegerOrN(getExponent(k).inverse())) {//TODO: remove (no need if to change other codes) of fix `isConstant`?
        return true;
      }
      return isConstant(k) || isConstant(k.divide(Expression.E));
    };
    //Note: experimental
    // {{1,0,0},{0,1,1},{0,0,1}}^n === {{1,0,0},{0,1,n},{0,0,1}}
    // A
    var a = matrix;
    // A^(n-1)
    var symbolName = "aa";
    var anm1 = matrix.map(function (e, i, j) {
      return new Expression.Symbol(symbolName + "_(" + i + "," + j + ")");
    });
    var anm1previous = anm1.map(function (e, i, j) {
      return Expression.ZERO;
    });
    var an = undefined;
    var iteration = -1;
    while (!anm1.eql(anm1previous)) {
      iteration += 1;
      anm1previous = anm1;
      // A^(n) = A^(n-1) * A;
      an = anm1.multiply(a);
      anm1 = an.map(function (e, i, j) {
        var isSymbol = anm1.e(i, j) instanceof Expression.Symbol && anm1.e(i, j).symbol.slice(0, symbolName.length) === symbolName;
        if (!isSymbol) {
          return anm1.e(i, j);//?
        }
        // an: {{1,0,0},{0,1,1+aa_23},{0,0,1}}
        // a_n = n + a_(n-1)
        // a_n = k * a_(n-1) + c * k**(n-(m+1)) * choose(n-1, m)
        // =>
        // a_n = c * k**(n-(m+1)) * choose(n, m+1)
        // Note: choose(n-1, m) + choose(n-2, m) + choose(n-3, m) + ... = choose(n, m+1)
        // choose(n-1, m+1) + choose(n-1, m) = choose(n, m+1)
        if (!(e instanceof Integer)) {
          var m = Polynomial.toPolynomial(e.getNumerator(), n).getDegree();
          var previous = anm1.e(i, j);
          var p = Polynomial.toPolynomial(e.getNumerator(), previous);
          var k = p.getLeadingCoefficient().divide(e.getDenominator());
          if (m !== 0 &&
              p.getDegree() === 1 &&
              a.e(i, j).equals(Expression.ZERO) && //TODO: remove
              (k instanceof Integer || k instanceof Expression.Complex || canExponentiate(k))) { //TODO: fix
            var f = k.pow(n).divide(k.pow(Integer.fromNumber(m + 1))).multiply(binomialCoefficient(n.subtract(Expression.ONE), m));
            var c = e.subtract(k.multiply(previous)).divide(f);
            //TODO: remove `k instanceof Integer`
            if (c instanceof Integer) {//?TODO: ?
              console.log("!", e.toString());
              // a.e(i, j).add()
              return c.multiply(k.pow(n).divide(k.pow(Integer.fromNumber(m + 2))).multiply(binomialCoefficient(n.subtract(Expression.ONE), m + 1)));
            }
          }
        }
        // a_n = a_(n-1)
        if (e.equals(anm1.e(i, j))) {
          return a.e(i, j);
        }
        // a_n = k * a_(n-1) + function (b) { return a_n = k**(n - 1) * a_1 + b * (1-k**(n-2))/(1-k); }
        if (anm1.e(i, j) instanceof Expression.Symbol && anm1.e(i, j).symbol === symbolName + "_(" + i + "," + j + ")" && !e.equals(Expression.ZERO)) {
          var previous = anm1.e(i, j);
          var p = Polynomial.toPolynomial(e.getNumerator(), previous);
          var k = p.getLeadingCoefficient().divide(e.getDenominator());
          var b = p.getCoefficient(0).divide(e.getDenominator());
          if (!Expression.has(b, Expression.Symbol) && //TODO: !!!
              e.equals(k.multiply(previous).add(b))) {
            var s = k.equals(Expression.ONE) ? b.multiply(n.subtract(Expression.TWO)) : b.multiply(Expression.ONE.subtract(k.pow(n.subtract(Expression.TWO))).divide(Expression.ONE.subtract(k)));
            return k.pow(n.subtract(Expression.TWO)).multiply(a.e(i, j)).add(s);
          }
        }
        if (anm1.e(i, j) instanceof Expression.Symbol && anm1.e(i, j).symbol === symbolName + "_(" + i + "," + j + ")" && e.equals(Expression.ZERO)) {
          //!TODO: conditions.push(iteration); //? n > 0 && n <= 3 , n > 3 - ?
          condition = iteration;
          return Expression.ZERO;
        }
        // a_n = a_(n-1) + function (b) { return a_n = a_1 + b*(n-1); }
        var sub = e.subtract(anm1.e(i, j));
        if (sub instanceof Integer) {
          return a.e(i, j).add(sub.multiply(n.subtract(Expression.TWO)));
        }
        var dpnm1pda = function (k) { // k**(n-1) + k * a_(n-1)
          if (!canExponentiate(k)) {//TODO: remove
            return Expression.ZERO;// cannot do k.pow(n)
          }
          var previous = anm1.e(i, j);
          return k.pow(n.subtract(Expression.ONE)).add(k.multiply(previous));
        };
        // a_n = d**(n-1) + d * a_(n-1)
        // a_n = d**(n-1) + d * a_(n-1) = 2 * d**(n-1) + d**2 * a_(n-2) = ... = n * d**(n-1) + d**n
        if (!e.equals(Expression.ZERO)) {
          var previous = anm1.e(i, j);
          var p = Polynomial.toPolynomial(e.getNumerator(), previous);
          var k = p.getLeadingCoefficient().divide(e.getDenominator());
          var d = k;
          if (e.equals(dpnm1pda(d))) {
            return d.pow(n.subtract(Expression.TWO)).multiply(n.subtract(Expression.TWO).add(a.e(i, j)));
          }
          var d = k.negate();
          if (e.equals(dpnm1pda(d))) {
            return d.pow(n.subtract(Expression.TWO)).multiply(n.subtract(Expression.TWO).add(a.e(i, j)));
          }
        }

        return anm1.e(i, j);
      });
    }
    for (var i = 0; i < anm1.rows(); i += 1) {
      for (var j = 0; j < anm1.cols(); j += 1) {
        var e = anm1.e(i, j);
        if (e instanceof Expression.Symbol && e.symbol.slice(0, symbolName.length) === symbolName) {
          return undefined;
        }
      }
    }
    if (condition > 0) {
      var cases = [];
      cases.push(new ExpressionWithCondition(new Expression.Matrix(an), Condition.TRUE.andGreaterZero(n.subtract(Integer.fromNumber(condition)))));
      for (var i = 1; i <= condition; i += 1) {
        cases.push(new ExpressionWithCondition(new Expression.Matrix(a.pow(i)), Condition.TRUE.andZero(n.subtract(Integer.fromNumber(i)))));
      }
      return new Expression.Cases(cases);
    }
    var e = new Expression.Matrix(an);
    return condition !== -1 ? new ExpressionWithCondition(e, Condition.TRUE.andGreaterZero(n.subtract(Integer.fromNumber(condition)))) : e;
  };

  var enableEX = true;
  var enable2X = true;
  var enableEC = true;
  var enableAN = true;

  var isPositiveQuick = function (x) {
    if (x instanceof Integer) {
      return x.compareTo(Expression.ZERO) > 0;
    }
    if (x instanceof NthRoot) {
      return isPositiveQuick(x.a);//?
    }
    if ((x instanceof Multiplication || x instanceof Division) && !x.a.equals(Expression.ONE.negate()) && !x.b.equals(Expression.ONE.negate())) {
      return (isPositiveQuick(x.a) && isPositiveQuick(x.b)) || (isPositiveQuick(x.a.negate()) && isPositiveQuick(x.b.negate()));//? bug - ?
    }
    if (x instanceof Addition) {
      return isPositiveQuick(x.a) && isPositiveQuick(x.b);
    }
    if (x instanceof Expression.PolynomialRootSymbol) {
      return isPositiveQuick(x.interval.a) && isPositiveQuick(x.interval.b);
    }
    if (x instanceof Expression.Multiplication && x.a.equals(Expression.ONE.negate()) && x.b instanceof Expression.PolynomialRootSymbol) {
      return !isPositiveQuick(x.b.interval.a) && !isPositiveQuick(x.b.interval.b);
    }
    //TODO: ?
    /*if (x instanceof Expression.ExpressionPolynomialRoot) {
      return isPositiveQuick(x.root.interval.a) && isPositiveQuick(x.root.interval.b);
    }
    if (x instanceof Expression.Multiplication && x.a.equals(Expression.ONE.negate()) && x.b instanceof Expression.ExpressionPolynomialRoot) {
      return !isPositiveQuick(x.b.root.interval.a) && !isPositiveQuick(x.b.root.interval.b);
    }
    if (x instanceof Expression.ExpressionWithPolynomialRoot) {
      return isPositiveQuick(x.e);
    }*/
    return false;
  };

  var isPositive = function (x) {
    if (x.equals(Expression.ZERO)) {
      return false;
    }
    if (isPositiveQuick(x)) {
      return true;
    }
    if (isPositiveQuick(x.negate())) {
      return false;
    }
    if (x instanceof Expression.Symbol && !(x instanceof Expression.PolynomialRootSymbol) && !(x instanceof Expression.ExpressionPolynomialRoot) && !(x instanceof Expression.ExpressionWithPolynomialRoot)) {
      return false;
    }
    if (x instanceof Expression.Complex) {
      return false;
    }
    if (Expression.has(x, Expression.Complex)) {//???
      return false;
    }
    //TODO:
    //if (x instanceof ExpressionPolynomialRoot) {
    //  var tmp = x.sign();
    //  return tmp > 0;
    //}
    if (x instanceof Addition || x instanceof Expression.Cos || x instanceof Expression.Sin || x instanceof Expression.Exponentiation || x instanceof Expression.Multiplication || x instanceof Expression.PolynomialRootSymbol || x instanceof Expression.ExpressionPolynomialRoot || x instanceof Expression.ExpressionWithPolynomialRoot || x instanceof Expression.Division) {
      var tmp = toDecimalStringInternal(x, {significantDigits: 1});
      var value = tmp == undefined ? 0/0 : Number(tmp.replace(/\((\d+)\)/g, '$1').replace(/\*10\^/g, 'e'));
      if (!Number.isNaN(value)) {
        return value > 0;
      }
    }
    if (x instanceof Expression.ExponentiationOfMinusOne) {
      return false;
    }
    if (x instanceof Expression.Exponentiation && getExponent(x) instanceof Expression.Integer) {
      return isPositive(x.a); // x**2
    }
    if (Expression.has(x, Expression.Symbol)) {
      return false;//?
    }
    //TODO: tests, fix for algebraic numbers (?)
    if (x instanceof Expression.Logarithm) {
      return isPositive(x.a.subtract(Expression.ONE));
    }
    throw new TypeError("!" + x);
  };

  Expression._isPositive = isPositive;




  var isIntegerOrN = function (e) {
    if (e instanceof Integer) {
      return true;
    }
    if (e instanceof Expression.Symbol && (e.symbol === "n" || e.symbol === "k")) {
      return true;
    }
    if (e instanceof Expression.Addition || e instanceof Expression.Multiplication || e instanceof Expression.Exponentiation) {
      return isIntegerOrN(e.a) && isIntegerOrN(e.b);
    }
    //TODO: factorial - ?
    //TODO: n*(n+1)/2
    return false;
  };

  var isGoodPolynomial = function (x) {
    if (x instanceof Expression.Exponentiation) {
      return false;
    }
    var v = getVariableInternal(getLastMultiplicationOperand(getFirstAdditionOperand(x))).next().value.v; // avoid square roots
    if (v instanceof Expression.Symbol) {
      var p = Polynomial.toPolynomial(x, v);
      if (p.getDegree() === 1 && p.getCoefficient(0) instanceof Expression.Integer && p.getCoefficient(1) instanceof Expression.Integer) {
        if (p.getContent().equals(Expression.ONE)) {
          return true;
        }
      }
    }
    return false;
  };

  Expression.prototype.powExpression = function (x) {
    var y = this;

    if (y instanceof Expression.Symbol && (y.symbol === "t" || y.symbol === "T")) {
      if (Expression.has(x, MatrixSymbol) || Expression.has(x, Expression.Matrix)) {//TODO: fix
        return x.transpose();
      }
    }
    if (y instanceof Expression.Multiplication && y.a instanceof Expression.Integer && y.b instanceof Expression.Symbol && (y.b.symbol === "t" || y.b.symbol === "T")) {
      if (Expression.has(x, MatrixSymbol) || Expression.has(x, Expression.Matrix)) {//TODO: fix
        return x.pow(y.a).transpose();
      }
    }

    //!
    if (y instanceof Division && y.a instanceof Integer && y.b instanceof Integer && x !== Expression.E && !(x instanceof Expression.Symbol) && !Expression.has(x, Expression.Symbol)) {
      if (typeof hit === "function") {
        hit({powExpression: y.toString()});
      }
      var n = y.b.toNumber();
      //if (n >= 2 && n <= Number.MAX_SAFE_INTEGER) {//TODO:
        var q = y.a.truncatingDivide(y.b);
        var r = y.a.subtract(q.multiply(y.b));
        if (q.equals(Expression.ZERO)) {// to avoid multiplication event
          return x.pow(r)._nthRoot(n);
        }
        return x.pow(q).multiply(x.pow(r)._nthRoot(n));
      //}
    }
    //!

    if (x instanceof Expression.Integer && y === Expression.CIRCLE) {
      return new Expression.Degrees(x);
    }

    //!new 2017-05-08
    if (enableEX) {
      if (x === Expression.E || (enable2X && x instanceof Integer && x.compareTo(Expression.ONE) > 0 && integerPrimeFactor(x).compareTo(x) === 0)) {
        var isValid = function (y) {
          if (y instanceof Expression.Symbol) {
            return true;
          }
          if (y instanceof Addition) {
            return isValid(y.a) && isValid(y.b);
          }
          if ((y instanceof Integer || y instanceof NthRoot) && (x === Expression.E || (x instanceof Integer && y instanceof NthRoot))) {//TODO: fix
            return true;
          }
          if (y instanceof Multiplication || y instanceof Exponentiation) {
            for (var iteratorf = y.factors()[globalThis.Symbol.iterator](), f = iteratorf.next().value; f != null; f = iteratorf.next().value) {
              var b = getBase(f);
              if (!(b instanceof Integer || b instanceof NthRoot || b instanceof Expression.Symbol)) {
                if (!isValid(b)) {
                  return false;
                }
              }
            }
            return true;
          }
          if ((x === Expression.E || x instanceof Integer && x.compareTo(Expression.ONE) > 0) && y instanceof Division && y.b instanceof Integer) {//!new 2019-08-08
            return isValid(y.a);//?
          }
          return false;
        };
        if (y.getNumerator() instanceof Addition && (y.getNumerator().a.isNegative() || y.getNumerator().b.isNegative())) { // e**(x-y)
          return Expression.ONE.divide(x.pow(y.getNumerator().a.negate().divide(y.getDenominator())).divide(x.pow(y.getNumerator().b.divide(y.getDenominator()))));
        }
        if (isValid(y)) {
          if (y.isNegative()) {
            return Expression.ONE.divide(new Expression.Exponentiation(x, y.negate()));
          }
          //!new
          if (y instanceof Expression.ExpressionWithPolynomialRoot) {
            return x.pow(y.upgrade());
          }
          return new Expression.Exponentiation(x, y);
        }
      }
      if (enable2X && x instanceof Integer && x.compareTo(Expression.ONE) > 0) {
        if (y instanceof Addition && (y.a instanceof Integer || y.b instanceof Integer)) {
          return x.pow(y.a).multiply(x.pow(y.b));
        }
        var xf = integerPrimeFactor(x);
        if (xf.equals(x)) {
          if (y instanceof Division && y.b instanceof Integer) {
            var n = y.b.toNumber();
            if (n >= 2 && n <= Number.MAX_SAFE_INTEGER) {
              return x.pow(y.a)._nthRoot(n);
            }
          }
          //!new 2020-18-01
          if (y instanceof Division && isIntegerOrN(y.a) && isIntegerOrN(y.b)) {
            if (x.compareTo(Expression.ONE) > 0) {
              return new Expression.Exponentiation(x, y);//?
            }
          }
          //!
        } else {
          if (!Expression.has(y, Expression.Logarithm)) {//TODO: ?
          var ctz = primeFactor._countTrailingZeros(x.toBigInt(), xf.toBigInt());
          return xf.pow(y.multiply(Integer.fromNumber(ctz))).multiply(x.divide(xf._pow(ctz)).pow(y));
          }
        }
      }
    }
    //!

    if (enableEX) {
      //TODO: - ?
      if (x instanceof Integer && x.equals(Expression.ONE)) {
        return Expression.ONE;
      }
      if (x instanceof Division || x instanceof Multiplication && (y.getDenominator().equals(Expression.ONE) || isPositive(x.a) || isPositive(x.b))) {
        if (x instanceof Division) {
          return x.a.pow(y).divide(x.b.pow(y));
        }
        if (enable2X) {
          if (x instanceof Multiplication) {
            return x.a.pow(y).multiply(x.b.pow(y));
          }
        }
      }
    }

    var yn = y.getNumerator();
    var yd = y.getDenominator();
    if (x === Expression.E && yn instanceof Multiplication && yn.a instanceof Expression.Complex && yn.a.real.equals(Expression.ZERO) && yn.b instanceof Expression.Symbol) {
      var t = y.multiply(Expression.I.negate());
      return t.cos().add(Expression.I.multiply(t.sin()));
    }
    if (x === Expression.E && getConstant(yn) instanceof Expression.Complex && yd instanceof Expression.Integer) {
      var c = getConstant(yn);
      if (c.real.equals(Expression.ZERO)) {
        var t = y.multiply(Expression.I.negate());
        t = Expression.has(y, Expression.Symbol) ? t : new Expression.Radians(t);
        return t.cos().add(Expression.I.multiply(t.sin()));
      }
      return x.pow(c.real.divide(yd)).multiply(x.pow(c.imaginary.multiply(Expression.I).multiply(yn.divide(c)).divide(yd)));
    }
    if (x === Expression.E && yn instanceof Expression.Addition && yd instanceof Expression.Integer) {
      return x.pow(yn.a.divide(yd)).multiply(x.pow(yn.b.divide(yd)));
    }

    //TODO:
    if (x instanceof Expression.Matrix && isIntegerOrN(y)) {
      if (!x.matrix.isSquare()) {
        throw new RangeError("NonSquareMatrixException");
      }
      var an = matrixInN(x.matrix, y);
      if (an != undefined) {
        //?
        var D = x.matrix.map(function (e, i, j) {
          return i === j ? e : Expression.ZERO;
        });
        var N = x.matrix.subtract(D);
        if (x.matrix.isDiagonal()) {
        //  if (Expression.callback != undefined) {
        //    Expression.callback(new Expression.Event("diagonal-matrix-pow", x));
        //  }
        //} else if (x.matrix.isJordanMatrix()) {
        //  if (Expression.callback != undefined) {
        //    Expression.callback(new Expression.Event("Jordan-matrix-pow", x));
        //  }
        } else if (N.isNilpotent() && D.multiply(N).eql(N.multiply(D))) {
          if (Expression.callback != undefined) {
            Expression.callback(new Expression.Event("DpN-matrix-pow", x));
          }
        }

        return an;
      }

      //! 2018-08-26
      if (true) {
        var tmp = Expression.getEigenvalues(x.matrix);
        var eigenvalues = tmp.eigenvalues;
        var multiplicities = tmp.multiplicities;
        if (Expression.sum(multiplicities) === x.matrix.cols()) {
          var tmp2 = Expression.getEigenvectors(x.matrix, eigenvalues);
          var eigenvectors = tmp2.eigenvectors;
          if (eigenvectors.length === x.matrix.cols()) {
            var tmp = Expression.diagonalize(x.matrix, eigenvalues, multiplicities, eigenvectors);
            var L = tmp.L;
            var SL = matrixInN(L, y);
            if (SL != undefined) {
              if (Expression.callback != undefined) {
                Expression.callback(new Expression.Event("pow-using-diagonalization", x));
              }
              if (Expression.callback != undefined) {
                //TODO more details (A=P*D*P^-function (1) { return A^n=P*D*P^-1 * ... * P*D*P^-1=P*D^n*P^1; }
                Expression.callback(new Expression.Event("diagonalize", x));
              }
              return new Expression.Matrix(tmp.T).multiply(SL).multiply(new Expression.Matrix(tmp.T_INVERSED));
            }
          } else {
            var tmp = Expression.getFormaDeJordan(x.matrix, eigenvalues, multiplicities);
            var JN = matrixInN(tmp.J, y);
            if (JN != undefined) {
              if (Expression.callback != undefined) {
                Expression.callback(new Expression.Event("pow-using-Jordan-normal-form", x));
              }
              if (Expression.callback != undefined) {
                //TODO more details (A=P*D*P^-function (1) { return A^n=P*D*P^-1 * ... * P*D*P^-1=P*D^n*P^1; }
                Expression.callback(new Expression.Event("Jordan-decomposition", x));
              }
              //TODO: details !!!
              return new Expression.Matrix(tmp.P).multiply(JN).multiply(new Expression.Matrix(tmp.P_INVERSED));
            }
          }
        }
      }
      //!
    }

    if (Expression.ExponentiationOfMinusOne != null) {
      if (x instanceof Integer && x.compareTo(Expression.ZERO) < 0 || x.equals(Expression.E.negate())) {
        if (y instanceof Expression.Symbol && (y.symbol === "n" || y.symbol === "k")) {
          return new Expression.ExponentiationOfMinusOne(Expression.ONE.negate(), y).multiply(x.negate().pow(y));
        }
        if (y instanceof Addition && y.a instanceof Expression.Symbol && (y.a.symbol === "n" || y.a.symbol === "k") && y.b instanceof Integer) {
          return new Expression.ExponentiationOfMinusOne(Expression.ONE.negate(), y.a).multiply(Expression.ONE.negate().pow(y.b)).multiply(x.negate().pow(y));
        }
        if (y instanceof Multiplication) {
          return x.pow(y.a).pow(y.b);
        }
        if (y instanceof Addition && y.b instanceof Integer) {
          return x.pow(y.a).multiply(x.pow(y.b));
        }
      }
    }

    if (Expression.ExponentiationOfImaginaryUnit != null) {
      if (x instanceof Expression.Complex && x.equals(Expression.I.negate())) {
        return Expression.ONE.negate().pow(y).multiply(x.negate().pow(y));
      }
      if (x instanceof Expression.Complex && (x.equals(Expression.I) || x.real.compareTo(Expression.ZERO) > 0 && x.primeFactor().equals(x))) {//TODO: -i, other complex numbers - ?
        if (y instanceof Expression.Symbol && (y.symbol === "n" || y.symbol === "k")) {
          return new Expression.ExponentiationOfImaginaryUnit(x, y);
        }
        if (y instanceof Addition && y.a instanceof Expression.Symbol && (y.a.symbol === "n" || y.a.symbol === "k") && y.b instanceof Integer) {
          //var t = x.pow(y.b);
          //return new Expression.ExponentiationOfImaginaryUnit(x, t instanceof Expression.Complex ? y.a.add(Expression.ONE) : y.a).multiply(t instanceof Expression.Complex ? t.divide(x) : t);
          return x.pow(y.a).multiply(x.pow(y.b));
        }
        if (y instanceof Multiplication) {
          return x.pow(y.a).pow(y.b);
        }
        if (y instanceof Addition && y.b instanceof Integer) {
          return x.pow(y.a).multiply(x.pow(y.b));
        }
      }
      if (x instanceof Expression.Complex && x.real.equals(Expression.ZERO) && !x.imaginary.equals(Expression.ONE)) {//TODO: -i, other complex numbers - ?
        if (y instanceof Expression.Symbol && (y.symbol === "n" || y.symbol === "k")) {
          return x.imaginary.pow(y).multiply(Expression.I.pow(y));
        }
        if (y instanceof Multiplication) {
          return x.pow(y.a).pow(y.b);
        }
        if (y instanceof Addition) {
          return x.pow(y.a).multiply(x.pow(y.b));
        }
      }
      if (x instanceof Expression.Complex) {//TODO: ?
        var pf = x.primeFactor();
        return x.divide(pf).pow(y).multiply(pf.pow(y));//TODO: test ?
      }

      //TODO:
      if (x instanceof Expression.Integer && y instanceof Division && y.getDenominator() instanceof Integer && y.getNumerator() instanceof Expression.Symbol &&
          (y.getNumerator().symbol === "n" || y.getNumerator().symbol === "k")) {
        return x.pow(Expression.ONE.divide(y.getDenominator())).pow(y.getNumerator());
      }
      //?
      if (x instanceof Expression.Integer && y instanceof Division && y.getDenominator() instanceof Integer && y.getNumerator() instanceof Addition) {
        return x.pow(Expression.ONE.divide(y.getDenominator())).pow(y.getNumerator());
      }
    }

    if (x === Expression.E && y instanceof Expression.Matrix) {
      if (!y.matrix.isSquare()) {
        throw new RangeError("NonSquareMatrixException");
      }
      // https://en.wikipedia.org/wiki/Matrix_exponential#Using_the_Jordan_canonical_form
      var tmp = Expression.getEigenvalues(y.matrix);
      var eigenvalues = tmp.eigenvalues;
      var multiplicities = tmp.multiplicities;
      if (Expression.sum(multiplicities) === y.matrix.cols()) {
        var tmp = Expression.getFormaDeJordan(y.matrix, eigenvalues, multiplicities);
        // exp(A) = exp(P*J*P^-1) = P*exp(D + N)*P^-1 = P*exp(D)*exp(N)*P^-1
        var D = tmp.J.map(function (e, i, j) {
          return i === j ? e : Expression.ZERO;
        });
        var N = tmp.J.map(function (e, i, j) {
          return i !== j ? e : Expression.ZERO;
        });
        var exp = function (N) {
          // https://en.wikipedia.org/wiki/Matrix_exponential#Nilpotent_case
          var z = Matrix.Zero(N.cols(), N.cols());
          var s = z;
          var p = Matrix.I(N.cols());
          var k = 0;
          var f = 1;
          while (!p.eql(z)) {
            var summand = p.scale(Expression.ONE.divide(Integer.fromNumber(f)));
            s = s.add(summand);
            p = p.multiply(N);
            k += 1;
            f *= k;
          }
          return s;
        };
        if (Expression.callback != undefined) {
          Expression.callback(new Expression.Event("exponential-using-Jordan-canonical-form", y));
        }
        //if (Expression.callback != undefined) {
        //  Expression.callback(new Expression.Event("Jordan-decomposition", y));
        //}
        return new Expression.Matrix(tmp.P.multiply(D.map(function (e, i, j) {
          return i === j ? Expression.E.pow(e) : Expression.ZERO;
        }).multiply(exp(N))).multiply(tmp.P_INVERSED));
      }
    }

    //!2019-04-22
    if (x instanceof NthRoot && x.a instanceof Integer) {
      return x.a.pow(y.divide(Expression.Integer.fromNumber(x.n)));
    }

    if (enableEC) {
      if (x === Expression.E && isConstant(y) && !has(y, Expression.Complex)) {
        return new Expression.Exponentiation(x, y);
      }
      if ((x instanceof Expression.Symbol || Expression.has(x, Expression.Symbol)) && y instanceof Expression.Division && y.getDenominator() instanceof Integer) {
        return x.pow(y.getNumerator())._nthRoot(y.getDenominator().toNumber());
      }
      if (x instanceof Expression.Symbol && y instanceof Expression.Division && isIntegerOrN(y.getNumerator()) && isIntegerOrN(y.getDenominator())) {
        return new Expression.Exponentiation(x, y);
      }
      if (x === Expression.E && y instanceof Expression.Addition) {
        return x.pow(y.a).multiply(x.pow(y.b));
      }
      if (x instanceof Exponentiation && getBase(x) === Expression.E) {//?
        return getBase(x).pow(getExponent(x).multiply(y));
      }
      if (isGoodPolynomial(x) && y instanceof Expression.Division && isIntegerOrN(y.getNumerator()) && isIntegerOrN(y.getDenominator())) {
        return new Expression.Exponentiation(x, y);
      }
    }

    if (x instanceof Expression.Matrix && y instanceof Expression.Addition) {
      return x.pow(y.a).multiply(x.pow(y.b));
    }
    if (x instanceof Expression.Matrix && y instanceof Expression.Multiplication && y.a instanceof Expression.Integer) {
      return x.pow(y.a).pow(y.b);
    }
    if (x instanceof Expression.Matrix && y instanceof Expression.Division) {
      //?
      if (y.getNumerator().equals(Expression.ONE) && y.getDenominator() instanceof Expression.Symbol && (y.getDenominator().symbol === "n" || y.getDenominator().symbol === "k")) {
        return x._nthRoot(y.getDenominator());//TODO: ?
      }
      if (isIntegerOrN(y.getNumerator()) && isIntegerOrN(y.getDenominator())) {
        return x.pow(y.getNumerator()).pow(Expression.ONE.divide(y.getDenominator()));
      }
    }

    //?
    if (y instanceof Expression.Symbol && (y.symbol === "n" || y.symbol === "k")) {
      var qi = QuadraticInteger.toQuadraticInteger(x);//?
      if (qi != null && /*qi.equals(qi.primeFactor()) &&*/ Number(qi.a.toString()) > 0 && qi.D > 0 && (qi.isValid() || true)) {
        if (Number(qi.b.toString()) > 0) {
          return new Expression.ExponentiationOfQuadraticInteger(x, y);
        }
        if (Number(qi.b.toString()) < 0) {
          var xc = qi.conjugate().toExpression();
          return x.multiply(xc).pow(y).divide(xc.pow(y));
        }
      }
      if (qi != null && Number(qi.a.toString()) < 0) {
        return Expression.ONE.negate().pow(y).multiply(qi.toExpression().negate().pow(y));
      }
      /*
      if (qi != null) {
        if (x._nthRoot(2) instanceof Expression.Addition) {//TODO: remove
          var t = x._nthRoot(2).pow(y);
          return new Expression.ExponentiationOfQuadraticInteger(x._nthRoot(2), y.multiply(Expression.TWO));
        }
      }
      */
    }
    /*
    if (y instanceof Multiplication && y.a instanceof Integer && y.b instanceof Expression.Symbol) {
      return x.pow(y.a).pow(y.b);
    }
    */
    //?

    if (enableAN) {
      if (x instanceof Expression.Symbol && y instanceof Expression.Symbol && (y.symbol === "n" || y.symbol === "k")) {
        return new Expression.Exponentiation(x, y);
      }
      if (y instanceof Addition && getConstant(y.a) instanceof Expression.Integer && getTerm(y.a) instanceof Expression.Symbol && (getTerm(y.a).symbol === "n" || getTerm(y.a).symbol === "k") && y.b instanceof Integer) {
        if (y.b.isNegative()) {
          return x.pow(y.a).multiply(x.pow(y.b));
        }
        return new Expression.Exponentiation(x, y);
      }
      if (y instanceof Multiplication && y.a instanceof Expression.Integer && y.b instanceof Expression.Symbol && (y.b.symbol === "n" || y.b.symbol === "k")) {
        return new Expression.Exponentiation(x, y);
      }
      if (x instanceof Exponentiation && getBase(x) instanceof Integer && getBase(x).compareTo(Expression.ONE) > 0 && isIntegerOrN(getExponent(x).getNumerator()) && isIntegerOrN(getExponent(x).getDenominator())) {//TODO: FIX
        return getBase(x).pow(getExponent(x).multiply(y));
      }
      if (x instanceof Exponentiation && isGoodPolynomial(getBase(x)) &&
          isIntegerOrN(getExponent(x).inverse()) &&
          isIntegerOrN(y.inverse())) {//TODO: FIX
        return getBase(x).pow(getExponent(x).multiply(y));
      }
    }

    if (Expression.has(x, Expression.Sin) || Expression.has(x, Expression.Cos)) {
      return Expression._replaceBySinCos(Expression._replaceSinCos(x).pow(y));
    }

    if (x === Expression.E && y instanceof Expression.Logarithm) {
      return y.a;
    }
    if (x === Expression.E && y instanceof Expression.Multiplication && y.a instanceof Integer && y.b instanceof Expression.Logarithm) {
      return x.pow(y.b).pow(y.a);
    }
    if (x === Expression.E && y instanceof Expression.Multiplication && y.a instanceof Expression.Symbol && y.b instanceof Expression.Logarithm) {
      return x.pow(y.b).pow(y.a);
    }
    if (x instanceof Expression.Integer && Expression.has(y, Expression.Logarithm)) {//?
      return Expression.E.pow(x.logarithm().multiply(y));
    }

    //!new 2020-12-11
    if (x instanceof Exponentiation && getBase(x) instanceof Integer && getBase(x).compareTo(Expression.TWO) >= 0 && isIntegerOrN(y)) { // (3^x)^k
      // https://en.wikipedia.org/wiki/Exponentiation#Identities_and_properties
      //TODO: positive real base check - ?
      return getBase(x).pow(getExponent(x).multiply(y));
    }
    //!
    throw new RangeError("NotSupportedError");
  };

  // compare two expression, which are factors (multiplicaiton operands) of terms (addition operands)
  Expression.prototype.compare4Addition = function (y) {
    var x = this;
    if (x instanceof Integer && y instanceof Integer) {
      return x.compareTo(y);
    }
    if (x instanceof Expression.Symbol && y instanceof Integer) {
      return +1;
    }
    if (x instanceof Integer && y instanceof Expression.Symbol) {
      return -1;
    }
    if (x instanceof Expression.Symbol && y instanceof Expression.Symbol) {
      return x.symbol < y.symbol ? -1 : (y.symbol < x.symbol ? +1 : 0);
    }
    //!
    if (x instanceof Expression.Matrix && y instanceof MatrixSymbol) {
      return +1;
    }
    if (x instanceof MatrixSymbol && y instanceof Expression.Matrix) {
      return -1;
    }
    if (x instanceof Expression.Matrix && y instanceof Expression.Matrix) {
      /*
      if (x.matrix.rows() === y.matrix.rows() &&
          x.matrix.cols() === y.matrix.cols()) {
        var rows = x.matrix.rows();
        var cols = x.matrix.cols();
        for (var i = 0; i < rows; i += 1) {
          for (var j = 0; j < cols; j += 1) {
            var c = x.matrix.e(i, j).compare4Addition(y.matrix.e(i, j));
            if (c !== 0) {
              return c;
            }
          }
        }
      }
      */
      return 0;
    }

    //!new 2016-12-17
    //NOTE: the `x instanceof Addition || y instanceof Addition` should be used before `x instanceof Multiplication || y instanceof Multiplication`
    if (x instanceof Addition || y instanceof Addition) {
      return Addition.compare4Addition(x, y);
    }

    //!new 2016-10-09
    if (x instanceof Multiplication || y instanceof Multiplication) {
      return Multiplication.compare4Addition(x, y);
    }


    //!new 2018-10-11
    if (x instanceof Integer && y instanceof Expression.Function) {
      return -1;
    }

    //!new 2018-11-12
    if (x instanceof Division && y instanceof Division) {
      return x.a.compare4Addition(y.a) || x.b.compare4Addition(y.b);//?
    }
    if (x instanceof Expression && y instanceof Division) {
      return +1;//?
    }
    if (x instanceof Division && y instanceof Expression) {
      return -1;//?
    }

    if (x instanceof Expression.Matrix) {
      return -1;
    }
    if (y instanceof Expression.Matrix) {
      return +1;
    }

    //!2019-02-18
    if (x instanceof Integer && y instanceof Expression.Complex) {
      return -1;//?
    }
    if (x instanceof Expression.Complex && y instanceof Integer) {
      return +1;//?
    }
    //!

    if (x.equals(y)) {
      return 0;//!
    }

    if (x instanceof Expression.Exponentiation || y instanceof Expression.Exponentiation) {
      return getBase(x).compare4Addition(getBase(y)) || (0 - getExponent(x).compare4Addition(getExponent(y)));
    }

    //!new 2017-02-10
    if (y instanceof Expression.Symbol) {
      return -1;
    }

    //!
    throw new RangeError();
  };

  var compare = function (x, y) {
    return x.compare4Addition(y);
  };

  var compare4Multiplication = function (x, y) {
    //TODO: Exponentiation + Exponentiation, Exponentiation + Symbol, Symbol + Exponentiation
    return x.compare4Multiplication(y);
  };

  var getBase = function (x) {
    //TODO: ?
    //if (x instanceof NthRoot) {
    //  return x.a;
    //}
    return x instanceof Exponentiation ? x.a : x;
  };
  var getExponent = function (x) {
    //TODO: ?
    //if (x instanceof NthRoot) {
    //  return Expression.Integer.fromNumber(x.n);
    //}
    return x instanceof Exponentiation ? x.b : Expression.ONE;
  };

  // use getContent instead (?)
  var getConstant = function (e, flag0) {
    if (e instanceof Integer) {
      return e;
    } else if (e instanceof Expression.Complex) {
      return e;
    } else if (e instanceof Expression.ExpressionPolynomialRoot) {
      if (flag0) {
        return e;
      }
    } else if (e instanceof Multiplication) {
      var c = undefined;
      var x = e;
      for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
        var t = getConstant(y, flag0);
        c = c == undefined ? t : t.multiply(c);
      }
      if (c != undefined) {
        return c;
      }
    } else if (e instanceof Addition) { // -5*x+15
      var c = undefined;
      for (var iteratorx = e.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
        var t = getConstant(x, flag0);
        //c = c == undefined ? t : integerGCD(t, c);
        c = c == undefined ? t : complexGCD(t, c);
      }
      if (c != undefined) {
        return c;
      }
    }
    return Expression.ONE;
  };
  var getTerm = function (x, flag0) {
  // TODO: fix performance ?
    if (x instanceof Integer) {
      return undefined;
    } else if (x instanceof Expression.Complex) {
      return undefined;
    } else if (x instanceof Expression.ExpressionPolynomialRoot) {
      if (flag0) {
        return undefined;
      }
    } else if (x instanceof Multiplication) {
      var terms = [];
      for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
        var t = getTerm(y, flag0);
        if (t != undefined) {
          terms.push(t);
        }
      }
      var result = undefined;
      for (var j = terms.length - 1; j >= 0; j -= 1) {
        result = result == undefined ? terms[j] : new Multiplication(result, terms[j]);
      }
      return result;
    } else if (x instanceof Addition) {
      return x.divide(getConstant(x));
    }
    return x;
  };

  Expression.getConstant = getConstant;

  var multiplyByInteger = function (x, y) {
    if (x.compareTo(Expression.ZERO) === 0) {
      return x;
    }
    if (x.compareTo(Expression.ONE) === 0) {
      return y;
    }
    return new Multiplication(x, y);
  };

  Expression.prototype.multiplyExpression = function (x) {
    var y = this;

    if (x instanceof Expression && y instanceof Multiplication) {
      return x.multiply(y.a).multiply(y.b);
    }
    if (x instanceof Multiplication && y instanceof Expression) {
      var c = compare4Multiplication2(x.b, y);
      if (c === 0) {
        return x.a.multiply(x.b.multiply(y));
      }
      return c > 0 ? x.a.multiply(y).multiply(x.b) : new Multiplication(x, y);
    }

    //!
    /*
    if (x instanceof IdentityMatrix && y instanceof MatrixSymbol) {
      return y;
    }
    if (y instanceof IdentityMatrix && x instanceof MatrixSymbol) {
      return x;
    }
    */
    //!
    // rest

    var c = 0;
    if (x instanceof Integer && y instanceof Expression.Symbol) {
      return multiplyByInteger(x, y);
    }
    if (x instanceof Expression.Symbol && y instanceof Integer) {
      return multiplyByInteger(y, x);
    }
    if (x instanceof Expression.Symbol && y instanceof Expression.Symbol) {
      c = compare4Multiplication(x, y);
      if (c === 0) {
        return x.pow(Expression.TWO);
      }
      return c > 0 ? new Multiplication(y, x) : new Multiplication(x, y);
    }
    if (x instanceof Integer && y instanceof Exponentiation) {
      return multiplyByInteger(x, y);
    }
    if (x instanceof Exponentiation && y instanceof Integer) {
      return multiplyByInteger(y, x);
    }
    if (x instanceof Exponentiation && y instanceof Expression.Symbol) {
      c = compare4Multiplication(getBase(x), y);
      if (c === 0) {
        return y.pow(getExponent(x).add(Expression.ONE));
      }
      return c > 0 ? new Multiplication(y, x) : new Multiplication(x, y);
    }
    if (x instanceof Expression.Symbol && y instanceof Exponentiation) {
      c = compare4Multiplication(x, getBase(y));
      if (c === 0) {
        return x.pow(getExponent(y).add(Expression.ONE));
      }
      return c > 0 ? new Multiplication(y, x) : new Multiplication(x, y);
    }
    if (x instanceof Exponentiation && y instanceof Exponentiation) {
      c = compare4Multiplication(getBase(x), getBase(y));
      if (c === 0) {
        return getBase(x).pow(getExponent(x).add(getExponent(y)));
      }
      return c > 0 ? new Multiplication(y, x) : new Multiplication(x, y);
    }

    if (x instanceof SquareRoot && y instanceof SquareRoot) {
      if (x.a instanceof Integer && y.a instanceof Exponentiation) {//TODO: fix
        return new Multiplication(x, y);
      }
      // optimization:
      var g = x.a.getNumerator().gcd(y.a.getDenominator()).divide(x.a.getDenominator().lcm(y.a.getDenominator()));
      return g.multiply(x.a.divide(g).multiply(y.a.divide(g)).squareRoot());
      //return x.a.multiply(y.a).squareRoot();
    }
    if (x instanceof CubeRoot && y instanceof CubeRoot) {
      // optimization:
      //var g = x.a.gcd(y.a);
      //return g.pow(2/3).multiply(x.a.divide(g).multiply(y.a.divide(g)).cubeRoot());
      return x.a.multiply(y.a).cubeRoot();
    }
    if (x instanceof NthRoot && y instanceof NthRoot) {
      //if (x.n === y.n) {
      //  return x.a.multiply(y.a)._nthRoot(x.n);
      //}
      //!2021-02-02 - hack
      if (x.a instanceof Integer && !(y.a instanceof Integer) && x.n < y.n && getVariable(y.a)._pow(2).gcd(x.a).equals(x.a)) {
        if (Expression.isConstant(x) && Expression.isConstant(y)) {
          return y.multiply(x);
        }
      }
      //!
      var ng = Math.gcd(x.n, y.n);
      //TODO: remove check for integers (?)
      if (!(x.a instanceof Integer) && (!(y.a instanceof Integer) || !x.a._pow(2).gcd(y.a).equals(Expression.ONE) || getVariable(x.a)._pow(2).gcd(y.a).equals(getVariable(x.a)._pow(2))) || !x.a.gcd(y.a).equals(Expression.ONE)) {
        var v = Expression.pow(x.a, y.n / ng).multiply(Expression.pow(y.a, x.n / ng));
        var nn = x.n / ng * y.n;
        return v._nthRoot(nn);
      }
      if (!(x.a instanceof Integer) && x.n === 2 && y.a instanceof Integer && y.n === 4 && !(getConstant(x.a.getNumerator()).multiply(y.a)._nthRoot(y.n) instanceof NthRoot)) {//HACK
        return x.a.multiply(y.a._nthRoot(2))._nthRoot(2);
      }
      return x.n < y.n ? new Multiplication(x, y) : (x.n > y.n ? new Multiplication(y, x) : x.a.multiply(y.a)._nthRoot(x.n));
    }

    //!
    if (x instanceof MatrixSymbol && y instanceof Expression.Matrix) {
      return new Multiplication(x, y);
    }
    if (x instanceof Expression.Matrix && y instanceof MatrixSymbol) {
      return new Multiplication(x, y);
    }
    if (has(x, MatrixSymbol) && y instanceof Expression.Matrix) { // X^2*{{1,2},{3,4}}
      return new Multiplication(x, y);
    }
    if (x instanceof Expression.Matrix && has(y, MatrixSymbol)) { // {{1,2},{3,4}}*X^2
      return new Multiplication(x, y);
    }

    //!
    //throw new RangeError();
    if (x instanceof Integer && y instanceof Expression) {
      if (x.compareTo(Expression.ZERO) === 0) {
        return x;
      }
      if (x.compareTo(Expression.ONE) === 0) {
        return y;
      }
    }
    if (x instanceof Expression && y instanceof Integer) {
      if (y.compareTo(Expression.ZERO) === 0) {
        return y;
      }
      if (y.compareTo(Expression.ONE) === 0) {
        return x;
      }
    }

/*
    // TODO: remove
    if (x instanceof Expression.Complex && y instanceof Expression.ExponentiationOfImaginaryUnit) {
      //!hack
      //TODO: remove
      if (x.real.equals(Expression.ZERO)) {
        if (!x.equals(Expression.I)) {
        //if (x.primeFactor().equals(y.a)) {//TODO: fix
        if (y.a.equals(Expression.I)) {//TODO: fix
        return x.imaginary.multiply(y.multiply(Expression.I));
        }
        //}
        }
      } else {
        if (getBase(y).equals(Expression.I)) {//TODO: remove
          return x.imaginary.multiply(Expression.I).multiply(y).add(x.real.multiply(y));
        }
      }
    }
    if (x instanceof Expression.ExponentiationOfImaginaryUnit && y instanceof Expression.Complex) {
      //!hack
      //TODO: remove
      if (y.real.equals(Expression.ZERO)) {
        if (!y.equals(Expression.I)) {
        return y.imaginary.multiply(x.multiply(Expression.I));
        }
      } else {
        if (getBase(x).equals(Expression.I)) {//TODO: remove
        return y.imaginary.multiply(Expression.I).multiply(x).add(y.real.multiply(x));
        }
      }
    }
*/

    //var cmp = x instanceof Expression.Complex && y instanceof Expression.ExponentiationOfImaginaryUnit && !x.equals(getBase(y)) ? -1 : (x instanceof Expression.ExponentiationOfImaginaryUnit && y instanceof Expression.Complex && !y.equals(getBase(x)) ? +1 : compare4Multiplication(getBase(x), getBase(y)));
    var cmp = x instanceof Expression.Complex && y instanceof Expression.ExponentiationOfImaginaryUnit ? -1 : (x instanceof Expression.ExponentiationOfImaginaryUnit && y instanceof Expression.Complex ? +1 : compare4Multiplication(getBase(x), getBase(y)));
    if (cmp === 0) {
      return getBase(x).pow(getExponent(x).add(getExponent(y)));
    }
    if (cmp < 0) {
      return new Multiplication(x, y);
    }
    if (cmp > 0) {
      return new Multiplication(y, x);
    }

  };

  function Iterator() {
  }
  if ("\v" !== "v") {
    Object.defineProperty(Iterator.prototype, "done", {
      get: function () {
        return this.value == null;
      }
    });
  }
  Iterator.prototype[globalThis.Symbol.iterator] = function () {
    return this;
  };

  function TermFactorsIterator(e) {
    this.value = undefined;
    this.e = e;
  }
  TermFactorsIterator.prototype = Object.create(Iterator.prototype);
  TermFactorsIterator.prototype.next = function () {
    this.value = this.e instanceof Multiplication ? this.e.b : (this.e instanceof Integer || this.e instanceof Expression.Complex ? null : this.e);
    this.e = this.e instanceof Multiplication ? this.e.a : undefined;
    return this;
  };

  function termFactors(e) {
    return new TermFactorsIterator(e);
  }

  var compare4Addition = function (x, y) {
    // undefined | Symbol | Exponentiation | Multiplication
    var i = termFactors(x);
    var j = termFactors(y);
    var a = i.next().value;
    var b = j.next().value;
    while (a != null && b != null) {

      //!
      // x^3*y^2, x^2*y^3
      var cmp = 0 - compare(getBase(a), getBase(b));
      if (cmp === 0) {
        cmp = compare(getExponent(a), getExponent(b));
      }
      if (cmp !== 0) {
        return cmp;
      }
      a = i.next().value;
      b = j.next().value;
    }
    //!new 2020-02-13
    if (a instanceof Expression.Matrix || b instanceof Expression.Matrix) {
      if (y instanceof Integer && x instanceof Multiplication) {
        return +1;//?
      }
      if (x instanceof Integer && y instanceof Multiplication) {
        return -1;//?
      }
      if (a != null && i.next().value != null) {
        return +1;
      }
      if (b != null && j.next().value != null) {
        return -1;
      }
      return 0;
    }
    //!
    return a != null ? +1 : (b != null ? -1 : 0);
  };

  var addSimilar = function (x, y) {
    var c1 = getConstant(x);//TODO: remove (?)
    var c2 = getConstant(y);
    var i = termFactors(getTerm(x));
    var j = termFactors(getTerm(y));
    var a = i.next().value;
    var b = j.next().value;
    var result = Expression.ONE;
    while (a != null || b != null) {
      var f = null;
      if (a instanceof Expression.Matrix || b instanceof Expression.Matrix) {
        f = (a == null ? c1 : a.multiply(c1)).add(b == null ? c2 : b.multiply(c2));
        c1 = Expression.ONE;
        c2 = Expression.ONE;
      } else {
        if (!a.equals(b)) {
          throw new TypeError();
        }
        f = a;
      }
      result = f.multiply(result);//!TODO: depends on the iteration order !!!
      a = i.next().value;
      b = j.next().value;
    }
    return result;
  };

  Expression.getComplexNumberParts = function (e) {
    if (e instanceof Expression.Division) {
      var tmp = Expression.getComplexNumberParts(e.getNumerator());
      return {real: tmp.real.divide(e.getDenominator()), imaginary: tmp.imaginary.divide(e.getDenominator())};
    }
    var real = Expression.ZERO;
    var imaginary = Expression.ZERO;
    for (var iteratorx = e.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
      var c = undefined;
      var r = Expression.ONE;
      for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
        if (c == undefined && y instanceof Expression.Complex) {
          c = y;
        } else {
          r = r.multiply(y);
        }
      }
      real = real.add(r.multiply(c == undefined ? Expression.ONE : c.real));
      imaginary = imaginary.add(c != undefined ? r.multiply(c.imaginary) : Expression.ZERO);
    }
    return {
      real: real,
      imaginary: imaginary
    };
  };

  Expression.prototype.addExpression = function (x) {
    var y = this;
    if (x.equals(Expression.ZERO)) {
      return y;
    }
    if (y.equals(Expression.ZERO)) {
      return x;
    }

    //!2019-02-16
    if (x instanceof Multiplication && x.b instanceof IdentityMatrix) {
      var t = getIdentityMatrixCoefficient(y);
      if (t != null) {
        return x.a.add(t).multiply(x.b);
      }
    } else if (x instanceof IdentityMatrix) {
      var t = getIdentityMatrixCoefficient(y);
      if (t != null) {
        return Expression.ONE.add(t).multiply(x);
      }
    }
    if (y instanceof Multiplication && y.b instanceof IdentityMatrix) {
      var t = getIdentityMatrixCoefficient(x);
      if (t != null) {
        return t.add(y.a).multiply(y.b);
      }
    } else if (y instanceof IdentityMatrix) {
      var t = getIdentityMatrixCoefficient(x);
      if (t != null) {
        return t.add(Expression.ONE).multiply(y);
      }
    }
    //!2019-02-16

    //!new 2019-09-30
    /*
    if (x instanceof Expression.Addition && y instanceof Expression.Matrix) {//TODO:
      return x.a.add(x.b.add(y));
    }
    if (x instanceof Expression.Matrix && y instanceof Expression.Addition) {
      return x.add(y.a).add(y.b);
    }
    if (x instanceof Expression.Addition && y instanceof Expression.Addition) {
      if (x.b instanceof Expression.Matrix && y.b instanceof Expression.Matrix) {
        return x.a.add(x.b.add(y));
      }
    }
    */

    // rest
    
    //!new 2020-12-26
    if (/*Expression.isConstant(x) && Expression.isConstant(y) && */
        (Expression.has(x, Expression.Complex) || Expression.has(y, Expression.Complex)) &&
        (Expression.has(x, Expression.ExpressionPolynomialRoot) || Expression.has(y, Expression.ExpressionPolynomialRoot))) {
      var tmp = Expression.getComplexNumberParts(x);
      var tmp1 = Expression.getComplexNumberParts(y);
      var re = tmp.real.add(tmp1.real);
      var im = tmp.imaginary.add(tmp1.imaginary);
      if (im.equals(Expression.ZERO)) {
        return re;
      }
      if (re.equals(Expression.ZERO)) {
        return im.multiply(Expression.I);
      }
      return new Expression.Addition(re, im.multiply(Expression.I));
    }
    //!

    var i = x.summands();
    var j = y.summands();
    var a = i.next().value;
    var b = j.next().value;
    var s = [];
    //a + b, compare4Addition("a", "b") > 0
    while (a != null && b != null) {
      var c = compare4Addition(a, b);
      if (c < 0) {
        s.push(a);
        a = i.next().value;
      } else if (c > 0) {
        s.push(b);
        b = j.next().value;
      } else {
        if (Expression.has(a, Expression.Matrix) || Expression.has(b, Expression.Matrix)) {
          var last = addSimilar(a, b);
          if (!last.equals(Expression.ZERO)) {
            s.push(last);
          }
        } else {
          var constantA = getConstant(a, true);
          var constantB = getConstant(b, true);
          var termA = getTerm(a, true) || Expression.ONE;
          var termB = getTerm(b, true) || Expression.ONE;
          var constant = (termA.equals(termB) ? constantA : constantA.multiply(termA.divide(termB))).add(constantB);
          var last = termB === Expression.ONE ? constant : (constant instanceof Expression.Addition ? new Expression.Multiplication(constant, termB) : constant.multiply(termB));
          if (!last.equals(Expression.ZERO)) {
            s.push(last);
          }
        }
        a = i.next().value;
        b = j.next().value;
      }
    }
    while (a != null) {
      s.push(a);
      a = i.next().value;
    }
    while (b != null) {
      s.push(b);
      b = j.next().value;
    }
    if (s.length === 0) {
      return Expression.ZERO;
    }
    var accumulator = s[s.length - 1];
    for (var k = s.length - 2; k >= 0; k -= 1) {
      var currentValue = s[k];
      accumulator = new Addition(accumulator, currentValue);
    }
    return accumulator;
  };

  var divideByInteger = function (e, f) {
    if (f.equals(Expression.ZERO)) {
      throw new TypeError("ArithmeticException");
    }
    //var result = Expression.ZERO;
    var result = [];
    for (var iteratorx = e.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
      var rest = Expression.ONE;
      var t = undefined;
      // TODO: check, fix?
      for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
        var z = y;
        if (z instanceof Integer || z instanceof Expression.Complex || z instanceof Expression.ExpressionPolynomialRoot) {
          if (t != undefined) {
            console.warn("!");
            t = t.multiply(z);
          } else {
            t = z;
          }
        } else {
          if (rest === Expression.ONE) {
            rest = z;
          } else {
            rest = z.multiply(rest);
          }
        }
      }
      if (!(t instanceof Expression.Complex)) {
      if (!(t instanceof Integer)) {
      if (!(t instanceof Expression.ExpressionPolynomialRoot)) {
        throw new RangeError();
      }
      }
      }
      var summand = null;
      //result = result.add(t.divide(f).multiply(rest));
      if (t instanceof Expression.ExpressionPolynomialRoot) {//TODO: 
        summand = t.divide(f).multiply(rest);
        //result = result.add(summand);
      } else {
        summand = t.truncatingDivide(f).multiply(rest);
        //result = result.add(summand);
      }
      result.push(summand);
    }
    return _sum(result);
  };

  Expression.getCoefficients = function (e, v) {
    if (e.equals(Expression.ZERO)) {
      return [];
    }
    var result = [];
    for (var iteratorx = e.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
      var d = Expression.ZERO;
      var c = Expression.ONE;
      for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
        var t = y;
        for (var iteratorve = getVariableInternal(t)[globalThis.Symbol.iterator](), ve = iteratorve.next().value; ve != null; ve = iteratorve.next().value) {
          if (ve.v.equals(v)) {
            d = d.add(ve.e);
          } else {
            c = c.multiply(ve.e === Expression.ONE ? ve.v : ve.v.pow(ve.e));
          }
        }
      }
      var degree = d.toNumber();
      result.push(Object.freeze({
        degree: degree,
        coefficient: c
      }));
    }
    result.sort(function (a, b) { return b.degree - a.degree; });
    var k = -1;
    for (var i = 0; i < result.length; i += 1) {
      var x = result[i];
      if (k === -1 || x.degree !== result[k].degree) {
        k += 1;
        result[k] = {
          degree: x.degree,
          coefficient: []
        };
      }
      result[k].coefficient.push(x.coefficient);
    }
    result.length = k + 1;
    for (var i = 0; i < result.length; i += 1) {
      result[i] = {
        degree: result[i].degree,
        coefficient: _sum(result[i].coefficient)
      };
    }
    return result;
  };

  //TODO: remove
  var getFirstAdditionOperand = function (x) {
    var result = x;
    while (result instanceof Addition) {
      result = result.a;
    }
    return result;
  };
  //TODO: remove
  var getLastMultiplicationOperand = function (x) {
    var result = x;
    while (result instanceof Multiplication) {
      result = result.b;
    }
    return result;
  };

  function VIterator(v) {
    if (v == undefined) {
      throw new TypeError();
    }
    this.value = undefined;
    this.v = v;
  }
  VIterator.prototype = Object.create(Iterator.prototype);
  VIterator.prototype.next = function () {
    this.value = this.v;
    this.v = undefined;
    return this;
  };

  function VariablesIterator(v, additions) {
    if (additions == undefined) {
      throw new TypeError();
    }
    this.value = undefined;
    this.v = v;
    this.additions = additions;
  }
  VariablesIterator.prototype = Object.create(Iterator.prototype);
  VariablesIterator.prototype.next = function () {
    var x = this.additions.next().value;
    var value = null;
    if (x == null) {
      value = null;
    } else if (x instanceof Expression.Symbol) {
      value = {v: new Exponentiation(this.v, x), e: Expression.ONE};
    } else if (x instanceof Expression.NthRoot) {//!new 2019-11-30
      value = {v: new Exponentiation(this.v, x), e: Expression.ONE};
    } else if (x instanceof Expression.Exponentiation) {//!new 2019-12-01
      value = {v: new Exponentiation(this.v, x), e: Expression.ONE};
    } else if (x instanceof Multiplication && x.a instanceof Integer) {
      value = {v: new Exponentiation(this.v, x.b), e: x.a};
    } else if (x instanceof Multiplication) {
      value = {v: new Exponentiation(this.v, getTerm(x)), e: getConstant(x)};
    } else if (x instanceof Integer) {
      value = {v: this.v, e: x};
    } else if (x instanceof Expression.Division && x.a instanceof Integer && x.b instanceof Integer) {//!new 2019-06-16
      value = {v: this.v, e: x};
    } else if (x instanceof Expression.Division && x.a instanceof NthRoot && x.b instanceof Integer) {//!new 2019-12-01
      //value = {v: new Exponentiation(this.v, x.a), e: x.getDenominator()};
      value = {v: new Exponentiation(this.v, x.getNumerator()), e: Expression.ONE.divide(x.getDenominator())};
    } else if (x instanceof Expression.Division && x.a instanceof Multiplication && x.a.a instanceof Integer && x.b instanceof Integer) {//!new 2019-06-16
      if (this.v instanceof Integer) {
        value = {v: new Exponentiation(this.v, x.a.b), e: x.divide(x.a.b)};
      } else {
      value = {v: this.v, e: x};//?
      }
    } else {
      // this.v instanceof Integer &&
      // && x.a instanceof Expression.Symbol
      if (x instanceof Division && x.b instanceof Integer) {
        var t = getTerm(x.a);
        value = {v: new Exponentiation(this.v, t), e: x.divide(t)};
      } else {
        if (x instanceof Division && x.a instanceof Integer && x.b instanceof Expression.Symbol && (this.v instanceof Integer || this.v instanceof Expression.Symbol || isGoodPolynomial(this.v))) {//TODO: fix ? 2**(1/n)
          var t = Expression.ONE.divide(x.b);
          value = {v: new Exponentiation(this.v, t), e: x.divide(t)};
        } else {
      throw new RangeError();
        }
      }
    }
    this.value = value;
    return this;
  };

  function NumeratorSummandsIterator(e) {
    this.value = undefined;
    this.internal = e.getNumerator().summands();
    this.denominator = e.getDenominator();
  }
  NumeratorSummandsIterator.prototype = Object.create(Iterator.prototype);
  NumeratorSummandsIterator.prototype.next = function () {
    var next = this.internal.next().value;
    this.value = next == null ? null : next.divide(this.denominator);
    return this;
  };

  var getVariableInternal = function (t) {
    if (t instanceof Expression.ExponentiationOfMinusOne) {//TODO: ?
      return new VIterator({v: t, e: Expression.ONE});
    }
    if (t instanceof Expression.ExponentiationOfImaginaryUnit) {//TODO: ?
      return new VIterator({v: t, e: Expression.ONE});
    }
    var v = getBase(t);
    var e = getExponent(t);

    //!new 2017-05-08
    if (enableEX) {
      if (!(e instanceof Integer)) {
        var additions = new NumeratorSummandsIterator(e);
        return new VariablesIterator(v, additions);
      }
    }
    //!
    return new VIterator({v: v, e: e});
  };

  var getVariable = function (e, options) {
options = options == undefined ?  null : options;

    if (options == null || !options.avoidNthRoots) {
    //? square roots at first
    for (var iteratorx = e.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
      for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
        if (y instanceof NthRoot) {
        //TODO: assert(y instanceof Integer)
          return y;
        }
      }
    }
    //?
    }

    var result = getVariableInternal(getLastMultiplicationOperand(getFirstAdditionOperand(e))).next().value.v;
    //!?
    //if (result instanceof NthRoot) {
    //  return undefined;
    //}
    //
    if (result instanceof Expression.Complex) {
      return undefined;//?
    }
    if (result instanceof Integer) {
      return undefined;//?
    }
    if (options != null && options.avoidNthRoots) {
      if (result instanceof NthRoot) {
        return undefined;
      }
    }
    return result;
  };

  Expression.getVariable = getVariable;

  var lastMaxSize = 1;
  var integerGCD = function (x, y) {
    if (x instanceof Expression.Complex && x.real.equals(Expression.ZERO)) {
      x = x.imaginary;
    }
    if (y instanceof Expression.Complex && y.real.equals(Expression.ZERO)) {
      y = y.imaginary;
    }
    if (x instanceof Expression.Integer && y instanceof Expression.Integer) {
      if (Math.abs(y.toNumber()) >= 1/0 && Math.abs(x.toNumber()) >= 1/0) {
        var size = Math.min(x.abs().bitLength(), y.abs().bitLength());
        size = Math.pow(2, Math.ceil(Math.log2(size)));
        if (size >= 128 * 1024) {
          if (size > lastMaxSize) {
            lastMaxSize = size;
            var error = new TypeError("big size of " + "gcd" + " " + size);
            if (globalThis.onerror != null) {
              globalThis.onerror(error.message, "", 0, 0, error);
            }
          }
        }
      }
      return Expression.Integer.fromBigInt(bigIntGCD(x.value, y.value));
    }
    var a = x;
    var b = y;
    while (!b.equals(Expression.ZERO)) {
      var r = a.remainder(b);
      a = b;
      b = r;
    }
    return a;
  };

  //var getIntegerContent = function (x) {
  //  return x instanceof Expression.Complex ? integerGCD(x.real, x.imaginary) : x;
  //};

  var complexGCD = function (a, b) {//?
    if ((a instanceof Expression.ExpressionPolynomialRoot) && b instanceof Integer) {
      return b;
    }
    if (a instanceof Integer && (b instanceof Expression.ExpressionPolynomialRoot)) {
      return a;
    }
    if (a instanceof Expression.ExpressionPolynomialRoot && b instanceof Expression.ExpressionPolynomialRoot) {
      //TODO: ???
      return Expression.ONE;
    }
    // return integerGCD(getIntegerContent(a), getIntegerContent(b));
    var x = integerGCD(a, b);
    if (x instanceof Expression.Complex) {
      //TODO: ?
      if (x.real.compareTo(Expression.ZERO) === 0) {
        return x.imaginary;
      }
    }
    if (x instanceof Expression.Integer) {
      if (x.compareTo(Expression.ZERO) < 0) {
        x = x.negate();
      }
    }
    return x;
  };

  var nthRootCommonFactor = function (a, b) {
    if (a instanceof Expression.NthRoot && b instanceof Expression.NthRoot) {//TODO: ?
      // gcd(a**(1/n), b**(1/k)) = gcd(a**(lcm(n,k)/n/lcm(n,k)), b**(lcm(n,k)/k/lcm(n,k))) = gcd(a**(lcm(n,k)/n), b**(lcm(n,k)/k))**(1/lcm(n,k))
      var lcm = a.n / Math.gcd(a.n, b.n) * b.n;
      // gcd(a**n, b**k) = gcd((gcd(a, b)*a/gcd(a, b))**n, (gcd(a, b)*b/gcd(a, b))**k) = gcd(a, b)**min(n, k)
      var radicandsGCD = a.radicand.gcd(b.radicand);
      var min = Math.min(lcm / a.n, lcm / b.n);
      var g = Math.gcd(lcm, min);
      return radicandsGCD._pow(min / g)._nthRoot(lcm / g);
    }
    return null;
  };

  // http://www-troja.fjfi.cvut.cz/~liska/ca/node33.html
  var gcd = function (a, b, v) {
    if (v == undefined) {
      //!TODO: (2020-06-13)
      if (getTerm(a) instanceof Expression.NthRoot && getTerm(b) instanceof Expression.NthRoot) {//TODO: remove (?)
        return gcd(getConstant(a), getConstant(b)).multiply(gcd(a.divide(getConstant(a)), b.divide(getConstant(b))));
      }
      //?
      return complexGCD(getConstant(a, false), getConstant(b, false));
    }

    var r = getReplacement(a, getReplacement(b, v));
    if (!r.equals(v)) {
      return substitute(substitute(a, v, r, inverseReplacement(r, v)).gcd(substitute(b, v, r, inverseReplacement(r, v))), v, inverseReplacement(r, v), r);
    }

    return Polynomial.polynomialGCD(Polynomial.toPolynomial(a, v), Polynomial.toPolynomial(b, v)).calcAt(v);
  };

  // ! new 21.12.2013 (square roots)

  var getConjugateFactor = function (e) {
    var r = -1 / 0;
    for (var iteratorx = e.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
      for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
        if (y instanceof NthRoot) {
          var degree = y.degree;
          if (r < degree) {
            r = degree;
          }
          if (!(y.a instanceof Integer)) {
            r = 1 / 0;
          }
        }
      }
    }
    var p = undefined;
    for (var iteratorx = e.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
      for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
        if (y instanceof NthRoot) {
          var degree = y.degree;
          var i = y.a instanceof Integer ? y.a : null;
          if (i == null) {
            i = QuadraticInteger.toQuadraticInteger(y.a);
            if (i != null && p == undefined) {
              var pf = i.primeFactor();
              while (pf.toExpression() instanceof Expression.SquareRoot) {
                i = i.truncatingDivide(pf);
                pf = i.primeFactor();
              }
              i = pf;
            }
          }
          if (i == null) {
            throw new TypeError();
          }
          if (r === 1 / 0 && !(y.a instanceof Integer)) {
            r = degree;
          }
          if (r % degree === 0) {
            if (p == undefined) {
              p = i;
            }
            //TODO: assert(y instanceof Integer)
            if (i != null) {
              var z = integerGCD(p, i);
              if (!z.isUnit()) {
                p = z;//!
              }
              if (z.isUnit() && !(z instanceof Integer) && (p.isUnit() || i.isUnit())) {
                p = z;//?
              }
            } else {
              throw new TypeError();
            }
          }
        }
      }
    }
    //!new 2020-12-16 - ExpressionParser.parse('1/(x+cbrt(18)+cbrt(12))')
    if (p != undefined) {
      if (p instanceof Integer) {//TODO: ?
      p = p.primeFactor();
      }
    }
    //!
    return {p: p, degree: r};
  };

  // TODO: test
  var getConjugate = function (a) {
    var e = undefined;
    e = Expression.getComplexConjugate(a);
    if (e != undefined) {
      return e;
    }
    e = Expression.getNthRootConjugate(a);
    if (e != undefined) {
      if (e.equals(a) && a instanceof Addition) {
        throw new TypeError();
      }
      return e;
    }
    return undefined;
  };

  Expression.getConjugate = getConjugate;

  Expression.getConjugateExpression = function (e) {//?
    try {
      var c = Expression.getConjugate(e);
      if (c != null) {
        return Expression.getConjugateExpression(c.multiply(e));
      }
      return e;
    } catch (error) {
      //TODO: FIX!!!
      console.error(error);
    }
    return null;
  };

  var getPolynomialRelativeToNthRoot = function (e, p, r) {
    // Make a polynomial, with a variable = p**(1/r):
    var polynomial = Polynomial.of();
    for (var iteratorx = e.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
      var degree = 0;
      var coefficient = Expression.ONE;
      for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
        if (y instanceof NthRoot && (r === y.degree || r % y.degree === 0 && p instanceof Integer)) {
          var i = y.a instanceof Integer ? y.a : null;
          if (i == null) {
            i = QuadraticInteger.toQuadraticInteger(y.a);
          }
          if (i != null) {
            var j = 0;
            var a = i;
            if (p.isUnit()) {
              if (a.isUnit()) {
                j = 1;
                a = a.truncatingDivide(p);
                // a == 3+sqrt(2), p == 1+sqrt(2)
                while (a.primeFactor().equals(p)) {
                  j += 1;
                  a = a.truncatingDivide(p);
                }
              } else {
                if (!(a instanceof Integer)) {
                //TODO: ?
                //throw new TypeError();
                  var tmp = a.truncatingDivide(p);
                  if (!(tmp instanceof Expression.Integer)) {
                    if (Number.isNaN(Number(tmp.a.toString()) * Number(tmp.b.toString()))) {
                      throw new TypeError();//TODO: FIX
                    }
                  }
                  if (tmp instanceof Expression.Integer || Number(tmp.a.toString()) * Number(tmp.b.toString()) >= 0) {
                    j = 1;
                    a = tmp;
                  }
                }
              }
            } else {
              //TODO: optimize using ctz
              while (a.isDivisibleBy(p) && j < y.degree) {//?
                a = a.truncatingDivide(p);
                j += 1;
              }
            }
            a = a.toExpression();
            coefficient = coefficient.multiply(a._nthRoot(y.degree));
            degree += j * (r / y.degree);
          } else {
            throw new TypeError();
          }
        } else {
          coefficient = coefficient.multiply(y);
        }
      }
      //TODO: efficiency ?
      polynomial = polynomial.add(Polynomial.of(coefficient).shift(degree));
    }
    return polynomial;
  };

  // https://en.wikipedia.org/wiki/Conjugate_(square_roots)
  Expression.getNthRootConjugate = function (e) {
    var expression = e;
    if (e instanceof Integer) {
      //optimize to not stop the debugger at common code
      return null;
    }
    if (e instanceof NthRoot) {
      //optimize to not stop the debugger at common code
      return e._pow(e.n - 1);
    }
    if (e instanceof Multiplication && e.a instanceof Integer) {
      //optimize to not stop the debugger at common code
      return Expression.getNthRootConjugate(e.b);
    }
    //!2019-10-20 a workaround
    if (e instanceof Addition &&
        e.a instanceof Multiplication && e.a.a instanceof Integer && e.a.b instanceof CubeRoot &&
        e.b instanceof Multiplication && e.b.a instanceof Integer && e.b.b instanceof CubeRoot) {
      // (aa-ab+bb)
      return e.a._pow(2).subtract(e.a.multiply(e.b)).add(e.b._pow(2));
    }
    //!
    //?
    //if (e instanceof Expression.Exponentiation && getExponent(e).equals(Expression.ONE.divide(Expression.TWO))) {//TODO: FIX
      //return e;//?
    //}
    //?

  //TODO: fix
  //if (true) return undefined;
    var tmp = getConjugateFactor(e);
    var p = tmp.p;
    var r = tmp.degree;
    if (p == undefined) {
      return undefined;
    }
    var polynomial = getPolynomialRelativeToNthRoot(e, p, r);
    polynomial = polynomial.divideAndRemainder(Polynomial.of(polynomial.getContent()), "throw").quotient;//!new
    var n = r;
    var x = p;
    x = x.toExpression();
    var mod = Polynomial.of(Expression.ONE).shift(r).subtract(Polynomial.of(x));
    if (polynomial.hasIntegerCoefficients()) {
      if (mod.hasIntegerCoefficients()) {//TODO: !?
      //var conjugate2 = polynomial.modularInverse(mod).primitivePart();
      //return conjugate2.calcAt(x._nthRoot(n));
      }
    }
    var e = polynomial;
    var conjugate = Polynomial.of(n % 2 === 1 ? Expression.ONE : Expression.ONE.negate());
    while (e.getDegree() > 0) {
      var k = e.getDegree();
      var ak = Polynomial.of(e.getLeadingCoefficient());
      var m = Polynomial.of(Expression.ONE).shift(n - k);
      var p = e.multiply(m).subtract(ak.shift(n)).add(ak.multiply(Polynomial.of(x)));
      while (p.getDegree() >= k) {
        var d = p.getDegree();
        var lc = p.getLeadingCoefficient();
        m = m.multiply(ak);
        p = p.multiply(ak);
        var t = Polynomial.of(lc.negate()).shift(d - k);
        m = m.add(t);
        p = p.add(e.multiply(t));
      }
      e = p;
      conjugate = conjugate.multiply(m);
    }
    conjugate = conjugate.divideAndRemainder(mod).remainder;
    //TODO: 
    if (false) {
      //!new
      conjugate = conjugate.primitivePart();
      //!
      var conjugate2 = polynomial.modularInverse(mod).primitivePart();
      if (!(conjugate.equals(conjugate2) || conjugate.equals(conjugate2.negate()))) {
        var a = conjugate2.scale(conjugate2.getLeadingCoefficient().inverse());
        var b = conjugate.scale(conjugate.getLeadingCoefficient().inverse());
        if (!a.equals(b)) {
          debugger;
        }
      }
    }
    return conjugate.calcAt(x._nthRoot(n));
  };

  // without the checks
  Expression.collectLinearEquationVariables = function (e) {
    if (e instanceof Division) {
      throw new RangeError();
    }
    var list = [];
    for (var iteratorx = e.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
      var v = undefined;
      var c = Expression.ONE;
      var NO_VARIABLE = "";
      for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
        if (y instanceof Expression.Symbol && v == undefined) {
          v = y;
        } else {
          if (!(y instanceof Integer) && !(y instanceof NthRoot)) {
            if (v == undefined) {
              v = NO_VARIABLE;
            }
          }
          c = c.multiply(y);
        }
      }
      if (v == undefined) {
        v = NO_VARIABLE;
      }
      var variable = v === NO_VARIABLE ? "" : v.toString();
      list.push({c: c, v: variable});
    }
    return list;
  };

  var has = function (e, Class) {
    if (e instanceof Class) {
      return true;
    }
    if (e instanceof BinaryOperation) {
      if (e instanceof Addition) {
        while (e instanceof Addition) {
          if (has(e.b, Class)) {
            return true;
          }
          e = e.a;
        }
        return has(e, Class);
      }
      if (has(e.b, Class)) {
        return true;
      }
      return has(e.a, Class);
    }
    if (e instanceof Negation) {
      return has(e.b, Class);
    }

    if (e instanceof Expression.Function) {
      return has(e.a, Class);
    }
    return false;//?
  };
  Expression.has = has;

  var inverseReplacement = function (e, v) {
    var t = v;
    while (!e.equals(v)) {
      if (e instanceof Expression.Exponentiation && e.b instanceof Multiplication && v instanceof Exponentiation) {
        t = t.pow(e.b.a.inverse());
        e = e.pow(e.b.a.inverse());
      } else if (e instanceof Expression.Exponentiation) {
        t = t.pow(getExponent(e).inverse());
        e = getBase(e);
      } else if (e instanceof Addition) {
        if (!(e.b instanceof Integer)) {
          throw new RangeError();
        }
        t = t.subtract(e.b);
        e = e.a;
      } else if (e instanceof Multiplication) {
        if (!(e.a instanceof Integer)) {
          throw new RangeError();
        }
        t = t.divide(e.a);
        e = e.b;
      } else if (e instanceof Division) {
        if (!(e.b instanceof Integer)) {
          throw new RangeError();
        }
        t = t.multiply(e.b);
        e = e.a;
      } else {
        if ((Expression.E === e) || (e instanceof Integer && e.compareTo(Expression.ONE) > 0) && getBase(v).equals(e)) {//!new 2019-09-23
          t = t.pow(getExponent(v));
          e = v;
        } else {
          throw new TypeError();
        }
      }
    }
    return t;
  };

  var h = function (e, n, q) {
    for (var iteratorx = e.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
      for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
        if (getBase(q).equals(getBase(y))) {
          n = n.lcm(getExponent(y).getDenominator());
        }
      }
    }
    return n;
  };

  // t=sqrt(x**2+1)
  Replacement._counter = 0;
  function Replacement(from) {
    this.from = getBase(from);
    this.to = new Expression.Symbol("$t" + (++Replacement._counter)).pow(getExponent(from).getDenominator());
  }
  Replacement.prototype.apply = function (e) {
    var from = this.from;
    var to = this.to;
    var variable = getVariable(from);
    var p1 = Polynomial.toPolynomial(from.subtract(to), variable);
    
    return Expression._map(function (x) {
      if (!Expression.has(x, Expression.Division)) {
        var p2 = Polynomial.toPolynomial(x, variable);
        return p2.divideAndRemainder(p1).remainder.calcAt(variable);
      }
      return x;
    }, e);
  };
  Replacement.prototype.undo = function (e) {
    var variable = getBase(this.to);
    var r = this.from.pow(getExponent(this.to).inverse());
    return Expression._map(function (x) {
      if (x.equals(variable)) {
        return r;
      }
      return x;
    }, e);
  };
  Replacement.prototype.equals = function () {
    return true;//TODO: ?
  };

  // a^(2/3)+a^(1/3), a->a**3
  // -2*(-1)^n*3^(n/2)+2*3^(n/2), 3^n -> 3^(2*n)
  // (4*k+1)^(1/2)-1, k->(k^2-1)/4
  var getReplacement = function (e, v, originalVariable) {
    if (v instanceof Replacement) {
      return v;
    }
    for (var iteratorx = e.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
      for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
        if (y instanceof Expression.Exponentiation && (Expression.has(y.a, Expression.Symbol) || y.a instanceof Integer && y.a.compareTo(Expression.ONE) > 0) && y.b instanceof Expression.Division) {
          if (getBase(v).equals(y.a)) {
            //v = new Expression.Exponentiation(y.a, y.b.b.lcm(getExponent(v).getNumerator()));
            v = new Expression.Exponentiation(y.a, getConstant(y.b.b).lcm(getExponent(v).getNumerator()).divide(getExponent(v).getDenominator()));
          } else if (getBase(v) instanceof Expression.Symbol) {
            if ((y.a instanceof Expression.Addition && y.a.a.divide(getBase(v)) instanceof Integer && y.a.b instanceof Integer) && (y.b instanceof Division && y.b.a instanceof Integer && y.b.b instanceof Integer)) {
              var n = y.b.getDenominator();
              n = h(e, n, y);//!
              //TODO: ?
              //debugger;
              // sqrt(y.a.a + y.a.b) = t
              // k * v = y.a.a = t**2 - y.a.b
              // v = (t**2 - y.a.b) / (y.a.a / v)
              var t = getBase(v).pow(n).subtract(y.a.b).divide(y.a.a.divide(getBase(v)));
              return t;
            } else {
              //TODO: test
              //throw new TypeError();
              if (originalVariable != null && originalVariable.equals(y.a)) {
                return new Replacement(y);
              }
            }
          }
        }
      }
    }
    return v;
  };

  Expression._getReplacement = getReplacement;

  var substitute = function (e, a, b, inv) {
    if (e.equals(a)) {
      return b;
    }
    if (e instanceof Expression.Exponentiation) {
      if (e.equals(inv)) {
        return a;
      }
      if (getBase(e).equals(getBase(inv))) {//!new 2019-09-23
        return a.pow(getExponent(e).divide(getExponent(inv)));
        //TODO: add an assertion below
      }
    }

    if (e instanceof Expression.Addition) {
      return substitute(e.a, a, b, inv).add(substitute(e.b, a, b, inv));
    }
    if (e instanceof Expression.Multiplication) {
      return substitute(e.a, a, b, inv).multiply(substitute(e.b, a, b, inv));
    }
    if (e instanceof Expression.Exponentiation) {
      var x = substitute(e.a, a, b, inv);
      var y = substitute(e.b, a, b, inv);
      //console.log(x + ' ' + y + ' ' + a + ' ' + b + ' ' + inv);
      if (x instanceof Expression.Exponentiation &&
          getBase(x).equals(getBase(inv)) &&
          getExponent(inv).getDenominator().remainder(Expression.TWO).equals(Expression.ZERO)) {
        //TODO: FIX
        return getBase(x).pow(getExponent(x).multiply(y));
      }
      return x.pow(y);
    }
    //return e;

    //! for sin.js:
    if (e instanceof Division) {
      return substitute(e.a, a, b, inv).divide(substitute(e.b, a, b, inv));
    }
    if (e instanceof Expression.Sin) {
      return substitute(e.a, a, b, inv).sin();
    }
    if (e instanceof Expression.Cos) {
      return substitute(e.a, a, b, inv).cos();
    }
    return e;
  };

  Expression._substitute = substitute;

  Expression.prototype.divideExpression = function (x) {
    var y = this;

    //if (Expression.getIdentityMatrixCoefficient(x) != undefined) {
    //  if (y instanceof Expression.Matrix) {
    //    return Expression.getIdentityMatrixCoefficient(x).divide(y);
    //  }
    //  return Expression.makeIdentityMatrixWithCoefficient(Expression.getIdentityMatrixCoefficient(x).divide(y));
    //}
    //if (Expression.getIdentityMatrixCoefficient(y) != undefined) {
    //  if (x instanceof Expression.Matrix) {
    //    return x.divide(Expression.getIdentityMatrixCoefficient(y));
    //  }
    //  return Expression.makeIdentityMatrixWithCoefficient(x.divide(Expression.getIdentityMatrixCoefficient(y)));
    //}

    //if (has(x, IdentityMatrix)) {//?
    //  throw new RangeError("NotSupportedError");
    //}
    //if (has(x, MatrixSymbol)) {
    //  throw new RangeError("NotSupportedError");
    //}

if (simplifyIdentityMatrixPower) {
    if (x instanceof Multiplication && x.b instanceof IdentityMatrix) {
      return x.b.equals(y) ? x.a : x.a.divide(y).multiply(x.b);
    } else if (x instanceof IdentityMatrix) {
      return Expression.ONE.divide(y).multiply(x);
    }
    if (y instanceof Multiplication && y.b instanceof IdentityMatrix) {
      return x.divide(y.a).multiply(y.b);
    } else if (y instanceof IdentityMatrix) {
      return x.multiply(y);
    }
}

    if (has(y, MatrixSymbol)) {
      //!?
      var tmp = getBase(y) instanceof MatrixSymbol ? y.pow(Expression.ONE.negate()) : new Expression.Exponentiation(y, Expression.ONE.negate());
      if (x.equals(Expression.ONE)) {
        if (y instanceof Multiplication) {
          //!?
          //TODO: info about properties of the Matrix Inversion
          return x.multiply(Expression.ONE.divide(y.b).multiply(Expression.ONE.divide(y.a)));
        }
        if (y instanceof Addition && !has(y, Expression.Matrix)) {
          var f = Expression.simpleDivisor(y);
          if (f != null && !f.equals(Expression.ONE) && isScalar(f) && !gcd(f, y).equals(Expression.ONE)) {
            return x.multiply(Expression.ONE.divide(f).multiply(Expression.ONE.divide(y.divide(f))));
          }
        }
        return tmp;
      }
      //return x.multiply(tmp);
      //return new Expression.Multiplication(x, tmp);
      //throw new RangeError("NotSupportedError");
    }

    if (x instanceof Expression.Matrix && y instanceof Expression.Matrix) {
      // TODO: callback ???
      return new Expression.Matrix(x.matrix.multiply(y.matrix.inverse()));
    }
    if (x instanceof Expression.Matrix && y instanceof Expression) {
      //return new Expression.Matrix(x.matrix.scale(y.inverse()));
      return x.multiply(y.inverse());
    }
    if (x instanceof Expression && y instanceof Expression.Matrix) {
      if (Expression.callback != undefined) {
        Expression.callback(new Expression.Event(y.matrix.getDeterminantEventType("inverse").type, y));
      }
      //return new Expression.Matrix(y.matrix.inverse().scale(x));
      return new Expression.Matrix(y.matrix.inverse()).multiply(x);
    }

    if (y.equals(Expression.ZERO)) {
      //TODO: fix?
      throw new TypeError("ArithmeticException");
    }
    if (x.equals(Expression.ZERO)) {
      return Expression.ZERO;
    }
    if (y.equals(Expression.ONE)) {
      return x;
    }
    
    //!!! new (2021-04-05)
    // hack!
    //TODO: remove - ?
    var term = getTerm(y);
    if (term instanceof Expression.Exponentiation && getBase(term) === Expression.E && (getExponent(term) instanceof Expression.ExpressionPolynomialRoot)) {
      //if (Expression.isConstant(term.b.e)) {
        if (getTerm(x) instanceof Expression.Exponentiation && getExponent(getTerm(x)) instanceof Expression.ExpressionPolynomialRoot) {
          if ((x instanceof Expression.Exponentiation || x instanceof Expression.Multiplication) && (y instanceof Expression.Exponentiation || y instanceof Expression.Multiplication)) {
            return getExponent(getTerm(x)).subtract(getExponent(getTerm(y))).exp().multiply(getConstant(x).divide(getConstant(y)));
          }
        }
        if (getExponent(getTerm(y)).isNegative()) {
        return x.multiply(term.inverse()).divide(y.divide(term));
        }
      //}
    }
    //!!!

    //!!! new (21.12.2013)
    if (true) { //TODO: remove hack!
      var e = getConjugate(y);
      if (e != undefined) {
        if (e.equals(Expression.ONE)) {
          //!
          if (Expression.isConstant(y)) {
            return x.multiply(Expression._map(function (x) { return x instanceof NthRoot ? Expression.toPolynomialRoot(x) : x; }, y).inverse());
          }
          //!
          throw new TypeError(); // "assertion"
        }
        //TODO: fix for g+i*g
        if (e instanceof Expression.Multiplication && e.a instanceof Expression.Complex) {
          e = e.a;
        }
        return x.multiply(e).divide(y.multiply(e));
      }
    }

    if (true) {//!new 2017-11-25
      var c = Expression.getComplexConjugate(x);
      if (c != undefined) {
        var a = x.add(c).divide(Expression.TWO);
        var b = x.subtract(c).multiply(Expression.I.negate()).divide(Expression.TWO);
        var g = (a.equals(Expression.ZERO) ? y : a.gcd(y)).gcd(b)._abs();
        if (!g.equals(Expression.ONE)) {
          x = a.divide(g).add(b.divide(g).multiply(Expression.I));
          y = y.divide(g);
        }
        if (y.isNegative()) {
          x = x.negate();
          y = y.negate();
        }
        return y.equals(Expression.ONE) ? x : new Division(x, y);
      }
    }//!

    //!2020-06-07
    if (!getConstant(y).equals(y) && x.divide(getConstant(x)).equals(y.divide(getConstant(y)))) {
      return getConstant(x).divide(getConstant(y));
    }

    // check if y is instance of Integer to avoid issues with nth-roots (?) - see a test
    //TODO: investigate
    var v = y instanceof Integer ? undefined : getVariable(x);//???
    //var v = getVariable(x);//???
    //TODO: move?

    if (has(v, MatrixSymbol) && isScalar(y)) {//TODO: fix ?
      v = getVariable(y);
    }

    //!2019-06-16
    if (v != null) { // e**(1/2)
      var originalVariable = v;
      v = getVariable(v);
      var r = getReplacement(y, getReplacement(x, v, originalVariable), originalVariable);
      if (r instanceof Replacement) {
        //debugger;
        var a = r.apply(x);
        var b = r.apply(y);
        var c = a.divide(b);
        var n = r.undo(c.getNumerator());
        var d = r.undo(c.getDenominator());
        //debugger;
        return d.equals(Expression.ONE) ? n : new Expression.Division(n, d);
      }
      if (!r.equals(v)) {
        var ir = inverseReplacement(r, v);
        var a = substitute(x, v, r, ir);
        var b = substitute(y, v, r, ir);
        //console.log(a + ' ' + b);
        var t = a.divide(b);
        a = substitute(t.getNumerator(), v, ir, r);
        b = substitute(t.getDenominator(), v, ir, r);
        return b.equals(Expression.ONE) ? a : new Expression.Division(a, b);
      }
    }


    // gcd
    var px = undefined;
    var py = undefined;
    if (v != undefined) {
      px = Polynomial.toPolynomial(x, v);
      py = Polynomial.toPolynomial(y, v);
      if (px.getDegree() === 0 && py.getDegree() === 0) {
        v = undefined;
      }
    }
    if (v == undefined) {
      var g = complexGCD(getConstant(x, true), getConstant(y, true));
      if (!g.equals(Expression.ONE)) {
        x = divideByInteger(x, g);
        y = divideByInteger(y, g);
        return x.divide(y);
      }
    } else {
      //!TODO: remove - performance optimization
      var t = px.divideAndRemainder(py, "undefined");
      if (t != undefined && t.remainder.equals(Polynomial.ZERO)) {
        return t.quotient.calcAt(v);
      }
      //!
      var g = Polynomial.polynomialGCD(px, py);
      if (g.getDegree() !== 0 || !g.getLeadingCoefficient().equals(Expression.ONE)) { // g !== 1
        var x2 = px.divideAndRemainder(g, "throw").quotient;
        var y2 = py.divideAndRemainder(g, "throw").quotient;
        return x2.calcAt(v).divide(y2.calcAt(v));
      }
    }

    //var lc = getConstant(getLeadingCoefficient(y, v));
    //var lc = getConstant(getLeadingCoefficient(y, getVariable(y)));
    var lc = getConstant(getFirstAdditionOperand(y));
    if (lc.compareTo(Expression.ZERO) < 0) {
      return x.negate().divide(y.negate());
    }
    if (has(y, MatrixSymbol)) {//?
      return new Expression.Multiplication(x, new Expression.Exponentiation(y, Expression.ONE.negate()));//?
    }//?
    return new Division(x, y);
  };

  function Expression() {
    throw new TypeError("Do not call for better performance");
  }

  Expression.callback = undefined;
  Expression.Event = function (type, data, second) {
    second = second == undefined ? undefined : second;
    this.type = type;
    this.data = data;
    this.second = second;
  };

  Expression.prototype.compare4Multiplication = function (y) {
    throw new TypeError(this.toString());
  };
  Expression.prototype.compare4MultiplicationInteger = function (x) {
    throw new TypeError();
  };
  Expression.prototype.compare4MultiplicationSymbol = function (x) {
    throw new TypeError();
  };
  Expression.prototype.compare4MultiplicationNthRoot = function (x) {
    throw new TypeError();
  };

  Expression.prototype.negate = function () {
    return Expression.ONE.negate().multiply(this);
  };
  Expression.prototype.add = function (y) {
    return y.addExpression(this);
  };
  Expression.prototype.subtract = function (y) {
    return this.add(y.negate());
  };
  Expression.prototype.divide = function (y) {
    //!2019-04-22
    if (!(y instanceof Expression.Matrix)) {
      if (this.equals(y)) { //!TODO: remove - a hack to avoid some exceptions
        //if (this instanceof IdentityMatrix) {
        //  return this;
        //}
        return Expression.ONE;
      }
      if (this.equals(y.negate())) {
        return Expression.ONE.negate();
      }
    }
    return y.divideExpression(this);
  };
  Expression.prototype.multiply = function (y) {
    return y.multiplyExpression(this);
  };
  Expression.prototype.pow = function (y) {
    return y.powExpression(this);
  };
  Expression.prototype.getDenominator = function () {
    //TODO: FIX!!!!
    return this instanceof Division ? this.b : Expression.ONE;
  };
  Expression.prototype.getNumerator = function () {
    //TODO: FIX!!!!
    return this instanceof Division ? this.a : this;
  };
  Expression.prototype.inverse = function () {
    return Expression.ONE.divide(this);
  };
  Expression.prototype.exp = function () {
    return Expression.E.pow(this);
  };


  //TODO: use in Expression#getCoefficients -?
  var variables = function (e) {
    var result = [];
    for (var iteratorx = e.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
      for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
        for (var iteratorve = getVariableInternal(y)[globalThis.Symbol.iterator](), ve = iteratorve.next().value; ve != null; ve = iteratorve.next().value) {
          if (!(ve.v instanceof Integer)) {
            result.push(ve.v);
          }
        }
      }
    }
    return result;
  };

  //TODO: remove - performance optimization
  var getCommonVariable = function (x, y) {
    var a = variables(x);
    var b = variables(y);
    for (var i = 0; i < a.length; i += 1) {
      if (a[i] instanceof NthRoot) {
        return a[i];
      }
    }
    for (var i = 0; i < b.length; i += 1) {
      if (b[i] instanceof NthRoot) {
        return b[i];
      }
    }
    for (var i = 0; i < a.length; i += 1) {
      if (a[i] instanceof Addition) {
        //return variables(a[i])[0];//TODO: fix
        a = a.concat(variables(a[i]));
        a[i] = null;
      }
    }
    for (var i = 0; i < b.length; i += 1) {
      if (b[i] instanceof Addition) {
        //return variables(b[i])[0];//TODO: fix
        b = b.concat(variables(b[i]));
        b[i] = null;
      }
    }
    for (var i = 0; i < a.length; i += 1) {
      for (var j = 0; j < b.length; j += 1) {
        if (a[i] != null && b[j] != null) {
        if (a[i].equals(b[j])) {
          return a[i];
        }
        }
      }
    }
    return null;
  };

  // TODO: fix or remove ?
  Expression.prototype.gcd = function (x) {
    if (this.equals(Expression.ONE)) {
      return this;
    }
    //if (this.equals(x)) {
      //return this;//?
    //}
    if (this instanceof Integer && x instanceof Integer) {
      return integerGCD(this, x);//performance
    }
    if (!(this instanceof Integer) && !(x instanceof Integer)) {
    //TODO: fix
    //return gcd(this, x, getVariable(this) || getVariable(x));
    //TODO: remove this block (a workaround for buggy gcd)
    var t1 = getTerm(this);
    var t2 = getTerm(x);
    if (t1 != null && t2 != null && t1.equals(t2)) {
      return getConstant(this).gcd(getConstant(x)).multiply(t2);
    }
    //!2020-11-05 more workarounds:
    t1 = getTerm(getFirstAdditionOperand(this));
    t2 = getTerm(getFirstAdditionOperand(x));
    if (t1 != null && t2 != null && t1.equals(t2)) {
      var c1 = getConstant(getFirstAdditionOperand(this));
      var c2 = getConstant(getFirstAdditionOperand(x));
      if (c1 instanceof Integer && c2 instanceof Integer) {
        var alpha = c1.truncatingDivide(c2);
        if (alpha instanceof Expression.Integer && alpha.multiply(c2).equals(c1)) {
          return this.subtract(x.multiply(alpha)).gcd(x);
        }
        var alpha = c2.truncatingDivide(c1);
        if (alpha instanceof Expression.Integer && alpha.multiply(c1).equals(c2)) {
          return this.gcd(x.subtract(this.multiply(alpha)));
        }
      }
    }
    }
    if (this.equals(Expression.ZERO) || x.equals(Expression.ZERO)) {
      return this.add(x);
    }
    //!
    var result = gcd(this, x, getCommonVariable(this, x));
    return result;
  };
  // Least common multiple
  Expression.prototype.lcm = function (x) {
    if (x.equals(Expression.ONE)) {
      return this;//performance
    }
    return this.divide(this.gcd(x)).multiply(x);
  };

  //!new 2020-07-21
  Expression.prototype.polynomialGCD = function (b) {
    var a = this;

    var v = getVariableInternal(getLastMultiplicationOperand(getFirstAdditionOperand(a))).next().value.v; // avoid square roots
    if (v instanceof Expression.Symbol) {
      var r = getReplacement(a, getReplacement(b, v));
      if (!r.equals(v)) {
        return substitute(substitute(a, v, r, inverseReplacement(r, v)).polynomialGCD(substitute(b, v, r, inverseReplacement(r, v))), v, inverseReplacement(r, v), r);
      }

      return Polynomial.polynomialGCD(Polynomial.toPolynomial(a, v), Polynomial.toPolynomial(b, v)).calcAt(v);
    }
    return a.gcd(b);//?
  };

  //TODO: merge with ExpressionParser.js ?!?
  var precedence = {
    binary: {
      ".^": 5,
      "^": 5,
      "*": 3,
      "/": 3,
      "+": 2,
      "-": 2
    },
    unary: {
      "-": 5//HACK
    }
  };

  var Symbol = null;

  Expression.Symbol = function (symbol) {
    //Expression.call(this);
    this.symbol = symbol;
  };

  Expression.Symbol.prototype = Object.create(Expression.prototype);

  Expression.Symbol.prototype.compare4Multiplication = function (y) {
    return y.compare4MultiplicationSymbol(this);
  };
  Expression.Symbol.prototype.compare4MultiplicationInteger = function (x) {
    return -1;
  };
  Expression.Symbol.prototype.compare4MultiplicationSymbol = function (x) {
    return x.symbol < this.symbol ? -1 : (this.symbol < x.symbol ? +1 : 0);
  };
  Expression.Symbol.prototype.compare4MultiplicationNthRoot = function (x) {
    return -1;
  };

  Expression.Symbol.prototype.toString = function (options) {
    if (this.symbol === '\u2147') {
      return 'e';//!
    }
    return this.symbol;
  };

  Expression.Symbol.prototype._pow = function (count) {
    if (count > 1) {
      return new Expression.Exponentiation(this, Expression.Integer.fromNumber(count));
    }
    return Expression.prototype._pow.call(this, count);
  };

  Expression.prototype.addInteger = function (x) {
    return this.addExpression(x);
  };
  Expression.prototype.multiplyInteger = function (x) {
    if (x === Expression.ONE) {
      return this;
    }
    return this.multiplyExpression(x);
  };
  Expression.prototype.divideInteger = function (x) {
    return this.divideExpression(x);
  };

  var simplifyIdentityMatrixPower = true; //! TODO:

  function Integer(value) {
    //Expression.call(this);
    this.value = value;
  }

  Integer.prototype = Object.create(Expression.prototype);

  Integer.prototype.powExpression = function (x) {
    var y = this;
    if (x instanceof IdentityMatrix) {
      if (simplifyIdentityMatrixPower) {
        return new IdentityMatrix(x.symbol);
      }
    }
    if (x instanceof MatrixSymbol) {
      if (y.equals(Expression.ZERO)) {
        return Expression.ONE;
      }
      if (y.equals(Expression.ONE)) {
        return x;
      }
      return new Exponentiation(x, y);//?
    }
    //!new 2019-12-16
    if (x instanceof Exponentiation && getExponent(x) instanceof Integer && y instanceof Integer) {//? (X**2)**(-1)
      return getBase(x).pow(getExponent(x).multiply(y));
    }
    //!
    //!new 2020-03-02
    if (x instanceof Exponentiation && getTerm(getExponent(x)) instanceof Expression.Symbol) {//? (X**2)**(-1)
      return getBase(x).pow(getExponent(x).multiply(y));
    }
    //!

    if (y.compareTo(Expression.ZERO) < 0) {
      return Expression.ONE.divide(x.pow(y.negate()));
    }
    if (x instanceof Expression.Matrix) {
      if (y.compareTo(Expression.ONE) > 0) {
        if (!x.matrix.isDiagonal()) {
          if (Expression.callback != undefined) {
            Expression.callback(new Expression.Event("pow", x, new Expression.Matrix(Matrix.I(1).map(function () { return y; }))));
          }
        }
      }
      var powMatrix = function (matrix, n) {
        if (n.toNumber() > Number.MAX_SAFE_INTEGER) {
          return powMatrix(matrix, n.truncatingDivide(Expression.TWO)).pow(2).multiply(matrix.pow(n.remainder(Expression.TWO).toNumber()));
        }
        return matrix.pow(n.toNumber());
      };
      return new Expression.Matrix(powMatrix(x.matrix, y));
    }
    if (y.equals(Expression.ZERO)) {
      return Expression.ONE;
    }
    if (y.equals(Expression.ONE)) {
      return x;
    }

    if (x instanceof Expression.Symbol) {
      return new Exponentiation(x, y);
    }
    if (x instanceof Exponentiation) {
      var t = x.b.multiply(y);
      if (t.getNumerator() instanceof Integer && t.getDenominator() instanceof Integer) {//TODO: ?
        var i = t.getNumerator().truncatingDivide(t.getDenominator());
        if (i.compareTo(Expression.ZERO) > 0) {
          return x.a.pow(i).multiply(x.a.pow(t.subtract(i)));
        }
      }
      return x.a.pow(x.b.multiply(y));
    }
    if (x instanceof Integer && (x.compareTo(Expression.ZERO) === 0 || x.compareTo(Expression.ONE) === 0 || x.compareTo(Expression.ONE.negate()) === 0)) {
      return y.remainder(Expression.TWO).compareTo(Expression.ZERO) === 0 ? x.multiply(x) : x;
    }
    if (x.equals(Expression.I)) {
      y = y.remainder(Expression.TWO.add(Expression.TWO));
      return Expression.pow(x, y.toNumber());
    }
    // assert(x instanceof Operation || x instanceof Integer);
    return Expression.pow(x, y.toNumber());
  };

  Integer.prototype.compare4Multiplication = function (y) {
    return y.compare4MultiplicationInteger(this);
  };
  Integer.prototype.compare4MultiplicationInteger = function (x) {
    return x.compareTo(this);
    //return 0;
  };
  Integer.prototype.compare4MultiplicationSymbol = function (x) {
    return +1;
  };
  Integer.prototype.compare4MultiplicationNthRoot = function (x) {
    return +1;
  };

  Integer.prototype.negate = function () {
    return new Integer(SmallBigInt.unaryMinus(this.value));
  };
  Integer.prototype.isUnit = function () {
    return this.equals(Expression.ONE) || this.equals(Expression.ONE.negate());
  };
  Expression.prototype.toExpression = function () {
    return this;
  };
  Integer.prototype.compareTo = function (y) {
    if (y instanceof Expression.Integer) {
      return Math.sign(0 - SmallBigInt.toNumber(SmallBigInt.subtract(y.value, this.value)));
    }
    return Expression.prototype.compareTo.call(this, y);
  };
  Integer.prototype.abs = function () {
    return SmallBigInt.toNumber(this.value) < 0 ? this.negate() : this;
  };
  Integer.prototype.sign = function () {
    return Math.sign(SmallBigInt.toNumber(this.value));
  };
  Integer.prototype.add = function (y) {
    if (this === Expression.ZERO) {
      return y;
    }
    return y.addInteger(this);
  };
  Integer.prototype.addInteger = function (x) {
    return new Integer(SmallBigInt.add(x.value, this.value));
  };
  Integer.prototype.multiply = function (y) {
    return y.multiplyInteger(this);
  };
  Integer.prototype.multiplyInteger = function (x) {
    if (x === Expression.ONE) {
      return this;
    }
    return new Integer(SmallBigInt.multiply(x.value, this.value));
  };
  Integer.prototype.divide = function (y) {
    return y.divideInteger(this);
  };
  //! for performance only
  Integer.prototype.divideInteger = function (x) {
    var y = this;
    var a = x.value;
    var b = y.value;
    //if (a == b) { // for performance
    //  return Expression.ONE;
    //}
    if (SmallBigInt.toNumber(b) === 0) {
      //TODO: fix?
      throw new TypeError("ArithmeticException");
    }
    if (typeof b === "number" && b === 1) {
      return x;//!!!
    }
    var q = SmallBigInt.divide(a, b);
    var r = SmallBigInt.subtract(a, SmallBigInt.multiply(q, b));
    if (SmallBigInt.toNumber(r) === 0) {
      return new Integer(q);
    }
    var g = SmallBigInt.BigInt(bigIntGCD(r, b));
    //if (BigInteger.notEqual(g, Expression.ONE.value)) {
      a = SmallBigInt.divide(a, g);
      b = SmallBigInt.divide(b, g);
    //}
    if (SmallBigInt.toNumber(b) < 0) {
      a = SmallBigInt.unaryMinus(a);
      b = SmallBigInt.unaryMinus(b);
    }
    return /*BigInteger.equal(b, Expression.ONE.value) ? new Integer(a) : */new Division(new Integer(a), new Integer(b));
  };
  Integer.prototype.truncatingDivide = function (y) {
    if (y.equals(Expression.ONE)) {
      return this;
    }
    return y.truncatingDivideInteger(this);
  };
  Integer.prototype.truncatingDivideInteger = function (x) {
    var y = this;
    return new Integer(SmallBigInt.divide(x.value, y.value));
  };
  Integer.prototype.isDivisibleBy = function (y) {
    return y.isDivisibleByInteger(this);
  };
  Integer.prototype.isDivisibleByInteger = function (x) {
    return x.remainder(this).equals(Expression.ZERO);
  };
  Integer.prototype.remainder = function (y) {
    return y.remainderInteger(this);
  };
  Integer.prototype.remainderInteger = function (x) {
    var y = this;
    var r = SmallBigInt.remainder(x.value, y.value);
    return r === 1 ? Expression.ONE : new Integer(r);
  };
  Integer.prototype.primeFactor = function () {
    return integerPrimeFactor(this);
  };
  Integer.prototype.toNumber = function () {
    return SmallBigInt.toNumber(this.value);
  };
  Integer.prototype.toBigInt = function () {
    return this.value;
  };
  Integer.prototype.toString = function (options) {
    return this.value.toString();
  };
  Integer.prototype.valueOf = function () {
    console.error("!");
    //throw new TypeError("");
    return this;
  };

  Integer.fromNumber = function (n) {
    return new Integer(SmallBigInt.BigInt(n));
  };
  Integer.fromString = function (s) {
    return new Integer(SmallBigInt.BigInt(s));
  };
  Integer.fromBigInt = function (i) {
    return new Integer(SmallBigInt.BigInt(i));
  };

  Expression.ZERO = Integer.fromNumber(0);
  Expression.ONE = Integer.fromNumber(1);
  Expression.TWO = Integer.fromNumber(2);
  Expression.TEN = Integer.fromNumber(10);

  Expression.Matrix = function (matrix) {
    //Expression.call(this);
    this.matrix = matrix;
  };

  Expression.Matrix.fromArray = function (rows) {
    return new Expression.Matrix(Matrix.padRows(rows, null));
  };

  Expression.Matrix.prototype = Object.create(Expression.prototype);

  Expression.Matrix.prototype.augment = function (other) {
    return new Expression.Matrix(this.matrix.augment(other.matrix));
  };

  Expression.Matrix.prototype.equals = function (x) {
    //!new 2019-12-03
    if (x === Expression.ZERO) {
      return this.matrix.isSquare() && this.matrix.eql(this.matrix.map(function (e, i, j) {
        return Expression.ZERO;
      }));
    }
    //!
    if (!(x instanceof Expression.Matrix)) {
      return false;
    }
    return this.matrix.eql(x.matrix);
  };

  Expression.Matrix.prototype.compare4Multiplication = function (y) {
    if (y instanceof Expression.Matrix) {
      return 0;
    }
    if (y instanceof MatrixSymbol) {
      if (this.matrix.isSquare() && this.matrix.isDiagonal()) {//?
        return +1;
      }
      return -1;
    }
    return +1;
  };
  Expression.Matrix.prototype.compare4MultiplicationNthRoot = function (x) {
    return +1;
  };

  Expression.Matrix.prototype.multiply = function (y) {
    return y.multiplyMatrix(this);
  };
  Expression.prototype.multiplyMatrix = function (x) {
    var t = getIdentityMatrixCoefficient(this);
    if (t != undefined) {
      return new Expression.Matrix(x.matrix.scale(t));
    }
    if (x.equals(Expression.ZERO)) {//!TODO: TEST, TODO: sizes are lost
      return x;
    }
    return this.multiplyExpression(x);
  };
  Expression.Matrix.prototype.multiplyExpression = function (x) {
    var t = getIdentityMatrixCoefficient(x);
    if (t != undefined) {
      return new Expression.Matrix(this.matrix.scale(t));
    }
    return Expression.prototype.multiplyExpression.call(this, x);
  };
  Expression.Matrix.prototype.multiplyMatrix = function (x) {
    if (Expression.callback != undefined) {
      Expression.callback(new Expression.Event("multiply", x, this));
    }
    return new Expression.Matrix(x.matrix.multiply(this.matrix));
  };
  Expression.Matrix.prototype.compare4MultiplicationSymbol = function (x) {
    return +1;
  };
  Expression.Matrix.prototype.multiplyDivision = Expression.Matrix.prototype.multiplyExpression;
  Expression.Matrix.prototype.add = function (y) {
    return y.addMatrix(this);
  };
  Expression.Matrix.prototype.addMatrix = function (x) {
    if (Expression.callback != undefined) {
      Expression.callback(new Expression.Event("add", x, this));
    }
    return new Expression.Matrix(x.matrix.add(this.matrix));
  };

  var isScalar = function (x) {
    if (x instanceof Integer) {
      return true;
    }
    if (x instanceof Expression.Complex) {
      return true;
    }
    if (x instanceof MatrixSymbol) {
      return false;
    }
    if (x instanceof Expression.ExpressionWithPolynomialRoot) {
      //TODO: ???
      return false;//!?
    }
    if (x instanceof Expression.Symbol) {
      return true;
    }
    if (x instanceof BinaryOperation) {
      return isScalar(x.a) && isScalar(x.b);
    }
    if (x instanceof Negation) {
      return isScalar(x.b);
    }
    if (x instanceof Expression.Function) {
      return isScalar(x.a);
    }
    if (x instanceof Expression.NonSimplifiedExpression) {//TODO: ?
      return isScalar(x.unwrap());
    }
    return false;//?
  };

  Expression.isScalar = isScalar;

  var getIdentityMatrixCoefficient = function (x) {
    var t = undefined;
    if (x instanceof Multiplication && x.b instanceof IdentityMatrix) {
      t = x.a;
    } else if (x instanceof IdentityMatrix) {
      t = Expression.ONE;
    } else if (isScalar(x)) {
      t = x;
    } else if (x instanceof Addition) {
      if (Expression.has(x, IdentityMatrix)) {//TODO: fix
        var ca = getIdentityMatrixCoefficient(x.a);
        var cb = getIdentityMatrixCoefficient(x.b);
        if (ca != undefined && cb != undefined) {
          t = ca.add(cb);
        }
      }
    }
    return t;
  };

  Expression.prototype.addMatrix = function (x) {
    var t = getIdentityMatrixCoefficient(this);
    if (t != undefined) {
      //?
      if (x.matrix.isSquare()) {
        return new Expression.Matrix(Matrix.I(x.matrix.rows()).scale(t)).add(x);
      } else {
        throw new RangeError("NonSquareMatrixException");
      }
    }
    return this.addExpression(x);
  };
  Expression.Matrix.prototype.addExpression = function (x) {
    var t = getIdentityMatrixCoefficient(x);
    if (t != undefined) {
      //?
      if (this.matrix.isSquare()) {
        return this.add(new Expression.Matrix(Matrix.I(this.matrix.rows()).scale(t)));
      } else {
        throw new RangeError("NonSquareMatrixException");
      }
    }
    return Expression.prototype.addExpression.call(this, x);
  };

  Expression.Matrix.prototype.toString = function (options) {
    return this.matrix.toString(setTopLevel(true, options));
  };

  Expression.Matrix.prototype.isExact = function () {
    return this.matrix.isExact();
  };

  function BinaryOperation(a, b) {
    //Expression.call(this);
    this.a = a;
    this.b = b;
  }

  BinaryOperation.prototype = Object.create(Expression.prototype);

  BinaryOperation.prototype.isNegation = function () {
    // TODO: What about NonSimplifiedExpression(s) ?
    //if (this instanceof Multiplication && this.a instanceof NonSimplifiedExpression && this.a.e instanceof Integer && this.a.e.equals(Expression.ONE.negate())) {
    //  return true;
    //}
    return (this instanceof Multiplication && this.a instanceof Integer && this.a.equals(Expression.ONE.negate()));
  };

  var setTopLevel = function (isTopLevel, options) {
    return options == undefined ? {isTopLevel: isTopLevel} : Object.assign({}, options, {isTopLevel: isTopLevel});
  };

  Expression.setTopLevel = setTopLevel;

  BinaryOperation.prototype.toString = function (options) {
    //if (this instanceof Division && this.isNegative()) {
    //  return '-' + this.negateCarefully().toString(options);
    //}
    var a = this.a;
    var b = this.b;
    var isSubtraction = false;
    // TODO: check
    /*
    if (Expression.simplification && this instanceof Addition && a.isNegative()) {
      var tmp = b;
      b = a;
      a = tmp;
    }*/

    if (this instanceof Addition && b.isNegative()) {
      isSubtraction = true;
      b = b.negateCarefully();//?
    }
    var fa = a.getPrecedence() + (a.isRightToLeftAssociative() ? -1 : 0) < this.getPrecedence();
    var fb = this.getPrecedence() + (this.isRightToLeftAssociative() ? -1 : 0) >= b.getPrecedence();
    if (options != undefined && options.isTopLevel != undefined && options.isTopLevel === false) {
      fa = fa || a.isUnaryPlusMinus();
    }
    fb = fb || b.isUnaryPlusMinus(); // 1*-3 -> 1*(-3)
    fb = fb || (this.unwrap() instanceof Exponentiation && b.unwrap() instanceof Exponentiation); // 2^3^4
    fa = fa || (this.unwrap() instanceof Exponentiation && a.unwrap() instanceof Expression.Function); // cos(x)^(2+3)
    var s = isSubtraction ? "-" : this.getS();
    //TODO: fix spaces (matrix parsing)
    if (this.isNegation()) {
      // assert(fa === false);
      return "-" + (fb ? "(" : "") + b.toString(setTopLevel(fb, options)) + (fb ? ")" : "");
    }
    return (fa ? "(" : "") + a.toString(setTopLevel(fa || options == undefined || options.isTopLevel, options)) + (fa ? ")" : "") + s + (fb ? "(" : "") + b.toString(setTopLevel(fb, options)) + (fb ? ")" : "");
  };

  //?
  Expression.prototype.unwrap = function () {
    return this;
  };

  function Exponentiation(a, b) {
    BinaryOperation.call(this, a, b);
  }

  Exponentiation.prototype = Object.create(BinaryOperation.prototype);

  //TODO: remove - ?
  Exponentiation.prototype.compare4Multiplication = function (y) {
    return y.compare4MultiplicationExponentiation(this);
  };
  Exponentiation.prototype.compare4MultiplicationInteger = function (x) {
    return -1;
  };

  Exponentiation.prototype.compare4MultiplicationExponentiation = function (x) {
    var y = this;
    return getBase(x).compare4Multiplication(getBase(y)) || getExponent(x).compare4Multiplication(getExponent(y));
  };

  function Multiplication(a, b) {
    BinaryOperation.call(this, a, b);
  }

  Multiplication.prototype = Object.create(BinaryOperation.prototype);

  Multiplication.prototype.multiply = function (y) {
    return y.multiplyExpression(this);
  };
  //TODO:
  var compare4Multiplication2 = function (x, y) {//TODO: fix

//  && x.n !== y.n
    if (x instanceof NthRoot && y instanceof NthRoot) {//TODO: fix
      var test = x.multiply(y);
      // instanceof is needeed to avoid ExpressionWithPolynomialRoot#equals, which cause an infinite loop
      if (test instanceof Expression.Multiplication) {
        if (test.equals(new Expression.Multiplication(x, y))) {
          return -1;
        }
        if (test.equals(new Expression.Multiplication(y, x))) {
          return +1;
        }
      }
      return 0;
    }
/*
    //!2019-04-22
    if (x instanceof NthRoot && y instanceof NthRoot && x.n === y.n) {//TODO: fix
      if (x.a instanceof Integer && y.a instanceof Integer) {
        return 0;
      }
      if (x.a instanceof Addition && y.a instanceof Integer) {
        return 0;//TODO: fix
      }
      if (x.a instanceof Integer && y.a instanceof Addition) {
        return 0;//TODO: fix
      }
      // -(2^0.5+1)^0.5*(2*2^0.5+2)^0.5
      if (x.a instanceof Addition && y.a instanceof Addition) {
        return 0;//TODO: fix
      }
      // 3 and 3^n
      return compare4Multiplication(x.a, y.a);
    }
  */
    if (x instanceof Integer && y instanceof Exponentiation) {
      return -1;//?
    }
    if (x instanceof Exponentiation && y instanceof Integer) {
      return +1;//?
    }
    if (x instanceof Expression.Complex && y instanceof Exponentiation) {
      return -1;//?
    }
    if (x instanceof Exponentiation && y instanceof Expression.Complex) {
      return +1;//?
    }

    return compare4Multiplication(getBase(x), getBase(y));
  };

  function Negation(b) {
    //Expression.call(this);
    this.b = b;
  }

  Negation.prototype = Object.create(Expression.prototype);

  Expression.prototype.equalsNegation = function (x) {
    return false;
  };
  Negation.prototype.equalsNegation = function (b) {
    return this.b.equals(b.b);
  };
  Negation.prototype.equals = function (b) {
    return b.equalsNegation();
  };
  Negation.prototype.toString = function (options) {
    var b = this.b;
    var fb = this.getPrecedence() + (this.isRightToLeftAssociative() ? -1 : 0) >= b.getPrecedence();
    fb = fb || b.isUnaryPlusMinus();
    // assert(fa === false);
    return "-" + (fb ? "(" : "") + b.toString(setTopLevel(fb, options)) + (fb ? ")" : "");
  };

  function Subtraction(a, b) {
    BinaryOperation.call(this, a, b);
  }

  Subtraction.prototype = Object.create(BinaryOperation.prototype);

  Subtraction.prototype.getS = function () {
    return "-";
  };

  //

  function Addition(a, b) {
    BinaryOperation.call(this, a, b);
  }

  Addition.prototype = Object.create(BinaryOperation.prototype);
  Addition.prototype.multiply = function (y) {
    return y.multiplyAddition(this);
  };
  var _multiplyAddition = function (value, addition, fromLeft) {
    // optimization (to avoid stack overflow when addition has a lot of summands (?))
    var result = [];
    for (var iterators = addition.summands()[globalThis.Symbol.iterator](), s = iterators.next().value; s != null; s = iterators.next().value) {
      var v = fromLeft ? value.multiply(s) : s.multiply(value);
      result.push(v);
    }
    return _sum(result);
  };
  var _sum = function (summands) {
    var k = summands.length;
    while (k > 1) {
      for (var i = 0; 2 * i < k; i += 1) {
        summands[i] = 2 * i + 1 < k ? summands[2 * i + 1].add(summands[2 * i]) : summands[2 * i];
      }
      k = Math.ceil(k / 2);
    }
    return summands[0];
  };
  Expression.prototype.multiplyAddition = function (x) {
    return _multiplyAddition(this, x, false);
    //return x.a.multiply(this).add(x.b.multiply(this));
  };
  Addition.prototype.multiplyExpression = function (x) {
    return _multiplyAddition(x, this, true);
    //return x.multiply(this.a).add(x.multiply(this.b));
  };

  function Division(a, b) {
    BinaryOperation.call(this, a, b);
  }

  Division.prototype = Object.create(BinaryOperation.prototype);
  Division.prototype.multiply = function (y) {
    return y.multiplyDivision(this);
  };
  Expression.prototype.multiplyDivision = function (x) {
    return x.a.multiply(this).divide(x.b);
  };
  Division.prototype.multiplyDivision = function (x) { // for performance
    return x.a.multiply(this.a).divide(x.b.multiply(this.b));
  };
  Division.prototype.multiplyExpression = function (x) {
    return x.multiply(this.a).divide(this.b);
  };
  Division.prototype.add = function (y) {
    return y.addDivision(this);
  };
  Expression.prototype.addDivision = function (x) {
    return x.a.add(this.multiply(x.b)).divide(x.b);
  };
  Division.prototype.addDivision = function (x) {
    if (x.b.equals(this.b)) {
      return x.a.add(this.a).divide(this.b);
    }
    //return BinaryOperation.prototype.addDivision.call(this, x);
    return x.a.multiply(this.b).add(x.b.multiply(this.a)).divide(x.b.multiply(this.b));
  };
  Division.prototype.addExpression = function (x) {
    return x.multiply(this.b).add(this.a).divide(this.b);
  };
  Division.prototype.divide = function (y) {
    return this.a.divide(this.b.multiply(y));
  };
  Division.prototype.divideExpression = function (x) {
    return x.multiply(this.b).divide(this.a);
  };
  //? not needed, but looks appropriate
  Division.prototype.multiplyAddition = function (x) {
    return x.multiply(this.a).divide(this.b);
  };

  // TODO: move
  Expression.prototype.equals = function (b) {
    throw new RangeError();//?
  };
  Expression.prototype.equalsInteger = function () {
    return false;
  };
  Integer.prototype.equals = function (y) {
    // TODO: fix
    //if (y == undefined) {
    //  return false;
    //}
    if (y === Expression.ZERO) {
      if (typeof this.value === "number") {
        return this.value === 0;//TODO: ?
      }
      if (typeof SmallBigInt.BigInt(0) === "number") {
        return false;
      }
    }
    if (y === Expression.ONE) {
      if (typeof this.value === "number") {
        return this.value === 1;//TODO: ?
      }
      if (typeof SmallBigInt.BigInt(1) === "number") {
        return false;
      }
    }
    return y.equalsInteger(this);
  };
  Integer.prototype.equalsInteger = function (x) {
    return x.compareTo(this) === 0;
    // performance:
    //return x.value == this.value;
  };
  Expression.Symbol.prototype.equals = function (b) {
    return b instanceof Expression.Symbol && this.symbol === b.symbol;
  };
  BinaryOperation.prototype.equals = function (b) {
    if (b instanceof Addition && Expression.has(b, Expression.ExpressionPolynomialRoot)) { // not e^(alpha) or -1 * e^(alpha)
      console.assert(false, '!!!');
      return this.subtract(b).equals(Expression.ZERO);
    }
    if (this instanceof Addition && b instanceof Addition) {
      //HACK TO not call Expression.has each time!!! (three lines before)
      var x = this;
      var y = b;
      var i = x.summands();
      var j = y.summands();
      var a = i.next().value;
      var b = j.next().value;
      while (a != null && b != null) {
        if (!a.equals(b)) {
          return false;
        }
        a = i.next().value;
        b = j.next().value;
      }
      return a != null ? false : (b != null ? false : true);
    }
    if (b instanceof Expression.ExpressionWithPolynomialRoot || b instanceof Expression.ExpressionPolynomialRoot) {
      console.assert(false, '!!!');
      return b.equals(this);
    }
    return b instanceof BinaryOperation && this.getS() === b.getS() && this.a.equals(b.a) && this.b.equals(b.b);
  };

  function MatrixSymbol(symbol) {//TODO: only for square matrix !!!
    Expression.Symbol.call(this, symbol);
  }
  MatrixSymbol.prototype = Object.create(Expression.Symbol.prototype);

  Exponentiation.prototype.inverse = function () {
    return this.pow(Expression.ONE.negate());
  };
  MatrixSymbol.prototype.inverse = function () {//TODO: only for square matrix !!!
    return this.pow(Expression.ONE.negate());
  };
  MatrixSymbol.prototype.compare4Multiplication = function (y) {
    return y.compare4MultiplicationMatrixSymbol(this);
  };
  Expression.prototype.compare4MultiplicationMatrixSymbol = function (x) {
    return +1;
  };
  Addition.prototype.compare4MultiplicationMatrixSymbol = function (x) { // (X+{{1}})*X
    return -1;
  };
  Expression.Matrix.prototype.compare4MultiplicationMatrixSymbol = function (x) {
    return x instanceof IdentityMatrix ? +1 : -1;//?
  };
  MatrixSymbol.prototype.compare4MultiplicationMatrixSymbol = function (x) {
    var c = Expression.Symbol.prototype.compare4MultiplicationSymbol.call(this, x);
    return c === +1 ? -1 : c;
  };
  MatrixSymbol.prototype.compare4MultiplicationSymbol = function (x) {
    return -1;
  };
  MatrixSymbol.prototype.equals = function (b) {
    return b instanceof MatrixSymbol && Expression.Symbol.prototype.equals.call(this, b);
  };
  MatrixSymbol.prototype.transpose = function () {
    // quick solution:
    return new Expression.Exponentiation(this, new Expression.Symbol("T")); // TODO: fix
  };
  //...

  Expression.MatrixSymbol = MatrixSymbol;

  function IdentityMatrix(symbol) {
    MatrixSymbol.call(this, symbol);
  }
  IdentityMatrix.prototype = Object.create(MatrixSymbol.prototype);
  //IdentityMatrix.prototype.multiply = function (y) {
  //  return y.multiplyIdentityMatrix(this);
  //};

  //TODO: move to MatrixSymbol - ?
  IdentityMatrix.prototype.multiplyAddition = function (x) {
    if (isScalar(x)) {
      return new Multiplication(x, this);
    }
    return Expression.prototype.multiplyAddition.call(this, x);
  };

  //Expression.prototype.multiplyIdentityMatrix = function (x) {
  //  return this.multiplyExpression(x);
  //};
  //IdentityMatrix.prototype.multiplyIdentityMatrix = function (x) {
  //  return new IdentityMatrix(this.symbol);
  //};
  IdentityMatrix.prototype.addMatrix = function (x) {
    return x.add(new Expression.Matrix(Matrix.I(x.matrix.rows())));
  };
  IdentityMatrix.prototype.add = function (y) {
    return y.addIdentityMatrix(this);
  };
  Expression.prototype.addIdentityMatrix = function (x) {
    return this.addExpression(x);//?
  };
  Expression.Matrix.prototype.addIdentityMatrix = function (x) {
    return new Expression.Matrix(Matrix.I(this.matrix.rows())).add(this);
  };

  IdentityMatrix.prototype.multiplyDivision = function (x) {
    if (isScalar(x)) {
      return new Multiplication(x, this);
    }
    return Expression.prototype.multiplyExpression.call(this, x);
  };

  IdentityMatrix.prototype.compare4MultiplicationMatrixSymbol = function (x) {
    var y = this;
    return x instanceof IdentityMatrix ? (x.symbol < y.symbol ? -1 : (y.symbol < x.symbol ? +1 : 0)) : +1;
  };

  Expression.IdentityMatrix = IdentityMatrix;

  BinaryOperation.prototype.getS = function () {
    throw new TypeError("abstract");
  };
  Exponentiation.prototype.getS = function () {
    return "^";
  };
  Multiplication.prototype.getS = function () {
    return "*";
  };
  Negation.prototype.getS = function () {
    return "-";
  };
  Addition.prototype.getS = function () {
    return "+";
  };
  Division.prototype.getS = function () {
    return "/";
  };

  // unary argument function, fix Expression.Function#compare4Addition for multiple argument functions (!)
  Expression.Function = function (name, a) {
    //Expression.call(this);
    this.name = name;
    this.a = a;
  };
  Expression.Function.prototype = Object.create(Expression.prototype);
  Expression.Function.prototype.toString = function (options) {
    //?
    return this.name + "(" + this.a.toString(setTopLevel(true, options)) + ")";
  };
  Expression.Function.prototype.equals = function (b) {
    return b instanceof Expression.Function && this.name === b.name && this.a.equals(b.a);
  };

  Negation.prototype.isUnaryPlusMinus = function () {
    return true;
  };
  BinaryOperation.prototype.isUnaryPlusMinus = function () {
    return this.isNegation();
  };
  Expression.Function.prototype.isUnaryPlusMinus = function () {
    return false;//!
  };
  Expression.prototype.isUnaryPlusMinus = function () {
    return false;
  };
  Integer.prototype.isUnaryPlusMinus = function () {//?
    return this.compareTo(Expression.ZERO) < 0;
  };

  Negation.prototype.getPrecedence = function () {
    return precedence.unary["-"];
  };
  BinaryOperation.prototype.getPrecedence = function () {
    return this.isNegation() ? precedence.unary["-"] : precedence.binary[this.getS()];
  };
  Expression.Function.prototype.getPrecedence = function () {
    return precedence.unary["-"];
  };
  Expression.prototype.getPrecedence = function () {
    return 1000;
  };
  Integer.prototype.getPrecedence = function () {//?
    return this.compareTo(Expression.ZERO) < 0 ? precedence.unary["-"] : 1000;
  };

  //! Note: this function is more for canonical order(?) or output(?), to check if a numeric expression is negative you should use Expression#sign()
  Expression.prototype.isNegative = function () {
    var x = this;
    if (x instanceof Integer) {
      return x.compareTo(Expression.ZERO) < 0;
    }
    if (x instanceof Expression.Complex) {
      return x.real.compareTo(Expression.ZERO) < 0 || (x.real.compareTo(Expression.ZERO) === 0 && x.imaginary.compareTo(Expression.ZERO) < 0);
    }
    if (x instanceof Addition) {
      return x.a.isNegative();
      //return x.a.isNegative() && x.b.isNegative();
    }
    if (x instanceof Multiplication) {
      return x.a.isNegative() !== x.b.isNegative();
    }
    if (x instanceof Division) {
      return x.a.isNegative() !== x.b.isNegative();
    }
    if (x instanceof Negation) {
      //return !x.b.isNegative();
      return true;
    }
    if (x instanceof Expression.Radians) {
      return x.value.isNegative();
    }
    return false;
  };

  //TODO: remove
  Expression.prototype.negateCarefully = function () {
    if (this instanceof Integer) {
      return this.negate();
    }
    if (this instanceof Addition) {
      return new Addition(this.a.negateCarefully(), this.b.negateCarefully());
    }
    if (this instanceof Multiplication) {
      return this.b.isNegative() ? new Multiplication(this.a, this.b.negateCarefully()) : (this.a.negateCarefully().equals(Expression.ONE) ? this.b : new Multiplication(this.a.negateCarefully(), this.b));
    }
    if (this instanceof Division) {
      return this.b.isNegative() ? new Division(this.a, this.b.negateCarefully()) : new Division(this.a.negateCarefully(), this.b);
    }
    if (this instanceof Negation) {
      return this.b;//!
    }
    return this.negate();
  };

  // https://en.wikipedia.org/wiki/Nth_root#Simplified_form_of_a_radical_expression
  // https://en.wikipedia.org/wiki/Factorization#Sum.2Fdifference_of_two_cubes

  function NthRoot(name, a, n) {
    Expression.Function.call(this, name, a);
    this.n = n;//TODO: remove
    this.degree = n;
    this.radicand = a;
    //this.index = n;
    console.assert(name === (n === 2 ? "sqrt" : (n === 3 ? "cbrt" : n + "-root"))); // otherwise it is not unary argument function (!)
  }

  NthRoot.prototype = Object.create(Expression.Function.prototype);

  NthRoot.prototype.compare4Multiplication = function (y) {
    return y.compare4MultiplicationNthRoot(this);
  };
  NthRoot.prototype.compare4MultiplicationInteger = function (x) {
    return -1;
  };
  NthRoot.prototype.compare4MultiplicationSymbol = function (x) {
    return +1;
  };
  NthRoot.prototype.compare4MultiplicationNthRoot = function (x) {
    return x.n < this.n ? -1 : (x.n > this.n ? + 1 : 0);
  };

  NthRoot.prototype.toString = function (options) {
    var fa = this.a.getPrecedence() <= this.getPrecedence();
    return (fa ? "(" : "") + this.a.toString(setTopLevel(fa || options == undefined || options.isTopLevel, options)) + (fa ? ")" : "") + "^" + (this.n === 2 ? "0.5" : "(1/" + this.n + ")");
  };

  var isCommutative = function (e) {
    return !Expression.has(e, Expression.Matrix) && !Expression.has(e, Expression.MatrixSymbol);
  };

  NthRoot.prototype.getDegree = function () {
    console.error('deprecated');
    return this.n;
  };
  NthRoot.prototype.multiplyExpression = function (x) {
    if (x instanceof Multiplication && isCommutative(this) && this.a instanceof Expression.Integer) {//TODO: fix
      for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
        if (y instanceof NthRoot && y.a instanceof Expression.Integer && compare4Multiplication2(y, this) === 0) {
          var multiplied = false;
          var result = Expression.ONE;
          for (var iteratory1 = x.factors()[globalThis.Symbol.iterator](), y1 = iteratory1.next().value; y1 != null; y1 = iteratory1.next().value) {
            var y2 = y1;
            if (!multiplied && y === y1) {
              y2 = y.multiply(this);
              multiplied = true;
            }
            result = result.multiply(y2);
          }
          return result;
        }
      }
    }
    return Expression.prototype.multiplyExpression.call(this, x);
  };

  //function isPrime(n) {
    //if (typeof n === "bigint") {//TODO: ?
    //  return n === BigInt(primeFactor(BigInt(n.toString())).toString());
    //}
    //return n == primeFactor(n);
  //}

  function isPerfectCube(n) {
    return SmallBigInt.toNumber(SmallBigInt.subtract(SmallBigInt.exponentiate(SmallBigInt.BigInt(nthRoot(n, 3)), SmallBigInt.BigInt(3)), n)) === 0;
  }
  function isPerfectSquare(n) {
    return SmallBigInt.toNumber(SmallBigInt.subtract(SmallBigInt.exponentiate(SmallBigInt.BigInt(nthRoot(n, 2)), SmallBigInt.BigInt(2)), n)) === 0;
  }
  var makeRoot = function (i, n) {
    return n === 1 ? i : (n === 2 ? new SquareRoot(i) : (n === 3 ? new CubeRoot(i) : new NthRoot(n + "-root", i, n)));
  };
  NthRoot.makeRoot = makeRoot;

  Expression.prototype._nthRoot = function (n) {
    if (typeof n === "number") {
      if (n < 1 || n > Number.MAX_SAFE_INTEGER || Math.floor(n) !== n) {
        throw new RangeError("NotSupportedError");
      }
    } else {
      if (!(this instanceof Expression.Matrix)) {
        throw new RangeError("NotSupportedError");
      }
    }
    var x = this;

    if (n === 2) {
      if (x instanceof Addition) {
        if ((x.a instanceof SquareRoot || x.a instanceof Multiplication && x.a.a instanceof Integer && x.a.b instanceof SquareRoot) && x.b instanceof Integer) {
          // (5^0.5+3)/2 or (-5^0.5+3)/2
          var u = x.a;
          var v = x.b;
          // (a+b)^2 = aa+2ab+bb = u+v
          // 2ab = u, b = u/(2a)
          // aa+bb = v, 4aaaa - 4vaa + uu = 0
          // t = sqrt(v*v-u*u);
          // a = sqrt(v+t)/sqrt(2)
          // b = sqrt(v-t)/sqrt(2)
          var tt = v.multiply(v).subtract(u.multiply(u));
          if (tt instanceof Integer && !isPerfectSquare(tt.abs().value)) {
            tt = null;
          }
          var t = tt instanceof Integer && tt.compareTo(Expression.ZERO) >= 0 ? tt.squareRoot() : undefined;
          if (t != undefined && (t instanceof Integer)) {//?
            var aa = v.add(t);
            var a = aa.compareTo(Expression.ZERO) >= 0 ? aa.squareRoot().divide(Expression.TWO.squareRoot()) : undefined;
            if (a != undefined) {
              var b = u.divide(Expression.TWO.multiply(a));
              return a.add(b);
            }
          }
        }
        //TODO: https://brownmath.com/alge/nestrad.htm  - √(√392 + √360)
        if ((x.a instanceof SquareRoot || x.a instanceof Multiplication && x.a.a instanceof Integer && x.a.b instanceof SquareRoot) &&
            (x.b instanceof SquareRoot || x.b instanceof Multiplication && x.b.a instanceof Integer && x.b.b instanceof SquareRoot)) {
          var a = x.a;
          var b = x.b;
          var aa = a.multiply(a);
          var bb = b.multiply(b);
          var g = aa.gcd(bb).squareRoot();
          if (!g.equals(Expression.ONE)) {
            var v = a.divide(g).add(b.divide(g)).squareRoot().multiply(g.squareRoot());
            if (typeof hit === "function") {
              hit({rootFromAddition: x.toString()});
            }
            return v;
          }
        }
        if (Expression._isPositive(x)) {//?
          var tmp = getConjugateFactor(x);
          if (tmp.p != null) {
            var t = tmp.p.toExpression()._nthRoot(tmp.degree);
            var polynomial = getPolynomialRelativeToNthRoot(x, tmp.p, tmp.degree);
            var u = polynomial.getCoefficient(1).multiply(t.toExpression());
            var v = polynomial.getCoefficient(0);
            var D = v.multiply(v).subtract(u.multiply(u));
            var f1 = function (aa) {
              var tmp = aa.divide(getConstant(aa));
              var c = Expression.getConjugate(tmp);
              return c != null && c.multiply(tmp) instanceof Integer && isPerfectSquare(c.multiply(tmp).abs().toBigInt());
            };
            if (D instanceof Integer || f1(D)) {//TODO: FIX
              var sD = D.squareRoot();
              var aa = v.add(sD);
              if (aa instanceof Integer || f1(aa)) {
                //console.log('aa', aa + '');
                var a = aa.squareRoot().divide(Expression.TWO.squareRoot());
                var b = u.divide(Expression.TWO.multiply(a));
                return a.add(b);
              }
            }
          }
        } else if (Expression._isPositive(x.negate()) && n === 2) {
          return Expression.I.multiply(x.negate()._nthRoot(2));
        }
      }
    }
    if (n === 3) {//? new: 2019-08-18
      if (x instanceof Addition) {
        if ((x.a instanceof SquareRoot && x.a.a instanceof Integer || x.a instanceof Multiplication && x.a.a instanceof Integer && x.a.b instanceof SquareRoot) && x.b instanceof Integer) {
          // (5^0.5+3)/2 or (-5^0.5+3)/2
          var u = x.a;
          var v = x.b;
          var d = u.multiply(u).subtract(v.multiply(v));
          if (isPerfectCube(d.toBigInt())) {//?
            // (a+b)^3 = aaa+3aab+3bba+bbb = u+v
            // aaa+3bba = v, bb=(v-aaa)/(3a)
            // 3aab+bbb = u, b(3aa+bb)=u, b=u/(3aa+bb), bb=u**2/(3aa+bb)**2
            // (9aaa+(v-aaa))**2*(v-aaa) = 27*aaa*u**2

            // t = aaa
            // (9t+(v-t))**2*(v-t) = 27*t*u**2

            var t = new Expression.Symbol('t');
            //var eq = ExpressionParser.parse('(9t+(v-t))**2*(v-t) - 27*t*u**2', new ExpressionParser.Context(function (id) {
            //  return id === 'v' ? v : (id === 'u' ? u : (id === 't' ? t : undefined));
            //})).simplify();
            var NINE = Expression.Integer.fromNumber(9);
            var TWENTY_SEVEN = Expression.Integer.fromNumber(27);
            var eq = Expression.pow(NINE.multiply(t).add(v.subtract(t)), 2).multiply(v.subtract(t)).subtract(TWENTY_SEVEN.multiply(t).multiply(Expression.pow(u, 2)));
            var p = Polynomial.toPolynomial(eq, t);
            p = p.scale(p.getContent().inverse());
            var t = p.doRationalRootTest();
            if (t != null) {
              var a = t._nthRoot(3);
              var b = v.subtract(t).divide(a).divide(Expression.Integer.fromNumber(3))._nthRoot(2);
              return a.add(b);
            }
          }
        }
      }
    }

    //?
    if (x instanceof NthRoot) {
      if (typeof hit === "function") {
        hit({rootFromRoot: ""});
      }
      return x.a._nthRoot(x.n * n);
    }
    if (x instanceof Division || x instanceof Multiplication) {
      if (n % 2 !== 0 || x.a instanceof Integer && x.a.compareTo(Expression.ZERO) > 0 || // sqrt(-x) = sqrt(-1 * -1) = i * i = -1
                         x.b instanceof Integer && x.b.compareTo(Expression.ZERO) > 0 || //TODO: fix
                         x.a instanceof Integer && isConstant(x.b) ||
                         isConstant(x) ||
                         isPositive(x.a) ||
                         isPositive(x.b) || // -sqrt(7)
                         //isPositive(x.a.negate()) ||
                         isPositive(x.b.negate())) {
        if (x instanceof Division) {
          return x.a._nthRoot(n).divide(x.b._nthRoot(n));
        }
        if (x instanceof Multiplication) {
          return x.a._nthRoot(n).multiply(x.b._nthRoot(n));
        }
      }
    }
    var qi = x instanceof Integer ? x : null;
    var qq = QuadraticInteger.toQuadraticInteger(x);
    // sqrt(2sqrt(2)+2) "(2*2^0.5+2)^0.5"
    // sqrt(sqrt(2)+2) "(2^0.5+1)^0.5*2^(1/4)"
    // sqrt(4sqrt(2)+4) 2*(2^0.5+1)^0.5
    // sqrt(2sqrt(2)+4) (2*2^0.5+2)^0.5*2^(1/4)

    //TODO: fix for !isPrime(qq.D)
    //if (qq != null && (isPrime(qq.D) && (qq.a / Math.gcd(qq.a, qq.b)) % qq.D == 0 || !isPrime(qq.D) && qq.a % qq.D == 0 && Math.gcd(qq.a, qq.b) % qq.D != 0)) {
      //var D = Expression.Integer.fromNumber(qq.D)._nthRoot(2);
      //return D._nthRoot(n).multiply(x.divide(D)._nthRoot(n));
    //}

    //!
    if (qq == null && x instanceof Expression.Addition) {
      if (x.a instanceof Multiplication && x.b instanceof Multiplication) {
        var g = x.a.pow(Expression.TWO).gcd(x.b.pow(Expression.TWO)).squareRoot();
        if (!g.equals(Expression.ONE)) {
          return g._nthRoot(n).multiply(x.divide(g)._nthRoot(n));
        }
      }
    }
    //!

    if (qq != null) {
      if (n !== 2 && n % 2 === 0) {
        //TODO: check
        var tmp = x.squareRoot();
        if (!(tmp instanceof Expression.SquareRoot)) {
          return tmp._nthRoot(n / 2);
        }
      }
      if ((n === 2 || n === 3) && qq.isValid()) {//Note: isValid should be checked here
      //if (qq.norm() === -1 * Math.pow(Math.gcd(qq.a, qq.b), 2)) {
        if (qq.isPositive()) {
        qi = qq;
        //!new 2020-12-31
        if (qq.norm != null && Math.abs(Number(qq.norm().toString())) > Number.MAX_SAFE_INTEGER) {
          qi = null;//!
        }
        //!
        } else {
          return Expression.ONE.negate()._nthRoot(n).multiply(this.negate()._nthRoot(n));
        }
      //}
      }
    }
    if (qi != null) {
      x = qi;//TODO:
      if (x instanceof Integer && x.compareTo(Expression.ZERO) < 0) {
        if (n % 2 === 0) {
          if (n === 2) {//TODO: ?
            return Expression.I.multiply(this.negate()._nthRoot(n));
          }
          throw new RangeError("NotSupportedError");
        }
        return this.negate()._nthRoot(n).negate();
      }
      if (x.equals(Expression.ZERO)) {
        return this;
      }
      var roots = [];
      var i = x;
      while (!i.equals(Expression.ONE)) {
        var d = i.primeFactor();
        if (d instanceof QuadraticInteger) {
          if (n !== 2 && n !== 3) {
            throw new TypeError(); // "assertion"
          }
          //if (Math.abs(Number(d.norm().toString())) === 1) {//!new
          //TODO: why is it here?
          // sqrt(sqrt(2)-1) = (sqrt(2)-1)*sqrt(sqrt(2)+1)
          if (Number(d.a.toString()) < 0 && Number(d.b.toString()) > 0 || Number(d.a.toString()) > 0 && Number(d.b.toString()) < 0) {
            var a = (n % 2 === 0 ? d.abs() : d);
            return x.toExpression().divide(a.toExpression()._pow(n))._nthRoot(n).multiply(a.toExpression());
          }
          //}
          var s = d.norm();
          // https://brownmath.com/alge/nestrad.htm#SurveyDoable
          //TODO: s >= 0 - ?
          if (Number(d.b.toString()) !== 0 && Number(d.a.toString()) !== 0 && Number(s.toString()) >= 0 && isPerfectSquare(s)) {
            if (n === 2) {
            return x.toExpression().divide(d.toExpression())._nthRoot(2).multiply(d.toExpression()._nthRoot(2));
            }
          }
        }
        var ctz = i instanceof Expression.Integer && d instanceof Expression.Integer ? primeFactor._countTrailingZeros(i.value, d.value) : -1;
        var e = 0;
        if (ctz !== -1) {
          e = ctz;
          i = i.truncatingDivide(d._pow(ctz));
        } else {
        if (i.isUnit()) {
          //TODO:
          // d should be a https://en.wikipedia.org/wiki/Fundamental_unit_(number_theory)
          while (!i.equals(Expression.ONE)) {
            i = i.truncatingDivide(d);
            e += 1;
          }
        } else {
          while (i.isDivisibleBy(d)) {
            i = i.truncatingDivide(d);
            e += 1;
          }
        }
        }
        //if (ctz !== -1) {
        //  console.assert(ctz === e);
        //}
        d = d.toExpression();
        var nn = n;
        if (d instanceof NthRoot) {
          nn *= d.n;
          d = d.a;
        }
        var t = Math.gcd(nn, e);
        nn /= t;//?
        e /= t;//?

        while (e !== 0) {
          //var g = e;
          //while (nn % g !== 0) {
          //  g -= 1;
          //}
          var g = e >= nn ? nn : 1;

          var e1 = Math.floor(e / g);
          var k = Math.floor(nn / g);
          roots.push(Object.freeze({
            degree: k,
            radicand: Expression.pow(d, e1)
          }));

          e = e - g * e1; // e = e % g;
        }
      }
      var y = Expression.ONE;
      roots.sort(function (a, b) { return a.degree - b.degree; });
      var k = -1;
      for (var i = 0; i < roots.length; i += 1) {
        if (k === -1 || roots[i].degree !== roots[k].degree) {
          k += 1;
          roots[k] = roots[i];
        } else {
          roots[k] = Object.freeze({
            degree: roots[i].degree,
            radicand: roots[k].radicand.multiply(roots[i].radicand)
          });
        }
      }
      roots.length = k + 1;
      //for (var j = 1; j <= n; j += 1) {
      //}
      // `for-in` loop is used to have better performance for "a sparse array"
      var f = null;
      for (var jj = 0; jj < roots.length; jj += 1) {//TODO: fix the iteration order
          var degree = roots[jj].degree;
        if (degree !== 1) {
          var radicand = roots[jj].radicand;
          //y = y.multiply(makeRoot(radicand, j));
          var x = makeRoot(radicand, degree);
          if (y !== Expression.ONE) {
            y = new Expression.Multiplication(y, x);
          } else {
            y = x;
          }
        } else {
          f = roots[jj].radicand;
        }
      }
      if (f != null) {
        y = f.multiply(y);
      }
      return y;
    }
    if (x instanceof Expression.Matrix) {
      if (typeof hit === "function") {
        hit(n === 2 ? {squareRoot: "matrix"} : (n === 3 ? {cubeRoot: "matrix"} : {nthRoot: "Matrix^(1/" + n + ")"}));
      }
      var tmp = Expression.getEigenvalues(x.matrix);
      var eigenvalues = tmp.eigenvalues;
      var multiplicities = tmp.multiplicities;
      var N = typeof n === "number" ? Expression.Integer.fromNumber(n) : n;
      if (Expression.sum(multiplicities) === x.matrix.cols()) {
        var tmp2 = Expression.getEigenvectors(x.matrix, eigenvalues);
        var eigenvectors = tmp2.eigenvectors;
        if (eigenvectors.length === x.matrix.cols()) {
          if (!x.matrix.isDiagonal()) {
            if (Expression.callback != undefined) {
              Expression.callback(new Expression.Event("nth-root-using-diagonalization", x));
            }
            if (Expression.callback != undefined) {//TODO: remove - ?
              Expression.callback(new Expression.Event("diagonalize", x));
            }
          }
          var tmp = Expression.diagonalize(x.matrix, eigenvalues, multiplicities, eigenvectors);
          var L = tmp.L;
          var SL = L.map(function (e, i, j) {
            return i === j ? e.pow(Expression.ONE.divide(N)) : e;
          });
          return new Expression.Matrix(tmp.T.multiply(SL).multiply(tmp.T_INVERSED));
        } else {
          if (!x.matrix.isJordanMatrix()) {
            if (Expression.callback != undefined) {
              Expression.callback(new Expression.Event("nth-root-using-Jordan-normal-form", x));
            }
            if (Expression.callback != undefined) {//TODO: remove - ?
              Expression.callback(new Expression.Event("Jordan-decomposition", x));
            }
          } else {
            if (Expression.callback != undefined) {
              Expression.callback(new Expression.Event("Jordan-matrix-nth-root", x));
            }
          }
          var rootOfJordanForm = function (J, N) {
            var tmp = J.map(function (e, i, j) {
              if (i > j) {
                return Expression.ZERO;
              }
              if (i === j) {
                return J.e(i, j).pow(Expression.ONE.divide(N));
              }
              if (J.e(i, i + 1).equals(Expression.ZERO)) {
                return Expression.ZERO;
              }
              if (!J.e(i, i + 1).equals(Expression.ONE)) {
                throw new TypeError("assertion");
              }
              //if (i + 1 === j) {
                //return J.e(i, i).pow(Expression.ONE.divide(N)).divide(N.multiply(J.e(i, i)));
                //return J.e(i, i + 1).divide(N.multiply(J.e(i, i).pow(Expression.ONE.divide(N)).pow(N.subtract(Expression.ONE))));
              //}
              //return new Expression.Symbol('aa_(' + (j - i) + ',' + j + ')');
              var m = j - i;
              for (var k = 0; k < m; k += 1) {
                if (!J.e(j - 1 - k, j - k).equals(Expression.ONE)) { // outside of a block
                  return Expression.ZERO;
                }
              }
              // 1/n(1/n-1)(1/n-2)(1/n-3)/(4!*λ**4) * λ**(1/n)
              var f = Expression.ONE;
              for (var k = 0; k < m; k += 1) {
                f = f.multiply(Expression.ONE.divide(N).subtract(Expression.Integer.fromNumber(k))).divide(Expression.Integer.fromNumber(k + 1));
              }
              return f.divide(J.e(i, i)._pow(m)).multiply(J.e(i, i).pow(Expression.ONE.divide(N)));
            });

            /*
            for (var k = 2; k < J.cols(); k += 1) {
              //var x = tmp.pow(N);
              var x = new Expression.Matrix(tmp).pow(N).matrix;//!?
              tmp = tmp.map(function (e, i, j) {
                if (i + k === j) {
                  if (x.e(i, j).equals(Expression.ZERO)) {
                    return Expression.ZERO;
                  }
                  var s = new Expression.Symbol('aa_(' + (j - i) + ',' + j + ')');
                  var p = Polynomial.toPolynomial(x.e(i, j).getNumerator(), s);
                  if (p.getDegree() === 0) {
                    return x.e(i, j);
                  }
                  if (p.getDegree() !== 1) {
                    throw new TypeError("!");
                  }
                  var y = p.getCoefficient(0).negate().divide(p.getCoefficient(1));
                  return y;
                }
                return e;
              });
            }
            */
            return tmp;
          };
          var tmp = Expression.getFormaDeJordan(x.matrix, eigenvalues, multiplicities);
          var JN = rootOfJordanForm(tmp.J, N);
          //TODO: details - ?
          return new Expression.Matrix(tmp.P.multiply(JN).multiply(tmp.P_INVERSED));
        }
      }
      //TODO: using Jordan normal form -?
    }
    //!2019-04-22
    if (x instanceof Exponentiation && x.a instanceof Integer && x.a.compareTo(Expression.ZERO) > 0) {
      //if (n === 2) {//TODO:
        if (x.b instanceof Expression.Symbol) {
          if (x.a instanceof Expression.Integer && integerPrimeFactor(x.a).equals(x.a)) {
            //return new SquareRoot(x);
            return new Expression.Exponentiation(x.a, x.b.divide(Expression.Integer.fromNumber(n)));
          }
        } else {
          return x.a.pow(x.b.divide(Expression.Integer.fromNumber(n)));
        }
      //}
    }

    //!2019-16-06
    if (x instanceof Exponentiation && x.a === Expression.E) {
      return x.a.pow(x.b.divide(Expression.Integer.fromNumber(n)));
    }
    if (x instanceof Exponentiation && getBase(x) instanceof Expression.Logarithm && getBase(x).a instanceof Expression.Integer) {//TODO: ?
      return x.a.pow(x.b.divide(Expression.Integer.fromNumber(n)));
    }
    if (x instanceof IdentityMatrix) {
      if (simplifyIdentityMatrixPower) {
        return x;
      }
    }
    //!2019-17-06
    if (x instanceof Expression.Symbol) {
      return new Expression.Exponentiation(x, Expression.ONE.divide(Expression.Integer.fromNumber(n)));
    }
    if (x instanceof Exponentiation &&
        (x.a instanceof Expression.Symbol || isGoodPolynomial(x.a)) &&
        (n % 2 === 1 || (x.b.getNumerator() instanceof Integer && x.b.getNumerator().remainder(Expression.TWO).equals(Expression.ONE)))) {
      //TODO: fix condition for n % 2 === 0
      var b = x.b.divide(Expression.Integer.fromNumber(n));
      return b.equals(Expression.ONE) ? x.a : new Expression.Exponentiation(x.a, b);
    }

    //!2019-06-20
    //var v = getVariable(x);
    var v = getVariableInternal(getLastMultiplicationOperand(getFirstAdditionOperand(x))).next().value.v; // avoid square roots
    if (v instanceof Expression.Symbol || (v instanceof Expression.Logarithm && v.a instanceof Expression.Integer) && (n === 2 || n === 3 || true)) {//TODO: other n's
      var p = Polynomial.toPolynomial(x, v);
      var c = p.getContent();
      if (c.isNegative()) {
        c = c.negate();
      }
      if (isPositive(c) && !c.equals(Expression.ONE)) {
        return x.divide(c)._nthRoot(n).multiply(c._nthRoot(n));
      }
      if (p.getDegree() === 1 && p.getCoefficient(0) instanceof Integer && !p.getCoefficient(0).equals(Expression.ZERO) && p.getCoefficient(1) instanceof Integer) {
        //TODO:
        if (p.getCoefficient(1).compareTo(Expression.ZERO) > 0) {
          var N = n instanceof Expression.Symbol ? n : Expression.Integer.fromNumber(n);//TODO: ?
          return new Expression.Exponentiation(x, Expression.ONE.divide(N));
        } else {
          //!TODO: fix
          if (n % 2 !== 0) {
            return Expression.ONE.negate()._nthRoot(n).multiply(new Expression.Exponentiation(x.negate(), Expression.ONE.divide(Expression.Integer.fromNumber(n))));
          }
        }
      }
      if (p.getDegree() > 1 && !p.getCoefficient(0).equals(Expression.ZERO)) {
        //TODO: check
        var N = p.getDegree();
        var t = v.multiply(p.getCoefficient(N)._nthRoot(N)).add(p.getCoefficient(0)._nthRoot(N));
        if (x.equals(t._pow(N))) {
          //!TODO: remove
          if (N >= n && (n % 2 !== 0 || Expression._isPositive(v))) {
            return t.pow(Expression.ONE).multiply(t._pow(N - n)._nthRoot(n));
          }
          //!
          if (n % 2 !== 0 || Expression._isPositive(v)) {
            return new Expression.Exponentiation(t, Expression.Integer.fromNumber(N).divide(Expression.Integer.fromNumber(n)));
          }
        }
        //TODO: (ax+b)**(n+1)
        if (p.getDegree() > 1 && p.getSquareFreePolynomial().equals(p) && n === 2) {//TODO: fix ?
          return new Expression.Exponentiation(x, Expression.ONE.divide(Expression.Integer.fromNumber(n)));
        }
        if (p.getDegree() > 1 && n === 3) {
          var d = simpleDivisor(x);
          return x.divide(d)._nthRoot(n).multiply(d._nthRoot(n));
        }
      }
    }

    if (n % 2 !== 0 && x instanceof Expression.ExponentiationOfMinusOne) {//?
      return getBase(x).pow(getExponent(x).divide(Expression.Integer.fromNumber(n)));
    }

    if (x instanceof Addition && x.b instanceof NthRoot && x.a instanceof NthRoot) {//TODO: ? multiple operands - ?
      var g = nthRootCommonFactor(x.a, x.b);
      if (!g.equals(Expression.ONE)) {
        return g._nthRoot(n).multiply(x.divide(g)._nthRoot(n));
      }
    }

    if (x instanceof Exponentiation && n === 3 && getExponent(x).equals(Integer.fromNumber(3))) {//TODO: other degrees (?)
      return getBase(x);
    }
    if (x instanceof Exponentiation && n === 2 && getExponent(x).equals(Integer.fromNumber(2))) {//TODO: other degrees (?)
      if (isPositive(getBase(x))) {
        return getBase(x);
      }
      if (isPositive(getBase(x).negate())) {
        return getBase(x).negate();
      }
    }

    var sd = simpleDivisor(x);
    if (!sd.equals(x)) {//TODO: FIX
      //debugger;
      //console.log(sd + '');
      //console.log(isPositive(sd));
      console.log(sd.toString());
      if (isPositive(sd) && (!(sd instanceof Addition) || !(x.divide(sd) instanceof Addition))) {
        return sd._nthRoot(n).multiply(x.divide(sd)._nthRoot(n));
      }
    }

    var allowComplexSqrt = true;
    var isComplexNumber = function (x) {
      return Expression.isConstant(x) && !Expression.has(x, Expression.Sin) && !Expression.has(x, Expression.Cos);
    };
    if (typeof n === "number" && (isPositive(x) || allowComplexSqrt && isComplexNumber(x) && n === 2)) {//?TODO: FIX
      var tmp = Expression.toPolynomialRoot(makeRoot(x, n));
      if (tmp != undefined) {
        return tmp;
      }
    }
    if (typeof n === "number" && isPositive(x.negate())) {
      var tmp = Expression.toPolynomialRoot(makeRoot(x.negate(), n));
      if (tmp != undefined) {
        return tmp.negate();
      }
    }

    if (getBase(x) instanceof Expression.Symbol && getBase(x).symbol.startsWith('$t') && typeof n === "number") {
      return getBase(x).pow(getExponent(x).divide(Expression.Integer.fromNumber(n)));
    }
    
    //!new
    //TODO: remove (move)
    if (Expression.isReal(x) && typeof n === "number") {
      if (isPositive(x)) {
        return new Expression.Exponentiation(x, Expression.Integer.fromNumber(n).inverse());//?
      } else {
        debugger;
      }
    }
    //!
    
    throw new RangeError("NotSupportedError");
  };

  function SquareRoot(a) {
    NthRoot.call(this, "sqrt", a, 2);
  }

  SquareRoot.prototype = Object.create(NthRoot.prototype);
  //!
  SquareRoot.prototype.divideInteger = function (x) {
    //TODO: check
    return x.multiply(this).divide(this.a);
  };

  Expression.prototype.squareRoot = function () {
    return this._nthRoot(2);
  };

  function CubeRoot(a) {
    NthRoot.call(this, "cbrt", a, 3);
  }

  CubeRoot.prototype = Object.create(NthRoot.prototype);

  Expression.prototype.cubeRoot = function () {
    return this._nthRoot(3);
  };

  Expression.Rank = function (matrix) {
    Expression.Function.call(this, "rank", matrix);
  };
  Expression.Rank.prototype = Object.create(Expression.Function.prototype);

  Expression.prototype.rank = function () {
    var x = this;
    if (!(x instanceof Expression.Matrix)) {
      throw new RangeError("NotSupportedError:matrixArgExpected");//?
    }
    //!
    if (Expression.callback != undefined) {
      Expression.callback(new Expression.Event("rank", x));
    }
    //TODO: fix
    var cases = [];
    var rank = undefined;
    Matrix.toRowEchelonWithCallback(x.matrix, Matrix.GaussMontante, "", undefined, function (result) {
      var condition = result.condition;
      if (!condition.isTrue()) {
        var resultMatrix = result.matrix;
        cases.push(new ExpressionWithCondition(Integer.fromNumber(resultMatrix.rank()), condition));
      } else {
        rank = result.matrix.rank();
      }
    });
    if (cases.length !== 0) {
      return new Expression.Cases(cases);
    }
    //!
    return Integer.fromNumber(rank);
  };
  Expression.Determinant = function (matrix) {
    Expression.Function.call(this, "determinant", matrix);
  };
  Expression.Determinant.prototype = Object.create(Expression.Function.prototype);
  Expression.prototype.determinant = function () {
    var x = this;
    if (x instanceof Expression.Multiplication && (x.a instanceof Expression.Matrix && x.a.matrix.isSquare() || x.b instanceof Expression.Matrix && x.b.matrix.isSquare())) {
      //TODO: ?
      //if (Expression.callback != undefined) {
      //  Expression.callback(new Expression.Event("property", {url: "https://en.wikipedia.org/wiki/Determinant#Multiplicativity_and_matrix_groups", value: "det(A*B)=det(A)*det(B)"});
      //}
      return x.a.determinant().multiply(x.b.determinant());
    }
    if (x instanceof Expression.MatrixSymbol) {
      return new Expression.Determinant(x);//?
    }
    if (!(x instanceof Expression.Matrix)) {
      throw new RangeError("NotSupportedError:matrixArgExpected");//?
    }
    //!
    if (Expression.callback != undefined) {
      Expression.callback(new Expression.Event(x.matrix.getDeterminantEventType("determinant").type, x));
    }
    return x.matrix.determinant();
  };
  Expression.RowReduce = function (matrix) {
    Expression.Function.call(this, "row-reduce", matrix);
  };
  Expression.RowReduce.prototype = Object.create(Expression.Function.prototype);
  Expression.prototype.rowReduce = function () {
    var x = this;
    if (!(x instanceof Expression.Matrix)) {
      throw new RangeError("NotSupportedError:matrixArgExpected");//?
    }
    //!
    if (Expression.callback != undefined) {
      Expression.callback(new Expression.Event("row-reduce".type, x));
    }
    //TODO: Matrix.GaussMontante
    return new Expression.Matrix(x.matrix.toRowEchelon(Matrix.GaussJordan, "", null).matrix);
  };
  Expression.Transpose = function (matrix) {
    Expression.Function.call(this, "transpose", matrix);
  };
  Expression.Transpose.prototype = Object.create(Expression.Function.prototype);
  Expression.prototype.transpose = function () {
    var x = this;
    if (x instanceof Expression.Multiplication) {
      //TODO: info about properties of the Matrix Transpose
      return x.b.transpose().multiply(x.a.transpose());//TODO: ?
    }
    if (x instanceof Expression.Addition) {
      return x.a.transpose().add(x.b.transpose());
    }
    if (isScalar(x)) {
      return x;
    }
    if (!(getBase(x) instanceof MatrixSymbol) && x instanceof Expression.Exponentiation && x.b.equals(Expression.ONE.negate())) {
      //TODO: (X^-2)^T
      return x.a.transpose().pow(x.b);
    }
    if (x instanceof Expression.Exponentiation && x.b.equals(new Expression.Symbol("T"))) {
      //TODO: (X**2)^T
      return x.a;
    }
    if (getBase(x) instanceof MatrixSymbol) {
      var e = getExponent(x).multiply(new Expression.Symbol("T"));
      //TODO: ?
      var p = Polynomial.toPolynomial(e, new Expression.Symbol("T"));
      if (p.getDegree() >= 2) {
        e = e.subtract(p.getCoefficient(2).multiply(new Expression.Symbol("T")._pow(2))).add(p.getCoefficient(2));
      }
      return new Expression.Exponentiation(getBase(x), e);
    }
    if (!(x instanceof Expression.Matrix)) {
      throw new RangeError("NotSupportedError");//?
    }
    return new Expression.Matrix(x.matrix.transpose());
  };
  Expression.Adjugate = function (matrix) {
    Expression.Function.call(this, "adjugate", matrix);
  };
  Expression.Adjugate.prototype = Object.create(Expression.Function.prototype);
  Expression.prototype.adjugate = function () {
    var x = this;
    if (x instanceof Expression.Multiplication && (x.a instanceof Expression.Matrix && x.a.matrix.isSquare() || x.b instanceof Expression.Matrix && x.b.matrix.isSquare())) {
      //TODO: ?
      //if (Expression.callback != undefined) {
      //  Expression.callback(new Expression.Event("property", {url: "https://en.wikipedia.org/wiki/Adjugate_matrix#Properties", value: "adj(A*B)=adj(B)*adj(A)"}));
      //}
      return x.b.adjugate().multiply(x.a.adjugate());
    }
    if (x instanceof Expression.MatrixSymbol) {
      //TODO: ?
      //assuming x is an invertible square matrix
      return x.determinant().multiply(x.inverse());
      //TODO: ?
      //return new Expression.Cases([
      //  new ExpressionWithCondition(new Expression.Adjugate(x), Condition.TRUE.andZero(new Expression.Determinant(x))),
      //  new ExpressionWithCondition(x.determinant().multiply(x.inverse()), Condition.TRUE.andNotZero(new Expression.Determinant(x)))
      //]);
    }
    if (!(x instanceof Expression.Matrix)) {
      throw new RangeError("NotSupportedError:matrixArgExpected");//?
    }
    if (Expression.callback != undefined) {
      Expression.callback(new Expression.Event("adjugate", x));
    }
    if (x.matrix.rows() === 1 && x.matrix.cols() === 1) {
      return new Expression.Matrix(Matrix.I(1));
    }
    var det = x.matrix.determinant();
    if (det instanceof Expression.Integer) {
      return new Expression.Matrix(x.matrix.inverse().scale(det));
    }
    debugger;
    //TODO: optimize
    var C = x.matrix.map(function (element, i, j, matrix) {
      return ((i + j) - 2 * Math.floor((i + j) / 2) === 1 ? Expression.ONE.negate() : Expression.ONE).multiply(matrix.minorMatrix(i, j).determinant());
    });
    var CT = new Expression.Matrix(C.transpose());
    return CT;
  };

  Expression.NoAnswerExpression = function (matrix, name, second) {
    Expression.Function.call(this, name, matrix);
    this.second = second;
  };
  Expression.NoAnswerExpression.prototype = Object.create(Expression.Function.prototype);
  //TODO: remove secondArgument (?)
  Expression.prototype.transformNoAnswerExpression = function (name, second) {
    second = second == undefined ? undefined : second;
    if (!(this instanceof Expression.Matrix)) {
      throw new RangeError("NotSupportedError");//?
    }
    if (name === "solve") {
      if (Expression.callback != undefined) {
        Expression.callback(new Expression.Event("solve", this));
      }
    }
    return new Expression.NoAnswerExpression(this, name, second);
  };

  //Expression.NoAnswerExpression.prototype.multiplyExpression =
  //Expression.NoAnswerExpression.prototype.multiplyMatrix =
  //Expression.NoAnswerExpression.prototype.multiplySymbol =
  //Expression.NoAnswerExpression.prototype.multiplyInteger =
  Expression.NoAnswerExpression.prototype.multiply = function () {
    throw new RangeError("NotSupportedError");
  };
  Expression.NoAnswerExpression.prototype.add = function () {
    throw new RangeError("NotSupportedError");
  };

  //TODO: remove (only for second)
  Expression.NoAnswerExpression.prototype.toString = function (options) {
    if (this.second == undefined) {
      return Expression.Function.prototype.toString.call(this, options);
    }
    return this.a.toString(setTopLevel(true, options)) + " " + this.name + " " + this.second.toString(setTopLevel(true, options));
  };


  Expression.ElementWisePower = function (a, b) {
    BinaryOperation.call(this, a, b);
  };
  Expression.ElementWisePower.prototype = Object.create(BinaryOperation.prototype);
  Expression.ElementWisePower.prototype.getS = function () {
    return ".^";
  };
  Expression.prototype.elementWisePower = function (e) {
    if (!(this instanceof Expression.Matrix)) {
      throw new RangeError("NotSupportedError");//?
    }
    return new Expression.Matrix(this.matrix.map(function (element, i, j) {
      return element.pow(e);
    }));
  };

  Expression.prototype.isRightToLeftAssociative = function () {
    var x = this;
    if (x instanceof Integer) {
      return x.compareTo(Expression.ZERO) < 0;
    }
    if (x instanceof Negation) {
      return true;
    }
    if (x instanceof BinaryOperation) {
      if (x.isNegation()) {
        return true;
      }
      return x instanceof Exponentiation;
    }
    return false;
  };

  var integerPrimeFactor = function (n) {
    return Integer.fromBigInt(primeFactor(n.value));
  };

  //?
  var simpleDivisor = function (e) {
    if (e instanceof Division) {
      throw new RangeError();
    }
    if (e instanceof Expression.Matrix) {
      throw new RangeError();
    }
    if (e instanceof Expression.Symbol) {
      return e;
    }
    if (e instanceof Integer) {
      var x = e;
      var i = x.compareTo(Expression.ZERO) < 0 ? x.negate() : x;
      if (i.compareTo(Expression.ONE) > 0) {
        return integerPrimeFactor(i);
      }
      return null;
    }
    if (e instanceof Expression.Complex) {
      //TODO: (!)
      var f = e.primeFactor();
      if (!f.equals(e) && e.divide(f) instanceof Expression.Integer) {
        f = f.multiply(Expression.I);
      }
      return f;
      /*
      var g = integerGCD(e.real, e.imaginary);
      var t = simpleDivisor(g);
      if (t != null) {
        return t;
      }
      if (typeof hit === "function") {
        hit({everySimpleDivisor: e.toString()});
      }
      return e;
      */
    }
    //var v = getVariable(e);
    // To avoid square roots / nth roots:
    var v = getVariableInternal(getLastMultiplicationOperand(getFirstAdditionOperand(e))).next().value.v;
    //if (v instanceof NthRoot || v instanceof Integer || v instanceof Expression.Complex) {
    //  v = undefined;
    //}
    if (v instanceof NthRoot && v.a instanceof Integer && v.n === 2) {//TODO: ???
      var p = getPolynomialRelativeToNthRoot(e, v.a, v.n);
      var f = p.getContent();
      if (!f.equals(Expression.ONE) && !f.equals(Expression.ONE.negate())) {
        return simpleDivisor(f);
      }
    }
    if (v != undefined) {
      v = getVariable(v);//!?TODO: FIX
      var r = getReplacement(e, v);
      if (!r.equals(v)) {
        return substitute(simpleDivisor(substitute(e, v, r, inverseReplacement(r, v))), v, inverseReplacement(r, v), r);
      }

      var np = Polynomial.toPolynomial(e, v);

      var content = np.getContent();
      var t = simpleDivisor(content);
      if (t != null) {
        return t;
      }
      var c = getConstant(np.getLeadingCoefficient());
      if (c instanceof Expression.Complex && c.real.equals(Expression.ZERO)) {
        return Expression.I;//!?
      }

      //?
      if (np.getCoefficient(0).equals(Expression.ZERO)) {
        return v;
      }

      if (np.getDegree() >= 2) {
        //TODO: square free polynomial - ?
        var root = np.doRationalRootTest();
        if (root != null) {
          var t = v.multiply(root.getDenominator()).subtract(root.getNumerator());
          return t;
        }
      }

      if (np.getDegree() >= 2 && np._hasIntegerLikeCoefficients()) {
        //TODO: TEST COVERAGE (!)
        var t = np.factorize();
        if (t != null) {
          //TODO: write a test case
          return simpleDivisor(t.calcAt(v));
        }
      }

      if (np.getDegree() >= 2 && !np._hasIntegerLikeCoefficients()) {
        //TODO: TEST COVERAGE (!)
        var t = np.squareFreeFactors();
        if (t.a0.getDegree() !== 0) {
          //TODO: write a test case
          return t.a0.scale(t.a0.getLeadingCoefficient().inverse()).calcAt(v);
        }
      }
      /*
      if (np.getDegree() >= 2) {
        var roots = np.getroots();
        if (roots.length > 0) {
          var root = roots[0];
          return v.subtract(root);
        }
      }
      */

      e = np.calcAt(v);
      if (e.isNegative()) {//TODO: remove - ?
        e = e.negate();//!?
      }
      return e;
    }
    throw new RangeError();//?
  };
  Expression.simpleDivisor = simpleDivisor;

  Expression.everyDivisor = function (e, callback) {
    if (e.equals(Expression.ZERO)) {
      return true;
    }
    if (!callback(Expression.ONE)) {
      return false;
    }
    var divisors = [];
    var rec = function (start, n, s) {
      if (n >= 0) {
        var x = divisors[n];
        for (var i = start; i <= x.e; i += 1) {
          if (!rec(0, n - 1, s.multiply(Expression.pow(x.d, i)))) {
            return false;
          }
        }
      } else {
        if (!callback(s)) {
          return false;
        }
      }
      return true;
    };
    while (!e.equals(Expression.ONE) && !e.equals(Expression.ONE.negate())) {
      var d = simpleDivisor(e);
      if (divisors.length === 0 || !divisors[divisors.length - 1].d.equals(d)) {
        divisors.push({
          d: d,
          e: 0
        });
      }
      divisors[divisors.length - 1].e += 1;
      if (!rec(divisors[divisors.length - 1].e, divisors.length - 1, Expression.ONE)) {
        return false;
      }
      e = e.divide(d);
    }
    return true;
  };

  Expression.Integer = Integer;
  Expression.NthRoot = NthRoot;
  Expression.SquareRoot = SquareRoot;
  Expression.CubeRoot = CubeRoot;
  Expression.Negation = Negation;
  Expression.Subtraction = Subtraction;
  Expression.BinaryOperation = BinaryOperation;
  Expression.Exponentiation = Exponentiation;
  Expression.Multiplication = Multiplication;
  Expression.Addition = Addition;
  Expression.Division = Division;
  //TODO: remove
  Expression.pow = function (x, count) {
    return x._pow(count);
  };
  Expression.prototype._pow = function (count) {
    return pow(this, count, Expression.ONE);
  };
  Expression.Integer.prototype._pow = function (count) {
    // for performance (?)
    if (typeof count === "number" && Math.floor(count) === count && count >= 0 && count <= Number.MAX_SAFE_INTEGER) {
      return new Integer(SmallBigInt.exponentiate(this.value, SmallBigInt.BigInt(count)));
    }
    return Expression.prototype._pow.call(this, count);
  };
  Expression.Integer.prototype._nthRoot = function (n) {
    // for performance (?)
    //TODO: fix (more cases)
    if (typeof n === "number" && n === 2 && this.equals(this.abs()) && isPerfectSquare(this.value)) {
      return Integer.fromBigInt(nthRoot(this.toBigInt(), 2));
    }
    if (typeof n === "number" && n === 3 && isPerfectCube(this.value)) {
      return Integer.fromBigInt(nthRoot(this.toBigInt(), 3));
    }
    //TODO: move !!!
    if (typeof n === "number" && n === 2 && this.equals(this.abs())) {
      var x = this;
      var a = Expression.ONE;
      var s = Expression.ONE;
      while (!isPerfectSquare(x.value)) {
        var f = Integer.fromBigInt(primeFactor(x.toBigInt()));
        var multiplicity = primeFactor._countTrailingZeros(x.toBigInt(), f.toBigInt());
        x = x.divide(f._pow(multiplicity));
        if (multiplicity % 2 === 1) {
          //var g = a.gcd(f);
          //if (!g.equals(Expression.ONE)) {
          //  f = f.divide(g);
          //  a = a.divide(g);
          //  a = a.multiply(g);
          //}
          //s.push(f);
          s = s.multiply(f);
          multiplicity -= 1;
        }
        a = a.multiply(f._pow(multiplicity / 2));
      }
      return x.squareRoot().multiply(a).multiply(new SquareRoot(s));
    }
    return Expression.prototype._nthRoot.call(this, n);
  };
  Expression.Integer.prototype._isPerfectSquare = function () {
    if (this.sign() < 0) {
      return false;
    }
    return isPerfectSquare(this.value);
  };
  Integer.prototype.bitLength = function () {
    return primeFactor._bitLength(this.toBigInt());
  };
  Integer.prototype.modInverse = function (p) {
    return Expression.Integer.fromBigInt(primeFactor._modInverse(this.toBigInt(), p.toBigInt()));
  };
  // ---





  Expression.Equality = function (a, b) {
    BinaryOperation.call(this, a, b);
  };

  Expression.Equality.prototype = Object.create(BinaryOperation.prototype);
  Expression.Equality.prototype.getS = function () {
    return "=";
  };

  Expression.Inequality = function (a, b, sign) {
    BinaryOperation.call(this, a, b);
    this.sign = sign;
  };

  Expression.Inequality.prototype = Object.create(BinaryOperation.prototype);
  Expression.Inequality.prototype.getS = function () {
    return this.sign;
  };

  function AdditionIterator(e) {
    if (e == undefined) {
      throw new TypeError();
    }
    this.value = undefined;
    this.e = e;
  }
  AdditionIterator.prototype = Object.create(Iterator.prototype);
  AdditionIterator.prototype.next = function () {
    this.value = this.e instanceof Addition ? this.e.b : this.e;
    this.e = this.e instanceof Addition ? this.e.a : undefined;
    return this;
  };

  function MultiplicationIterator(e) {
    if (e == undefined) {
      throw new TypeError();
    }
    this.value = undefined;
    this.e = e;
  }
  MultiplicationIterator.prototype = Object.create(Iterator.prototype);
  MultiplicationIterator.prototype.next = function () {
    this.value = this.e instanceof Multiplication ? this.e.b : this.e;
    this.e = this.e instanceof Multiplication ? this.e.a : null;
    return this;
  };

  Expression.prototype.summands = function () {
    return new AdditionIterator(this);
  };

  Expression.prototype.factors = function () {
    return new MultiplicationIterator(this);
  };

  var splitX = function (e) {
    var scalar = undefined;
    var l = undefined;
    var r = undefined;
    var xx = undefined;
    for (var iteratorx = e.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
      //TODO: why iteration by additions - (?)
      var state = 0;
      for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
        var factor = y;
        var factorBase = getBase(y);
        var factorExponent = getExponent(y);
        /*if ((!(factorBase instanceof Integer) && !(factorBase instanceof Expression.Symbol) && !(factorBase instanceof Expression.Matrix)) ||
            !(factorExponent instanceof Integer) && !(factorExponent instanceof Expression.Symbol && factorExponent.toString() === "T")) {//TODO: fix
          throw new RangeError("NotSupportedError");
        }*/
        var s = factorBase instanceof Expression.Symbol ? factorBase.toString() : "";
        if (s === "X" && state === 0) {
          state = 1;
          xx = factor;
        } else {
          if (isScalar(factor)) {
            scalar = scalar == undefined ? factor: factor.multiply(scalar);
          } else {
            if (state === 0) {
              r = r == undefined ? factor : factor.multiply(r);
            }
            if (state === 1) {
              l = l == undefined ? factor : factor.multiply(l);
            }
          }
        }
      }
    }
    scalar = scalar == undefined ? Expression.ONE : scalar;
    return {s: scalar, l: l, r: r, x: xx};
  };
  Expression.splitX = splitX;
  var groupX = function (a, b) {
    var tmp1 = splitX(a);
    var tmp2 = splitX(b);
    var s1 = tmp1.s;
    var l1 = tmp1.l;
    var r1 = tmp1.r;
    var s2 = tmp2.s;
    var l2 = tmp2.l;
    var r2 = tmp2.r;
    if (r1 == undefined && r2 == undefined && tmp1.x.equals(tmp2.x)) {
      l1 = l1 == undefined ? new IdentityMatrix("I") : l1;
      l2 = l2 == undefined ? new IdentityMatrix("I") : l2;
      return new Multiplication(s1.multiply(l1).add(s2.multiply(l2)), tmp1.x);
    }
    if (l1 == undefined && l2 == undefined && tmp1.x.equals(tmp2.x)) {
      r1 = r1 == undefined ? new IdentityMatrix("I") : r1;
      r2 = r2 == undefined ? new IdentityMatrix("I") : r2;
      return new Multiplication(tmp1.x, s1.multiply(r1).add(s2.multiply(r2)));
    }
    return undefined;
  };

  //TODO: remove (replace with a Condition) - ?
  //?
  var getExpressionWithX = function (e) {
    if (e instanceof Division) {
      if (e.getDenominator() instanceof Expression.Integer) {
        e = e.getNumerator();//!
      } else {
        return {withX: undefined, withoutX: undefined};
      }
    }

    var withX = undefined;
    var withoutX = undefined;
    for (var iteratorx = e.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
      var summand = x;
      var hasX = false;
      for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
        var factor = y;
        var factorBase = getBase(factor);
        //!new2019-12-03
        if (factorBase instanceof Addition && getExponent(factor).isNegative()) { // (<matrix addition>)**-1 (?)
          //TODO: fix
          var q = null; // e.subtract(x)
          for (var iteratorx1 = e.summands()[globalThis.Symbol.iterator](), x1 = iteratorx1.next().value; x1 != null; x1 = iteratorx1.next().value) {
            if (x1 !== x) {
              q = q == null ? x1 : q.add(x1);
            }
          }
          var exponent = getExponent(factor).negate();
          var e1 = q.multiply(factorBase.pow(exponent)).add(x.multiply(new Expression.Exponentiation(factorBase, exponent)));
          var z2 = e1.transformEquality(Expression.ZERO);
          //TODO:
          //var tmp = Polynomial.toPolynomial(factorBase, z2.a).calcAt(z2.b);
          var variable = getExponent(z2.a) instanceof Expression.Symbol ? z2.a : getBase(z2.a);
          var tmp = Polynomial.toPolynomial(factorBase, variable).divideAndRemainder(Polynomial.toPolynomial(z2.a.subtract(z2.b), variable)).remainder.calcAt(variable);
          var d = tmp instanceof Expression.Matrix ? tmp.determinant() : null;
          if (!Expression.isConstant(d)) {//TODO: ?
            return {withX: undefined, withoutX: undefined};
          }
          if (d.equals(Expression.ZERO)) {
            return {withX: Expression.ZERO, withoutX: Expression.ONE};//TODO: no solutions
          }
          return getExpressionWithX(e1);//!hack
        }
        //!
        //!2020-06-14
        if (factorBase instanceof MatrixSymbol && getExponent(factor).isNegative()) { // (<matrix addition>)**-1 (?)
          var exponent = getExponent(factor).negate();
          // if the multiplication will "remove" the factor
          var e1 = x.b.equals(factor) ? e.multiply(factorBase.pow(exponent)) : (Array.from(factorBase.pow(exponent).multiply(x).factors()).length < Array.from(x.factors()).length ? factorBase.pow(exponent).multiply(e) : null);
          //TODO: determinant(X) != 0
          //?
          /*
          var g = null;
          for (var iteratorx = e1.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
            var y = x.factors().next().value;
            if (getBase(y) instanceof Expression.MatrixSymbol) {//TODO: FIX
              g = g == null ? y : y.gcd(g);
            } else {
              g = Expression.ONE;
            }
          }
          if (g != null && !g.equals(Expression.ONE)) {
            e1 = e1.multiply(g.inverse());//!?
          }
          */
          //?
          if (e1 != null) {
            return getExpressionWithX(e1);
          }
        }
        //!
        if (!(factorBase instanceof Integer) && !(factorBase instanceof Expression.Symbol)) {
          if (!(factorBase instanceof Expression.Matrix)) {//?
          if (!(factorBase instanceof NthRoot)) {//?TODO: remove - ?
          if (factorBase instanceof Expression.Determinant && factorBase.a.toString() === "X") {//TODO: wrong
            return {withX: null, withoutX: null};
          }
          if (Expression.has(factorBase, Expression.MatrixSymbol)) {//?
            throw new RangeError("NotSupportedError");
          }
          }
          }
        }
        if (factorBase instanceof Expression.Symbol) {
          var s = factorBase.toString();
          if (s === "X") {
            if (hasX) {
              //throw new RangeError("NotSupportedError");
              return {withX: null, withoutX: null};
            }
            hasX = true;
          }
        }
      }
      if (hasX) {
        if (withX != undefined) {
          withX = groupX(withX, summand);
          if (withX == null) {
            //throw new RangeError("NotSupportedError");
            return {withX: null, withoutX: null};
          }
          //throw new RangeError("NotSupportedError");
        } else {
          withX = summand;
        }
      }
      if (!hasX) {
        withoutX = withoutX == undefined ? summand.negate() : withoutX.subtract(summand);
      }
    }
    return {withX: withX, withoutX: withoutX};
  };

  // Some number, including e and pi
  var isConstant = function (e) {
    if (e instanceof Expression.BinaryOperation) {
      return isConstant(e.b) && isConstant(e.a);
    } else if (e instanceof Expression.Integer) {
      return true;
    } else if (e instanceof Expression.PolynomialRootSymbol) { // note: e instanceof Expression.Symbol for now (!) so this check should go first
      return true;
    } else if (e instanceof Expression.ExpressionWithPolynomialRoot) {
      return isConstant(e.e);
    } else if (e instanceof Expression.ExpressionPolynomialRoot) { // note: e instanceof Expression.Symbol for now (!) so this check should go first
      return true;
    } else if (e instanceof Expression.Symbol) {
      return e === Expression.E || e === Expression.PI;
    } else if (e instanceof Expression.Complex) {
      return true;
    } else if (e instanceof Expression.NthRoot) {
      return isConstant(e.a);
    } else if (e instanceof Expression.Sin || e instanceof Expression.Cos) {
      return isConstant(e.a);
    } else if (e instanceof Expression.Radians) {
      return isConstant(e.value);
    //TODO:
    //} else if (e instanceof Expression.Logarithm) {
    //  return isConstant(e.a);//TODO: test
    } else if (e === Expression.E || e === Expression.PI) {
      return true;
    }
    return false;
  };

  Expression.isConstant = isConstant;

  Expression.getMultivariatePolynomial = function (e) {
    if (e instanceof Expression.Division) {
      return undefined;
    }
    //var v = Expression.getVariable(e);
    // To avoid square roots / nth roots:
    var v = getVariableInternal(getLastMultiplicationOperand(getFirstAdditionOperand(e))).next().value.v;
    if (v instanceof NthRoot || v instanceof Integer || v instanceof Expression.Complex) {
      v = undefined;
    }
    if (v == undefined) {
      //throw new TypeError("undefined");
      return undefined;
    }
    //?
    if (v instanceof Expression.Addition) {
      v = getVariableInternal(getLastMultiplicationOperand(getFirstAdditionOperand(v))).next().value.v;
    }
    //?

    //TODO:
    var r = getReplacement(e, v);
    if (!r.equals(v)) {
      e = substitute(e, v, r, inverseReplacement(r, v));
      if (e instanceof Expression.Division && e.b instanceof Expression.Integer) {
        e = e.a;//!
      }
    }

    var p = Polynomial.toPolynomial(e, v);
    if (p.getDegree() === 0) {
      console.warn('Expression.getMultivariatePolynomial');
      return undefined;
    }
    //TODO: iteration by sparse coefficients
    for (var i = 0; i <= p.getDegree(); i += 1) {
      var c = p.getCoefficient(i);
      if (!isConstant(c)) {
        var pc = Expression.getMultivariatePolynomial(c);
        if (pc == undefined) {
          return undefined;
        }
      }
    }
    return {p: p.map(function (c) { return substitute(c, v, inverseReplacement(r, v), r); }), v: inverseReplacement(r, v)};
  };
  Expression.isSingleVariablePolynomial = function (e) {
    var tmp = Expression.getMultivariatePolynomial(e);
    if (tmp == null) {
      return false;
    }
    var p = tmp.p;
    //TODO: iteration by sparse coefficients
    for (var i = 0; i <= p.getDegree(); i += 1) {
      var c = p.getCoefficient(i);
      if (!isConstant(c)) {
        return false;
      }
    }
    return true;
  };

  // TODO: NotSupportedError
  Expression.prototype.transformEquality = function (b) {
    var e = this.subtract(b);
    var tmp = getExpressionWithX(e);
    var withX = tmp.withX;
    var withoutX = tmp.withoutX;
    if (withX == undefined) {
      if (e.getDenominator() instanceof Integer &&
          !(e.getNumerator() instanceof Expression.Matrix) &&
          !Expression.has(e, Expression.MatrixSymbol)) {
        if (typeof e.upgrade === "function") {//TODO:
          e = e.upgrade();
        }
        //TODO: tests
        //TODO: fix, TODO: for 'y'
        var tmpv = new Expression.Symbol('x');
        var tmp = {p: Polynomial.toPolynomial(e.getNumerator(), tmpv), v: tmpv};
        if (tmp.p.getDegree() === 0 || Expression.has(e, Expression.Function)) {//TODO: FIX!!!
          tmp = Expression.getMultivariatePolynomial(e.getNumerator());
        }
        if (tmp != undefined && tmp.v instanceof Expression.Symbol) {
          var p = tmp.p;
          var v = tmp.v;
          var m = Matrix.Zero(1, p.getDegree() + 1).map(function (e, i, j) {
            return p.getCoefficient(p.getDegree() - j);
          });
          return new Expression.NoAnswerExpression(new Expression.Matrix(m), "polynomial-roots", {polynomial: p, variable: v});
        }
      }
      if (e instanceof Expression.Matrix) {
        if (this instanceof Expression.Matrix && (b instanceof Expression.Matrix || b instanceof Expression.IdentityMatrix)) {
          return Expression.SystemOfEquations.from([{left: this, right: b}]);
        }
        //TODO: other things - ?
      }
      if (true) {//!new 2019-11-27
        //TODO: fix
        return Expression.SystemOfEquations.from([{left: this, right: b}]);
      }
      throw new RangeError("NotSupportedError");
    }

    if (withoutX == undefined) {
      withoutX = Expression.ZERO;//?
    }
    //console.log(withX.toString() + "=" + withoutX.toString());

    var left = withX;
    var right = withoutX;

    var isToTheLeft = false;
    var x = withX;
    for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
      var factor = y;
      var factorBase = getBase(factor);
      //if (!(factorBase instanceof Integer) && !(factorBase instanceof Expression.Symbol)) {
      //  if (!(factorBase instanceof Expression.Matrix)) {//?
      //    throw new RangeError("NotSupportedError");
      //  }
      //}
      var isX = false;
      if (factorBase instanceof Expression.Symbol) {
        var s = factorBase.toString();
        if (s === "X") {
          isX = true;
          isToTheLeft = true;
        }
      }
      if (!isX) {
        if (factor instanceof Expression.Matrix && (!(factor.matrix.cols() === factor.matrix.rows()) || factor.determinant().equals(Expression.ZERO))) {
          //TODO: when determinant is not constant - ?
          return Expression.SystemOfEquations.from([{left: withX, right: withoutX}]);
        }
        var f = factor.inverse();
        //  console.log(isToTheLeft, f.toString());
        if (isToTheLeft) {
          right = f.multiply(right);
          //left = f.multiply(left);
        } else {
          right = right.multiply(f);
          //left = left.multiply(f);
        }
      } else {
        left = factor;
      }
    }

    //console.log(left.toString() + "=" + right.toString());
    if (left instanceof Expression.Exponentiation && getExponent(left).equals(Expression.ONE.negate())) {//TODO: FIX!!!
      if (right instanceof Expression.Matrix && !right.determinant().equals(Expression.ZERO)) {//TODO: condition - ?
        left = left.inverse();
        right = right.inverse();
        //TODO: add a step (?)
        //console.log(left.toString() + "=" + right.toString());
      }
    }
    return new Expression.Equality(left, right);
  };

  Expression.prototype.transformInequality = function (b, sign) {//TODO: ?
    var a = this;
    /*var c = Condition.TRUE;
    if (sign === '>') {
      c = c.andGreaterZero(a.subtract(b));
    } else if (sign === '<') {
      c = c.andGreaterZero(a.subtract(b).negate());
    //} else if (sign === '>=') {
    //  c = c.andGreaterZero(a.subtract(b).negate());
    //} else if (sign === '<=') {
    //  c = c.andGreaterZero(a.subtract(b));
    } else if (sign === '!=') {
      c = c.andNotZero(a.subtract(b));
    } else {
      throw new TypeError();
    }
    */
    //return new ExpressionWithCondition(Expression.ZERO, c);//TODO: ?
    return new Expression.Inequality(a, b, sign);
  };

  Expression.simplifications = [];
  Expression.prototype.simplifyExpression = function () {
    var e = this;
    for (var i = 0; i < Expression.simplifications.length; i += 1) {
      e = Expression.simplifications[i](e);
    }
    return e;
  };

  Expression.prototype.isExact = function () {
    //TODO: it is used in diagonalization (!!!), which is not good for performance (?)
    return !Expression.has(this, Expression.PolynomialRootSymbol) && !Expression.has(this, Expression.ExpressionPolynomialRoot);
  };

  Expression.getComplexConjugate = function (e) {
    return undefined;
  };

  //Expression.Complex = function () {
  //};

  Expression.PI = new Expression.Symbol("\u03C0"); // PI
  Expression.E = new Expression.Symbol("\u2147"); // EulerNumber
  Expression.I = new Expression.Symbol("\u2148"); // ImaginaryUnit

  Expression.CIRCLE = new Expression.Symbol("○");

  Expression.prototype.addPosition = function () {
    return this;
  };

  //! 2018-09-30
  Expression.SystemOfEquations = function (equations) {
    throw new TypeError();
    this.equations = equations;
  };
  Expression.SystemOfEquations.from = function (equations) {
    return new Expression.NoAnswerExpression({matrix: null}, "system-of-equations", {equations: equations});
  };

  Expression.ExponentiationOfMinusOne = function (x, y) {
    Expression.Exponentiation.call(this, x, y);
  };
  Expression.ExponentiationOfMinusOne.prototype = Object.create(Expression.Exponentiation.prototype);
  Expression.ExponentiationOfMinusOne.prototype.divideExpression = function (x) {
    return x.multiply(this);
  };

  Expression.ExponentiationOfImaginaryUnit = function (x, y) {
    Expression.Exponentiation.call(this, x, y);
  };
  Expression.ExponentiationOfImaginaryUnit.prototype = Object.create(Expression.Exponentiation.prototype);
  Expression.ExponentiationOfImaginaryUnit.prototype.divideExpression = function (x) {
    var c = getConjugate(getBase(this)).pow(getExponent(this));
    return x.multiply(c).divide(this.multiply(c));
  };

  Expression.ExponentiationOfQuadraticInteger = function (x, y) {
    Expression.Exponentiation.call(this, x, y);
  };
  Expression.ExponentiationOfQuadraticInteger.prototype = Object.create(Expression.ExponentiationOfImaginaryUnit.prototype);
  Expression.ExponentiationOfQuadraticInteger.prototype.divideExpression = function (x) {
    return Expression.Exponentiation.prototype.divideExpression.call(this, x);
  };

  //!
  Expression.Division.prototype.negate = function () {
    return new Expression.Division(this.a.negate(), this.b);
  };

  Expression.Polynomial = function (polynomial) {
    this.polynomial = polynomial;
  };
  Expression.Polynomial.prototype = Object.create(Expression.prototype);
  Expression.Polynomial.prototype.equals = function (y) {
    return y.equalsPolynomial(this);
  };
  Expression.Polynomial.prototype.equalsPolynomial = function (x) {
    //TODO: test case
    return x.polynomial.equals(this.polynomial);
  };
  Expression.prototype.equalsPolynomial = function (x) {
    return (x.polynomial.equals(Polynomial.ZERO) && this.equals(Expression.ZERO)) || (x.polynomial.getDegree() === 0 && this.equals(x.polynomial.getCoefficient(0)));
  };
  Expression.Polynomial.prototype.multiply = function (p) {
    if (p === Expression.ONE) {
      return this;
    }
    return p.multiplyPolynomial(this);
  };
  Expression.Polynomial.prototype.multiplyPolynomial = function (x) {
    return new Expression.Polynomial(x.polynomial.multiply(this.polynomial));
  };
  Expression.Division.prototype.multiplyPolynomial = function (p) {
    return this.multiplyExpression(p);
  };
  Expression.Integer.prototype.multiplyPolynomial = function (p) {
    return new Expression.Polynomial(p.polynomial.scale(this));
  };
  Expression.Polynomial.prototype.multiplyInteger = function (x) {
    return new Expression.Polynomial(this.polynomial.scale(x));
  };
  Expression.Polynomial.prototype.divide = function (l) {
    if (l.equals(Expression.ONE)) {
      return this;
    }
    if (l.equals(Expression.ONE.negate())) {
      return this.negate();
    }
    return l.dividePolynomial(this);
  };
  Expression.Division.prototype.dividePolynomial = function (p) {
    return this.divideExpression(p);
  };
  Expression.Polynomial.prototype.dividePolynomial = function (x) {
    var y = this;
    var a = x.polynomial;
    var b = y.polynomial;
    if (a.getDegree() < 0 && b.getDegree() >= 0) {
      return new Expression.Polynomial(a);
    }
    //TODO: ?
    var tmp = a.divideAndRemainder(b);
    if (tmp.remainder.equals(Polynomial.ZERO)) {
      return new Expression.Polynomial(tmp.quotient);
    }
    var ca = a.getContent();
    if (!ca.getDenominator().equals(Expression.ONE)) {
      return y.multiply(ca.getDenominator()).dividePolynomial(x.multiply(ca.getDenominator()));
    }
    var cb = b.getContent();
    if (!cb.getDenominator().equals(Expression.ONE)) {
      return y.multiply(cb.getDenominator()).dividePolynomial(x.multiply(cb.getDenominator()));
    }
    var gcd = Polynomial.polynomialGCD(a, b);
    //TODO:
    if (y.polynomial.equals(gcd)) {
      return new Expression.Polynomial(x.polynomial.divideAndRemainder(gcd).quotient);
    }
    return new Expression.Division(new Expression.Polynomial(x.polynomial.divideAndRemainder(gcd).quotient), new Expression.Polynomial(y.polynomial.divideAndRemainder(gcd).quotient));
  };
  Expression.Polynomial.prototype.negate = function () {
    return new Expression.Polynomial(this.polynomial.negate());
  };
  Expression.Polynomial.prototype.add = function (y) {
    return y.addPolynomial(this);
  };
  Expression.Polynomial.prototype.addPolynomial = function (x) {
    return new Expression.Polynomial(x.polynomial.add(this.polynomial));
  };
  Expression.prototype.addPolynomial = function (x) {
    if (this === Expression.ZERO) {
      return x;
    }
    throw new RangeError();
  };
  Expression.Polynomial.prototype.getPrecedence = function () {
    var d = this.polynomial.getDegree();
    var count = 0;
    for (var i = 0; i <= d; i += 1) {
      if (!this.polynomial.getCoefficient(i).equals(Expression.ZERO)) {
        count += 1;
      }
    }
    return (count < 2 ? (this.polynomial.getLeadingCoefficient().equals(Expression.ONE) ? new Expression.Symbol("x") : new Expression.Multiplication(Expression.ONE, Expression.ONE)) : new Expression.Addition(Expression.ONE, Expression.ONE)).getPrecedence();
  };

  Expression.sum = function (array) {
    var count = 0;
    for (var i = 0; i < array.length; i += 1) {
      count += array[i];
    }
    return count;
  };

Expression.Multiplication.prototype.compare4Multiplication = function (y) {
  var x = this;
  if (y instanceof Addition) {//TODO: fix
    return 0 - y.compare4Multiplication(x);
  }
  var i = x.factors();
  var j = y.factors();
  var a = i.next().value;
  var b = j.next().value;
  while (a != null && b != null) {
    var c = a.compare4Multiplication(b);
    if (c !== 0) {
      return c;
    }
    a = i.next().value;
    b = j.next().value;
  }
  return a != null ? +1 : (b != null ? -1 : 0);
};

Expression.Multiplication.compare4Addition = function (x, y) {
  var i = x.factors();
  var j = y.factors();
  var a = i.next().value;
  var b = j.next().value;
  while (a != null && b != null) {
    var c = a.compare4Addition(b);
    if (c !== 0) {
      return c;
    }
    a = i.next().value;
    b = j.next().value;
  }
  return a != null ? +1 : (b != null ? -1 : 0);
};


// cos(2 * x) * cos(x)
Expression.Multiplication.prototype.compare4MultiplicationSymbol = function (x) {
  return 0 - this.compare4Multiplication(x);
};

Expression.Function.prototype.compare4Addition = function (y) {
  if (y instanceof Expression.Function) {
    return this.name < y.name ? -1 : (y.name < this.name ? +1 : this.a.compare4Addition(y.a));
  }
  if (y instanceof Multiplication) {
    var x = this;
    return Multiplication.compare4Addition(x, y);
  }
  if (y instanceof Addition) {
    var x = this;
    return Addition.compare4Addition(x, y);
  }
  return +1;
};

Expression.NthRoot.prototype.compare4Addition = function (y) {
  return y.compare4AdditionNthRoot(this);
};
Expression.prototype.compare4AdditionNthRoot = function (x) {
  return Expression.Function.prototype.compare4Addition.call(x, this);
};
Expression.NthRoot.prototype.compare4AdditionNthRoot = function (x) {
  return (this.n - x.n) || x.a.compare4Addition(this.a);
};

Expression.prototype.compare4AdditionSymbol = function (x) {
  var y = this;
  if (y instanceof Expression.Function) {
    return -1;
  }
  return Expression.prototype.compare4Addition.call(x, y);
};

Expression.Symbol.prototype.compare4Addition = function (y) {
  return y.compare4AdditionSymbol(this);
};
Expression.Symbol.prototype.compare4AdditionSymbol = function (x) { // for performance
  var y = this;
  return x.symbol < y.symbol ? -1 : (y.symbol < x.symbol ? +1 : 0);
};

Expression.Function.prototype.compare4Multiplication = function (y) {
  if (y instanceof Expression.NthRoot) {
    return +1;
  }
  if (y instanceof Expression.Function) {
    return this.name < y.name ? -1 : (y.name < this.name ? +1 : this.a.compare4Multiplication(y.a));
  }
  if (y instanceof Expression.MatrixSymbol) {
    return -1;
  }
  return +1;
};

Expression.Function.prototype.compare4MultiplicationInteger = function (x) {
  return 0 - this.compare4Multiplication(x);
};

Expression.Function.prototype.compare4MultiplicationSymbol = function (x) {
  return -1;//?
};

Expression.Function.prototype.compare4MultiplicationNthRoot = function (x) {
  return 0 - this.compare4Multiplication(x);
};

Expression.Function.prototype.pow = function (y) {
  if (this instanceof Expression.NthRoot) {
    return Expression.prototype.pow.call(this, y);
  }
  if (y instanceof Expression.Integer) {
    if (y.compareTo(Expression.ONE) > 0) {
      return new Expression.Exponentiation(this, y);
    }
    return Expression.prototype.pow.call(this, y);
  }
  throw new RangeError("NotSupportedError");
};

function ExpressionWithCondition(e, condition) {
  this.e = e;
  this.condition = condition;
}
ExpressionWithCondition.prototype = Object.create(Expression.prototype);
ExpressionWithCondition.prototype.toString = function () {
  return this.e.toString() + '; ' + this.condition.toString();
};
ExpressionWithCondition.prototype.toMathML = function (options) {
  return this.e.toMathML(options) + '<mtext>; </mtext>' + this.condition.toMathML(options);
};

ExpressionWithCondition.prototype.multiplyExpression =
ExpressionWithCondition.prototype.multiplyMatrix = function (x) {
  //TODO: apply condition - ?
  return new ExpressionWithCondition(x.multiply(this.e), this.condition);
};
ExpressionWithCondition.prototype.multiply = function (y) {
  return y.multiplyExpressionWithCondition(this);
};
ExpressionWithCondition.prototype.multiplyExpressionWithCondition = function (x) {
  throw new TypeError("TODO:");
};
Expression.prototype.multiplyExpressionWithCondition = function (x) {
  //TODO: apply condition - ?
  return new ExpressionWithCondition(x.e.multiply(this), x.condition);
};

ExpressionWithCondition.prototype.add = function (y) {
  return y.addExpressionWithCondition(this);
};
ExpressionWithCondition.prototype.addExpressionWithCondition = function (x) {
  throw new TypeError("TODO:");
};
Expression.prototype.addExpressionWithCondition = function (x) {
  //TODO: apply condition - ?
  return new ExpressionWithCondition(x.e.add(this), x.condition);
};

Expression.ExpressionWithCondition = ExpressionWithCondition;

  self.Expression = Expression;

  //TODO: ?
  Addition.prototype.compare4MultiplicationNthRoot = function (x) {
    return +1;
  };
  Multiplication.prototype.compare4MultiplicationNthRoot = function (x) {
    return -1;//TODO: ?
  };



// piecewise functions
// https://en.wikipedia.org/wiki/Piecewise
// https://en.wikibooks.org/wiki/LaTeX/Advanced_Mathematics#The_cases_environment

function Cases(cases) {
  this.cases = cases;
}

Cases.prototype = Object.create(Expression.prototype);

Cases.prototype._cross = function (x, f) {
  var y = this;
  var result = [];
  for (var i = 0; i < x.cases.length; i += 1) {
    for (var j = 0; j < y.cases.length; j += 1) {
      var condition = x.cases[i].condition.and(y.cases[j].condition);
      //TODO: check
      if (!condition.isFalse()) {
        var e = f(x.cases[i].e, y.cases[j].e);
        result.push(new ExpressionWithCondition(e, condition));
      }
    }
  }
  return new Expression.Cases(result);
};

Cases.prototype.multiply = function (y) {
  return y.multiplyCases(this);
};
Cases.prototype.multiplyCases = function (x) {
  return this._cross(x, function (a, b) {
    return a.multiply(b);
  });
};
Cases.prototype.toString = function () {//TODO: ?
  var s = '';
  for (var i = 0; i < this.cases.length; i += 1) {
    s += '(' + this.cases[i].toString() + ')' + ',';
  }
  return '{{' + s.slice(0, -1) + '}}';
};
Expression.prototype.multiplyCases = function (x) {
  var y = this;
  return new Cases(x.cases.map(function (c) {
    return c.multiply(y);
  }));
};

Cases.prototype.multiplyExpression =
Cases.prototype.multiplyMatrix = function (x) {
  return new Cases(this.cases.map(function (c) {
    return x.multiply(c);
  }));
};

Cases.prototype.add = function (y) {
  return y.addCases(this);
};
Cases.prototype.addCases = function (x) {
  return this._cross(x, function (a, b) {
    return a.add(b);
  });
};
Expression.prototype.addCases = function (x) {
  var y = this;
  return new Cases(x.cases.map(function (c) {
    return c.add(y);
  }));
};

Cases.prototype.equals = function (b) {
  var a = this;
  if (a === b) {
    return true;
  }
  if (!(b instanceof Cases)) {
    //TODO: check that zero becomes zero
    return false;
  }
  //TODO: fix
  throw new TypeError();
  //return false;
};

Cases.prototype.toMathML = function (printOptions) {
  // https://www.w3.org/TR/2006/NOTE-arabic-math-20060131/#Moroccan
  var s = '';
  s += '<mrow>';
  s += '<mo>{</mo>';
  s += '<mtable rowspacing="0ex" columnalign="left">';
  for (var i = 0; i < this.cases.length; i += 1) {
    var x = this.cases[i];
    s += '<mtr>';
    s += '<mtd>';
    s += x.e.toMathML(printOptions);
    s += '</mtd>';
    s += '<mtd>';
    // <mtext> if </mtext> - ?
    s += x.condition.toMathML(printOptions);
    s += '</mtd>';
    s += '</mtr>';
  }
  s += '</mtable>';
  s += '</mrow>';
  return s;
};

Expression.Cases = Cases;


Expression.Factorial = function (n) {
  this.n = n;
};
Expression.Factorial.prototype = Object.create(Expression.prototype);

Expression.prototype.factorial = function () {
  //a = a.unwrap();
  var n = this;
  if (!(n instanceof Expression.Integer)) {
    throw new TypeError("NotSupportedError");
  }
  if (n.compareTo(Expression.ZERO) < 0) {
    throw new TypeError("NotSupportedError");
  }
  var f = Expression.ONE;
  for (var i = n; i.compareTo(Expression.ONE) >= 0; i = i.subtract(Expression.ONE)) {
    f = f.multiply(i);
  }
  return f;
};

Expression.prototype._abs = function () {
  return this.isNegative() ? this.negate() : this;
};


  //?
  Expression.Comma = function (a, b) {
    BinaryOperation.call(this, a, b);
  };
  Expression.Comma.prototype = Object.create(BinaryOperation.prototype);
  Expression.Comma.prototype.getS = function () {
    return ",\u200B ";
  };
  Expression.prototype.transformComma = function (b) {
    var a = this;
    if (a instanceof Expression.Equality && b instanceof Expression.Equality) {
      return Expression.SystemOfEquations.from([{left: a.a, right: a.b}, {left: b.a, right: b.b}]);
    }
    if (a instanceof Expression.Equality && b instanceof Expression.NoAnswerExpression && b.name === 'system-of-equations') {
      return Expression.SystemOfEquations.from([{left: a.a, right: a.b}].concat(b.second.equations));
    }
    if (a instanceof Expression.NoAnswerExpression && a.name === 'system-of-equations' && b instanceof Expression.Equality) {
      return Expression.SystemOfEquations.from(a.second.equations.concat([{left: b.a, right: b.b}]));
    }
    if (a instanceof Expression.NoAnswerExpression && a.name === 'system-of-equations' && b instanceof Expression.Inequality) {
      return Expression.SystemOfEquations.from(a.second.equations.concat([{left: b.a, right: b.b, sign: b.sign}]));
    }
    if (a instanceof Expression.NoAnswerExpression && a.name === 'polynomial-roots' && b instanceof Expression.NoAnswerExpression && b.name === 'polynomial-roots') {
      var ae = a.second.polynomial.calcAt(a.second.variable);
      var be = b.second.polynomial.calcAt(b.second.variable);
      //TODO: use original input expression
      return Expression.SystemOfEquations.from([{left: ae, right: Expression.ZERO}, {left: be, right: Expression.ZERO}]);
    }
    if (a instanceof Expression.NoAnswerExpression && a.name === 'system-of-equations' && b instanceof Expression.NoAnswerExpression && b.name === 'polynomial-roots') {
      var be = b.second.polynomial.calcAt(b.second.variable);
      //TODO: do not use NonSimplifiedExpression - ? and systemo-of-equations (?) or change (!)
      return Expression.SystemOfEquations.from(a.second.equations.concat([{left: be, right: Expression.ZERO}]));
    }
    if (a instanceof Expression.NoAnswerExpression && a.name === 'polynomial-roots' && b instanceof Expression.NoAnswerExpression && b.name === 'system-of-equations') {
      var ae = a.second.polynomial.calcAt(a.second.variable);
      //TODO: do not use NonSimplifiedExpression - ? and systemo-of-equations (?) or change (!)
      return Expression.SystemOfEquations.from([{left: ae, right: Expression.ZERO}].concat(b.second.equations));
    }
    if (a instanceof Expression.NoAnswerExpression && a.name === 'system-of-equations' && b instanceof Expression.NoAnswerExpression && b.name === 'system-of-equations') {
      return Expression.SystemOfEquations.from(a.second.equations.concat(b.second.equations));
    }
    if (a instanceof Expression.Inequality && b instanceof Expression.Inequality) {
      return Expression.SystemOfEquations.from([{left: a.a, right: a.b, sign: a.sign}, {left: b.a, right: b.b, sign: b.sign}]);
    }
    if (a instanceof Expression.Inequality && b instanceof Expression.NoAnswerExpression && b.name === 'polynomial-roots') {
      var be = b.second.polynomial.calcAt(b.second.variable);
      return Expression.SystemOfEquations.from([{left: a.a, right: a.b, sign: a.sign}, {left: be, right: Expression.ZERO}]);
    }
    throw new TypeError("NotSupportedError");
  };

Expression.Logarithm = function (argument) {
  Expression.Function.call(this, "log", argument);
};
Expression.Logarithm.prototype = Object.create(Expression.Function.prototype);
Expression.prototype.logarithm = function () {
  var arg = this;
  if (arg instanceof Expression.Integer) {
    if (arg.compareTo(Expression.ZERO) <= 0) {
      throw new TypeError("ArithmeticException");//TODO: better message
    }
    if (arg.compareTo(Expression.ONE) === 0) {
      return Expression.ZERO;
    }
    var p = integerPrimeFactor(arg);
    if (p.equals(arg)) {
      return new Expression.Logarithm(arg);
    }
    var ctz = primeFactor._countTrailingZeros(arg.toBigInt(), p.toBigInt());
    return p.logarithm().multiply(Integer.fromNumber(ctz)).add(arg.truncatingDivide(p._pow(ctz)).logarithm());
  }
  if (arg instanceof Expression.Division) {
    var n = arg.getNumerator();
    var d = arg.getDenominator();
    if (d instanceof Integer || isConstant(n)) {
      return n.logarithm().subtract(d.logarithm());
    }
  }
  if (arg instanceof Expression.Multiplication) {
    var c = arg.a;
    if (isConstant(c)) {
      return c.logarithm().add(arg.divide(c).logarithm());
    }
    var c = getConstant(arg);
    if (c instanceof Integer && !c.equals(Expression.ONE)) {
      return c.logarithm().add(arg.divide(c).logarithm());
    }
    if (arg.b instanceof Expression.MatrixSymbol) {//?
      return arg.a.logarithm().add(arg.b.logarithm());
    }
  }
  if (arg instanceof Expression.ExpressionWithPolynomialRoot) {
    arg = arg.upgrade();//?
  }
  if (arg instanceof Expression.ExpressionPolynomialRoot) {
    var g = arg.root.toPolynomialRoot().polynomial.getGCDOfTermDegrees();
    if (g > 1) {
      return arg._pow(g).logarithm().divide(Expression.Integer.fromNumber(g));
    }
  }
  //TODO: other kinds of polynomial roots (?)
  if (arg instanceof Expression.Symbol) {
    if (arg === Expression.E) {//?
      return Expression.ONE;
    }
    return new Expression.Logarithm(arg);
  }
  if (arg instanceof Expression.NthRoot) {
    var a = arg.a;
    var n = arg.n;
    if (a instanceof Expression.Integer && a.compareTo(Expression.ONE) > 0) {
      return a.logarithm().divide(Expression.Integer.fromNumber(n));
    }
    if (isPositive(a)) {
      return a.logarithm().divide(Expression.Integer.fromNumber(n));
    }
  }
  if (arg instanceof Expression.Exponentiation) {
    var b = getBase(arg);
    var e = getExponent(arg);
    if (b === Expression.E) {//?
      return e;
    }
    if (b instanceof Expression.MatrixSymbol && e instanceof Integer) {//?
      return b.logarithm().multiply(e);
    }
    if (b instanceof Expression.Integer) {
      return b.logarithm().multiply(e);
    }
  }
  if (arg instanceof Expression.Matrix) {
    var matrix = arg.matrix;
    if (matrix.isDiagonal()) {
      return new Expression.Matrix(matrix.map(function (e, i, j) {
        return i === j ? e.logarithm() : Expression.ZERO;
      }));
    }
    var tmp = Expression.getEigenvalues(matrix);
    var eigenvalues = tmp.eigenvalues;
    var multiplicities = tmp.multiplicities;
    if (Expression.sum(multiplicities) === matrix.cols()) {
      var tmp2 = Expression.getEigenvectors(matrix, eigenvalues);
      var eigenvectors = tmp2.eigenvectors;
      if (eigenvectors.length === matrix.cols()) {
        if (Expression.callback != undefined) {
          Expression.callback(new Expression.Event("logarithm-using-diagonalization", new Expression.Matrix(matrix)));//TODO:
        }
        var tmp = Expression.diagonalize(matrix, eigenvalues, multiplicities, eigenvectors);
        // https://en.wikipedia.org/wiki/Logarithm_of_a_matrix#Calculating_the_logarithm_of_a_diagonalizable_matrix
        return new Expression.Matrix(tmp.T).multiply(new Expression.Matrix(tmp.L).logarithm()).multiply(new Expression.Matrix(tmp.T_INVERSED));
      } else {
        var tmp = Expression.getFormaDeJordan(matrix, eigenvalues, multiplicities);
        // https://en.wikipedia.org/wiki/Logarithm_of_a_matrix#The_logarithm_of_a_non-diagonalizable_matrix
        var J = tmp.J;
        var logarithmOfJordanBlockMatrix = function (B) {
          var K = B.map(function (e, i, j) {
            return i !== j ? e.divide(B.e(i, i)) : Expression.ZERO;
          });
          var S = B.map(function (e, i, j) {
            return i === j ? e.logarithm() : Expression.ZERO;
          });
          var n = B.cols();
          for (var i = 1; i < n; i += 1) {
            var x = K.pow(i).scale(Expression.ONE.divide(Expression.Integer.fromNumber(i)));
            S = i % 2 === 1 ? S.add(x) : S.subtract(x);
          }
          return S;
        };
        var LJ = logarithmOfJordanBlockMatrix(J);
        //if (!J.eql(matrix)) {
        //TODO:
        if (Expression.callback != undefined) {
          Expression.callback(new Expression.Event("logarithm-using-Jordan-canonical-form", new Expression.Matrix(matrix)));
        }
        //}
        return new Expression.Matrix(tmp.P).multiply(new Expression.Matrix(LJ)).multiply(new Expression.Matrix(tmp.P_INVERSED));
      }
    }
  }
  if (arg instanceof Expression.Addition) {
    var c = getConstant(arg);
    if (!c.equals(Expression.ONE)) {
      return c.logarithm().add(arg.divide(c).logarithm());
    }
    if (arg.a instanceof Expression.Symbol && arg.b instanceof Expression.Integer) {
      return new Expression.Logarithm(arg);
    }
    var v = getVariableInternal(getLastMultiplicationOperand(getFirstAdditionOperand(arg))).next().value.v; // avoid square roots
    if (v instanceof Expression.Symbol) {
      var p = Polynomial.toPolynomial(arg, v);
      var c = p.getContent();
      if (c.isNegative()) {
        c = c.negate();
      }
      if (isPositive(c) && !c.equals(Expression.ONE)) {
        return arg.divide(c).logarithm().add(c.logarithm());
      }
      //TODO: check
      var sf = p.getSquareFreePolynomial();
      var n = Math.floor(p.getDegree() / sf.getDegree());
      if (n > 1 && sf.calcAt(v)._pow(n).equals(arg)) {
        return Expression.Integer.fromNumber(n).multiply(sf.calcAt(v).logarithm());
      }
    }
    if (isGoodPolynomial(arg)) {//?
      return new Expression.Logarithm(arg);
    }
  }
  var qi = QuadraticInteger.toQuadraticInteger(arg);//?
  if (qi != null && (Number(qi.a.toString()) > 0 || Number(qi.b.toString()) > 0) && qi.D > 0 && (qi.isValid() || qi.D === 5 || qi.D === 37)) {
    var f = qi.primeFactor();
    if (f.toExpression().equals(Expression.TWO)) {//TODO: !?
      qi = qi.truncatingDivide(f);
      f = qi.primeFactor();
    }
    if (!f.equals(qi)) {
      return f.toExpression().logarithm().add(arg.divide(f.toExpression()).logarithm());
    }
    if (Number(qi.a.toString()) > 0 && Number(qi.b.toString()) > 0) {
      //return new Expression.ExponentiationOfQuadraticInteger(x, y);
      return new Expression.Logarithm(arg);
    }
    if (Number(qi.a.toString()) < 0 || Number(qi.b.toString()) < 0) {
      var xc = qi.conjugate().toExpression();
      if (xc.isNegative()) {
        xc = xc.negate();
      }
      return arg.multiply(xc).logarithm().subtract(xc.logarithm());
    }
  }
  if (arg instanceof Addition && arg.b instanceof NthRoot && arg.a instanceof NthRoot) {//TODO: ? multiple operands - ?
    var g = nthRootCommonFactor(arg.a, arg.b);
    if (!g.equals(Expression.ONE) && isPositive(g)) {
      return g.logarithm().add(arg.divide(g).logarithm());
    }
  }
  if (Expression.isConstant(arg)) {
    var sd = simpleDivisor(arg);
    if (!sd.equals(arg)) {
      return sd.logarithm().add(arg.divide(sd).logarithm());
    }
  }
  throw new TypeError("NotSupportedError");
};


//!new
NthRoot.prototype.compare4MultiplicationExponentiation = Exponentiation.prototype.compare4MultiplicationExponentiation;
Expression.Symbol.prototype.compare4MultiplicationExponentiation = Exponentiation.prototype.compare4MultiplicationExponentiation;


//!new
Expression.prototype.complexConjugate = function () {
  throw new TypeError("NotSupportedError");
};
Expression.Integer.prototype.complexConjugate = function () {
  return this;
};
// https://en.wikipedia.org/wiki/Complex_conjugate#Properties
Expression.Division.prototype.complexConjugate = function () {
  return this.getNumerator().complexConjugate().divide(this.getDenominator().complexConjugate());
};
Expression.Multiplication.prototype.complexConjugate = function () {
  return this.a.complexConjugate().multiply(this.b.complexConjugate());
};
Expression.Addition.prototype.complexConjugate = function () {
  return this.a.complexConjugate().add(this.b.complexConjugate());
};
Expression.Function.prototype.complexConjugate = function () {
  if (this.a instanceof Integer || Expression.isReal(this)) {
    return this;
  }
  throw new TypeError("NotSupportedError");//TODO: ?
};
Expression.Matrix.prototype.complexConjugate = function () {
  var a = this;
  return new Expression.Matrix(a.matrix.map(function (x) { return x.complexConjugate(); }));
};
Expression.Symbol.prototype.complexConjugate = function () {
  if (this === Expression.E || this === Expression.PI || Expression.isReal(this)) {
    return this;
  }
  return new Expression.ComplexConjugate(this);
};
//TODO: complexConjugate(log(z)) = log(complexConjugate(z))
Expression.Exponentiation.prototype.complexConjugate = function () {
  // complexConjugate(exp(z)) = exp(complexConjugate(z))
  if (getBase(this) === Expression.E) {
    return getBase(this).pow(getExponent(this).complexConjugate());
  }
  // complexConjugate(z**n) = complexConjugate(z)**n
  if (getExponent(this) instanceof Expression.Integer) {//?
    return getBase(this).complexConjugate().pow(getExponent(this));
  }
  if (getExponent(this) instanceof Expression.Symbol && getExponent(this).symbol === "T" && getBase(this) instanceof Expression.MatrixSymbol) {
    //return getBase(this).complexConjugate().pow(getExponent(this));
    return new Expression.Exponentiation(getBase(this).complexConjugate(), getExponent(this));
  }
  throw new TypeError("NotSupportedError");//TODO: ?
};
Expression.Logarithm.prototype.complexConjugate = function () {
  return this.a.complexConjugate().logarithm();
};


  Expression.ComplexConjugate = function (matrix) {
    Expression.Function.call(this, "complexConjugate", matrix);
  };
  Expression.ComplexConjugate.prototype = Object.create(Expression.Function.prototype);


  Expression.AugmentedMatrix = function (A, B) {
    Expression.Function.call(this, "augment", null);
    this.a = A;
    this.b = B;
  };
  Expression.AugmentedMatrix.prototype = Object.create(Expression.Function.prototype);
  Expression.AugmentedMatrix.prototype.toString = function (options) {
    //TODO:
    return '(' + this.a.toString(options) + '|' + this.b.toString(options) + ')';
  };
  Expression.AugmentedMatrix.prototype.toMathML = function (options) {
    //TODO:
    return '<mrow>' + '<mo>(</mo>' + this.a.toMathML(options) + '<mo>|</mo>' + this.b.toMathML(options) + '<mo>)</mo>' + '</mrow>';
  };

})();
(function () {
"use strict";




var BASE = 2;
//var BASE = 10;

function MakeMath(BigDecimal, BASE) {
  function BigDecimalMath() {
  }
  var BIG_DECIMAL_BASE = BigDecimal.round(BigDecimal.BigDecimal(BASE), {maximumSignificantDigits: 1, roundingMode: 'half-even'});
  /*
  BigDecimalMath.nthRoot = function (x, n, rounding) {
    //TODO: fix, tests
    if (!BigDecimal.lessThan(x, BigDecimal.BigDecimal(2)) &&
        rounding.maximumSignificantDigits != undefined &&
        rounding.maximumSignificantDigits < n - 2) {//?
      // ExpressionParser.parse('2**(1/10000)').toMathML({fractionDigits: 10});
      var roundingToInteger = {
        maximumFractionDigits: 0,
        roundingMode: 'half-even'
      };
      var roundingToSingleDigit = {
        maximumSignificantDigits: 1,
        roundingMode: 'half-even'
      };
      var e = Math.ceil(Math.log2(Number(BigDecimal.toBigInt(BigDecimal.round(BigDecimal.log(BigDecimal.round(x, roundingToSingleDigit), roundingToSingleDigit), roundingToInteger)).toString()) / n) / Math.log2(BASE));
      var internalRounding = {
        maximumSignificantDigits: rounding.maximumSignificantDigits + 1 + Math.max(e, 0),
        roundingMode: rounding.roundingMode
      };
      var log = function (x) { return BigDecimal.log(x, internalRounding); };
      var exp = function (x) { return BigDecimal.exp(x, internalRounding); };
      var divide = function (x, n) { return BigDecimal.divide(x, BigDecimal.BigDecimal(n), internalRounding); };
      return exp(divide(log(x), n));
    }
    // (f * Math.pow(10, e))**(1/n) = (f * 10**(e - round(e / n) * n))**(1/n) * 10**round(e / n)
    var fractionDigits = 2;
    while (!BigDecimal.equal(BigDecimal.round(x, {maximumFractionDigits: fractionDigits, roundingMode: 'half-even'}), x)) {
      fractionDigits *= 2;
    }
    var scaling = rounding.maximumSignificantDigits != null ? rounding.maximumSignificantDigits + Math.ceil(fractionDigits / n) : Math.max(rounding.maximumFractionDigits, fractionDigits / 2);
    var sx = BigDecimal.toBigInt(BigDecimal.multiply(x, exponentiate(BIG_DECIMAL_BASE, scaling * n)));
    var x0 = nthRoot(sx, n);
    if (rounding.roundingMode === 'ceil') {
      var exponentiate = function (x, n) {
        return n === 1 ? x : (n % 2 === 0 ? exponentiate(BigDecimal.multiply(x, x), n / 2) : BigDecimal.multiply(x, exponentiate(x, n - 1)));
      };
      x0 = BigDecimal.lessThan(exponentiate(BigDecimal.BigDecimal(x0), n), BigDecimal.BigDecimal(sx)) ? BigDecimal.toBigInt(BigDecimal.add(BigDecimal.BigDecimal(x0), BigDecimal.BigDecimal(1))) : x0;
    } else if (rounding.roundingMode !== 'floor') {
      throw new RangeError("not implemented!");
    }
    return BigDecimal.multiply(BigDecimal.BigDecimal(x0), exponentiate(BIG_DECIMAL_BASE, -scaling));
  };
  */
  BigDecimalMath.nextAfter = function (a, rounding) {
    if (rounding == undefined) {
      throw new RangeError();
    }
    if (rounding.roundingMode !== 'floor' && rounding.roundingMode !== 'ceil') {
      throw new RangeError();
    }
    var t = BigDecimal.round(a, rounding);
    if (!BigDecimal.equal(a, t)) {
      return t;
    }
    var _nextAfter = function (a, k, v, rounding) {
      var small = BigDecimal.multiply(BigDecimal.BigDecimal(rounding.roundingMode === 'floor' ? -1 : 1), exponentiate(BIG_DECIMAL_BASE, -k));
      var aim = BigDecimal.multiply(BigDecimal.abs(v), small);
      return BigDecimal.add(a, aim, rounding);
    };
    if (rounding.maximumFractionDigits != undefined) {
      return _nextAfter(a, rounding.maximumFractionDigits, BigDecimal.BigDecimal(1), rounding);
    }
    if (rounding.maximumSignificantDigits != undefined) {
      // a * (1 + 1 / Math.pow(2, maximumSignificantDigits))
      return _nextAfter(a, rounding.maximumSignificantDigits, a, rounding);
    }
    throw new RangeError();
  };
  //TODO: remove
  //BigDecimalMath.fma = function (a, b, c, rounding) { // a * b + c
  //  return BigDecimal.round(BigDecimal.add(BigDecimal.multiply(a, b), c), rounding);
  //};
  var exponentiate = function (a, n) {
    //console.assert(a == 2);
    if (n < 0) {
      return BigDecimal.divide(BigDecimal.BigDecimal(1), exponentiate(a, -n), null);
    }
    var y = BigDecimal.BigDecimal(1);
    while (n >= 1) {
      if (0 === n % 2) {
        a = BigDecimal.multiply(a, a);
        n = n / 2;
      } else {
        y = y == undefined ? a : BigDecimal.multiply(a, y);
        n = n - 1;
      }
    }
    return y;
  };
  return BigDecimalMath;
};

var BigDecimalMath = MakeMath(BigDecimal, 10);
var BigFloatMath = MakeMath(BigFloat, 2);

//BigDecimalMath.nthRoot(BigDecimal.BigDecimal(2), 2, 3);




// https://en.wikipedia.org/wiki/Interval_arithmetic
function Interval(a, b) {
  if (a instanceof Interval || b instanceof Interval) {
    throw new TypeError();// to help with debugging
  }
  if (BigFloat.greaterThan(a, b)) {
    throw new TypeError();
  }
  this.a = a;
  this.b = b;
}

Interval.Context = function (precision, flag0) {
  //this.precision = precision;
  //this.anyRounding = {maximumSignificantDigits: precision, roundingMode: 'half-even'};
  var anyRounding = flag0 ? {maximumSignificantDigits: precision, roundingMode: 'half-even'} : {maximumFractionDigits: precision - 1, roundingMode: 'half-even'};
  this.anyRounding = anyRounding;
  this.floorRounding = Object.assign({}, anyRounding, {roundingMode: 'floor'});
  this.ceilRounding = Object.assign({}, anyRounding, {roundingMode: 'ceil'});
};
Interval.Context.prototype.unaryMinus = function (x) {
  if (BigFloat.equal(x.a, x.b)) {
    var t = BigFloat.unaryMinus(x.a);
    return new Interval(t, t);
  }
  return new Interval(BigFloat.unaryMinus(x.b), BigFloat.unaryMinus(x.a));
};
Interval.Context.prototype.add = function (x, y) {
  return new Interval(BigFloat.add(x.a, y.a, this.floorRounding), BigFloat.add(x.b, y.b, this.ceilRounding));
};
Interval.Context.prototype.subtract = function (x, y) {
  return new Interval(BigFloat.add(x.a, BigFloat.unaryMinus(y.b), this.floorRounding), BigFloat.add(x.b, BigFloat.unaryMinus(y.a), this.ceilRounding));
};
Interval.Context.prototype._multiply = function (x1, x2, y1, y2, f) {
  var sign = BigFloat.sign;
  if (sign(x1) >= 0) {
    if (sign(y1) >= 0) {
      return f(x1, y1, x2, y2);
    }
    if (sign(y2) <= 0) {
      return f(x2, y1, x1, y2);
    }
    // y1 < 0 && y2 > 0
    return f(x2, y1, x2, y2);
  }
  if (sign(x2) <= 0) {
    if (sign(y2) <= 0) {
      return f(x2, y2, x1, y1);
    }
    if (sign(y1) >= 0) {
      return f(x1, y2, x2, y1);
    }
    // y1 < 0 && y2 > 0
    return f(x1, y2, x1, y1);
  }
  if (sign(y1) >= 0) {// x1 < 0 && x2 > 0
    return f(x1, y2, x2, y2);
  }
  if (sign(y2) <= 0) {// x1 < 0 && x2 > 0
    return f(x2, y1, x1, y1);
  }
  // x1 < 0 && x2 > 0 && y1 < 0 && y2 > 0
  var interval1 = f(x1, y2, x1, y1);
  var interval2 = f(x2, y1, x2, y2);
  return new Interval(BigFloat.min(interval1.a, interval2.a),
                      BigFloat.max(interval1.b, interval2.b));
};
Interval.Context.prototype.multiply = function (x, y) {
  var floorRounding = this.floorRounding;
  var ceilRounding = this.ceilRounding;
  if (BigFloat.equal(x.a, x.b) && BigFloat.equal(y.a, y.b)) {
    var product = BigFloat.multiply(x.a, y.a);
    return new Interval(BigFloat.round(product, floorRounding), BigFloat.round(product, ceilRounding));
  }
  var f = function (a, b, c, d) {
    return new Interval(BigFloat.multiply(a, b, floorRounding), BigFloat.multiply(c, d, ceilRounding));
  };
  return this._multiply(x.a, x.b, y.a, y.b, f);
};
Interval.Context.prototype.divide = function (x, y) {
  var floorRounding = this.floorRounding;
  var ceilRounding = this.ceilRounding;
  if (BigFloat.sign(y.a) <= 0 && BigFloat.sign(y.b) >= 0) {
    if (BigFloat.equal(y.a, y.b)) {
      throw new RangeError();
    }
    return "CANNOT_DIVIDE";//TODO: FIX
  }
  //if (BigFloat.equal(x.a, x.b) && BigFloat.equal(y.a, y.b)) {
  //  var q = BigFloat.divide(x.a, y.a, this.anyRounding);
  //  var r = BigFloat.subtract(x.a, BigFloat.multiply(y.a, q));
  //  return new Interval(floorDivide(x.a, y.a), ceilDivide(x.a, y.a)); //TODO: single division
  //}
  var f = function (a, d, c, b) {
    //Note: b and d are swapped
    return new Interval(BigFloat.divide(a, b, floorRounding), BigFloat.divide(c, d, ceilRounding));
  };
  return this._multiply(x.a, x.b, y.a, y.b, f);
};
Interval.Context.prototype.sqrt = function (x) {
  if (BigFloat.sign(x.a) < 0 && BigFloat.sign(x.b) >= 0) {
    return "CANNOT_DIVIDE";//TODO: FIX
  }
  if (BigFloat.equal(x.a, x.b)) {
    var ya = BigFloat.sqrt(x.a, this.floorRounding);
    var yb = BigFloat.equal(BigFloat.multiply(ya, ya), x.b) ? ya : BigFloatMath.nextAfter(ya, this.ceilRounding);
    return new Interval(ya, yb);
  }
  return this._map(x, function (x, rounding) {
    return BigFloat.sqrt(x, rounding);
  });
};
Interval.Context.prototype.cbrt = function (x) {
  if (BigFloat.equal(x.a, x.b)) {
    var ya = BigFloat.cbrt(x.a, this.floorRounding);
    var yb = BigFloat.equal(BigFloat.multiply(ya, BigFloat.multiply(ya, ya)), x.b) ? ya : BigFloatMath.nextAfter(ya, this.ceilRounding);
    return new Interval(ya, yb);
  }
  return this._map(x, function (x, rounding) {
    return BigFloat.cbrt(x, rounding);
  });
};
/*Interval.Context.prototype.nthRoot = function (x, n) {
  if (n % 2 === 0 && BigFloat.sign(x.a) < 0 && BigFloat.sign(x.b) >= 0) {
    return "CANNOT_DIVIDE";//TODO: FIX
  }
  if (BigFloat.equal(x.a, x.b)) {
    var exponentiate = function (x, n) {
      return n === 1 ? x : (n % 2 === 0 ? exponentiate(BigFloat.multiply(x, x), n / 2) : BigFloat.multiply(x, exponentiate(x, n - 1)));
    };
    var round = function (x, rounding) {
      if (rounding.maximumFractionDigits != undefined) {
        return BigFloat.round(x, {roundingMode: 'half-even', maximumFractionDigits: Math.ceil(rounding.maximumFractionDigits / n)});
      }
      if (rounding.maximumSignificantDigits != undefined) {
        return BigFloat.round(x, {roundingMode: 'half-even', maximumSignificantDigits: Math.ceil(rounding.maximumSignificantDigits / n)});
      }
      throw new RangeError();
    };
    var ya = BigFloatMath.nthRoot(x.a, n, this.floorRounding);
    var yb = BigFloat.equal(exponentiate(round(ya, this.anyRounding), n), x.b) ? ya : BigFloatMath.nextAfter(ya, this.ceilRounding);
    return new Interval(ya, yb);
  }
  return this._map(x, function (x, rounding) {
    return BigFloatMath.nthRoot(x, n, rounding);
  });
};*/
Interval.Context.prototype.exp = function (x) {
  return this._map(x, BigFloat.exp);
};
Interval.Context.prototype.log = function (x, precision) {
  if (BigFloat.sign(x.a) <= 0 && BigFloat.sign(x.b) > 0) {
    return "CANNOT_DIVIDE";//TODO: FIX
  }
  if (BigFloat.equal(x.a, x.b) && BigFloat.equal(x.b, BigFloat.BigFloat(1))) {
    return new Interval(BigFloat.BigFloat(0), BigFloat.BigFloat(0));
  }
  return this._map(x, BigFloat.log);
};
Interval.Context.prototype.atan = function (x, precision) {
  return this._map(x, BigFloat.atan);
};
Interval.Context.prototype._mapValue = function (value, callback) {
  var c = callback(value, this.floorRounding); // TODO: ?
  //var a = BigFloatMath.nextAfter(c, this.floorRounding);
  var a = c;
  var b = BigFloatMath.nextAfter(c, this.ceilRounding);
  if (BigFloat.equal(value, BigFloat.BigFloat(0))) {
    b = c;
  }
  return new Interval(a, b);
};
Interval.Context.prototype._map = function (x, callback) {
  if (BigFloat.equal(x.a, x.b)) {
    return this._mapValue(x.a, callback);
  }
  var a = callback(x.a, this.floorRounding);
  var b = callback(x.b, this.ceilRounding);
  return new Interval(a, b);
};
Interval.Context.prototype._trigonometry = function (x, which) {
  if (BigFloat.equal(x.a, x.b)) {
    return this._mapValue(x.a, which === 'sin' ? BigFloat.sin : BigFloat.cos);
  }
  var tau = BigFloat.multiply(BigFloat.BigFloat(8), BigFloat.atan(BigFloat.BigFloat(1), this.anyRounding));
  if (!BigFloat.lessThan(BigFloat.subtract(x.b, x.a), tau)) {
    return new Interval(BigFloat.BigFloat(-1), BigFloat.BigFloat(+1));
  }
  var f = function (x, rounding) {
    return which === 'sin' ? BigFloat.sin(x, rounding) : BigFloat.cos(x, rounding);
  };
  var middle = BigFloat.divide(BigFloat.add(x.a, x.b), BigFloat.BigFloat(2), this.anyRounding); // with rounding it works better in case the interval has huge significant digits difference
  var anyRounding = this.anyRounding;
  var extremumPoint = function (q) {
    var shift = BigFloat.multiply(BigFloat.divide(BigFloat.BigFloat(q), BigFloat.BigFloat(4), anyRounding), tau);
    var k = BigFloat.round(BigFloat.divide(BigFloat.subtract(middle, shift, anyRounding), tau, anyRounding), {
      maximumFractionDigits: 0,
      roundingMode: 'half-even'
    });
    return BigFloat.add(BigFloat.multiply(tau, k), shift);
  };
  var minimumPoint = extremumPoint(which === 'sin' ? 3 : 2);
  var maximumPoint = extremumPoint(which === 'sin' ? 1 : 0);
  var fmin = BigFloat.lessThan(minimumPoint, x.a) ? f(x.a, this.floorRounding) : (BigFloat.greaterThan(minimumPoint, x.b) ? f(x.b, this.floorRounding) : BigFloat.BigFloat(-1));
  var fmax = BigFloat.lessThan(maximumPoint, x.a) ? f(x.a, this.ceilRounding) : (BigFloat.greaterThan(maximumPoint, x.b) ? f(x.b, this.ceilRounding) : BigFloat.BigFloat(+1));
  /**/
  return new Interval(fmin, fmax);
};
Interval.Context.prototype.sin = function (x) {
  return this._trigonometry(x, 'sin');
};
Interval.Context.prototype.cos = function (x) {
  return this._trigonometry(x, 'cos');
};
Interval.Context.prototype.fromInteger = function (a) {
  if (BASE !== 2) {
    var abs = function (a) {
      return a < 0 ? BigInteger.unaryMinus(a) : a;
    };
    var k = a != 0 ? bitLength(abs(a)) - Math.ceil(Math.log2(10) * this.anyRounding.maximumSignificantDigits) : 0;
    if (k > 42) {
      //TODO: move to BigFloat.round - ?
      // for performance
      var p2k = BigInteger.exponentiate(BigInteger.BigInt(2), BigInteger.BigInt(k));
      var q = BigInteger.divide(a, p2k);
      var from = a < 0 ? BigInteger.subtract(q, BigInteger.BigInt(1)) : q;
      var to = a < 0 ? q : BigInteger.add(q, BigInteger.BigInt(1));
      return this.multiply(this.fromIntegers(from, to), this.exponentiate(this.fromInteger(BigInteger.BigInt(2)), k));
    }
  }
  //var x = BigFloat.BigFloat(a);
  //if (BigInteger.equal(BigInteger.BigInt(BigFloat.toBigInt(x)), a)) { // TODO: ?
  //  return new Interval(x, x);
  //}
  a = BigFloat.BigFloat(a);
  return new Interval(BigFloat.round(a, this.floorRounding),
                      BigFloat.round(a, this.ceilRounding));
  //return this.fromIntegers(a, a);
};
Interval.Context.prototype.fromIntegers = function (a, b) {
  var a = BigFloat.BigFloat(a);
  var b = BigFloat.BigFloat(b);
  //TODO: test case (!!!)
  console.assert(!BigFloat.lessThan(b, a));
  return new Interval(BigFloat.round(a, this.floorRounding),
                      BigFloat.round(b, this.ceilRounding));
};
Interval.Context.prototype.abs = function (x) {
  if (BigFloat.lessThan(x.a, BigFloat.BigFloat(0))) {
    if (BigFloat.lessThan(x.b, BigFloat.BigFloat(0))) {
      return new Interval(BigFloat.unaryMinus(x.b), BigFloat.unaryMinus(x.a));
    } else {
      return new Interval(BigFloat.BigFloat(0), BigFloat.max(BigFloat.unaryMinus(x.a), x.b));
    }
  }
  return x;
};
Interval.Context.prototype.exponentiate = function (x, n) {
  var y = undefined;
  while (n >= 1) {
    if (n === 2 * Math.floor(n / 2)) {
      x = this.multiply(x, x);
      n = Math.floor(n / 2);
    } else {
      y = y == undefined ? x : this.multiply(x, y);
      n -= 1;
    }
  }
  return y;
};

//?

      // todo: for exact notation (?):
      // 10000 -> Math.pow(10, 4)
      // 15000 -> 15*10**3
      // 0.00015 -> 15*10**(-5)



Interval.Context.prototype.formatToDecimal = function (x, rounding) {
  // assume, that the value is not exact
  var signA = BigFloat.sign(x.a);
  var signB = BigFloat.sign(x.b);
  var sign = (signA || signB) === (signB || signA) ? (signA || signB) : 0;
  x = this.abs(x);
  var stringify = function (a, roundingMode) {
    if (rounding.fractionDigits != undefined) {
      return a.toFixed(rounding.fractionDigits, roundingMode);
    }
    return a.toPrecision(rounding.significantDigits, roundingMode);
  };
  var a = stringify(x.a, "half-up");
  var b = BigFloat.equal(x.a, x.b) ? a : stringify(x.b, "half-down");
  var isZero = function (a) {
    return !/[^0\.]/.test(a);
  };
  if (a === b && (sign !== 0 || isZero(a) && isZero(b))) {
    return (sign < 0 ? '-' : (sign > 0 && isZero(a) && isZero(b) ? '+' : '')) + a;
  }
  return undefined;
};
Interval.prototype.toString = function () {
  return "[" + this.a.toString() + ";" + this.b.toString() + "]";
};

var calcAt = function (polynomial, x, context) {
  var result = evaluateExpression(Expression.ZERO, context);
  for (var i = polynomial.getDegree(); i >= 0; i--) {
    result = context.multiply(result, x);
    var tmp = evaluateExpression(polynomial.getCoefficient(i), context);
    if (tmp === "CANNOT_DIVIDE" || tmp == undefined) {
      return tmp;
    }
    result = context.add(result, tmp);
  }
  return result;
};

var evaluateExpression = function (e, context) {
  if (e instanceof Expression.Integer) {
    var n = e.value;
    return context.fromInteger(n);
  } else if (e instanceof Expression.NthRoot) {
    var a = e.a;
    var n = e.n;
    var y = evaluateExpression(a, context);
    if (y === "CANNOT_DIVIDE" || y == undefined) {
      return y;
    }
    if (n == 2) {
      return context.sqrt(y);
    }
    if (n == 3) {
      return context.cbrt(y);
    }
    return context.exp(context.divide(context.log(y), context.fromInteger(n)));
  } else if (e instanceof Expression.BinaryOperation) {
    // slow for some cases:
    if (e instanceof Expression.Addition && Expression.has(e, Expression.PolynomialRootSymbol)) {
      var root = Expression.getVariable(e);//?
      var p = Polynomial.toPolynomial(e, root);
      if (p.hasIntegerCoefficients()) {// trying to avoid slow cases (?)
        //TODO: https://en.wikipedia.org/wiki/Horner%27s_method - ?
        var zero = evaluateExpression(root, context);
        //return evaluateExpression(p.calcAt(), context);
        return calcAt(p, zero, context);
      }
    }
    if (e.a === Expression.E && e.getS() === "^") {
      var b = evaluateExpression(e.b, context);
      if (b === "CANNOT_DIVIDE" || b == undefined) {
        return b;
      }
      return context.exp(b);
    }

    var a = evaluateExpression(e.a, context);
    if (a === "CANNOT_DIVIDE" || a == undefined) {
      return a;
    }
    var b = evaluateExpression(e.b, context);
    if (b === "CANNOT_DIVIDE" || b == undefined) {
      return b;
    }
    var operator = e.getS();
    if (operator === "+") {
      return context.add(a, b);
    } else if (operator === "-") {
      return context.subtract(a, b);
    } else if (operator === "*") {
      return context.multiply(a, b);
    } else if (operator === "/") {
      return context.divide(a, b);
    } else if (operator === "^") { // Expression.PolynomialRootSymbol^3, pi^2, 2**(sqrt(3)), (log(2))^2
      //TODO: to polynomial
      if (!(e.b instanceof Expression.Integer) || e.b.toNumber() <= 0 || e.b.toNumber() > Number.MAX_SAFE_INTEGER) {
        //throw new TypeError();
        var log = context.log(a);
        if (log === "CANNOT_DIVIDE") {
          return log;
        }
        return context.exp(context.multiply(log, b));
      }
      var n = e.b.toNumber();//TODO: FIX!
      return context.exponentiate(a, n);
    }
  } else if (e instanceof Expression.PolynomialRootSymbol) {
    var i = e.toDecimal(context.anyRounding.maximumSignificantDigits || context.anyRounding.maximumFractionDigits);
    // "lcm" is too slow to compute (?)
    /*if (true) {
      var a = BigFloat.divide(BigFloat.BigFloat(i.a.getNumerator().value), BigFloat.BigFloat(i.a.getDenominator().value), context.floorRounding);
      var b = BigFloat.divide(BigFloat.BigFloat(i.b.getNumerator().value), BigFloat.BigFloat(i.b.getDenominator().value), context.ceilRounding);
      return new Interval(a, b);
    }*/
    return context.divide(context.fromIntegers(i.b.getDenominator().multiply(i.a.getNumerator()).value,
                                               i.a.getDenominator().multiply(i.b.getNumerator()).value),
                          context.fromInteger(i.a.getDenominator().multiply(i.b.getDenominator()).value));
  } else if (e === Expression.E) {
    return context.exp(context.fromInteger(1));
  } else if (e === Expression.PI) {
    return context.multiply(context.fromInteger(4), context.atan(context.fromInteger(1)));
  } else if (e instanceof Expression.Function) {
    var x = evaluateExpression((e instanceof Expression.Sin || e instanceof Expression.Cos) && e.a instanceof Expression.Radians ? e.a.value : e.a, context);
    if (x === "CANNOT_DIVIDE" || x == undefined) {
      return x;
    }
    if (e instanceof Expression.Sin) {
      return context.sin(x);
    }
    if (e instanceof Expression.Cos) {
      return context.cos(x);
    }
    if (e instanceof Expression.Logarithm) {
      return context.log(x);
    }
    if (e instanceof Expression.Arctan) {
      return context.atan(x);
    }
  } else if (e instanceof Expression.ExpressionWithPolynomialRoot) {
    return evaluateExpression(e.e, context);
  } else if (e instanceof Expression.ExpressionPolynomialRoot) {
    var i = e.root.toDecimal(context.anyRounding.maximumSignificantDigits || context.anyRounding.maximumFractionDigits);
    // "lcm" is too slow to compute (?)
    /*if (true) {
      var a = BigFloat.divide(BigFloat.BigFloat(i.a.getNumerator().value), BigFloat.BigFloat(i.a.getDenominator().value), context.floorRounding);
      var b = BigFloat.divide(BigFloat.BigFloat(i.b.getNumerator().value), BigFloat.BigFloat(i.b.getDenominator().value), context.ceilRounding);
      return new Interval(a, b);
    }*/
    var root = context.divide(context.fromIntegers(i.b.getDenominator().multiply(i.a.getNumerator()).value,
                                                   i.a.getDenominator().multiply(i.b.getNumerator()).value),
                              context.fromInteger(i.a.getDenominator().multiply(i.b.getDenominator()).value));
    return root;
  }

  return undefined;
};

var decimalToString = function (decimal) {
  return decimal.replace(/[eE]/g, '*10^');
};

var complexToString = function (real, imaginary) {
  return real + (/^[\-\+]/.test(imaginary) ? imaginary.replace(/^([\-\+])[\s\S]+/g, '$1') : (real !== '' ? '+' : '')) + (imaginary !== '1' && imaginary !== '-1' ? imaginary.replace(/^[\-\+]/g, '') + '*' + 'i' : 'i');
};

  //? ((n * 10**(fractionDigits + 1)) ~/ d + 5) ~/ 10

var toDecimalStringInternal = function (expression, rounding, decimalToStringCallback, complexToStringCallback) {
  decimalToStringCallback = decimalToStringCallback || decimalToString;
  complexToStringCallback = complexToStringCallback || complexToString;
  if (rounding.fractionDigits == undefined && rounding.significantDigits == undefined ||
      rounding.fractionDigits != undefined && rounding.significantDigits != undefined) {//?
    throw new RangeError();
  }
  if (rounding.fractionDigits != undefined && (rounding.fractionDigits < 0 || rounding.fractionDigits > Number.MAX_SAFE_INTEGER) ||
      rounding.significantDigits != undefined && (rounding.significantDigits < 1 || rounding.significantDigits > Number.MAX_SAFE_INTEGER) ||
      rounding.roundingMode != undefined) {
    throw new RangeError();
  }

  if (expression instanceof Expression.Complex || Expression.has(expression, Expression.Complex)) {//?TODO: ?
    var numerator = expression.getNumerator();//.unwrap();
    var denominator = expression.getDenominator();//.unwrap();
    if (denominator instanceof Expression.Integer ||
        Expression.has(denominator, Expression.PolynomialRootSymbol) ||
        Expression.has(denominator, Expression.ExpressionPolynomialRoot) ||
        Expression._isPositive(denominator)) { // e^2
      if (numerator instanceof Expression.Addition || numerator instanceof Expression.Multiplication || numerator instanceof Expression.Complex) {
        var tmp = Expression.getComplexNumberParts(numerator);
        var realValue = tmp.real;
        var imaginaryValue = tmp.imaginary;
        if (!imaginaryValue.equals(Expression.ZERO)) {
          realValue = realValue.divide(denominator);
          imaginaryValue = imaginaryValue.divide(denominator);
          var real = realValue.equals(Expression.ZERO) ? '' : toDecimalStringInternal(realValue, rounding, decimalToStringCallback, complexToStringCallback);
          var imaginary = toDecimalStringInternal(imaginaryValue, rounding, decimalToStringCallback, complexToStringCallback);
          return complexToStringCallback(real, imaginary);
        }
      }
    }
  }
   
  if (expression instanceof Expression.Integer || expression instanceof Expression.Division && expression.a instanceof Expression.Integer && expression.b instanceof Expression.Integer) {
    //TODO: ?
    if (true) {//TODO: ?
      return decimalToStringCallback(primeFactor._rationalNumberToDecimalString(expression.getNumerator().toBigInt(), expression.getDenominator().toBigInt(), rounding));
    }
  }
  //TODO: remove - ?
  /*TODO: enable
  if (expression instanceof Expression.NthRoot) {
    var a = expression.a;//.unwrap();
    if (a instanceof Expression.Integer) {
      var A = a.value;
      var n = expression.n;
      var scale = BigInteger.exponentiate(BigInteger.BigInt(10), BigInteger.BigInt(fractionDigits));
      var sA = BigInteger.multiply(A, BigInteger.exponentiate(scale, BigInteger.BigInt(n)));

      var x0 = nthRoot(sA, n);
      var x1 = BigInteger.lessThan(BigInteger.exponentiate(x0, BigInteger.BigInt(n)), sA) ? BigInteger.add(x0, BigInteger.BigInt(1)) : x0;

      // root - x0 < x1 - root
      // 2root < x0 + x1
      // Math.pow(2, n) * A < (x0 + x1)**n
      var nearest = BigInteger.lessThan(BigInteger.multiply(BigInteger.exponentiate(BigInteger.BigInt(2), BigInteger.BigInt(n)), sA), BigInteger.exponentiate(BigInteger.add(x0, x1), BigInteger.BigInt(n))) ? x0 : x1;
      //return toDecimalStringInternal(new Expression.Division(new Expression.Integer(nearest), new Expression.Integer(scale)), fractionDigits, decimalToStringCallback, complexToStringCallback);
      var context = new Interval.Context(fractionDigits + 1);
      var a = BigFloat.divide(BigFloat.BigFloat(nearest), BigFloat.BigFloat(scale));
      var result = context.formatToDecimal(new Interval(a, BigFloatMath.nextAfter(a, {maximumFractionDigits: fractionDigits + 1, roundingMode: 'ceil'})), fractionDigits);
      return decimalToStringCallback(result);
    }
  }
  */
  //---
  /*if (!Expression.has(expression, Expression.Symbol) &&
      !Expression.has(expression, Expression.NthRoot) &&
      !Expression.has(expression, Expression.PolynomialRootSymbol) &&
      !Expression.has(expression, Expression.ExpressionPolynomialRoot) &&
      !(expression instanceof Expression.Integer) &&
      !(expression instanceof Expression.Division) &&
      !Expression.has(expression, Expression.Radians) &&
      !Expression.has(expression, Expression.Logarithm) &&
      !Expression.has(expression, Expression.Exponentiation)) {
    throw new TypeError("toDecimalString:" + JSON.stringify(rounding) + ":" + expression.toString({}));
  }*/
  console.assert(BASE % 2 === 0);
  var result = undefined;
  var guessedPrecision = 1; //TODO: ?
  //!new
  //TODO: !!!
  //if (expression instanceof Expression.Multiplication && expression.a instanceof Expression.Integer && rounding.fractionDigits != undefined) {
    //guessedPrecision = 2 * bitLength(expression.a.toBigInt());
    //guessedPrecision  = 128;
  //}
  //!
  var flag0 = Expression.has(expression, Expression.Function) || Expression.has(expression, Expression.Exponentiation);
  while (result == undefined) {
    if (guessedPrecision > 60000 && guessedPrecision > (rounding.fractionDigits || rounding.significantDigits) * 4 * Math.log2(10)) {
      debugger;
      throw new TypeError();
    }
    //if (guessedPrecision > 1024) throw new Error();
    var context = new Interval.Context(guessedPrecision, flag0);
    var x = evaluateExpression(expression, context);
    if (x == undefined) {
      return undefined;
    }
    if (x !== "CANNOT_DIVIDE") { // continue the loop otherwise
      result = context.formatToDecimal(x, rounding);
    }
    if (guessedPrecision > 1  && result == undefined) {
      //console.count('guessedPrecision > 1  && result == undefined');
    }
    if (x !== "CANNOT_DIVIDE" && result == undefined && rounding.fractionDigits != undefined && guessedPrecision === 1) {//TODO: ?
      var log10OfValue = BigFloat.max(BigFloat.abs(x.a), BigFloat.abs(x.b)).toFixed(0).length;
      guessedPrecision = Math.ceil(Math.max(log10OfValue * Math.log2(10), 2) / 2 + Math.log2(10) * rounding.fractionDigits / 2 * 2);
    }
    if (x !== "CANNOT_DIVIDE" && result == undefined && rounding.significantDigits != undefined && guessedPrecision === 1) {//TODO: ?
      if (BigFloat.sign(x.a) === BigFloat.sign(x.b)) { // zero is not part of the interval, so we know the minimal value
        var tmp = BigFloat.log(BigFloat.min(BigFloat.abs(x.a), BigFloat.abs(x.b)), {maximumSignificantDigits: 1, roundingMode: 'half-even'}).toFixed(0).length;
        guessedPrecision = Math.max(Math.ceil(tmp * Math.log2(10) / 2), 1);
      }
    }
    guessedPrecision *= 2;
  }
  if (guessedPrecision !== 256) {
    //console.log(guessedPrecision);
  }
  return decimalToStringCallback(result);
};

self.toDecimalStringInternal = toDecimalStringInternal;

toDecimalStringInternal.testables = {
  BigDecimalMath: BigDecimalMath,
  BigDecimal: BigDecimal,
  BigFloat: BigFloat,
  Interval: Interval
};

})();
(function () {
"use strict";
  

  function GF2(a) {
    this.a = a;
  }
  GF2.prototype = Object.create(Expression.prototype);

  Expression.GF2 = GF2;
  Expression.GF2.prototype.toString = function (options) {
    return "GF2(" + this.a.toString(Expression.setTopLevel(true, options)) + ")";
  };

  function GF2Value(value) {
    //Expression.call(this);
    this.value = value;
  }
  Expression.GF2Value = GF2Value;

  GF2Value.prototype = Object.create(Expression.prototype);
  Expression.GF2Value.prototype.equals = function (b) {
    if (Expression.ZERO === b) {
      return this.value === 0;//!
    }
    return false;//?
  };
  Expression.GF2Value.prototype.negate = function () {
    return new GF2Value(this.value === 0 ? 0 : 2 - this.value);
  };

  GF2Value.prototype.add = function (x) {
    if (x === Expression.ZERO) {
      return new GF2Value(this.value);
    }
    if (!(x instanceof GF2Value)) {
      throw new RangeError();
    }
    var v = this.value - 2 + x.value;
    return new GF2Value(v >= 0 ? v : v + 2);
  };

  GF2Value.prototype.multiply = function (x) {
    if (x === Expression.ZERO) {
      return new GF2Value(0);
    }
    if (!(x instanceof GF2Value)) {
      throw new RangeError();
    }
    var v = this.value * x.value;
    return new GF2Value(v - 2 * Math.floor(v / 2));
  };

  GF2Value.prototype.divide = function (x) {
    //if (!(x instanceof GF2Value)) {
    //  throw new RangeError();
    //}
    return new GF2Value(this.value);
  };

  Expression.prototype.GF2 = function () {
    var x = this;
    if (!(x instanceof Expression.Matrix)) {
      throw new RangeError("NotSupportedError");//?
    }
    return new Expression.Matrix(x.matrix.map(function (e, i, j) {
      if (!(e.equals(Expression.ZERO) || e.equals(Expression.ONE))) {
        throw new TypeError();
      }
      return new Expression.GF2Value(e.equals(Expression.ZERO) ? 0 : 1);
    }));
  };

  GF2Value.prototype.toString = function (options) {
    return this.value.toString();
  };

})();
(function () {
"use strict";
  
  

  var Integer = Expression.Integer;
  var Addition = Expression.Addition;
  var Multiplication = Expression.Multiplication;
  var Division = Expression.Division;
  var Exponentiation = Expression.Exponentiation;
  var BinaryOperation = Expression.BinaryOperation;

var separateSinCos = function (e) {
  if (!(e instanceof Multiplication)) {
    throw new TypeError();
  }
  var sinCos = undefined;
  var other = undefined;
  var x = e;
  for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
    var v = y;
    if (v instanceof Sin || v instanceof Cos ||
        (v instanceof Exponentiation && (v.a instanceof Sin || v.a instanceof Cos))) {
      sinCos = sinCos == undefined ? v : sinCos.multiply(v);
    } else {
      other = other == undefined ? v : other.multiply(v);
    }
  }
  return {
    sinCos: sinCos == undefined ? Expression.ONE : sinCos,
    other: other == undefined ? Expression.ONE : other
  };
};

var expandMainOp = function (u) {
  return u;
};

var contractTrigonometryInternal = function (a, b) {
  // sin(a) * sin(b) = (cos(a - b) - cos(a + b)) / 2
  // sin(a) * cos(b) = (sin(a + b) + sin(a - b)) / 2
  // cos(a) * sin(b) = (sin(a + b) - sin(a - b)) / 2
  // cos(a) * cos(b) = (cos(a - b) + cos(a + b)) / 2
  var ax = a.a;
  var bx = b.a;
  if (a instanceof Sin && b instanceof Sin) {
    return ax.subtract(bx).cos().divide(Expression.TWO).subtract(ax.add(bx).cos().divide(Expression.TWO));
  }
  if (a instanceof Sin && b instanceof Cos) {
    return ax.add(bx).sin().divide(Expression.TWO).add(ax.subtract(bx).sin().divide(Expression.TWO));
  }
  if (a instanceof Cos && b instanceof Sin) {
    return ax.add(bx).sin().divide(Expression.TWO).subtract(ax.subtract(bx).sin().divide(Expression.TWO));
  }
  if (a instanceof Cos && b instanceof Cos) {
    return ax.subtract(bx).cos().divide(Expression.TWO).add(ax.add(bx).cos().divide(Expression.TWO));
  }
  throw new TypeError();
};

// page 306
var contractTrigonometryPower = function (u) {
  var b = u.a;
  if (!(b instanceof Sin) && !(b instanceof Cos)) {
    return u;
  }
  var e = contractTrigonometryInternal(b, b).multiply(u.divide(b.multiply(b)));
  return contractTrigonometryRules(e.getNumerator()).divide(e.getDenominator());
};

// page 318
var contractTrigonometryProduct = function (u) {
  var i = u.factors();
  var a = i.next().value;
  var b = i.next().value;
  var rest = Expression.ONE;
  var y = i.next().value;
  while (y != null) {
    rest = y.multiply(rest);//TODO: fix
    y = i.next().value;
  }

  if (a instanceof Exponentiation) {
    a = contractTrigonometryPower(a);
    return contractTrigonometryRules(a.multiply(b).multiply(rest));
  }
  if (b instanceof Exponentiation) {
    b = contractTrigonometryPower(b);
    return contractTrigonometryRules(a.multiply(b).multiply(rest));
  }
  // (a instanceof Sin || a instanceof Cos) && (b instanceof Sin || b instanceof Cos)
  var c = contractTrigonometryInternal(a, b);

  return contractTrigonometryRules(c.multiply(rest));
};

// page 317
var contractTrigonometryRules = function (u) {
  var v = expandMainOp(u);
  if (v instanceof Exponentiation) {
    return contractTrigonometryPower(v);
  }
  if (v instanceof Multiplication) {
    var tmp = separateSinCos(v);
    var c = tmp.other;
    var d = tmp.sinCos;
    if (d.equals(Expression.ONE)) {
      return v;
    }
    if (d instanceof Sin || d instanceof Cos) {
      return v;
    }
    if (d instanceof Exponentiation) {
      return expandMainOp(c.multiply(contractTrigonometryPower(d)));
    }
    if (d instanceof Multiplication) {
      return expandMainOp(c.multiply(contractTrigonometryProduct(d)));
    }
    throw new TypeError();
  }
  if (v instanceof Addition) {
    var s = Expression.ZERO;
    var e = v;
    for (var iteratorx = e.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
      if (x instanceof Multiplication || x instanceof Exponentiation) {
        s = s.add(contractTrigonometryRules(x));
      } else {
        s = s.add(x);
      }
    }
    return s;
  }
  return v;
};

var map = function (f, u) {
  if (u instanceof Integer) {
    return f(u);
  }
  if (u instanceof Addition) {
    return f(map(f, u.a).add(map(f, u.b)));
  }
  if (u instanceof Multiplication) {
    return f(map(f, u.a).multiply(map(f, u.b)));
  }
  if (u instanceof Division) {
    return f(map(f, u.a).divide(map(f, u.b)));
  }
  if (u instanceof Exponentiation) {
    return f(map(f, u.a).pow(map(f, u.b)));
  }
  if (u instanceof Sin) {
    return f(map(f, u.a).sin());
  }
  if (u instanceof Cos) {
    return f(map(f, u.a).cos());
  }
  if (u instanceof Expression.Matrix) {
    return new Expression.Matrix(u.matrix.map(function (e, i, j) {
      return map(f, e);
    }));
  }
  if (u instanceof Expression.Polynomial) {//TODO: test case
    return new Expression.Polynomial(u.polynomial.map(function (c, d) {
      return map(f, c);
    }));
  }
  if (u instanceof Expression.GF2Value) {
    return u;
  }
  if (u instanceof Expression.NthRoot) {
    return f(u);
  }
  if (u instanceof Expression.Negation) {
    return u;//?
  }
  if (u instanceof Expression.Complex) {
    return u;//?
  }
  if (u instanceof Expression.NonSimplifiedExpression) {
    //TODO: fix
    return u;//?
  }
  if (u instanceof Expression.Degrees) {
    return u;//?
  }
  if (u instanceof Expression.Radians) {
    return u;//?
  }
  if (u instanceof Expression.Symbol) {
    return f(u);//?
  }
  if (u instanceof Expression.Arctan) {
    return f(map(f, u.a).arctan());
  }
  if (u instanceof Expression.Logarithm) {
    return f(map(f, u.a).logarithm());
  }
  if (u instanceof Expression.Determinant) {
    return f(map(f, u.a).determinant());
  }
  throw new TypeError();
};

Expression._map = map;

// page 303

var expandTrigonometryRulesInternal = function (a, b, type) {
  if (type === "cos") {
    // cos(a + b) = cos(a) * cos(b) - sin(a) * sin(b)
    return expandTrigonometryRules(a, "cos").multiply(expandTrigonometryRules(b, "cos")).subtract(expandTrigonometryRules(a, "sin").multiply(expandTrigonometryRules(b, "sin")));
  }
  if (type === "sin") {
    // sin(a + b) = sin(a) * cos(b) + cos(a) * sin(b)
    return expandTrigonometryRules(a, "sin").multiply(expandTrigonometryRules(b, "cos")).add(expandTrigonometryRules(a, "cos").multiply(expandTrigonometryRules(b, "sin")));
  }
  throw new TypeError(type);
};

var expandTrigonometryRules = function (A, type) {
  if (A instanceof Addition) {
    return expandTrigonometryRulesInternal(A.a, A.b, type);
  } else if (A instanceof Multiplication) {
    var i = Expression.ONE;
    for (var iteratory = A.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
      if (y instanceof Expression.Integer) {
        i = i.multiply(y);
      }
    }
    var a = i;
    var b = A.divide(i);
    //var a = A.a;
    //var b = A.b;
    if (!(a instanceof Integer)) {
      throw new TypeError();
    }
    if (a.equals(Expression.ONE)) {
      if (type === "cos") {
        return A.cos();
      }
      if (type === "sin") {
        return A.sin();
      }
    }
    if (a.compareTo(Expression.ONE.negate()) === 0) {
      if (type === "cos") {
        return expandTrigonometryRules(b, type);
      }
      if (type === "sin") {
        return expandTrigonometryRules(b, type).negate();
      }
    }
    var c = a.compareTo(Expression.ZERO) > 0 ? Expression.ONE : Expression.ONE.negate();
    return expandTrigonometryRulesInternal(c.multiply(b), a.subtract(c).multiply(b), type);
  } else if (A instanceof Division) {
    var t = simplifyConstantValue(A, type);
    if (t != null) {
      return t;
    }
    var a = A.a;
    var b = A.b;
    if (a instanceof Addition) {
      return expandTrigonometryRulesInternal(a.a.divide(b), a.b.divide(b), type);
    }
  }
  if (A instanceof Expression.Symbol ||
      A instanceof Expression.Exponentiation && A.a instanceof Expression.Symbol && Expression.isScalar(A.a) && A.b instanceof Expression.Integer && A.b.compareTo(Expression.ONE) > 0 || // TODO: ?
      A instanceof Expression.Degrees ||
      A instanceof Expression.Radians ||
      A instanceof Expression.Complex ||
      A instanceof Expression.Arctan) {
    if (type === "cos") {
      return A.cos();
    }
    if (type === "sin") {
      return A.sin();
    }
  }
  throw new TypeError();
};

// CA and SC, EA, p. 303

var expandTrigonometry = function (u) {
  return map(function (v) {
    if (v instanceof Sin) {
      return expandTrigonometryRules(v.a, "sin");
    }
    if (v instanceof Cos) {
      return expandTrigonometryRules(v.a, "cos");
    }
    return v;
  }, u);
};

Expression._expandTrigonometry = expandTrigonometry;//!

var contractTrigonometry = function (u) {
  return map(function (v) {
    if (v instanceof Multiplication || v instanceof Exponentiation || v instanceof Addition) {//! Addition - ?
      return contractTrigonometryRules(v);
    }
    if (v instanceof Division) {
      return contractTrigonometryRules(v.getNumerator()).divide(v.getDenominator());
    }
    return v;
  }, u);
};

// page 323

var hasTrigonometry = function (e) {//TODO: remove
  if (e instanceof BinaryOperation) {
    return hasTrigonometry(e.a) || hasTrigonometry(e.b);
  }
  return e instanceof Cos || e instanceof Sin;
};

var simplifyTrigonometry = function (u) {
  if (!hasTrigonometry(u)) {
    return u;
  }
  //!new
  var v = null;
  var r = null;
  Expression._map(function (e) {
    // sin(x/2) -> sin(t), t = 2x
    if (e instanceof Expression.Sin || e instanceof Expression.Cos) {
      var a = e.a;
      if (a instanceof Division) {
        var n = a.getNumerator();
        var d = a.getDenominator();
        if (!d.equals(Expression.ONE)) {
          for (var iteratorx = n.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
            var g = x.gcd(d);
            if (!g.equals(d)) {
              for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
                if (y instanceof Expression.Symbol && y !== Expression.PI) {
                  r = d.divide(g);
                  v = y;
                }
              }
            }
          }
        }
      }
    }
    return e;
  }, u);
  if (v != null && r != null) {
    // sin(x/2) -> sin(x)
    u = Expression._substitute(u, v, v.multiply(r), v.divide(r));
    u = simplifyTrigonometry(u);
    // sin(x) -> sin(x/2)
    u = Expression._substitute(u, v, v.divide(r), v.multiply(r));
    return u;
  }

  //!
  // TODO: https://en.wikipedia.org/wiki/Euler%27s_formula#Relationship_to_trigonometry - is it possible to do this with anoher method?
  var n = u.getNumerator();
  n = expandTrigonometry(n);
  n = contractTrigonometry(n);
  var d = u.getDenominator();
  d = expandTrigonometry(d);
  d = contractTrigonometry(d);
  return n.divide(d);
};

Expression.Division.prototype.compare4Multiplication = function (y) {
  if (y instanceof Division) {
    return this.a.compare4Multiplication(y.a) || this.b.compare4Multiplication(y.b);
  }
  return -1;//TODO:
};
Expression.Division.prototype.compare4MultiplicationSymbol = function () {
  return +1;//TODO:
};
Expression.Division.prototype.compare4MultiplicationInteger = function () {
  return +1;//TODO:
};
Expression.Division.prototype.compare4MultiplicationNthRoot = function () {
  return +1;//TODO:
};

Expression.simplifyTrigonometry = simplifyTrigonometry;//?


function Sin(x) {
  Expression.Function.call(this, "sin", x);
}
Sin.prototype = Object.create(Expression.Function.prototype);

//TODO: new 2017-04-26
var simplifyConstantValueInternal = function (d, fraction) {
  fraction = fraction || Expression.ZERO;
  if (d >= +360 || d <= -360) {
    throw new RangeError();
  }
  if (d < 0) {
    d = 0 - d;
    fraction = fraction.negate();
  }
  if (d >= 180) {
    d = d - 180;
    var tmp = simplifyConstantValueInternal(d, fraction);
    return tmp == null ? null : tmp.negate();
  }
  if (d > 90) {
    d = 0 - d;
    fraction = fraction.negate();
    d = d + 180;
    var tmp = simplifyConstantValueInternal(d, fraction);
    return tmp == null ? null : tmp.negate();
  }
  console.assert(d >= 0 && d <= 90);
  console.assert(fraction.getNumerator().abs().compareTo(fraction.getDenominator()) < 0);

  function f(x) {
    // https://en.wikipedia.org/wiki/Trigonometric_constants_expressed_in_real_radicals#Calculated_trigonometric_values_for_sine_and_cosine
    // cos(x) = sqrt(2+2cos(2x))/2 - sign - ?
    var y = simplifyConstantValueInternal(x * 2);
    return y == null ? null : Expression.TWO.add(Expression.TWO.multiply(y)).squareRoot().divide(Expression.TWO);
  }
  function cosapb(a, b) { // cos(d) = cos(a + b)
    var cosa = simplifyConstantValueInternal(a);
    var cosb = simplifyConstantValueInternal(b);
    var sina = simplifyConstantValueInternal(90 - a);
    var sinb = simplifyConstantValueInternal(90 - b);
    return cosa.multiply(cosb).subtract(sina.multiply(sinb));
  }

  function phi() {
    return Expression.ONE.add(Expression.TWO.add(Expression.TWO).add(Expression.ONE).squareRoot()).divide(Expression.TWO);
  }

  //function cos2x(d) { // cos(d) = cos(a + b)
    // cos(2x) = 2cos^2(x)-1
    //var y = simplifyConstantValueInternal(d / 2);
    //return Expression.TWO.multiply(y.multiply(y)).subtract(Expression.ONE);
  //}


  //if (d === 24) {
    // https://en.wikipedia.org/wiki/Trigonometric_constants_expressed_in_real_radicals#24°:_sum_12°_+_12°
    //return ExpressionParser.parse('(sqrt(6*(5-sqrt(5)))+sqrt(5)+1)/8');
    //return cosapb(60, -36);
  //}
  //if (d === 42) {
    // cos(42) = sin(48) = 2*sin(24)*cos(24)
    //return ExpressionParser.parse('2*sin(24)*cos(24)');
  //}

  // 0, 15, 30, 36, 45, 60, 72, 75, 90 - more simple

if (fraction.equals(Expression.ZERO)) {
  if (d === 0) {
    return Expression.ONE;
  }
  if (d === 30) {
    return Expression.ONE.add(Expression.TWO).squareRoot().divide(Expression.TWO);
  }
  if (d === 45) {
    return Expression.ONE.divide(Expression.TWO.squareRoot());
  }
  if (d === 60) {
    return Expression.ONE.divide(Expression.TWO);
  }
  if (d === 90) {
    return Expression.ZERO;
  }

  if (d === 15) {
    return f(d);
  }
  if (d === 75) {
    return f(d);
  }

  if (d === 36) {
    return phi().divide(Expression.TWO);
  }
  if (d === 72) {
    return phi().subtract(Expression.ONE).divide(Expression.TWO);
  }

  if (d === 18) {
    return Expression.TWO.add(phi()).squareRoot().divide(Expression.TWO);
  }
  // http://www.maths.surrey.ac.uk/hosted-sites/R.Knott/Fibonacci/simpleTrig.html#section4.2
  if (d === 54) {
    //return Expression.TWO.subtract(Expression.TWO.subtract(phi()).squareRoot()).squareRoot().divide(Expression.TWO);
    // https://www.cut-the-knot.org/pythagoras/cos36.shtml
    return Expression.TWO.add(Expression.ONE).subtract(phi()).squareRoot().divide(Expression.TWO);
  }

  // https://en.wikipedia.org/wiki/Sine


  //for (var d = 3; d <= 90; d += 3) {
  //  if (d % 15 !== 0 && d % 18 !== 0) {
  //    for (var a = 75; a > 0; a -= 15) {
  //      var b = -(a - d);
  //      if (b % 18 === 0) {
  //        console.log(`cos(${d})=cos(${a}+${b})`);
  //      }
  //    }
  //  }
  //}


  //if (d === 3) {
    // https://en.wikipedia.org/wiki/Trigonometric_constants_expressed_in_real_radicals#3°:_regular_hexacontagon_(60-sided_polygon)
    //return cosapb(18, -15);
  //}

  if (d % 3 === 0) {
    var a = 90 - (Math.floor(d / 3) % 6) * 15;
    var b = -(a - d);
    return cosapb(a, b);
  }
}

if (fraction.multiply(Expression.TWO).getDenominator().equals(Expression.ONE)) {
  var dd = d + fraction.multiply(Expression.TWO).toNumber() / 2;
  if (dd === 7.5) {
    return cosapb(30, -22.5);
  }
  if (dd === 22.5) {
    return f(dd);
  }
  if (dd === 37.5) {
    return cosapb(60, -22.5);
  }
  if (dd === 52.5) {
    return cosapb(30, +22.5);
  }
  if (dd === 67.5) {
    return f(dd);
  }
  if (dd === 82.5) {
    return cosapb(60, +22.5);
  }
}

  //TODO: sin(1.5)
  
  // https://math.stackexchange.com/questions/125774/how-to-expand-cos-nx-with-cos-x#answer-125826
  if (d % 1 === 0) {//TODO: !!!
    var rational = Integer.fromNumber(d).add(fraction).divide(Integer.fromNumber(60));
    //var n = 360 / Math.gcd(360, d);
    var n = rational.getDenominator().toNumber();
    var a = rational.getNumerator().toNumber();
    if (n > Number.MAX_SAFE_INTEGER || a > Number.MAX_SAFE_INTEGER) {
      return undefined;
    }
    var T = function (n) {
      // https://en.wikipedia.org/wiki/Chebyshev_polynomials#Definition
      var x = Polynomial.of(Expression.ZERO, Expression.ONE);
      var Tprevious = Polynomial.of(Expression.ONE);
      var Tcurrent = x;
      var i = 1;
      while (i < n) {
        var Tnext = Polynomial.of(Expression.TWO).multiply(x).multiply(Tcurrent).subtract(Tprevious);
        Tprevious = Tcurrent;
        Tcurrent = Tnext;
        i += 1;
      }
      return Tcurrent;
    };
    var polynomial = T(n).subtract(Polynomial.of(simplifyConstantValueInternal(60 * (a % 6), Expression.ZERO)));
    polynomial = polynomial.scale(polynomial.getContent().inverse());
    //TODO: ?
    var approximate = Math.cos((d + fraction.getNumerator().toNumber() / fraction.getDenominator().toNumber()) / 180 * Math.PI);
    var tmp = Math.floor(approximate * Math.pow(2, 24) + 0.5);
    var scale = Expression.Integer.fromNumber(Math.pow(2, 24));
    var interval = new Expression.ExpressionPolynomialRoot.SimpleInterval(Expression.Integer.fromNumber(tmp - 1).divide(scale), Expression.Integer.fromNumber(tmp + 1).divide(scale));
    return Expression.ExpressionPolynomialRoot._create(polynomial, interval);
  }
  
  return undefined;
};

var simplifyConstantValue = function (x, type) {
  var a = undefined;
  var b = undefined;
  if (x instanceof Integer && x.compareTo(Expression.ZERO) === 0) {
    a = Expression.ZERO;
    b = Expression.ONE;
  } else if (x === Expression.PI) {
    a = Expression.ONE;
    b = Expression.ONE;
  } else if (x instanceof Multiplication && x.a instanceof Integer && x.b === Expression.PI) {
    a = x.a;
    b = Expression.ONE;
  } else if (x instanceof Division && x.b instanceof Integer && x.a === Expression.PI) {
    a = Expression.ONE;
    b = x.b;
  } else if (x instanceof Division && x.b instanceof Integer && x.a instanceof Multiplication && x.a.a instanceof Integer && x.a.b === Expression.PI) {
    a = x.a.a;
    b = x.b;
  } else if (x instanceof Expression.Degrees) {
    var t = x.value.simplify();
    t = t.multiply(Expression.PI).divide(Integer.fromNumber(180));
    if (type === 'sin') {
      return t.sin();
    }
    if (type === 'cos') {
      return t.cos();
    }
  }
  if (a != undefined && b != undefined) {
    //b = b.toNumber();
    //var k = Math.pow(2, 44);
    //if (b >= 1 && b <= 180 && (180 * k) % b === 0) {
      //var d = a.multiply(Integer.fromNumber(Math.floor((180 * k) / b))).remainder(Integer.fromNumber(360 * k)).toNumber();
      //d /= k;
      var integer = a.multiply(Integer.fromNumber(180)).truncatingDivide(b);
      var fraction = a.multiply(Integer.fromNumber(180)).subtract(integer.multiply(b)).divide(b);
      //var degrees = integer.remainder(Integer.fromNumber(360)).add(fraction);
      var d = integer.remainder(Integer.fromNumber(360)).toNumber();
      if (type === "sin") {
        d = 90 - d;
        fraction = fraction.negate();
        if (d >= 360 - 90) {
          d -= 360;
        }
      } else if (type !== "cos") {
        throw new TypeError();
      }
      return simplifyConstantValueInternal(d, fraction);
    //}
  }
  if (x instanceof Expression.Radians && x.value.equals(Expression.ZERO)) {
    return simplifyConstantValue(x.value, type);
  }
  if (Expression.has(x, Expression.Complex)) {
    if (type === "sin") {
      return Expression.I.multiply(x.divide(Expression.I).sinh());
    }
    if (type === "cos") {
      return x.divide(Expression.I).cosh();
    }
  }
  if (x instanceof Expression.Arctan) {
    if (Expression.callback != undefined) {
      Expression.callback(new Expression.Event("trigonometric-function-of-inverse-trigonometric-function-arg", new Expression.Matrix(Matrix.I(1))));
    }
    // https://www.rapidtables.com/math/trigonometry/arctan.html#rules
    // https://en.wikipedia.org/wiki/Inverse_trigonometric_functions#Relationships_between_trigonometric_functions_and_inverse_trigonometric_functions
    //TODO: lin in details
    //TODO: test
    var a = x.a;
    if (type === "sin") {
      //TODO: fix (sign - ?), fix complex numbers - ?
      return a.getNumerator().divide(a.getDenominator()._pow(2).add(a.getNumerator()._pow(2)).squareRoot());
    }
    if (type === "cos") {
      //TODO: fix (sign - ?), fix complex numbers - ?
      return a.getDenominator().divide(a.getDenominator()._pow(2).add(a.getNumerator()._pow(2)).squareRoot());
    }
    //TODO:
  }
  if (x instanceof Expression.ExpressionWithPolynomialRoot) {
    return simplifyConstantValue(x.upgrade(), type);
  }
  return undefined;
};

Expression.prototype.cosh = function () {
  var a = this;
  return a.exp().add(a.negate().exp()).divide(Expression.TWO);
};

Expression.prototype.sinh = function () {
  var a = this;
  return a.exp().subtract(a.negate().exp()).divide(Expression.TWO);
};

Expression.prototype.tanh = function () {
  var a = this;
  return a.exp().subtract(a.negate().exp()).divide(a.exp().add(a.negate().exp()));
};

Expression.prototype.coth = function () {
  var a = this;
  return a.exp().add(a.negate().exp()).divide(a.exp().subtract(a.negate().exp()));
};

Expression.prototype.arccos = function () {
  var a = this;
  //return a.pow(Expression.TWO).subtract(Expression.ONE).negate().squareRoot().divide(a).arctan();
  return a.arcsin().subtract(Expression.PI.divide(Expression.TWO)).negate();
};

Expression.prototype.arcsin = function () {
  var a = this;
  // see https://en.wikipedia.org/wiki/Inverse_trigonometric_functions#:~:text=Useful%20identities%20if%20one%20only%20has%20a%20fragment%20of%20a%20sine%20table:
  return a.divide(a.pow(Expression.TWO).subtract(Expression.ONE).negate().squareRoot()).arctan();
};

Expression.prototype.arccot = function () {
  var a = this;
  //TODO: details ?
  // see https://en.wikipedia.org/wiki/Inverse_trigonometric_functions#:~:text=Useful%20identities%20if%20one%20only%20has%20a%20fragment%20of%20a%20sine%20table:
  return a.arctan().subtract(Expression.PI.divide(Expression.TWO)).negate();
};

Expression.prototype.arcosh = function () {
  var x = this;
  // https://en.wikipedia.org/wiki/Inverse_hyperbolic_functions#Inverse_hyperbolic_cosine
  return x.add(x.multiply(x).subtract(Expression.ONE).squareRoot()).logarithm();
};
Expression.prototype.arsinh = function () {
  var x = this;
  // https://en.wikipedia.org/wiki/Inverse_hyperbolic_functions#Inverse_hyperbolic_cosine
  return x.add(x.multiply(x).add(Expression.ONE).squareRoot()).logarithm();
};
Expression.prototype.artanh = function () {
  var x = this;
  // https://en.wikipedia.org/wiki/Inverse_hyperbolic_functions#Inverse_hyperbolic_tangent
  return x.add(Expression.ONE).divide(x.subtract(Expression.ONE).negate()).logarithm().divide(Expression.TWO);
};
Expression.prototype.arcoth = function () {
  var x = this;
  // https://en.wikipedia.org/wiki/Inverse_hyperbolic_functions#Inverse_hyperbolic_tangent
  return x.add(Expression.ONE).divide(x.subtract(Expression.ONE)).logarithm().divide(Expression.TWO);
};

Expression.isRealAlgebraicNumber = function isRealAlgebraicNumber(x) {
  return x instanceof Expression.Integer ||
         x instanceof Expression.NthRoot && typeof x.n === "number" && x.n % 1 === 0 && isRealAlgebraicNumber(x.a) && (x.n % 2 !== 0 || Expression._isPositive(x.a)) ||
         x instanceof Expression.Division && isRealAlgebraicNumber(x.getNumerator()) && isRealAlgebraicNumber(x.getDenominator()) ||
         x instanceof Expression.Addition && isRealAlgebraicNumber(x.a) && isRealAlgebraicNumber(x.b) ||
         x instanceof Expression.Multiplication && isRealAlgebraicNumber(x.a) && isRealAlgebraicNumber(x.b);
};

var isArgumentValid = function (x, type) {
  if (x instanceof Expression.Radians) {
    // https://ru.wikipedia.org/wiki/Трансцендентное_число#Примеры_трансцендентных_чисел
    return Expression.isRealAlgebraicNumber(x.value);
  }
  if (x instanceof Expression.Degrees) {
    return simplifyConstantValue(x, type) != undefined;
  }
  if (x instanceof Expression.Symbol) {
    return Expression.isScalar(x);
  }
  if (x instanceof Expression.Exponentiation) {
    //TODO: ?
    return x.a instanceof Expression.Symbol && Expression.isScalar(x.a) && x.b instanceof Expression.Integer && x.b.compareTo(Expression.ONE) > 0;
  }
  if (x instanceof Addition) {
    return isArgumentValid(x.a, type) && isArgumentValid(x.b, type);
  }
  if (x instanceof Expression.Arctan) {
    return true;//?
  }
  if (x instanceof Multiplication) {
    if (x.a instanceof Integer && Expression.isScalar(x.b) && x.b instanceof Expression.Symbol) {
      return true;
    }
    if (x.a instanceof Integer && Expression.isScalar(x.b) && x.b instanceof Expression.Arctan) {
      return true;
    }
    if (Expression.isScalar(x.b) && x.b instanceof Expression.Symbol) {
      if (x.a instanceof Expression.NthRoot && x.a.a instanceof Integer) {
        return true;
      }
      if (x.a instanceof Multiplication && x.a.a instanceof Integer && x.a.b instanceof Expression.NthRoot && x.a.b.a instanceof Integer) {
        return true;
      }
    }
    var c = Expression.getConstant(x);
    var t = x.divide(c);
    if (Expression.isScalar(x) &&
        (c instanceof Integer || c instanceof Expression.Complex) &&
        (t instanceof Multiplication || t instanceof Expression.Symbol || t instanceof Expression.Exponentiation)) {
      for (var iteratory = t.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
        if (!(y instanceof Expression.NthRoot) &&
            !(y instanceof Expression.Symbol) &&
            !(y instanceof Expression.Exponentiation && y.a instanceof Expression.Symbol && Expression.isScalar(y.a) && y.b instanceof Expression.Integer && y.b.compareTo(Expression.ONE) > 0)) {
          return false;
        }
      }
      //TODO: is it correct ?
      return true;//!?
    }
  }
  if (x instanceof Division) {
    if (x.b instanceof Integer) {
      return isArgumentValid(x.a);
    }
  }
  if (x instanceof Expression.Complex) {
    return true;//?
  }
  return false;
};

Expression.prototype.sin = function () {
  var x = this;
  var t = simplifyConstantValue(x, "sin");
  if (t != undefined) {
    return t;
  }
  if (x.isNegative()) {
    return x.negate().sin().negate();
  }
  if (!isArgumentValid(x, "sin")) {
    throw new RangeError("NotSupportedError");
  }
  return new Sin(x);
};

function Cos(x) {
  Expression.Function.call(this, "cos", x);
}
Cos.prototype = Object.create(Expression.Function.prototype);

Expression.prototype.cos = function () {
  var x = this;
  var t = simplifyConstantValue(x, "cos");
  if (t != undefined) {
    return t;
  }
  if (x.isNegative()) {
    return x.negate().cos();
  }
  if (!isArgumentValid(x, "cos")) {
    throw new RangeError("NotSupportedError");
  }
  return new Cos(x);
};

Expression.simplifications.push(Expression.simplifyTrigonometry);

Expression.Sin = Sin;
Expression.Cos = Cos;

//Expression.Negation.prototype.compare4Multiplication = function (y) {
//TODO: fix, more tests
//  return new Expression.Multiplication(Expression.ONE.negate(), this.a).compare4Multiplication(y);
//};

Expression.Addition.prototype.compare4Addition = function (y) {
  // cos(a + b) + cos(a + b)
  var x = this;
  return Expression.Addition.compare4Addition(x, y);
};

Expression.Multiplication.prototype.compare4MultiplicationInteger = function (x) {
  return -1;
};

/*
Expression.MatrixSymbol.prototype.compare4MultiplicationExponentiation = function (x) {
  return -1;//?
};
*/

//!!!
Expression.Addition.prototype.compare4Multiplication = function (y) {
  if (y instanceof Integer) {
    return -1;
  }
  if (y instanceof Expression.MatrixSymbol) {
    return +1;
  }
  //TODO: fix

  var x = this;
  var i = x.summands();
  var j = y.summands();
  var a = i.next().value;
  var b = j.next().value;
  while (a != null && b != null) {
    var c = a.compare4Multiplication(b);
    if (c !== 0) {
      return c;
    }
    a = i.next().value;
    b = j.next().value;
  }
  return a != null ? +1 : (b != null ? -1 : 0);
};

Expression.Addition.prototype.compare4MultiplicationSymbol = function (x) {
  return 0 - this.compare4Multiplication(x);
};

Expression.Addition.prototype.compare4MultiplicationInteger = function (x) {
  return +1;
};

Expression.Addition.compare4Addition = function (x, y) {
  var i = x.summands();
  var j = y.summands();
  var a = i.next().value;
  var b = j.next().value;
  while (a != null && b != null) {
    var c = a.compare4Addition(b);
    if (c !== 0) {
      return c;
    }
    a = i.next().value;
    b = j.next().value;
  }
  return a != null ? +1 : (b != null ? -1 : 0);
};

//!!!


// unit of measurement
Expression.Unit = function (value) {
  this.value = value;
};
Expression.Unit.prototype = Object.create(Expression.prototype);
Expression.Unit.prototype.toString = function (options) {
  var b = this.value;
  var fb = b instanceof Expression.Integer ? false : true;
  return (fb ? "(" : "") + b.toString(options) + (fb ? ")" : "") + this.unitSymbol();
};
Expression.Unit.prototype.equals = function (y) {
  return y instanceof Expression.Unit && this.unitSymbol() === y.unitSymbol() && this.value.equals(y.value);
};
Expression.Unit.prototype.compare4AdditionSymbol = function (x) {
  //return -1;
  return x.compare4Addition(this.value);
};
Expression.Unit.prototype.compare4Addition = function (y) {
  return this.value.compare4Addition(y instanceof Expression.Unit && this.unitSymbol() === y.unitSymbol() ? y.value : y);
};
Expression.Unit.prototype.compare4Multiplication = function (y) {
  return this.value.compare4Multiplication(y instanceof Expression.Unit && this.unitSymbol() === y.unitSymbol() ? y.value : y);
};
Expression.Unit.prototype.compare4MultiplicationSymbol = function (x) {
  return x.compare4Multiplication(this.value);
};
Expression.Unit.prototype.compare4MultiplicationInteger = function (x) {
  return +1;
};
Expression.Unit.prototype.negate = function () {
  return this.create(this.value.negate());
};
Expression.Unit.prototype.multiply = function (y) {
  return this.create(this.value.multiply(y));
};
Expression.Unit.prototype.multiplyInteger = function (x) {
  return this.create(x.multiply(this.value));
};

Expression.Unit.prototype.add = function (y) {
  if (y instanceof Expression.Unit && this.unitSymbol() === y.unitSymbol()) {
    var x = this.value.add(y.value);
    if (x.equals(Expression.ZERO)) {
      return x;//!?
    }
    return this.create(x);//!?
  }
  return Expression.prototype.add.call(this, y);
};


//!new 2017-04-26
Expression.Degrees = function (value) {
  Expression.Unit.call(this, value);
};
Expression.Degrees.prototype = Object.create(Expression.Unit.prototype);
Expression.Degrees.prototype.unitSymbol = function () {
  return "\u00B0";
};
Expression.Degrees.prototype.create = function (value) {
  return new Expression.Degrees(value);
};

//!new 2019-12-27
Expression.Radians = function (value) {
  this.value = value;
};
Expression.Radians.prototype = Object.create(Expression.Unit.prototype);
Expression.Radians.prototype.unitSymbol = function () {
  return " rad";
};
Expression.Radians.prototype.create = function (value) {
  return new Expression.Radians(value);
};


//!new 2019-11-23
// https://en.wikipedia.org/wiki/Trigonometric_functions_of_matrices#cite_note-3
Expression.Matrix.prototype.sin = function () {
  var X = this;
  var i = Expression.I;
  var TWO = Expression.TWO;
  return i.multiply(X).exp().subtract(i.negate().multiply(X).exp()).divide(TWO.multiply(i));
};
Expression.Matrix.prototype.cos = function () {
  var X = this;
  var i = Expression.I;
  var TWO = Expression.TWO;
  return i.multiply(X).exp().add(i.negate().multiply(X).exp()).divide(TWO);
};



//!
(function () {
  var i = new Expression.Symbol('_i');
  function replaceSinCos(e) {
    return Expression._map(function (x) {
      if (x instanceof Expression.Sin) {
        var a = x.a;
        // Euler's formula
        return i.multiply(a).exp().subtract(i.multiply(a).negate().exp()).divide(Expression.TWO.multiply(Expression.I));
      }
      if (x instanceof Expression.Cos) {
        var a = x.a;
        // Euler's formula
        return i.multiply(a).exp().add(i.multiply(a).negate().exp()).divide(Expression.TWO);
      }
      return x;
    }, e);
  }
  function replaceBySinCos(e) {
    return Expression._map(function (x) {
      if (x instanceof Expression.Exponentiation && x.a === Expression.E) {
        var b = x.b;
        //var p = Polynomial.toPolynomial(b, i);
        var p = Polynomial.toPolynomial(b.getNumerator(), i).scale(b.getDenominator().inverse()); // as denominator may be not equal 1 and Polynomial.toPolynomial throws in that case
        if (p.getDegree() === 1) {
          var q = p.getCoefficient(0);
          var w = p.getCoefficient(1);
          // Euler's formula
          return w.cos().add(Expression.I.multiply(w.sin())).multiply(q.exp());
        }
        if (p.getDegree() > 1) {
          throw new TypeError("!?");
        }
      }
      return x;
    }, e);
  }

  Expression._replaceSinCos = replaceSinCos;
  Expression._replaceBySinCos = replaceBySinCos;
}());

// Arctangent
function Arctan(x) {
  Expression.Function.call(this, "arctan", x);
}
Arctan.prototype = Object.create(Expression.Function.prototype);
Expression.Arctan = Arctan;

// https://en.wikipedia.org/wiki/Continued_fraction#Infinite_continued_fractions_and_convergents
// https://stackoverflow.com/a/14011299/839199
function getlowestfraction(x0) {
    var eps = 1.0E-15;
    var h, h1, h2, k, k1, k2, a, x;

    x = x0;
    a = Math.floor(x);
    h1 = 1;
    k1 = 0;
    h = a;
    k = 1;

    while (x-a > eps*k*k) {
        x = 1/(x-a);
        a = Math.floor(x);
        h2 = h1; h1 = h;
        k2 = k1; k1 = k;
        h = h2 + a*h1;
        k = k2 + a*k1;
    }

    return h + "/" + k;
}

Expression.prototype.arctan = function () {
  var x = this;
  if (x.isNegative()) {
    return x.negate().arctan().negate();
  }
  if (Expression.isConstant(x)) {
    var value = Number(toDecimalStringInternal(x, {fractionDigits: 15}));
    console.assert(!Number.isNaN(value));
    var tmp = getlowestfraction(Math.atan(value) / Math.PI).split("/");
    var guess = Expression.Integer.fromNumber(Number(tmp[0])).divide(Expression.Integer.fromNumber(tmp[1])).multiply(Expression.PI);
    if (guess.getDenominator().toNumber() < 10000 && guess.tan().subtract(x).equals(Expression.ZERO)) {
      return guess;
    }
    throw new RangeError("NotSupportedError");
  }
  if (x instanceof Division) {
    var n = x.getNumerator();
    var d = x.getDenominator();
    if (d.subtract(Expression.ONE).subtract(n).multiply(d.subtract(Expression.ONE).add(n)).subtract(Expression.ONE).equals(Expression.ZERO)) {
      var y = Expression.TWO.multiply(x).divide(Expression.ONE.subtract(x._pow(2)));
      return (new Arctan(y)).divide(Expression.TWO);
    }
  }
  if (x instanceof Expression.Matrix) {
    if (x.matrix.isDiagonal()) {
      return new Expression.Matrix(x.matrix.map(function (e, i, j) {
        return i === j ? e.arctan() : Expression.ZERO;
      }));
    }
    // https://math.stackexchange.com/questions/2077674/what-is-the-alternate-form-of-arcsin-x
    // y = arctan(x)
    // tan(y) = x
    // -i*(e**(iy)-e**(-iy))/(e**(iy)+e**(-iy)) = x
    // y = ln((i-x)/(i+x))/(2i)
    // y = (ln((i-x)/(i+x)/i)+ln(i))/(2i)
    //TODO: details (a link or a formula - ?)
    var b = Expression.I.subtract(x).divide(Expression.I.add(x)).matrix;
    //var tmp = Expression.getFormaDeJordan(b, Expression.getEigenvalues(b).eigenvalues, Expression.getEigenvalues(b).multiplicities);
    //var J = tmp.J;
    var c = b.map(function (e, i, j) {
      return i === j ? e : Expression.ZERO;
    });
    //c = tmp.P.multiply(c).multiply(tmp.P_INVERSED);
    var complexLogarithm = function (e) {
      if (e instanceof Division) {
        return complexLogarithm(e.a).subtract(e.b.logarithm());
      }
      var c = Expression.getComplexConjugate(e);
      if (c != undefined) {
        var real = e.add(c).divide(Expression.TWO);
        var imaginary = e.subtract(c).multiply(Expression.I.negate()).divide(Expression.TWO);
        var phi = real.equals(Expression.ZERO) ? Expression.PI.divide(Expression.TWO) : imaginary.divide(real).arctan();
        if (real.isNegative()) {//?
          phi = phi.add(Expression.PI);
        }
        // https://www.varsitytutors.com/hotmath/hotmath_help/topics/polar-form-of-a-complex-number
        return e.divide(Expression.I.multiply(phi).exp()).logarithm().add(Expression.I.multiply(phi));
      }
      return e.logarithm();
    };
    var lnC = new Expression.Matrix(c.map(function (e, i, j) {
      return i === j ? complexLogarithm(e) : Expression.ZERO;
    }));
    //Expression.I.multiply(Expression.PI).divide(Expression.TWO);
    return new Expression.Matrix(b.multiply(c.inverse())).logarithm().add(lnC).divide(Expression.TWO.multiply(Expression.I));
  }
  /*
  var t = simplifyConstantValue(x, "sin");
  if (t != undefined) {
    return t;
  }
  if (!isArgumentValid(x, "sin")) {
    throw new RangeError("NotSupportedError");
  }
  */
  return new Arctan(x);
};

Expression.prototype.tan = function () {
  var a = this;
  //return a.sin().divide(a.cos());
  var a2 = a.multiply(Expression.TWO);
  return a2.sin().divide(a2.cos().add(Expression.ONE));
};
Expression.prototype.cot = function () {
  var a = this;
  if (a instanceof Expression.Matrix) {
    return a.cos().divide(a.sin());
  }
  //return a.cos().divide(a.sin());
  var a2 = a.multiply(Expression.TWO);
  return a2.cos().add(Expression.ONE).divide(a2.sin());
};


Expression.Sin.prototype.complexConjugate = function () {
  var a = this.a;
  if (a instanceof Expression.Radians) {
    a = a.value; //TODO: !!!
  }
  var i = Expression.I;
  // Euler's formula + complex conjugation
  return i.multiply(a).complexConjugate().exp().subtract(i.multiply(a).negate().complexConjugate().exp()).divide(Expression.TWO.multiply(i).complexConjugate());
};
Expression.Cos.prototype.complexConjugate = function () {
  var a = this.a;
  if (a instanceof Expression.Radians) {
    a = a.value; //TODO: !!!
  }
  var i = Expression.I;
  // Euler's formula + complex conjugation
  return i.multiply(a).complexConjugate().exp().add(i.multiply(a).negate().complexConjugate().exp()).divide(Expression.TWO);
};

})();
(function () {
"use strict";
  
  
  

  var Integer = Expression.Integer;

  function Complex(real, imaginary) {
    //Expression.call(this);
    if (!(real instanceof Integer) || !(imaginary instanceof Integer) || imaginary.compareTo(Expression.ZERO) === 0) {
      throw new RangeError();
    }
    this.real = real;
    this.imaginary = imaginary;
  }

  Complex.prototype = Object.create(Expression.prototype);

  Expression.I = new Complex(Expression.ZERO, Expression.ONE);
  Expression.Complex = Complex;

  Complex.prototype.add = function (y) {
    return y.addComplex(this);
  };
  Expression.prototype.addComplex = function (x) {
    return this.addExpression(x);
  };
  Integer.prototype.addComplex = function (x) {
    return new Complex(x.real.add(this), x.imaginary);
  };
  Complex.prototype.addComplex = function (x) {
    var real = x.real.add(this.real);
    var imaginary = x.imaginary.add(this.imaginary);
    return imaginary.compareTo(Expression.ZERO) === 0 ? real : new Complex(real, imaginary);
  };
  Complex.prototype.addInteger = function (x) {
    return new Complex(x.add(this.real), this.imaginary);
  };

  Complex.prototype.equals = function (y) {
    return y instanceof Complex && this.real.equals(y.real) && this.imaginary.equals(y.imaginary) ? true : false;
  };

  Complex.prototype.compare4AdditionSymbol = function (x) {
    return +1;
  };
  Complex.prototype.compare4MultiplicationNthRoot = function (x) {
    return +1;
  };
  Complex.prototype.compare4Addition = function (y) {
    if (y instanceof Complex) {
      if (this.equals(y)) {
        return 0;
      }
      return this.real.compareTo(y.real) || this.imaginary.compareTo(y.imaginary);
    }
    if (y instanceof Integer) {
      return +1;
    }
    if (y instanceof Expression.Division) {
      return Expression.prototype.compare4Addition.call(this, y);
    }
    if (y instanceof Expression.Exponentiation) {
      return Expression.prototype.compare4Addition.call(this, y);
    }
    if (y instanceof Expression.Matrix) {
      return Expression.prototype.compare4Addition.call(this, y);
    }
    return -1;
  };
  // ? zero in case of same "base"
  Complex.prototype.compare4Multiplication = function (y) {
    if (y instanceof Complex) {
      if (y.equals(this)) {
        return 0;
      }
      return this.real.abs().compareTo(y.real.abs()) || this.imaginary.abs().compareTo(y.imaginary.abs());
      //return 0;
      //TODO: fix
      //throw new RangeError("NotSupportedError");//TODO:
    }
    return y.compare4MultiplicationComplex(this);
  };
  Expression.prototype.compare4MultiplicationComplex = function (x) {
    return -1;//?
  };
  Complex.prototype.compare4MultiplicationSymbol = function (x) {
    return +1;
  };
  Complex.prototype.multiply = function (y) {
    return y.multiplyComplex(this);
  };
  Complex.prototype.multiplyComplex = function (x) {
    var real = x.real.multiply(this.real).subtract(x.imaginary.multiply(this.imaginary));
    var imaginary = x.real.multiply(this.imaginary).add(x.imaginary.multiply(this.real));
    return imaginary.compareTo(Expression.ZERO) === 0 ? real : new Complex(real, imaginary);
  };
  Expression.prototype.multiplyComplex = function (x) {
    return this.multiplyExpression(x);
  };
  Integer.prototype.multiplyComplex = function (x) {
    if (this.compareTo(Expression.ZERO) === 0) {
      return this;
    }
    return new Complex(x.real.multiply(this), x.imaginary.multiply(this));
  };
  Complex.prototype.multiplyInteger = function (x) {
    if (x.compareTo(Expression.ZERO) === 0) {
      return x;
    }
    return new Complex(x.multiply(this.real), x.multiply(this.imaginary));
  };

  Complex.prototype.conjugate = function () {
    return new Complex(this.real, this.imaginary.negate());
  };
  //Complex.prototype.divideExpression = function (x) {
  //  var y = this;
  //  return x.multiply(y.conjugate()).divide(y.multiply(y.conjugate()));
  //};
  Complex.prototype.getPrecedence = function () {
    return this.real.equals(Expression.ZERO) ? (this.imaginary.equals(Expression.ONE) ? 1000 : 3) : 2; // precedence.binary['+']
  };

  Complex.prototype.truncatingDivide = function (f) {
    if (f instanceof Integer) {
      return new Complex(this.real.truncatingDivide(f), this.imaginary.truncatingDivide(f));
    }
    return this.multiply(f.conjugate()).truncatingDivide(f.multiply(f.conjugate()));
  };

  Complex.prototype.toStringInternal = function (options, times, i, minus, plus, start, end, toString) {
    if (this.real.equals(Expression.ZERO)) {
      if (this.imaginary.equals(Expression.ONE)) {
        return i;
      }
      if (this.imaginary.equals(Expression.ONE.negate())) {
        return start + minus + i + end;
      }
      return start + toString(this.imaginary, options) + times + i + end;
    }
    var isNegative = this.imaginary.isNegative();
    var imaginary = (isNegative ? this.imaginary.negateCarefully() : this.imaginary);
    var si = (imaginary.equals(Expression.ONE) ? i : start + toString(imaginary, options) + times + i + end);
    var sr = toString(this.real, options);
    return start + sr + (isNegative ? minus : plus) + si + end;
  };

  Complex.prototype.toString = function (options) {
    return this.toStringInternal(options, "", "i", "-", "+", "", "", function (x, options) { return x.toString(options); });
  };

  Expression.getComplexConjugate = function (e) {
    if (!Expression.has(e, Complex)) {
      return undefined;
    }
    var c = Expression.ZERO;
    for (var iteratorx = e.summands()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
      var f = undefined;
      for (var iteratory = x.factors()[globalThis.Symbol.iterator](), y = iteratory.next().value; y != null; y = iteratory.next().value) {
        if (y instanceof Complex) {
          f = y;
        }
      }
      if (f == undefined) {
        c = c.add(x);
      } else {
        var fc = f.conjugate();
        c = c.add(x.multiply(fc).divide(f.multiply(fc)).multiply(fc));
      }
    }
    //!?
    if (c.equals(e)) {
      return undefined;
    }
    //!?
    return c;
  };

  Complex.prototype.compare4MultiplicationInteger = function (x) {
    return +1;
  };

  Complex.prototype.remainderInteger = function (x) {
    return Complex.prototype.remainder.call(x, this);
  };

  Complex.prototype.remainder = function (y) {
    function norm(x) {
      return x instanceof Expression.Integer ? x.multiply(x) : x.multiply(x.conjugate());
    }
    function roundDivision(a, b) {
      if (b.compareTo(Expression.ZERO) < 0) {
        b = b.negate();
        a = a.negate();
      }
      var sign = a.compareTo(Expression.ONE) < 0 ? Expression.ONE.negate() : Expression.ONE;
      return a.add(b.truncatingDivide(Expression.TWO).multiply(sign)).truncatingDivide(b);
    }
    var x = this;
    var n = y instanceof Expression.Integer ? x : x.multiply(y.conjugate());
    var d = y instanceof Expression.Integer ? y : y.multiply(y.conjugate());
    //TODO: fix
    var q1 = n instanceof Complex ? roundDivision(n.real, d) : roundDivision(n, d);
    var q2 = n instanceof Complex ? roundDivision(n.imaginary, d) : Expression.ZERO;
    var q = q2.compareTo(Expression.ZERO) === 0 ? q1 : new Complex(q1, q2);
    var r =  x.subtract(y.multiply(q));
    if (norm(r).compareTo(norm(y)) >= 0) {
      throw new TypeError();
    }
    return r;
  };

  Complex.prototype.primeFactor = function () {
    return QuadraticInteger._complexIntegerPrimeFactor(this.real.toBigInt(), this.imaginary.toBigInt());
  };

  Expression.Complex = Complex;

Expression.Complex.prototype.complexConjugate = function () {
  return this.conjugate();
};

/*
//!
Expression.Complex.prototype.isValid = function () {
  return true;
};
//!
Expression.Complex.prototype.isPositive = function () {
  return this.imaginary.compareTo(Expression.ZERO) > 0;// || (this.imaginary.compareTo(Expression.ZERO) === 0 && this.real.compareTo(Expression.ZERO) > 0);
};
Expression.Complex.prototype.isUnit = function () {
  return this.multiply(this.conjugate()).equals(Expression.ONE);
};
Expression.Complex.prototype.truncatingDivideInteger = function (x) {
  debugger;
  return x.multiply(this.conjugate()).divide(this.multiply(this.conjugate()));
};

Expression.Complex.prototype.isDivisibleBy = function (y) {
  return !(this.divide(y) instanceof Expression.Division);
};
Expression.Complex.prototype.isDivisibleByInteger = function (x) {
  return !(x.multiply(this.conjugate()).divide(this.multiply(this.conjugate())) instanceof Expression.Division);
};
Expression.Complex.prototype.toExpression = function () {
  return this;
};
*/

})();
(function () {
"use strict";
  
  
  
  

  var idCounter = 0;

  function NonSimplifiedExpression(e, position, length, input) {
    //Expression.call(this);
    this.e = e;
    this.position = position == undefined ? -1 : position;
    this.length = length == undefined ? -1 : length;
    this.input = input == undefined ? "" : input;
    this.id = (idCounter += 1);
  }

  NonSimplifiedExpression.prototype = Object.create(Expression.prototype);

  // same set of public properties (and same order) as for Expressions ...
  NonSimplifiedExpression.prototype.negate = function () {
    return new NonSimplifiedExpression(new Expression.Negation(this));
  };
  NonSimplifiedExpression.prototype.add = function (y) {
    return new NonSimplifiedExpression(new Expression.Addition(this, y));
  };
  NonSimplifiedExpression.prototype.subtract = function (y) {
    return new NonSimplifiedExpression(new Expression.Subtraction(this, y));
  };
  NonSimplifiedExpression.prototype.divide = function (y) {
    return new NonSimplifiedExpression(new Expression.Division(this, y));
  };
  NonSimplifiedExpression.prototype.multiply = function (y) {
    return new NonSimplifiedExpression(new Expression.Multiplication(this, y));
  };
  NonSimplifiedExpression.prototype.pow = function (y) {
    return new NonSimplifiedExpression(new Expression.Exponentiation(this, y));
  };

  NonSimplifiedExpression.prototype.exp = function () {
    return new NonSimplifiedExpression(Expression.E).pow(this);
  };
  NonSimplifiedExpression.prototype.logarithm = function () {
    return new NonSimplifiedExpression(new Expression.Logarithm(this));
  };
  NonSimplifiedExpression.prototype.inverse = function () {
    return new NonSimplifiedExpression(new Expression.Exponentiation(this, Expression.ONE.negate())); // to support the MathML serialization of the `inverse(B)`
    //return new NonSimplifiedExpression(Expression.ONE).divide(this);
  };

  NonSimplifiedExpression.prototype.factorial = function () {
    return new NonSimplifiedExpression(new Expression.Factorial(this));
  };

/*
  NonSimplifiedExpression.prototype.powExpression = function (x) {
    return new NonSimplifiedExpression(new Expression.Exponentiation(x, this));
  };
  NonSimplifiedExpression.prototype.multiplyAddition = function (x) {
    return new NonSimplifiedExpression(new Expression.Multiplication(x, this));
  };
  NonSimplifiedExpression.prototype.multiplyDivision = function (x) {
    return new NonSimplifiedExpression(new Expression.Multiplication(x, this));
  };
  NonSimplifiedExpression.prototype.multiplyMatrix = function (x) {
    return new NonSimplifiedExpression(new Expression.Multiplication(x, this));
  };
  NonSimplifiedExpression.prototype.addDivision = function (x) {
    return new NonSimplifiedExpression(new Expression.Addition(x, this));
  };

  //?
  NonSimplifiedExpression.prototype.addMatrix = function (x) {
    return new NonSimplifiedExpression(new Expression.Addition(x, this));
  };

  NonSimplifiedExpression.prototype.addExpression = function (x) {
    return new NonSimplifiedExpression(new Expression.Addition(x, this));
  };
  NonSimplifiedExpression.prototype.multiplyExpression = function (x) {
    return new NonSimplifiedExpression(new Expression.Multiplication(x, this));
  };
  NonSimplifiedExpression.prototype.divideExpression = function (x) {
    return new NonSimplifiedExpression(new Expression.Division(x, this));
  };
*/

  NonSimplifiedExpression.prototype.addExpression = function (x) {
    throw new TypeError();
  };

  NonSimplifiedExpression.prototype.squareRoot = function () {
    return new NonSimplifiedExpression(new Expression.SquareRoot(this));
  };
  NonSimplifiedExpression.prototype.cubeRoot = function () {
    return new NonSimplifiedExpression(new Expression.CubeRoot(this));
  };
  NonSimplifiedExpression.prototype.cos = function () {
    return new NonSimplifiedExpression(new Expression.Function("cos", this));
  };
  NonSimplifiedExpression.prototype.sin = function () {
    return new NonSimplifiedExpression(new Expression.Function("sin", this));
  };
  NonSimplifiedExpression.prototype.tan = function () {
    return new NonSimplifiedExpression(new Expression.Function("tan", this));
  };
  NonSimplifiedExpression.prototype.cot = function () {
    return new NonSimplifiedExpression(new Expression.Function("cot", this));
  };
  NonSimplifiedExpression.prototype.cosh = function () {
    return new NonSimplifiedExpression(new Expression.Function("cosh", this));
  };
  NonSimplifiedExpression.prototype.sinh = function () {
    return new NonSimplifiedExpression(new Expression.Function("sinh", this));
  };
  NonSimplifiedExpression.prototype.tanh = function () {
    return new NonSimplifiedExpression(new Expression.Function("tanh", this));
  };
  NonSimplifiedExpression.prototype.coth = function () {
    return new NonSimplifiedExpression(new Expression.Function("coth", this));
  };
  NonSimplifiedExpression.prototype.arccos = function () {
    return new NonSimplifiedExpression(new Expression.Function("arccos", this));
  };
  NonSimplifiedExpression.prototype.arcsin = function () {
    return new NonSimplifiedExpression(new Expression.Function("arcsin", this));
  };
  NonSimplifiedExpression.prototype.arctan = function () {
    return new NonSimplifiedExpression(new Expression.Function("arctan", this));
  };
  NonSimplifiedExpression.prototype.arccot = function () {
    return new NonSimplifiedExpression(new Expression.Function("arccot", this));
  };
  NonSimplifiedExpression.prototype.arcosh = function () {
    return new NonSimplifiedExpression(new Expression.Function("arcosh", this));
  };
  NonSimplifiedExpression.prototype.arsinh = function () {
    return new NonSimplifiedExpression(new Expression.Function("arsinh", this));
  };
  NonSimplifiedExpression.prototype.artanh = function () {
    return new NonSimplifiedExpression(new Expression.Function("artanh", this));
  };
  NonSimplifiedExpression.prototype.arcoth = function () {
    return new NonSimplifiedExpression(new Expression.Function("arcoth", this));
  };
  NonSimplifiedExpression.prototype.rank = function () {
    return new NonSimplifiedExpression(new Expression.Rank(this));
  };
  NonSimplifiedExpression.prototype.determinant = function () {
    return new NonSimplifiedExpression(new Expression.Determinant(this));
  };
  NonSimplifiedExpression.prototype.rowReduce = function () {
    return new NonSimplifiedExpression(new Expression.RowReduce(this));
  };
  //?
  NonSimplifiedExpression.prototype.GF2 = function () {
    return new NonSimplifiedExpression(new Expression.GF2(this));
  };
  NonSimplifiedExpression.prototype.transpose = function () {
    return new NonSimplifiedExpression(new Expression.Transpose(this));
  };
  NonSimplifiedExpression.prototype.complexConjugate = function () {
    return new NonSimplifiedExpression(new Expression.ComplexConjugate(this));
  };
  NonSimplifiedExpression.prototype.adjugate = function () {
    return new NonSimplifiedExpression(new Expression.Adjugate(this));
  };

  NonSimplifiedExpression.prototype.elementWisePower = function (a) {
    return new NonSimplifiedExpression(new Expression.ElementWisePower(this, a));
  };
  NonSimplifiedExpression.prototype.transformNoAnswerExpression = function (name, second) {
    return new NonSimplifiedExpression(new Expression.NoAnswerExpression(this, name, second));
  };
  NonSimplifiedExpression.prototype.transformEquality = function (b) {
    return new NonSimplifiedExpression(new Expression.Equality(this, b));
  };
  NonSimplifiedExpression.prototype.transformInequality = function (b, sign) {
    return new NonSimplifiedExpression(new Expression.Inequality(this, b, sign));
  };
  NonSimplifiedExpression.prototype.transformComma = function (b) {
    return new NonSimplifiedExpression(new Expression.Comma(this, b));
  };

  NonSimplifiedExpression.prototype.addPosition = function (position, length, input) {
    return new NonSimplifiedExpression(this.e, position, length, input);
  };

  var prepare = function (x, holder) {
    var e = x.simplify();
    ExpressionParser.startPosition = holder.position;
    ExpressionParser.endPosition = holder.position + holder.length;
    ExpressionParser.input = holder.input;
    return e;
  };

  //TODO:
  Expression.prototype.simplifyInternal = function (holder) {
    return this;
  };
  Expression.Exponentiation.prototype.simplifyInternal = function (holder) {
    return prepare(this.a, holder).pow(prepare(this.b, holder));
  };
  Expression.Multiplication.prototype.simplifyInternal = function (holder) {
    return prepare(this.a, holder).multiply(prepare(this.b, holder));
  };
  Expression.Addition.prototype.simplifyInternal = function (holder) {
    return prepare(this.a, holder).add(prepare(this.b, holder));
  };
  Expression.Division.prototype.simplifyInternal = function (holder) {
    return prepare(this.a, holder).divide(prepare(this.b, holder));
  };
  Expression.SquareRoot.prototype.simplifyInternal = function (holder) {
    return prepare(this.a, holder).squareRoot();
  };
  Expression.CubeRoot.prototype.simplifyInternal = function (holder) {
    return prepare(this.a, holder).cubeRoot();
  };
  Expression.Function.prototype.simplifyInternal = function (holder) {
    return prepare(this.a, holder)[this.name]();
  };
  Expression.Logarithm.prototype.simplifyInternal = function (holder) {
    return prepare(this.a, holder).logarithm();
  };
  Expression.Rank.prototype.simplifyInternal = function (holder) {
    return prepare(this.a, holder).rank();
  };
  Expression.Determinant.prototype.simplifyInternal = function (holder) {
    return prepare(this.a, holder).determinant();
  };
  Expression.RowReduce.prototype.simplifyInternal = function (holder) {
    return prepare(this.a, holder).rowReduce();
  };
  Expression.GF2.prototype.simplifyInternal = function (holder) {
    return prepare(this.a, holder).GF2();
  };
  Expression.Transpose.prototype.simplifyInternal = function (holder) {
    return prepare(this.a, holder).transpose();
  };
  Expression.ComplexConjugate.prototype.simplifyInternal = function (holder) {
    return prepare(this.a, holder).complexConjugate();
  };
  Expression.Adjugate.prototype.simplifyInternal = function (holder) {
    return prepare(this.a, holder).adjugate();
  };
  Expression.NoAnswerExpression.prototype.simplifyInternal = function (holder) {
    return prepare(this.a, holder).transformNoAnswerExpression(this.name, this.second == undefined ? undefined : prepare(this.second, holder));
  };
  Expression.Equality.prototype.simplifyInternal = function (holder) {
    return prepare(this.a, holder).transformEquality(prepare(this.b, holder));
  };
  Expression.Inequality.prototype.simplifyInternal = function (holder) {
    return prepare(this.a, holder).transformInequality(prepare(this.b, holder), this.sign);
  };
  Expression.Matrix.prototype.simplifyInternal = function (holder) {
    return new Expression.Matrix(this.matrix.map(function (e, i, j) {
      return prepare(e, holder);
    }));
  };

  Expression.Radians.prototype.simplifyInternal = function (holder) {
    return new Expression.Radians(prepare(this.value, holder));
  };

  Expression.Comma.prototype.simplifyInternal = function (holder) {
    return prepare(this.a, holder).transformComma(prepare(this.b, holder));
  };

  Expression.prototype.simplify = function () {
    return this;//? this.simplifyInternal(undefined);
  };
  NonSimplifiedExpression.prototype.simplify = function () {
    //return this.e.simplifyInternal(this);
    //return this.e.simplifyInternal(this).simplifyExpression();//new

    // to get an expression after a double "wrapping"
    return this.e.simplify().simplifyInternal(this).simplifyExpression();//new
  };
  NonSimplifiedExpression.prototype.toString = function (options) {
    return this.e.toString(options);
  };
  NonSimplifiedExpression.prototype.equals = function (y) {
    return this.simplify().equals(y.simplify());
  };

  //!
  NonSimplifiedExpression.prototype.unwrap = function () {
    return this.e;
  };
  Expression.Negation.prototype.simplifyInternal = function (holder) {
    return prepare(this.b, holder).negate();
  };
  Expression.Subtraction.prototype.simplifyInternal = function (holder) {
    return prepare(this.a, holder).subtract(prepare(this.b, holder));
  };
  NonSimplifiedExpression.prototype.isUnaryPlusMinus = function () {
    return this.e.isUnaryPlusMinus();
  };
  NonSimplifiedExpression.prototype.getPrecedence = function () {
    return this.e.getPrecedence();
  };

  Expression.ElementWisePower.prototype.simplifyInternal = function (holder) {
    return prepare(this.a, holder).elementWisePower(prepare(this.b, holder));
  };
  Expression.Factorial.prototype.simplifyInternal = function (holder) {
    return prepare(this.n, holder).factorial();
  };

//?
  NonSimplifiedExpression.prototype.getId = function () {
    return "e" + this.id.toString();
  };
  Expression.prototype.getIds = function () {
    return "";
  };
  Expression.BinaryOperation.prototype.getIds = function () {
    var a = this.a.getIds();
    var b = this.b.getIds();
    return a === "" ? b : (b === "" ? a : a + ", " + b);
  };
  NonSimplifiedExpression.prototype.getIds = function () {
    var a = this.getId();
    var b = this.e.getIds();
    return a === "" ? b : (b === "" ? a : a + ", " + b);
  };

  NonSimplifiedExpression.prototype.isNegative = function () {
    //return this.e.isNegative();
    return false;
  };
  NonSimplifiedExpression.prototype.negateCarefully = function () {
    return new NonSimplifiedExpression(this.e.negateCarefully());
  };
  NonSimplifiedExpression.prototype.isRightToLeftAssociative = function () {
    return this.e.isRightToLeftAssociative();
  };

  NonSimplifiedExpression.prototype.isExact = function () {
    return this.e.isExact();
  };

  Expression.DecimalFraction = function (integer, transient, repetend, exponent) {
    this.integer = integer;
    this.transient = transient;
    this.repetend = repetend;
    this.exponent = exponent;
  };
  Expression.DecimalFraction.prototype = Object.create(Expression.prototype);
  Expression.DecimalFraction.prototype.getPrecedence = function () {
    //TODO: comma may affect precedence - ?
    return 1000;//TODO: ?
  };
  Expression.DecimalFraction.prototype.simplifyInternal = function () {
    return ExpressionParser._getDecimalFraction(this.integer, this.transient, this.repetend, this.exponent);
  };
  Expression.DecimalFraction.prototype.toString = function () {
    return (this.integer || '0') + '.' + (this.transient || '') + (this.repetend != undefined ? '(' + this.repetend + ')' : '') + (this.exponent != undefined ? 'E' + this.exponent : '')
  };

  NonSimplifiedExpression.prototype.augment = function (other) {
    return new NonSimplifiedExpression(new Expression.AugmentedMatrix(this, other));
  };
  Expression.AugmentedMatrix.prototype.simplifyInternal = function (holder) {
    return prepare(this.a, holder).augment(prepare(this.b, holder));
  };

  Expression.NonSimplifiedExpression = NonSimplifiedExpression;

  self.NonSimplifiedExpression = NonSimplifiedExpression;

})();
(function () {
"use strict";
/*jslint plusplus: true, vars: true, indent: 2 */
  
  

  //var isAlpha = function (code) {
  //  return (code >= "a".charCodeAt(0) && code <= "z".charCodeAt(0)) ||
  //         (code >= "A".charCodeAt(0) && code <= "Z".charCodeAt(0));
  //};

  // http://en.wikipedia.org/wiki/Operators_in_C_and_C%2B%2B#Operator_precedence

  var LEFT_TO_RIGHT = 0;
  var RIGHT_TO_LEFT = 1;

  var COMMA_PRECEDENCE = 1;
  var EQUALITY_PRECEDENCE = 2;
  var ADDITIVE_PRECEDENCE = 3;
  var MULTIPLICATIVE_PRECEDENCE = 4;
  var UNARY_PRECEDENCE = 6;

  var UNARY_PRECEDENCE_PLUS_ONE = UNARY_PRECEDENCE + 1; // TODO: remove
  var UNARY_PRECEDENCE_PLUS_TWO = UNARY_PRECEDENCE + 2;

  function Operator(name, arity, rightToLeftAssociative, precedence, i) {
    this.name = name;
    this.arity = arity;
    this.rightToLeftAssociative = rightToLeftAssociative;
    this.precedence = precedence;
    this.i = i;
    //this.xyz = isAlpha(name.charCodeAt(0)) && isAlpha(name.charCodeAt(name.length - 1));
  }

  Operator.trigonometry = function (name) {
    return new Operator(name, 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function (a) {
      a = prepareTrigonometricArgument(a);
      return a[name]();
    });
  };
  Operator.simple = function (name) {
    return new Operator(name, 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function (a) {
      return a[name]();
    });
  };



  var UNARY_PLUS = new Operator("+", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function (e) {
    return e;
  });
  var UNARY_MINUS = new Operator("-", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function (e) {
    return e.negate();
  });

  var prepareTrigonometricArgument = function (a) {
    if (a instanceof Expression.Integer) {
      return new Expression.Degrees(a);
    }
    if (a instanceof Expression.NonSimplifiedExpression && a.e instanceof Expression.Integer) {
      return new Expression.NonSimplifiedExpression(new Expression.Degrees(a));
    }
    if (a instanceof Expression.NonSimplifiedExpression && a.e instanceof Expression.Negation && a.e.b instanceof Expression.NonSimplifiedExpression && a.e.b.e instanceof Expression.Integer) {
      return new Expression.NonSimplifiedExpression(new Expression.Degrees(a));
    }
    if (a instanceof Expression.NonSimplifiedExpression && a.e instanceof Expression.Multiplication &&
        a.e.a instanceof Expression.NonSimplifiedExpression && a.e.a.e instanceof Expression.Integer &&
        a.e.b instanceof Expression.Integer) {
      return new Expression.NonSimplifiedExpression(new Expression.Degrees(a));
    }
    return a;
  };

  var toDegrees = function (a) {
    return a instanceof Expression.NonSimplifiedExpression ? new Expression.NonSimplifiedExpression(new Expression.Degrees(a)) : new Expression.Degrees(a);
  };

  var toRadians = function (a) {
    return a instanceof Expression.NonSimplifiedExpression ? new Expression.NonSimplifiedExpression(new Expression.Radians(a)) : new Expression.Radians(a);
  };

  var notSupported = function (a) {
    throw new TypeError();
  };

  var conjugateTranspose = function (a) {
    return a.transpose().complexConjugate();
  };

  var operations = [
    new Operator("=", 2, LEFT_TO_RIGHT, EQUALITY_PRECEDENCE, function (a, b) {
      return a.transformEquality(b);
    }),
    new Operator("≠", 2, LEFT_TO_RIGHT, EQUALITY_PRECEDENCE, function (a, b) {
      return a.transformInequality(b, '!=');//TODO:
    }),
    new Operator("!=", 2, LEFT_TO_RIGHT, EQUALITY_PRECEDENCE, function (a, b) {
      return a.transformInequality(b, '!=');//TODO:
    }),
    new Operator(">", 2, LEFT_TO_RIGHT, EQUALITY_PRECEDENCE, function (a, b) {
      return a.transformInequality(b, '>');//TODO: ?
    }),
    new Operator("<", 2, LEFT_TO_RIGHT, EQUALITY_PRECEDENCE, function (a, b) {
      return a.transformInequality(b, '<');//TODO: ?
    }),
    new Operator("⩽", 2, LEFT_TO_RIGHT, EQUALITY_PRECEDENCE, function (a, b) {
      return a.transformInequality(b, '<=');//TODO: ?
    }),
    new Operator("⩾", 2, LEFT_TO_RIGHT, EQUALITY_PRECEDENCE, function (a, b) {
      return a.transformInequality(b, '>=');//TODO: ?
    }),
    new Operator(";", 2, LEFT_TO_RIGHT, COMMA_PRECEDENCE, function (a, b) {
      return a.transformComma(b);
    }),
    new Operator(",", 2, LEFT_TO_RIGHT, COMMA_PRECEDENCE, function (a, b) {
      return a.transformComma(b);
    }),

    new Operator("+", 2, LEFT_TO_RIGHT, ADDITIVE_PRECEDENCE, function (a, b) {
      return a.add(b);
    }),
    new Operator("-", 2, LEFT_TO_RIGHT, ADDITIVE_PRECEDENCE, function (a, b) {
      return a.subtract(b);
    }),
    new Operator("*", 2, LEFT_TO_RIGHT, MULTIPLICATIVE_PRECEDENCE, function (a, b) {
      return a.multiply(b);
    }),
    new Operator("/", 2, LEFT_TO_RIGHT, MULTIPLICATIVE_PRECEDENCE, function (a, b) {
      return a.divide(b);
    }),
    new Operator("\\", 2, LEFT_TO_RIGHT, MULTIPLICATIVE_PRECEDENCE, function (a, b) {
      return a.inverse().multiply(b);
    }),
    //new Operator("%", 2, LEFT_TO_RIGHT, MULTIPLICATIVE_PRECEDENCE, function (a, b) {
    //  return a.remainder(b);
    //}),
    //UNARY_PLUS,
    //UNARY_MINUS,
    // Exponentiation has precedence as unary operators
    new Operator("^", 2, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function (a, b) {
      return a.pow(b);
    }),
    new Operator("**", 2, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function (a, b) {
      return a.pow(b);
    }),
    new Operator(".^", 2, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function (a, b) {
      return a.elementWisePower(b);
    }),//?
    new Operator("\u221A", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function (a) {
      return a.squareRoot();
    }),
    new Operator("sqrt", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function (a) {
      return a.squareRoot();
    }),
    new Operator("radical", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function (a) {
      return a.squareRoot();
    }),
    new Operator("\u221B", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function (a) {
      return a.cubeRoot();
    }),
    new Operator("cbrt", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function (a) {
      return a.cubeRoot();
    }),
    new Operator("\u221C", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function (a) {
      return a.pow(Expression.ONE.divide(Expression.TWO.add(Expression.TWO)));
    }),
    new Operator("rank", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function (a) {
      return a.rank();
    }),
    new Operator("adj", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function (a) {//?
      return a.adjugate();
    }),
    new Operator("adjugate", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function (a) {
      return a.adjugate();
    }),
    //new Operator("trace", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function (a) {
    //  return Expression.transformTrace(a);
    //}),
    new Operator("inverse", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function (a) {
      return a.inverse();
    }),
    new Operator("det", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function (a) {//?
      return a.determinant();
    }),
    new Operator("determinant", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function (a) {
      return a.determinant();
    }),
    new Operator("row-reduce", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function (a) {
      return a.rowReduce();
    }),
    new Operator("transpose", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function (a) {
      return a.transpose();
    }),
    //new Operator("^T", 1, LEFT_TO_RIGHT, UNARY_PRECEDENCE, function (a) {
    //  return a.transpose();
    //}),
    //new Operator("^t", 1, LEFT_TO_RIGHT, UNARY_PRECEDENCE, function (a) {
    //  return a.transpose();
    //}),
    new Operator("'", 1, LEFT_TO_RIGHT, UNARY_PRECEDENCE, function (a) {
      return a.transpose();
    }),
    //TODO: https://en.wikipedia.org/wiki/Conjugate_transpose
    new Operator("^*", 1, LEFT_TO_RIGHT, UNARY_PRECEDENCE, conjugateTranspose),
    new Operator("^{*}", 1, LEFT_TO_RIGHT, UNARY_PRECEDENCE, conjugateTranspose),
    new Operator("⃰", 1, LEFT_TO_RIGHT, UNARY_PRECEDENCE, conjugateTranspose),

    //?
    new Operator("solve", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function (a) {
      return a.transformNoAnswerExpression("solve");//?
    }),

    new Operator("GF2", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function (a) {
      return a.GF2();
    }),

    new Operator("°", 1, LEFT_TO_RIGHT, UNARY_PRECEDENCE_PLUS_TWO, function (a) {
      return toDegrees(a);
    }),
    new Operator("deg", 1, LEFT_TO_RIGHT, UNARY_PRECEDENCE_PLUS_TWO, function (a) {
      return toDegrees(a);
    }),
    new Operator("rad", 1, LEFT_TO_RIGHT, UNARY_PRECEDENCE_PLUS_TWO, function (a) {
      return toRadians(a);
    }),

    new Operator("exp", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function (a) {
      return a.exp();
    }),
    new Operator("log", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function (a) {
      return a.logarithm();
    }),
    new Operator("lg", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function (a) {
      return a.logarithm().divide(Expression.TEN.logarithm());
    }),
    new Operator("ln", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function (a) {
      return a.logarithm();
    }),

    new Operator("\\left", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function (a) {
      return a;
    }),
    new Operator("\\right", 1, LEFT_TO_RIGHT, UNARY_PRECEDENCE_PLUS_ONE, function (a) {
      return a;
    }),
    new Operator("├", 1, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function (a) { // like \\left
      return a;
    }),
    new Operator("┤", 1, LEFT_TO_RIGHT, UNARY_PRECEDENCE_PLUS_ONE, function (a) { // like \\right
      return a;
    }),

    new Operator("frac", 2, RIGHT_TO_LEFT, UNARY_PRECEDENCE_PLUS_ONE, function (a, b) {
      return a.divide(b);
    }),

    new Operator("!", 1, LEFT_TO_RIGHT, UNARY_PRECEDENCE, function (a) {
      return a.factorial();
    }),
    new Operator("!!", 1, LEFT_TO_RIGHT, UNARY_PRECEDENCE, notSupported), // to not parse 3!! as (3!)!, see https://en.wikipedia.org/wiki/Double_factorial
    new Operator("!!!", 1, LEFT_TO_RIGHT, UNARY_PRECEDENCE, notSupported)
  ];

  function OperationSearchCache() {
    this.map = {};
    this.re = null;
  }

  OperationSearchCache.prototype.append = function (operator) {
    this.map[operator.name.toLowerCase()] = operator;
    this.re = null;
  };
  OperationSearchCache.prototype.getByName = function (name) {
    return this.map[name.toLowerCase()];
  };
  OperationSearchCache.prototype.getRegExp = function () {
    // https://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    var escapeRegExp = function (s) {
      // "-" is not escaped
      return s.replace(/[\/\\^$*+?.()|[\]{}]/g, '\\$&');
    };
    // longest: ? "^T" and "^"
    // ignore case
    if (this.re == null) {//TODO: ?
      var names = [];
      for (var name in this.map) {
        if (Object.prototype.hasOwnProperty.call(this.map, name)) {
          names.push(name);
        }
      }
      names.sort(function (a, b) {
        // longest is lesser then shortest when one of strings is a prefix of another
        return a < b && b.lastIndexOf(a, 0) !== 0 || a.lastIndexOf(b, 0) === 0 ? -1 : +1;
      });
      this.re = new RegExp('^(?:' + escapeRegExp(names.join('\uFFFF')).replace(/\uFFFF/g, '|').replace(/\|ch\|/g, '|ch(?!i)|').replace(/\|th\|/g, '|th(?!eta)|') + ')', 'i');
    }
    return this.re;
  };

  var operationSearchCache = new OperationSearchCache();
  var trigonometryFunctions = {};

  var i = -1;
  while (++i < operations.length) {
    operationSearchCache.append(operations[i]);
  }
  for (var iteratorname = 'cos sin tan cot'.split(' ')[globalThis.Symbol.iterator](), name = iteratorname.next().value; name != null; name = iteratorname.next().value) {
    operationSearchCache.append(Operator.trigonometry(name));
    trigonometryFunctions[name] = true;
  }
  for (var iteratorname = 'cosh sinh tanh coth arccos arcsin arctan arccot arcosh arsinh artanh arcoth'.split(' ')[globalThis.Symbol.iterator](), name = iteratorname.next().value; name != null; name = iteratorname.next().value) {
    operationSearchCache.append(Operator.simple(name));
  }

  var nextToken = function (tokenizer) {
    var token = null;
    do {
      token = tokenizer.next();
    } while (token.type === 'whitespace');
    return token;
  };

  var parsePunctuator = function (tokenizer, token, punctuator) {
    if (token.type !== 'punctuator' || token.value !== punctuator) {
      ExpressionParser.startPosition = tokenizer.previousPosition;
      ExpressionParser.endPosition = tokenizer.position;
      ExpressionParser.input = tokenizer.input;
      if (token.type === 'EOF') {
        throw new RangeError("UserError: unexpected end of input, '" + punctuator + "' expected");
      }
      throw new RangeError("UserError: unexpected '" + tokenizer.input.slice(tokenizer.previousPosition, tokenizer.position) + "', '" + punctuator + "' expected");
    }
    token = nextToken(tokenizer);
    return token;
  };

  function ParseResult(result, token) {
    this.result = result;
    this.token = token;
  }

  var parseMatrix = function (tokenizer, token, context) {
    var openingBracket = "{";
    var closingBracket = "}";

    var rows = [];
    var hasNextRow = true;
    while (hasNextRow) {
      token = parsePunctuator(tokenizer, token, openingBracket);
      var row = [];
      var hasNextCell = true;
      while (hasNextCell) {
        var tmp = parseExpression(tokenizer, token, context, COMMA_PRECEDENCE, undefined);
        token = tmp.token;
        row.push(tmp.result);
        if (token.type === 'punctuator' && token.value === ",") {
          hasNextCell = true;
          token = nextToken(tokenizer);
        } else {
          hasNextCell = false;
        }
      }
      token = parsePunctuator(tokenizer, token, closingBracket);
      rows.push(row);
      if (token.type === 'punctuator' && token.value === ",") {
        hasNextRow = true;
        token = nextToken(tokenizer);
      } else {
        hasNextRow = false;
      }
    }
    token = parsePunctuator(tokenizer, token, "}");
    return new ParseResult(context.wrap(Expression.Matrix.fromArray(rows)), token);
  };

  var parseLaTeXMatrix = function (tokenizer, token, context, rowSeparator) {
    var rows = [];
    var firstRow = true;
    while (firstRow || (token.type === 'punctuator' && token.value === rowSeparator)) {
      if (firstRow) {
        firstRow = false;
      } else {
        token = nextToken(tokenizer);
      }
      var row = [];
      var firstCell = true;
      while (firstCell || token.type === 'punctuator' && token.value === "&") {
        if (firstCell) {
          firstCell = false;
        } else {
          token = nextToken(tokenizer);
        }
        var tmp = parseExpression(tokenizer, token, context, COMMA_PRECEDENCE, undefined);
        token = tmp.token;
        row.push(tmp.result);
      }
      rows.push(row);
    }
    return new ParseResult(context.wrap(Expression.Matrix.fromArray(rows)), token);
  };

  var parseLaTeXArgument = function (tokenizer, token, context) {
    return parseExpression(tokenizer, token, context, 0, undefined);
  };

  var getVulgarFraction = function (vulgarFraction) {
    var input = normalizeVulgarFractions(vulgarFraction).replace(/[\u2044]/g, "/");
    var e = Expression.Integer.fromString(input.slice(0, input.indexOf('/'))).divide(Expression.Integer.fromString(input.slice(input.indexOf('/') + '/'.length)));
    return e;
  };

  var getDecimalFraction = function (integerPart, nonRepeatingFractionalPart, repeatingFractionalPart, exponentPart) {
    var numerator = Expression.ZERO;
    var denominator = Expression.ONE;

    if (integerPart != undefined) {
      numerator = Expression.Integer.fromString(integerPart);
    }
    if (nonRepeatingFractionalPart != undefined) {
      var factor = Expression.pow(Expression.TEN, nonRepeatingFractionalPart.length);
      numerator = numerator.multiply(factor).add(Expression.Integer.fromString(nonRepeatingFractionalPart));
      denominator = denominator.multiply(factor);
    }
    if (repeatingFractionalPart != undefined) {
      var factor = Expression.pow(Expression.TEN, repeatingFractionalPart.length).subtract(Expression.ONE);
      numerator = numerator.multiply(factor).add(Expression.Integer.fromString(repeatingFractionalPart));
      denominator = denominator.multiply(factor);
    }
    if (exponentPart != undefined) {
      var exponent = 0 + Number(exponentPart);
      var factor = Expression.pow(Expression.TEN, exponent < 0 ? -exponent : exponent);
      if (exponent < 0) {
        denominator = denominator.multiply(factor);
      } else {
        numerator = numerator.multiply(factor);
      }
    }

    var value = numerator.divide(denominator);
    return value;
  };
  ExpressionParser._getDecimalFraction = getDecimalFraction;

  var parseDecimalFraction = function (tokenizer, token, context) {
    var isOnlyInteger = true;
    var result = undefined;
    if (token.type === 'integerLiteral') {
      result = Expression.Integer.fromString(token.value);
      result = context.wrap(result);
      token = nextToken(tokenizer);
    } else if (token.type === 'numericLiteral') {
      var value = token.value;
      //var match = token.match;
      var match = decimalFractionWithGroups.exec(value);
      isOnlyInteger = false;
      if (!context.needsWrap) {
        result = getDecimalFraction(match[1], match[2], match[3], match[4]);
      } else {
        result = new Expression.DecimalFraction(match[1], match[2], match[3], match[4]);
      }
      result = context.wrap(result);
      token = nextToken(tokenizer);
    }
    //!
    if (isOnlyInteger || result == undefined) {
      if (token.type === 'vulgarFraction') {
        var fraction = context.wrap(getVulgarFraction(token.value, context));
        if (result != undefined) {
          result = result.add(fraction).addPosition(tokenizer.previousPosition, tokenizer.previousPosition, tokenizer.input);
        } else {
          result = fraction;
        }
        token = nextToken(tokenizer);
      }
    }
    return result != undefined ? new ParseResult(result, token) : undefined;
  };

  // TODO: sticky flags - /\s+/y
  var whiteSpaces = /^\s+/;
  var punctuators = /^(?:[,&(){}|■@]|\\\\|(?:\\begin|\\end)(?:\{[bvp]?matrix\})?)/;
  var integerLiteral = /^\d+(?![\d.])(?![eEЕ]|اس)(?!,(?:\d|\(\d+\)))/; // for performance
  var integerLiteralWithoutComma = /^\d+(?![\d.])(?![eEЕ]|اس)/; // for performance
  var decimalFraction = /^(?=[.,]?\d)\d*(?:(?:[.]|[.,](?=\d|\(\d+\)))\d*(?:\(\d+\))?)?(?:(?:[eEЕ]|اس)[\+\-]?\d+)?/;
  var decimalFractionWithoutComma = new RegExp(decimalFraction.source.replace(/,/g, ''));
  // Base Latin, Base Latin upper case, Base Cyrillic, Base Cyrillic upper case, Greek alphabet
  // + https://en.wikipedia.org/wiki/Modern_Arabic_mathematical_notation#Mathematical_letters
  var greek = "alpha beta gamma delta epsilon zeta eta theta iota kappa lambda mu nu xi omicron pi rho varsigma sigma tau upsilon phi chi psi omega".split(" ");
  var ARABIC_MATHEMATIC_LETTER = /(?:[\u0627\u066E\u062D\u062F\u0633\u0634\u0635\u0639\u0637\u06BE\u062A]|\u062d\u0640\u0640\u0640\u0640)(?![\u0600-\u06FF])/;
  var symbols = new RegExp(/^(?:GREEK|circ|[a-zA-Zа-яА-Яα-ωß]|ARABIC_MATHEMATIC_LETTER)(?:\_[0-9]+|\_\([a-z0-9]+,[a-z0-9]+\)|[\u2080-\u2089]+)?/.source.replace(/GREEK/g, greek.join('|')).replace(/ARABIC_MATHEMATIC_LETTER/g, ARABIC_MATHEMATIC_LETTER.source));
  var superscripts = /^[\u00B2\u00B3\u00B9\u2070\u2071\u2074-\u207F]+/; // superscript characters "2310i456789+−=()n"
  var vulgarFractions = /^[\u00BC-\u00BE\u2150-\u215E]/;
  //var other = /^\S/u;
  var other = /^(?:[\uD800-\uDBFF][\uDC00-\uDFFF]|\S)/; // should not split surrogate pairts (for Tokenizer and other things)

  var decimalFractionWithGroups = /^(\d+)?(?:[.,](\d+)?(?:\((\d+)\))?)?(?:(?:[eEЕ]|اس)([\+\-]?\d+))?$/;

  // s.normalize("NFKD")
  var normalizeSuperscripts = function (s) {
    return s.replace(/[\u00B2\u00B3\u00B9\u2070\u2071\u2074-\u207F]/g, function (c) {
      var charCode = c.charCodeAt(0);
      if (charCode === 0x00B2) {
        return "2";
      }
      if (charCode === 0x00B3) {
        return "3";
      }
      if (charCode === 0x00B9) {
        return "1";
      }
      var i = charCode - 0x2070;
      return "0i  456789+-=()n".slice(i, i + 1);
    });
  };

  // s.normalize("NFKD")
  var normalizeVulgarFractions = function (s) {
    return s.replace(/[\u00BC-\u00BE\u2150-\u215E]/g, function (c) {
      var charCode = c.charCodeAt(0);
      var i = charCode - 0x2150 < 0 ? (charCode - 0x00BC) * 2 : (3 + charCode - 0x2150) * 2;
      return "141234171911132315253545165618385878".slice(i, i + 2).replace(/^\S/g, "$&\u2044").replace(/1\u20441/g, "1\u204410");
    });
  };

  var normalizeSubscripts = function (s) {
    var i = s.length - 1;
    while (i >= 0 && s.charCodeAt(i) >= 0x2080) {
      i -= 1;
    }
    return i === s.length - 1 ? s : s.slice(0, i + 1) + "_" + s.slice(i + 1).replace(/[\u2080-\u2089]/g, function (c) {
      return String.fromCharCode(c.charCodeAt(0) - 0x2080 + "0".charCodeAt(0));
    });
  };

  var normalizeGreek = function (s) {
    var i = s.indexOf("_");
    var k = i === -1 ? s.length : i;
    if (k > 1) {
      var name = s.slice(0, k);
      var j = greek.indexOf(name);
      if (j !== -1) {
        return String.fromCharCode(0x03B1 + j) + s.slice(k);
      }
    }
    return s;
  };

  var parseExpression = function (tokenizer, token, context, precedence, left) {
    var ok = true;
    var isDecimalFraction = false;
    var tmp = undefined;
    var right = undefined;
    //!

    while (token.type !== 'EOF' && ok) {
      var op = undefined;
      var operand = undefined;

        var bestMatch = token.type === 'operator' || (token.type === 'punctuator' && token.value === ',') ? operationSearchCache.getByName(token.value) : null;
        if (bestMatch != null) {
          op = left == null && bestMatch.name === '+' ? UNARY_PLUS : (left == null && bestMatch.name === '-' ? UNARY_MINUS : bestMatch);
        }
        //  if (Input.startsWith(input, position, '\\begin') || Input.startsWith(input, position, '\\end')) {
        //    op = null;
        //  }

      //if (op != null && op.name === "\\" && Input.startsWith(input, position, "\\\\")) {
      //  if (isMatrixElement) {//TODO: optimize
      //    op = null;
        //} else if (Input.startsWith(input, position + 1, "begin") || Input.startsWith(input, position + 1, "left")) {
        //  op = null;
      //  }
      //}

      if (op != null && op.name === "frac") { // !isAlpha(Input.getFirst(input, position + "frac".length))
        if (!(left == null && precedence <= UNARY_PRECEDENCE_PLUS_ONE || precedence < MULTIPLICATIVE_PRECEDENCE)) {
          ok = false;
        } else {
        // https://en.wikipedia.org/wiki/Operand#Positioning_of_operands - prefix notation

        token = nextToken(tokenizer);
        tmp = parseExpression(tokenizer, token, context, MULTIPLICATIVE_PRECEDENCE, undefined);
        var a = tmp.result;
        token = tmp.token;
        tmp = parseExpression(tokenizer, token, context, MULTIPLICATIVE_PRECEDENCE, undefined);
        var b = tmp.result;
        token = tmp.token;
        // addPosition - ?
        operand = op.i(a, b);
        ok = true;
        }
      } else if (op != undefined) {
        // TODO: check if the checks are needed (tests - ?)
        if (!(left != undefined && (op.arity !== 1 || op.rightToLeftAssociative !== RIGHT_TO_LEFT || precedence < MULTIPLICATIVE_PRECEDENCE) ||
              left == undefined && op.arity === 1 && op.rightToLeftAssociative === RIGHT_TO_LEFT) ||
            //!(!candidate.xyz || !isAlpha(Input.getFirst(input, position + candidate.name.length))) ||//TODO: fix - ExpressionParser.parse("George")
            precedence > op.precedence + (op.rightToLeftAssociative === RIGHT_TO_LEFT ? 0 : -1)) {
          ok = false;
        } else {
          var operatorPosition = tokenizer.previousPosition;
          token = nextToken(tokenizer);
          if (op.arity === 1 && op.rightToLeftAssociative !== RIGHT_TO_LEFT) {
            //TODO: fix
            ExpressionParser.startPosition = operatorPosition;
            ExpressionParser.endPosition = operatorPosition + op.name.length;
            ExpressionParser.input = tokenizer.input;
            left = op.i(left).addPosition(operatorPosition, op.name.length, tokenizer.input);
          } else {
            if (op.arity === 1 && op.rightToLeftAssociative === RIGHT_TO_LEFT && op.precedence === UNARY_PRECEDENCE_PLUS_ONE && op.name.length > 1 &&
                trigonometryFunctions[op.name] === true &&
                (token.type === 'operator' && token.value === '^' || token.type === 'superscript' && /^\d+$/.test(normalizeSuperscripts(token.value)))) {
              // https://en.wikipedia.org/wiki/Exponentiation#Exponential_notation_for_function_names

              // cos^2(x)
              //!new 2017-11-04
              // parse an operator for the exponentiation
              var exponentiationPosition = tokenizer.position;

              var exponentiationLength = 0;
              var middle = null;
              if (token.type === 'superscript') {
                middle = Expression.Integer.fromString(normalizeSuperscripts(token.value));
                exponentiationLength = tokenizer.position - tokenizer.previousPosition;
                token = nextToken(tokenizer);
              } else {
                exponentiationLength = '^'.length;
                token = nextToken(tokenizer);
                if (token.type !== 'integerLiteral') {
                  ok = false;
                } else {
                  tmp = parseExpression(tokenizer, token, context, UNARY_PRECEDENCE, undefined);
                  middle = tmp.result;
                  token = tmp.token;
                }
              }
              if (ok) {
                // parse an operator for the current operator
                tmp = parseExpression(tokenizer, token, context, op.precedence, undefined);
                right = tmp.result;
                token = tmp.token;
                operand = op.i(right).addPosition(operatorPosition, op.name.length, tokenizer.input).pow(middle).addPosition(exponentiationPosition, exponentiationLength, tokenizer.input);
              }
            } else {
              tmp = parseExpression(tokenizer, token, context, op.precedence, undefined);
              right = tmp.result;
              token = tmp.token;
              //TODO: fix `1/(2-2)`
              ExpressionParser.startPosition = operatorPosition;
              ExpressionParser.endPosition = operatorPosition + op.name.length;
              ExpressionParser.input = tokenizer.input;
              if (op.arity === 1) {
                // left <implicit multiplication> operand
                operand = op.i(right).addPosition(operatorPosition, op.name.length, tokenizer.input);
              } else if (op.arity === 2) {
                left = op.i(left, right).addPosition(operatorPosition, op.name.length, tokenizer.input);
              } else {
                throw new RangeError();
              }
            }
          }
        }
      } else if (left == undefined || precedence < MULTIPLICATIVE_PRECEDENCE || (precedence === UNARY_PRECEDENCE_PLUS_ONE && isDecimalFraction && token.type === 'symbol')) {
        if ((tmp = parseDecimalFraction(tokenizer, token, context)) != undefined) {
          operand = tmp.result;
          token = tmp.token;
          isDecimalFraction = true;
        } else if (token.type === 'punctuator' && token.value === "(") {
          token = parsePunctuator(tokenizer, token, "(");
          tmp = parseExpression(tokenizer, token, context, 0, undefined);
          operand = tmp.result;
          token = tmp.token;
          token = parsePunctuator(tokenizer, token, ")");
        } else if (token.type === 'punctuator' && token.value === "{") {
          token = parsePunctuator(tokenizer, token, "{");
          if (token.type === 'punctuator' && token.value === "{") {
            tmp = parseMatrix(tokenizer, token, context);
            operand = tmp.result;
            token = tmp.token;
          } else {
            tmp = parseLaTeXArgument(tokenizer, token, context);
            operand = tmp.result;
            token = tmp.token;
            token = parsePunctuator(tokenizer, token, "}");
          }
        } else if (token.type === 'punctuator' && (token.value === "\\begin{bmatrix}" ||
                                                   token.value === "\\begin{vmatrix}" ||
                                                   token.value === "\\begin{pmatrix}" ||
                                                   token.value === "\\begin{matrix}")) {
          var kind = token.value.slice('\\begin{'.length, -1);
          token = nextToken(tokenizer);
          tmp = parseLaTeXMatrix(tokenizer, token, context, '\\\\');
          operand = tmp.result;
          token = tmp.token;
          if (token.type === 'punctuator' && token.value === "\\end{" + kind + "}") {
            token = nextToken(tokenizer);
          }
          if (kind === 'vmatrix') {
            operand = operand.determinant();//!
          }
        } else if (token.type === 'symbol') {
          var symbolName = token.value;
          symbolName = normalizeSubscripts(symbolName);
          symbolName = normalizeGreek(symbolName);
          operand = context.get(symbolName);
          operand = context.wrap(operand);
          token = nextToken(tokenizer);
        } else if (token.type === 'punctuator' && token.value === "|") {
          if (left == undefined || !(left.unwrap() instanceof Expression.Matrix) && precedence < COMMA_PRECEDENCE) {//!
            token = parsePunctuator(tokenizer, token, "|");
            tmp = parseExpression(tokenizer, token, context, COMMA_PRECEDENCE, undefined);
            operand = tmp.result;
            token = tmp.token;
            token = parsePunctuator(tokenizer, token, "|");
            operand = operand.determinant();//!
          } else if (precedence < COMMA_PRECEDENCE) {
            //TODO: fix
            token = parsePunctuator(tokenizer, token, "|");
            tmp = parseExpression(tokenizer, token, context, 0, undefined);
            operand = tmp.result;
            token = tmp.token;
            operand = left.augment(operand);
            left = undefined;
          } else {
            ok = false;
          }
        } else if (token.type === 'punctuator' && token.value === '■') {
          token = nextToken(tokenizer);
          token = parsePunctuator(tokenizer, token, '(');
          tmp = parseLaTeXMatrix(tokenizer, token, context, '@');
          operand = tmp.result;
          token = tmp.token;
          token = parsePunctuator(tokenizer, token, ')');
        } else {
          ok = false;
        }
      } else {
        ok = false;
      }

      //!TODO: fix
      if (!ok && left != undefined && precedence <= UNARY_PRECEDENCE + (RIGHT_TO_LEFT === RIGHT_TO_LEFT ? 0 : -1)) {
        if (token.type === 'superscript') {
          // implicit exponentiation
          //TODO: check position
          var x = ExpressionParser.parse(normalizeSuperscripts(token.value), context);//?
          left = left.pow(x).addPosition(tokenizer.previousPosition, tokenizer.previousPosition, tokenizer.input);
          token = nextToken(tokenizer);
          ok = true;//!
        }
      }

      if (!ok && token.type === 'operator' && token.value === "\\") { // isAlpha(Input.getFirst(input, position + 1))
        // TODO: LaTeX - ?
        ok = true;
        token = nextToken(tokenizer);
      }

      if (operand != undefined) {
        if (left != undefined) {
          // implied multiplication
          var oldPosition = tokenizer.position;
          tmp = parseExpression(tokenizer, token, context, MULTIPLICATIVE_PRECEDENCE, operand);
          var right1 = tmp.result;
          token = tmp.token;
          left = left.multiply(right1).addPosition(oldPosition, "*".length, tokenizer.input);
        } else {
          left = operand;
        }
      }
    }

    if (left == undefined) {
      ExpressionParser.startPosition = tokenizer.previousPosition;
      ExpressionParser.endPosition = tokenizer.position;
      ExpressionParser.input = tokenizer.input;
      if (token.type === 'EOF') {
        throw new RangeError("UserError: unexpected end of input");//TODO: fix
      }
      //TODO: ?
      throw new RangeError("UserError: unexpected '" + tokenizer.input.slice(tokenizer.previousPosition, tokenizer.position) + "'");//TODO: fix
    }
    return new ParseResult(left, token);
  };

  // https://tc39.es/ecma402/#table-numbering-system-digits (June 23, 2020)
  var numberingSystemsWithSimpleDigitMappings = [0x0030, 0x0660, 0x06F0, 0x07C0, 0x0966, 0x09E6, 0x0A66, 0x0AE6, 0x0B66, 0x0BE6, 0x0C66, 0x0CE6, 0x0D66, 0x0DE6, 0x0E50, 0x0ED0, 0x0F20, 0x1040, 0x1090, 0x17E0, 0x1810, 0x1946, 0x19D0, 0x1A80, 0x1A90, 0x1B50, 0x1BB0, 0x1C40, 0x1C50, 0xA620, 0xA8D0, 0xA900, 0xA9D0, 0xA9F0, 0xAA50, 0xABF0, 0xFF10, 0x0104A0, 0x010D30, 0x011066, 0x0110F0, 0x011136, 0x0111D0, 0x0112F0, 0x011450, 0x0114D0, 0x011650, 0x0116C0, 0x011730, 0x0118E0, 0x011950, 0x011C50, 0x011D50, 0x011DA0, 0x016A60, 0x016B50, 0x01D7CE, 0x01D7D8, 0x01D7E2, 0x01D7EC, 0x01D7F6, 0x01E140, 0x01E2F0, 0x01E950, 0x01FBF0];

  // To generate use the next code:
  //var numberingSystemsWithSimpleDigitMappings = [];
  //var i = 0;
  //while (i <= 0x10FFFF) {
  //  if (/\p{Decimal_Number}/u.test(String.fromCodePoint(i))) {
  //    numberingSystemsWithSimpleDigitMappings.push(i);
  //    i += 10;
  //  } else {
  //    i += 1;
  //  }
  //}

  // https://stackoverflow.com/a/29018745
  function binarySearch(ar, el, compare_fn) {
      var m = 0;
      var n = ar.length - 1;
      while (m <= n) {
          var k = (n + m) >> 1;
          var cmp = compare_fn(el, ar[k]);
          if (cmp > 0) {
              m = k + 1;
          } else if(cmp < 0) {
              n = k - 1;
          } else {
              return k;
          }
      }
      return -m - 1;
  }

  // https://www.ecma-international.org/ecma-402/5.0/index.html#table-numbering-system-digits
  var replaceSimpleDigit = function (codePoint) {
    var i = binarySearch(numberingSystemsWithSimpleDigitMappings, codePoint, function (codePoint, systemOffset) {
      if (codePoint < systemOffset) {
        return -1;
      }
      if (codePoint > systemOffset + 9) {
        return +1;
      }
      return 0;
    });
    if (i >= 0) {
      return codePoint - numberingSystemsWithSimpleDigitMappings[i];
    }
    return -1;
  };


  var map = {
    ":": "/",
    "[": "(",
    "]": ")",
    "·": "*",
    "×": "*",
    "÷": "/",
    "ˆ": "^",
    "ϕ": "φ",
    "А": "A",
    "В": "B",
    "С": "C",
    "Т": "T",
    "а": "A",
    "в": "B",
    "с": "C",
    "т": "T",
    "،": ",",
    "٫": ",",
    "\u200B": " ",
    "‐": "-",
    "‑": "-",
    "‒": "-",
    "–": "-",
    "—": "-",
    "―": "-",
    "•": "*",
    "\u2061": " ",
    "\u2062": "*",
    "\u2063": ",",
    "\u2064": " ",
    "ⅇ": "e",
    "ⅈ": "i",
    "−": "-",
    "∕": "/",
    "∙": "*",
    "≤": "⩽",
    "≥": "⩾",
    "⋅": "*",
    "│": "|",
    "█": "■",
    "✓": "√",
    "〇": "0",
    "〖": "(",
    "〗": ")",
    "ー": "-",
    "一": "1",
    "七": "7",
    "三": "3",
    "九": "9",
    "二": "2",
    "五": "5",
    "八": "8",
    "六": "6",
    "四": "4"
  };


    //if (charCode === "Х".charCodeAt(0)) {
    //  return "X";
    //}
    //if (charCode === "х".charCodeAt(0)) {
    //  return "X";
    //}
    // 0x003A - Deutsch
    // "\u2064" is replaced by " ", not "+", as "+" has smaller priority
    // "ϕ".normalize("NFKD") === "φ"
    //if (/\p{Cf}/u.test(String.fromCodePoint(codePoint))) {
    //  return " ".charCodeAt(0);
    //}
    // hanidec digits

  var getCodePointReplacement = function (codePoint) {
    if (codePoint >= 0xFF01 && codePoint <= 0xFF5E) {
      // normalize full-width forms:
      return codePoint - 0xFF01 + 0x0021;
    }
    var digit = replaceSimpleDigit(codePoint);
    if (digit !== -1) {
      return digit + "0".charCodeAt(0);
    }
    // /\p{Bidi_Control}/u.test(String.fromCodePoint(codePoint))
    if (codePoint === 0x061C ||
        codePoint === 0x200E ||
        codePoint === 0x200F ||
        codePoint >= 0x202A && codePoint <= 0x202E ||
        codePoint >= 0x2066 && codePoint <= 0x2069) {
      return " ".charCodeAt(0);
    }
    if (codePoint >= 0x0000 && codePoint <= 0xFFFF) {
      // today map contains only BMP characters in keys and values
      var replacement = map[String.fromCharCode(codePoint)];
      if (replacement != undefined && replacement.length === 1) {
        return replacement.charCodeAt(0);
      }
    }
    return -1;
  };

  //var replaceRegExp = /[...]/g;
  //var replaceFunction = function (c) {
  //  return getCodePointReplacement(c.charCodeAt(0));
  //};
  //input = input.replace(replaceRegExp, replaceFunction); - slow in Chrome
  var replaceSomeChars = function (input) {
    var lastIndex = 0;
    var result = '';
    var i = 0;
    while (i < input.length) {
      var codePoint = input.codePointAt(i);
      var width = codePoint <= 0xFFFF ? 1 : 2;
      if (codePoint > 0x007F || codePoint === 0x003A || codePoint === 0x005B || codePoint === 0x005D) {
        var x = getCodePointReplacement(codePoint);
        if (x !== -1) {
          if (!(x >= 0x0000 && x <= 0xFFFF)) {
            throw new RangeError(); // assertion
          }
          result += input.slice(lastIndex, i);
          result += String.fromCharCode(x);
          lastIndex = i + width;
        }
      }
      i += width;
    }
    result += input.slice(lastIndex);
    return result;
  };

  var config = [
    {type: 'integerLiteral', re: null},
    {type: 'numericLiteral', re: null},
    {type: 'whitespace', re: whiteSpaces},
    {type: 'punctuator', re: punctuators},
    {type: 'operator', re: null},
    {type: 'symbol', re: symbols},
    {type: 'vulgarFraction', re: vulgarFractions},
    {type: 'superscript', re: superscripts},
    {type: 'OTHER', re: other}
  ];

  function Token(type, value) {
    this.type = type;
    this.value = value;
  }

  Token.EOF = new Token('EOF', '');

  function Tokenizer(input, position, states) {
    this._preparedInput = replaceSomeChars(input.slice(position)); //TODO: fix ???
    this.input = input;
    this._preparedInputPosition = 0;
    this.previousPosition = position;
    this.position = position;
    this.states = states;
  }

  Tokenizer.prototype.next = function () {
    this.previousPosition = this.position;
    if (this.position >= this.input.length) {
      return Token.EOF;
    }
    // iteration by object keys is slower (?)
    for (var i = 0; i < config.length; i += 1) {
      var c = config[i];
      var type = c.type;
      var re = c.re;
      if (re == null) {
        if (type === 'integerLiteral') {
          if (this.states != null && this.states.value === '{}') {
            re = integerLiteralWithoutComma;
          } else {
            re = integerLiteral;
          }
        } else if (type === 'numericLiteral') {
          if (this.states != null && this.states.value === '{}') {
            re = decimalFractionWithoutComma;
          } else {
            re = decimalFraction;
          }
        } else if (type === 'operator') {
          re = operationSearchCache.getRegExp();//?TODO:
        }
      }
      var tmp = re.exec(this._preparedInput.slice(this._preparedInputPosition));
      if (tmp != null) {
        var value = tmp[0];
        if (type === 'punctuator') {
          if (value === '(') {
            this.states = {previous: this.states, value: '()'};
          } else if (value === ')') {
            if (this.states != null && this.states.value === '()') {
              this.states = this.states.previous;
            }
          } else if (value === '{') {
            this.states = {previous: this.states, value: '{}'};
          } else if (value === '}') {
            if (this.states != null && this.states.value === '{}') {
              this.states = this.states.previous;
            }
          }
        }
        for (var j = 0; j < value.length; j += (value.codePointAt(j) <= 0xFFFF ? 1 : 2)) {
          this.position += this.input.codePointAt(this.position) <= 0xFFFF ? 1 : 2;
        }
        this._preparedInputPosition += value.length;
        return new Token(type, value);
      }
    }
    throw new TypeError();
  };

  var fs = {};//!TODO: remove!!!

  function ExpressionParser() {
  }

  ExpressionParser.parse = function (input, context) {
    context = context == undefined ? new ExpressionParser.Context(undefined, false) : context;

    ExpressionParser.startPosition = -1;
    ExpressionParser.endPosition = -1;
    ExpressionParser.input = input; //?

    // TODO: remove
    if (typeof input !== "string") {
      throw new RangeError();
    }

    if (typeof hit === "function" && context.getter != undefined) {
      var re = /[a-z][a-z][a-z\-]+/gi;
      var m = null;
      while ((m = re.exec(input)) != null) {
        var t = m[0];
        if (!(t in fs) && t.indexOf("-") === -1) {
          fs[t] = true;
          hit({fs: t});
        }
      }
    }

    var tokenizer = new Tokenizer(input, 0, null);
    var token = nextToken(tokenizer);
    var tmp = parseExpression(tokenizer, token, context, 0, undefined);
    token = tmp.token;
    if (token.type !== 'EOF') {
      ExpressionParser.startPosition = tokenizer.previousPosition;
      ExpressionParser.endPosition = tokenizer.position;
      ExpressionParser.input = tokenizer.input;
      throw new RangeError("UserError: unexpected '" + tokenizer.input.slice(tokenizer.previousPosition, tokenizer.position) + "'");
    }

    return tmp.result;
  };

  globalThis.Tokenizer = Tokenizer;

  ExpressionParser.startPosition = -1;
  ExpressionParser.endPosition = -1;
  ExpressionParser.input = "";

  var getConstant = function (symbolName) {
    if (symbolName === "pi" || symbolName === "\u03C0" || symbolName === "\u0637") {
      return Expression.PI;
    }
    if (symbolName === "e" || symbolName === "\u06BE") {
      return Expression.E;
    }
    if (symbolName === "i" || symbolName === "\u062A") {
      return Expression.I;
    }
    if (symbolName === "I" || symbolName === "U" || symbolName === "E") {
      return new Expression.IdentityMatrix(symbolName);
    }
    if (symbolName === "circ") { //TODO: ○ - ?
      return Expression.CIRCLE;
    }
    return new Expression.Symbol(symbolName);
  };

  ExpressionParser.Context = function (getter, needsWrap) {
    this.getter = getter;
    this.needsWrap = needsWrap == undefined ? true : needsWrap;
  };
  ExpressionParser.Context.prototype.get = function (symbolName) {
    if (this.getter != undefined) {
      var x = this.getter(symbolName);
      if (x != undefined) {
        return x;
      }
    }
    return getConstant(symbolName);
  };
  ExpressionParser.Context.prototype.wrap = function (e) {
    if (!this.needsWrap) {
      return e;
    }
    return new Expression.NonSimplifiedExpression(e);
  };

  ExpressionParser.addOperation = function (denotation, arity) {
    //TODO: UNARY_PRECEDENCE -> UNARY_PRECEDENCE_PLUS_ONE - ???
    var newOperation = arity === 1 ? new Operator(denotation, arity, RIGHT_TO_LEFT, UNARY_PRECEDENCE, function (a) {
      return a.transformNoAnswerExpression(denotation);
    }) : new Operator(denotation, arity, RIGHT_TO_LEFT, MULTIPLICATIVE_PRECEDENCE, function (a, b) {
      return a.transformNoAnswerExpression(denotation, b);
    });
    //operations.push(newOperation);
    operationSearchCache.append(newOperation);
  };

  ExpressionParser.addDenotations = function (denotationsByOperation) {
    for (var operationName in denotationsByOperation) {
      if (Object.prototype.hasOwnProperty.call(denotationsByOperation, operationName)) {
        var denotations = denotationsByOperation[operationName];
        var operation = operationSearchCache.getByName(operationName);
        var added = {};
        added[operationName] = true;
        for (var key in denotations) {
          if (Object.prototype.hasOwnProperty.call(denotations, key)) {
            var denotation = denotations[key];
            if (added[denotation] == undefined) {
              added[denotation] = true;
              var newOperation = new Operator(denotation, operation.arity, operation.rightToLeftAssociative, operation.precedence, operation.i);
              //operations.push(newOperation);
              operationSearchCache.append(newOperation);
              if (trigonometryFunctions[operationName]) {
                trigonometryFunctions[denotation] = true;
              }
            }
          }
        }
      }
    }
  };

  self.ExpressionParser = ExpressionParser;

})();
(function () {
"use strict";
/*jslint plusplus: true, vars: true, indent: 2 */

//(function (exports) {
  //"use strict";

  function Heap(compareTo) {
    this.data = [];
    this.compareTo = compareTo;
  }

  Heap.prototype.push = function (value) {
    var data = this.data;
    var compareTo = this.compareTo;
    data.push(value);
    // bubbleUp(size - 1)
    var size = data.length;
    var j = size - 1;
    var tmp = data[j];
    var parent = -1;
    while (j > 0 && compareTo(tmp, data[parent = Math.floor((j - 1) / 2)]) < 0) {
      data[j] = data[parent];
      j = parent;
    }
    data[j] = tmp;
  };
  
  Heap.prototype.pop = function () {
    var data = this.data;
    var compareTo = this.compareTo;
    var size = data.length;
    if (size === 0) {
      return undefined;
    }
    if (size === 1) {
      return data.pop();
    }
    var value = data[0];
    data[0] = data.pop();
    --size;
    // bubbleDown(0)
    var j = 0;
    if (j < size) {
      var tmp = data[j];
      do {
        var child = size;
        var t = tmp;
        var c = j * 2;
        if (++c < size && compareTo(data[c], t) < 0) {
          child = c;
          t = data[child];
        }
        if (++c < size && compareTo(data[c], t) < 0) {
          child = c;
          t = data[child];
        }
        data[j] = t;
        j = child;
      } while (j < size);
    }
    return value;
  };

  Heap.prototype.peek = function () {
    var data = this.data;
    return data.length > 0 ? data[0] : undefined;
  };

  Heap.prototype.size = function () {
    var data = this.data;
    return data.length;
  };

  Heap.prototype.replace = function (newItem) {
    this.data.push(newItem);
    return this.pop();
  };

  //exports.Heap = Heap;

//}(this));
self.Heap = Heap;

})();
(function () {
"use strict";
/*global hit*/
// Transformation methods:
//   Polynomial#_exponentiateRoots(n) (α_1 = α**n or x = x_1**(1/n)) - ? - throws when cannot do it (?)
//   Polynomial#_scaleRoots(s) (α_1 = α * s or x = x_1 / s)
//   Polynomial#_translateRoots(h) (α_1 = α + h or x = x_1 - h)



 //



var nextPrime = primeFactor._nextPrime; //var freeze = Object.freeze; - too slow

var freeze = function (x) { return x; }; // similar to https://developer.android.com/reference/android/util/SparseArray


function PolynomialData(length) {
  this.degrees = new Array(length);
  this.coefficients = new Array(length);
  this.size = 0; // public
}

PolynomialData.prototype.add = function (degree, coefficient) {
  var k = this.size;

  if (!(Math.floor(degree) === degree && degree >= 0 && degree <= Number.MAX_SAFE_INTEGER)) {
    throw new RangeError("NotSupportedError");
  }

  if (k > 0 && !(degree < this.degrees[k - 1]) || k >= this.degrees.length || k >= this.coefficients.length) {
    throw new RangeError();
  }

  this.degrees[k] = degree;
  this.coefficients[k] = coefficient;
  this.size = k + 1;
};

PolynomialData.prototype.degree = function (i) {
  return this.degrees[i];
};

PolynomialData.prototype.coefficient = function (i) {
  return this.coefficients[i];
};

PolynomialData.prototype.trim = function () {
  if (this.size !== this.degrees.length || this.size !== this.coefficients.length) {
    this.degrees.length = this.size;
    this.coefficients.length = this.size;
  }

  return this;
}; // Polynomial([a0, a1, a2, ...., an]);
// an*x^n+ an-1 x ^n-1 +... + a0


function Polynomial(a) {
  this.a = a.trim();
}

Polynomial.of = function () {
  var newData = new PolynomialData(arguments.length);

  for (var i = arguments.length - 1; i >= 0; i -= 1) {
    var a = arguments[i];

    if (!a.equals(Expression.ZERO)) {
      newData.add(i, a);
    }
  }

  return new Polynomial(newData);
};

Polynomial.from = function (array) {
  var newData = new PolynomialData(array.length);

  for (var i = array.length - 1; i >= 0; i -= 1) {
    var degree = i;
    var coefficient = array[i];

    if (!coefficient.equals(Expression.ZERO)) {
      newData.add(degree, coefficient);
    }
  }

  return new Polynomial(newData);
};

Polynomial.ZERO = Polynomial.of();

Polynomial.prototype.getDegree = function () {
  return this.a.size === 0 ? -1 : this.a.degree(0);
};

Polynomial.prototype.getCoefficient = function (degree) {
  var from = 0;
  var to = this.a.size;

  while (from < to) {
    var middle = from + Math.floor((to - from) / 2);
    var y = this.a.degree(middle);

    if (y > degree) {
      from = middle + 1;
    } else if (y < degree) {
      to = middle;
    } else {
      return this.a.coefficient(middle);
    }
  }

  return Expression.ZERO;
};

Polynomial.prototype.getLeadingCoefficient = function () {
  return this.a.size === 0 ? Expression.ZERO : this.a.coefficient(0);
};

Polynomial.prototype.map = function (mapFunction) {
  //?
  if (mapFunction.length !== 1) {
    throw new RangeError("deprecated");
  }

  var newData = new PolynomialData(this.a.size);

  for (var i = 0; i < this.a.size; i += 1) {
    var degree = this.a.degree(i);
    var coefficient = this.a.coefficient(i);
    var c = mapFunction(coefficient);

    if (!c.equals(Expression.ZERO)) {
      newData.add(degree, c);
    }
  }

  return new Polynomial(newData);
};

Polynomial.prototype.equals = function (p) {
  if (p === Expression.ZERO) {
    return this.a.size === 0;
  }

  if (this.a.size !== p.a.size) {
    return false;
  }

  var i = 0;
  var j = 0;

  while (i < this.a.size && j < p.a.size) {
    if (this.a.degree(i) !== p.a.degree(j) || !this.a.coefficient(i).equals(p.a.coefficient(j))) {
      return false;
    }

    i += 1;
    j += 1;
  }

  return true;
};

Polynomial.prototype.add = function (p) {
  if (p.a.size === 0) {
    return this;
  }

  if (this.a.size === 0) {
    return p;
  }

  var newData = new PolynomialData(this.a.size + p.a.size);
  var i = -1;
  var x = -2;
  var xc = Expression.ZERO;
  var j = -1;
  var y = -2;
  var yc = Expression.ZERO;

  while (x !== -1 || y !== -1) {
    var d = Math.max(x, y);
    var flag = x !== y;
    var c = x > y ? xc : y > x ? yc : d === -2 ? Expression.ZERO : xc.add(yc);

    if (x === d) {
      i += 1;

      if (i < this.a.size) {
        x = this.a.degree(i);
        xc = this.a.coefficient(i);
      } else {
        x = -1;
        xc = Expression.ZERO;
      }
    }

    if (y === d) {
      j += 1;

      if (j < p.a.size) {
        y = p.a.degree(j);
        yc = p.a.coefficient(j);
      } else {
        y = -1;
        yc = Expression.ZERO;
      }
    }

    if (flag || d !== -2 && !c.equals(Expression.ZERO)) {
      newData.add(d, c);
    }
  }

  return new Polynomial(newData);
};

function split_at(p, d) {
  var tmp = p.divideAndRemainder(Polynomial.of(Expression.ONE).shift(d));
  return [tmp.quotient, tmp.remainder];
}

var KARATSUBA_THRESHOLD = 81; // https://en.wikipedia.org/wiki/Karatsuba_algorithm#Pseudocode

function karatsuba(p1, p2) {
  if (p1.a.size < KARATSUBA_THRESHOLD || p2.a.size < KARATSUBA_THRESHOLD) {
    return p1.multiply(p2);
  }
  /* Calculates the size of the numbers. */


  var m = Math.min(p1.a.size, p2.a.size);
  var m2 = (p2.a.size <= p1.a.size ? p2 : p1).a.degree(Math.floor(m / 2));
  /* var m2 = Math.ceil(m / 2) will also work */

  /* Split the digit sequences in the middle. */

  var $tmphigh1_low1 = split_at(p1, m2);
  var high1 = $tmphigh1_low1[0];
  var low1 = $tmphigh1_low1[1];
  var $tmphigh2_low2 = split_at(p2, m2);
  var high2 = $tmphigh2_low2[0];
  var low2 = $tmphigh2_low2[1];
  /* 3 calls made to numbers approximately half the size. */

  var z0 = karatsuba(low1, low2);
  var z1 = karatsuba(low1.add(high1), low2.add(high2));
  var z2 = karatsuba(high1, high2);
  return z2.shift(m2 * 2).add(z1.subtract(z2).subtract(z0).shift(m2)).add(z0);
}

function multiplyInternal(A, B, fromLeft) {
  var npmp1 = A.getDegree() + B.getDegree() + 1;

  if ((A.a.size + B.a.size + Math.min(A.a.size, B.a.size)) * 4 >= npmp1) {
    // "dense"
    var result = new Array(npmp1).fill(Expression.ZERO);

    for (var i = 0; i < A.a.size; i += 1) {
      var d = A.a.degree(i);
      var c = A.a.coefficient(i);

      for (var j = 0; j < B.a.size; j += 1) {
        var bd = B.a.degree(j);
        var bj = B.a.coefficient(j);
        var degree = d + bd;
        var coefficient = fromLeft ? c.multiply(bj) : bj.multiply(c);
        result[degree] = result[degree].add(coefficient);
      }
    }

    return Polynomial.from(result);
  } else {
    var result = new FastAdditionPolynomial();

    for (var i = 0; i < A.a.size; i += 1) {
      var d = A.a.degree(i);
      var c = A.a.coefficient(i);
      result.add(c, d, B, fromLeft);
    }

    return result.toPolynomial();
  }
}

Polynomial.prototype.multiply = function (p) {
  if (this.a.size === 0 || p.a.size === 0) {
    return Polynomial.ZERO;
  }

  if (p.a.size === 1 && p.a.coefficient(0) instanceof Expression.Integer) {
    // commutative multiplication
    return this.shift(p.a.degree(0)).scale(p.a.coefficient(0));
  }

  if (p.a.size >= KARATSUBA_THRESHOLD && this.a.size >= KARATSUBA_THRESHOLD) {
    //debugger;
    console.count('KARATSUBA_THRESHOLD');
    return karatsuba(this, p);
  }

  if (this.a.size <= p.a.size) {
    return multiplyInternal(this, p, true);
  } else {
    return multiplyInternal(p, this, false);
  }
};

Polynomial.prototype.shift = function (n) {
  // *= x**n, n >= 0
  if (!(n >= 0)) {
    throw new TypeError();
  }

  if (n === 0) {
    return this;
  }

  var newData = new PolynomialData(this.a.size);

  for (var i = 0; i < this.a.size; i += 1) {
    newData.add(this.a.degree(i) + n, this.a.coefficient(i));
  }

  return new Polynomial(newData);
}; //note: no Map is needed


function FastAdditionPolynomial() {
  // see http://www.cecm.sfu.ca/~mmonagan/teaching/TopicsinCA11/johnson.pdf
  // see https://en.wikipedia.org/wiki/K-way_merge_algorithm#Heap
  this.maxHeap = new Heap(function (a, b) { return b.degree - a.degree; });
  this.degree = -1;
  this.leadingCoefficient = Expression.ZERO;
}

FastAdditionPolynomial.prototype.add = function (scale, shift, polynomial, fromLeft) {
  var i = 0;
  var iterator = {
    next: function () {
      if (i === polynomial.a.size) {
        return undefined;
      }

      var d = polynomial.a.degree(i);
      var c = polynomial.a.coefficient(i);
      i += 1;
      return freeze({
        degree: d + shift,
        coefficient: c === Expression.ONE ? scale : scale === Expression.ONE ? c : fromLeft ? scale.multiply(c) : c.multiply(scale),
        iterator: iterator
      });
    }
  };
  var newEntry = iterator.next();

  if (newEntry.degree > this.degree && this.degree !== -1) {
    throw new RangeError();
  } else if (newEntry.degree < this.degree) {
    this.maxHeap.push(newEntry);
  } else {
    if (this.degree === -1) {
      this.leadingCoefficient = newEntry.coefficient;
      this.degree = newEntry.degree;
    } else {
      this.leadingCoefficient = this.leadingCoefficient.add(newEntry.coefficient);
    }

    newEntry = newEntry.iterator.next();

    if (newEntry != undefined) {
      this.maxHeap.push(newEntry);
    } // Computation of the leading coefficient:


    while (this.maxHeap.size() > 0 && (this.degree === this.maxHeap.peek().degree || this.leadingCoefficient.equals(Expression.ZERO))) {
      var tmp = this.maxHeap.peek();
      this.leadingCoefficient = this.leadingCoefficient.add(tmp.coefficient);
      this.degree = tmp.degree;
      var next = tmp.iterator.next();

      if (next != undefined) {
        //this.maxHeap.pop();
        //this.maxHeap.push(next);
        this.maxHeap.replace(next);
      } else {
        this.maxHeap.pop();
      }
    }

    if (this.maxHeap.size() === 0 && this.leadingCoefficient.equals(Expression.ZERO)) {
      this.degree = -1;
    }
  }
};

FastAdditionPolynomial.prototype.getDegree = function () {
  return this.degree;
};

FastAdditionPolynomial.prototype.getLeadingCoefficient = function () {
  return this.leadingCoefficient;
};

FastAdditionPolynomial.prototype.toPolynomial = function () {
  var terms = [];
  var ONE = Polynomial.of(Expression.ONE);

  while (this.getDegree() >= 0) {
    var degree = this.getDegree();
    var coefficient = this.getLeadingCoefficient();
    this.add(coefficient.negate(), degree, ONE, true);
    terms.push({
      degree: degree,
      coefficient: coefficient
    });
  }

  return Polynomial.fromTerms(terms);
};

Polynomial.prototype.divideAndRemainder = function (p, w) {
  w = w || undefined;

  if (p.equals(Polynomial.ZERO)) {
    throw new TypeError("ArithmeticException");
  }

  if (this.getDegree() < p.getDegree()) {
    return {
      quotient: Polynomial.ZERO,
      remainder: this
    };
  }

  if (p.a.size === 1 && p.a.coefficient(0).equals(Expression.ONE) && (this._hasIntegerLikeCoefficients() || w == undefined)) {
    //TODO: !!!
    if (p.a.degree(0) === 0) {
      return {
        quotient: this,
        remainder: Polynomial.ZERO
      };
    }

    var s = p.a.degree(0);
    var k = 0;

    while (this.a.degree(k) >= s && k < this.a.size) {
      k += 1;
    }

    var q = new PolynomialData(k);

    for (var i = 0; i < k; i += 1) {
      q.add(this.a.degree(i) - s, this.a.coefficient(i));
    }

    var r = new PolynomialData(this.a.size - k);

    for (var i = k; i < this.a.size; i += 1) {
      r.add(this.a.degree(i), this.a.coefficient(i));
    }

    return {
      quotient: new Polynomial(q),
      remainder: new Polynomial(r)
    };
  }

  var quotient = []; //var remainder = this;

  var remainder = new FastAdditionPolynomial();
  remainder.add(Expression.ONE, 0, this, true);
  var minusP = p.negate();
  var lcp = p.getLeadingCoefficient();
  var lcpInv = lcp instanceof Expression.ExpressionWithPolynomialRoot ? lcp.inverse() : undefined; // TODO: ?

  while (remainder.getDegree() >= p.getDegree()) {
    var n = remainder.getDegree() - p.getDegree();
    var lcr = remainder.getLeadingCoefficient();
    var q = lcpInv == undefined ? lcr.divide(lcp) : lcr.multiply(lcpInv);

    if (w != undefined) {
      if (q instanceof Expression.Division) {
        if (w === "throw") {
          throw new RangeError(); // AssertionError
        }

        if (w === "undefined") {
          return undefined;
        }

        throw new RangeError();
      }
    } //TODO: optimize - ?


    quotient.push({
      degree: n,
      coefficient: q
    }); //TODO: optimize - ?

    remainder.add(q, n, minusP, true); //if (!(q instanceof Expression.Integer)) {
    //  remainder = remainder.add(Polynomial.of(q).shift(n).multiply(minusP));
    //} else {
    //  remainder = remainder.add(minusP.shift(n).scale(q));
    //}

    if (remainder.getDegree() - p.getDegree() === n) {
      // to avoid the infite loop
      throw new TypeError("there is a some problem with the expression evaluation"); //!
    }
  }

  remainder = remainder.toPolynomial();
  return {
    quotient: Polynomial.fromTerms(quotient),
    remainder: remainder
  };
};

Polynomial.pseudoRemainder = function (A, B) {
  var d = A.getDegree() - B.getDegree(); // assertion

  if (d < 0) {
    throw new RangeError();
  }

  return A.scale(B.getLeadingCoefficient()._pow(d + 1)).divideAndRemainder(B, "throw").remainder;
};

Polynomial.polynomialGCD = function (a, b) {
  //!optimization 2021-03-15
  if (b.getDegree() > 0 && a.getDegree() > 0) {
    var ctz = function (p) {
      var i = 0;

      while (p.getCoefficient(i).equals(Expression.ZERO)) {
        i += 1;
      }

      return i;
    };

    var i = ctz(b);
    var j = ctz(a);

    if (i !== 0 || j !== 0) {
      //TODO: optimize (?)
      return Polynomial.polynomialGCD(a.divideAndRemainder(Polynomial.of(Expression.ONE).shift(j), "throw").quotient, b.divideAndRemainder(Polynomial.of(Expression.ONE).shift(i), "throw").quotient).shift(Math.min(i, j));
    }
  } //!
  //TODO: fix (place condition for degrees earlier - ?)


  if (a.getDegree() < b.getDegree()) {
    //!!!
    var tmp = a;
    a = b;
    b = tmp;
  }

  if (b.equals(Polynomial.ZERO)) {
    return a;
  } //!


  if (a.getDegree() === 1 && b.getDegree() === 0) {
    return Polynomial.of(b.getCoefficient(0).gcd(a.getCoefficient(0)).gcd(a.getCoefficient(1))); //?
  } //!


  var contentA = a.getContent();
  var contentB = b.getContent();
  var ppA = a.divideAndRemainder(Polynomial.of(contentA), "throw").quotient;
  var ppB = b.divideAndRemainder(Polynomial.of(contentB), "throw").quotient;
  var ppGCD = gcdOfPrimitivePolynomials(ppA, ppB);
  var contentGCD = contentA.gcd(contentB);
  return Polynomial.of(contentGCD).multiply(ppGCD);
};

function hasQuadraticInteger(c) {
  if (c instanceof Expression.NthRoot) {
    return !(c instanceof Expression.Integer);
  }

  if (c instanceof Expression.ExponentiationOfMinusOne) {
    return true; //TODO: RENAME or remove, add a test, other classes
  }

  if (c instanceof Expression.BinaryOperation) {
    return hasQuadraticInteger(c.a) || hasQuadraticInteger(c.b);
  } //if (c instanceof Expression.ExpressionWithPolynomialRoot) {//TODO: rename function or remove (?)
  //  return true;
  //}


  if (c instanceof Expression.Integer || c instanceof Expression.Symbol || c instanceof Expression.Complex) {
    return false;
  }

  console.info(c); //?

  return false;
}
/*

    if (!a._hasIntegerLikeCoefficients() || !b._hasIntegerLikeCoefficients()) {
      var g = gcdOfPrimitivePolynomials(a, b);
      g = g.scale(g.getLeadingCoefficient().inverse()).primitivePart();
      return g;//TODO: rename, change, ..., check - ?
    }

    if (B.getDegree() > 0) {
      var g1 = gcdUsingPseudoRemainderSequence(A, B, "subresultant");//?
      return g1.scale(g1.getLeadingCoefficient().inverse()).primitivePart();//?
    }

*/
//TODO: ? 


var getY = function (p) {
  for (var i = 0; i < p.a.size; i++) {
    var c = p.a.coefficient(i);
    var v = Expression.getVariable(c, {
      avoidNthRoots: true
    });

    if (v != null) {
      if (v instanceof Expression.ExpressionWithPolynomialRoot) {
        //debugger;
        return null; //!?
      }

      if (Expression.isConstant(v)) {
        //debugger;
        return null;
      } //if (v instanceof Expression.Addition) { //TODO: replacement - ?
      //  v = null;
      //}


      for (var j = i; j < p.a.size; j += 1) {
        if (v != null && !Expression._getReplacement(p.a.coefficient(j), v).equals(v)) {
          v = null;
        }
      }

      if (v != null) {
        return v;
      }
    }
  }

  return null;
};

function gcdOfPrimitivePolynomials(A, B) {
  console.assert(A.getDegree() >= B.getDegree());
  var g = Math.gcd(A.getGCDOfTermDegrees(), B.getGCDOfTermDegrees());

  if (g > 1) {
    return gcdOfPrimitivePolynomials(A._exponentiateRoots(g), B._exponentiateRoots(g))._exponentiateRoots(1 / g);
  } //if (B.getDegree() === 1) {
  //  return A.divideAndRemainder(B).remainder.equals(Polynomial.ZERO) ? B : Polynomial.of(Expression.ONE);
  //}
  //TODO: for rings - ?


  if (A.hasIntegerCoefficients() && B.hasIntegerCoefficients() && B.getDegree() > 2) {
    if (A.isDivisibleBy(B)) {
      return B;
    }

    return gcdByModularAlgorithm(A, B);
  } //TODO: 
  //if (A._hasIntegerLikeCoefficients() && B._hasIntegerLikeCoefficients() && B.getDegree() > 2) {


  if (B.getDegree() > 1) {
    if (getY(A) != null || getY(B) != null) {
      return gcdByMultivariateModularAlgorithm(A, B);
    }
  } //}


  if (B.getDegree() > 2) {
    //TODO: why isn't it working or slow for other cases - ?
    return gcdUsingPseudoRemainderSequence(A, B, "subresultant").primitivePart();
  } //TODO:
  //if (isUniqueFactorizationDomain()) {


  if (!A._testCoefficients(function (c) { return hasQuadraticInteger(c); }) && !B._testCoefficients(function (c) { return hasQuadraticInteger(c); }) && B.getDegree() > 0) {
    //TODO: REMOVE
    return gcdUsingPseudoRemainderSequence(A, B, "primitive");
  } //}


  if (B.getDegree() === 0) {
    return Polynomial.of(Expression.ONE);
  }

  return gcdUsingRemainderSequence(A, B).primitivePart();
}

function gcdUsingRemainderSequence(A, B) {
  while (!B.equals(Polynomial.ZERO)) {
    var R = A.divideAndRemainder(B).remainder;
    A = B;
    B = R;
  }

  return A;
}

function gcdUsingPseudoRemainderSequence(A, B, type) {
  var g = Math.gcd(A.getGCDOfTermDegrees(), B.getGCDOfTermDegrees());

  if (g > 1) {
    console.error('g > 1');
    return gcdUsingPseudoRemainderSequence(A._exponentiateRoots(g), B._exponentiateRoots(g), type)._exponentiateRoots(1 / g);
  }

  for (var iteratortmp = Polynomial._pseudoRemainderSequence(A, B, type)[globalThis.Symbol.iterator](), tmp = iteratortmp.next().value; tmp != null; tmp = iteratortmp.next().value) {
    var newR = tmp.R;
    A = B;
    B = newR;
  }

  var lastNonzeroRemainder = A;
  return lastNonzeroRemainder;
}

Polynomial._gcdUsingPseudoRemainderSequence = gcdUsingPseudoRemainderSequence;

function ChineseRemainderTheorem(m1, m2) {
  // https://en.wikipedia.org/wiki/Chinese_remainder_theorem#Case_of_two_moduli
  // x = r1 (mod m1)
  // x = r2 (mod m2)
  var c = m1.remainder(m2).modInverse(m2);
  return function (r1, r2) {
    return r1.add(r2.subtract(r1.modulo(m2)).multiply(c).modulo(m2).multiply(m1));
  };
}

globalThis.ChineseRemainderTheorem = ChineseRemainderTheorem; //TODO: REMOVE

/*
 var i = Expression.Integer.fromNumber;
 console.assert(ChineseRemainderTheorem(i(36), i(1), i(119), i(23)).equals(i(2416)));
*/

function ChineseRemainderTheoremForPolynomialCoefficients(p1, p2, m1, m2) {
  var n = Math.max(p1.getDegree(), p2.getDegree());
  var solution = ChineseRemainderTheorem(m1, m2);
  var c = new Array(n);

  for (var i = 0; i <= n; i += 1) {
    var r1 = p1.getCoefficient(i);
    var r2 = p2.getCoefficient(i);
    c[i] = solution(r1, r2);
  }

  return Polynomial.from(c);
}

Polynomial.prototype._exponentiateRoots = function (n) {
  // α = α**n
  if (n === -1) {
    if (this.getCoefficient(0).equals(Expression.ZERO)) {
      throw new RangeError();
    }

    var newData = new PolynomialData(this.a.size);

    for (var j = this.a.size - 1; j >= 0; j -= 1) {
      newData.add(this.getDegree() - this.a.degree(j), this.a.coefficient(j));
    }

    var p = new Polynomial(newData);

    if (p.getLeadingCoefficient() instanceof Expression.Integer && p.getLeadingCoefficient().sign() < 0) {
      //TODO: ?
      p = p.negate(); //!!!
    }

    return p;
  }

  var inv = Math.floor(1 / n + 0.5);

  if (Math.floor(n) === n && n >= 2 || 1 / inv === n && inv >= 2) {
    var newData = new PolynomialData(this.a.size);

    for (var i = 0; i < this.a.size; i += 1) {
      if (Math.floor(n) === n && this.a.degree(i) % n !== 0) {
        throw new RangeError(); //?
      }

      newData.add(Math.floor(n) === n ? this.a.degree(i) / n : this.a.degree(i) * inv, this.a.coefficient(i));
    }

    return new Polynomial(newData);
  }

  throw new RangeError(n);
};

Polynomial.prototype._scaleRoots = function (s) {
  var that = this; //if (s.equals(Expression.TWO)) {
  //  return this.map(function (c, degree) { return s.getNumerator()._pow(that.getDegree() - degree).multiply(s.getDenominator()._pow(degree)).multiply(c); });
  //}

  var lastScale = Expression.ONE;
  var lastScaleDegree = 0;
  var newData = new PolynomialData(this.a.size);

  for (var i = 0; i < this.a.size; i += 1) {
    var degree = this.a.degree(i);
    var d = this.getDegree() - degree;
    lastScale = lastScale.multiply(s.getNumerator()._pow(d - lastScaleDegree));
    lastScaleDegree = d;
    newData.add(degree, lastScale.multiply(s.getDenominator()._pow(degree)).multiply(this.a.coefficient(i)));
  }

  return new Polynomial(newData);
};

Polynomial.prototype._translateRoots = function (h) {
  // α = α + h
  if (h.equals(Expression.ONE.negate())) {
    //return this.map(function (c) { return Polynomial.of(c); }).calcAt(Polynomial.of(Expression.ONE, Expression.ONE));
    // The Art of Computer Science by Donald Knuth, Volume 2, page 489:
    var u = this;
    var n = u.getDegree();
    var v = new Array(n + 1);

    for (var j = 0; j <= n; j += 1) {
      v[j] = u.getCoefficient(j);
    }

    for (var k = 0; k <= n - 1; k += 1) {
      for (var j = n - 1; j >= k; j -= 1) {
        v[j] = v[j].add(v[j + 1]);
      }
    }

    return Polynomial.from(v);
  }

  if (h.equals(Expression.ZERO)) {
    return this;
  }

  var v = h.getNumerator()._pow(this.getDegree());

  return this._scaleRoots(h.negate().inverse())._translateRoots(Expression.ONE.negate())._scaleRoots(h.negate()).map(function (c) { return c.divide(v); });
}; //TODO: ???


Polynomial.prototype._pow = function (count) {
  var pow = function (x, count, accumulator) {
    if (count < 0) {
      throw new RangeError();
    }

    if (count > Number.MAX_SAFE_INTEGER) {
      throw new RangeError("NotSupportedError");
    }

    return count < 1 ? accumulator : 2 * Math.floor(count / 2) !== count ? pow(x, count - 1, accumulator.multiply(x)) : pow(x.multiply(x), Math.floor(count / 2), accumulator);
  }; //throw new Error();//TODO: ?


  return pow(this, count, Polynomial.of(Expression.ONE));
};

function gcdByModularAlgorithm(a, b) {
  if (true) {
    var g = Math.gcd(a.getGCDOfTermDegrees(), b.getGCDOfTermDegrees());

    if (g > 1) {
      console.error('g > 1');
      return gcdByModularAlgorithm(a._exponentiateRoots(g), b._exponentiateRoots(g))._exponentiateRoots(1 / g);
    }
  } // https://www3.risc.jku.at/education/courses/ws2011/ca/3-gcd.pdf


  var d = a.getLeadingCoefficient().abs().gcd(b.getLeadingCoefficient().abs());

  if (a.getCoefficient(0).equals(Expression.ZERO) || b.getCoefficient(0).equals(Expression.ZERO)) {
    throw new RangeError();
  }

  if (d.compareTo(a.getCoefficient(0).abs().gcd(b.getCoefficient(0).abs())) > 0) {
    //?
    return gcdByModularAlgorithm(a._exponentiateRoots(-1), b._exponentiateRoots(-1))._exponentiateRoots(-1);
  }

  console.assert(a.hasIntegerCoefficients() && a.getContent().abs().equals(Expression.ONE) && a.getDegree() > 0);
  console.assert(b.hasIntegerCoefficients() && b.getContent().abs().equals(Expression.ONE) && b.getDegree() > 0);
  var maxGCDDegree = Math.min(a.getDegree(), b.getDegree());

  var bound = function (a, b, maxGCDLeadingCoefficient, maxGCDDegree) {
    //TODO: not necessary to use power of two
    var logarithmOfCoefficientBound = Math.min(a._log2OfBoundForCoefficientsOfFactor(maxGCDDegree, maxGCDLeadingCoefficient), b._log2OfBoundForCoefficientsOfFactor(maxGCDDegree, maxGCDLeadingCoefficient)); //TODO: multiply by gcd of leading coefficients (?)

    return Expression.TWO._pow(1 + Math.ceil(logarithmOfCoefficientBound));
  };

  var M = bound(a, b, d, maxGCDDegree); //if (M === 1 / 0) {
  //  return gcdUsingPrimitivePseudoRemainderSequence(a, b);//TODO: !!!
  //}

  var p = Expression.Integer.fromBigInt(Math.min(M.toNumber(), Math.floor(Math.sqrt((Number.MAX_SAFE_INTEGER + 1) / 2)))); // TODO: should we divide on n - ?
  //var p = Expression.Integer.fromNumber(3);//TODO: remove

  var counter = 0;
  var g = null;

  while (g == null) {
    var P = Expression.ZERO;

    while (P.compareTo(M) < 0) {
      counter += 1;

      if (counter > 50 && p._pow(counter - 50).compareTo(M) >= 0) {
        throw new TypeError("!!!");
      }

      do {
        p = Expression.Integer.fromBigInt(nextPrime(p.toBigInt()));
      } while (d.remainder(p).equals(Expression.ZERO));

      var cp = Polynomial._gcdOfPolynomialsOverFiniteField(a, b, p);

      console.assert(cp.getLeadingCoefficient().equals(Expression.ONE));
      var gp = cp.scale(d.remainder(p)).mod(p); //TODO: should it do .mod(p) ? as the book does not tell this

      if (gp.getDegree() < 1) {
        return Polynomial.of(Expression.ONE);
      }

      if (gp.getDegree() > 2 / 3 * a.getDegree()) {// see Donald Knuth's book
        //TODO: ?
        //return gcdOfPrimitivePolynomials(a, b);
      }

      if (g == null || gp.getDegree() < g.getDegree()) {
        //TODO: why ?
        if (g != null) {//debugger;
        }

        g = gp.mod2(p);
        P = p;
        M = bound(a, b, d, gp.getDegree()); //!?
      } else if (gp.getDegree() === g.getDegree()) {
        //TODO: why ?
        var oldG = g;
        g = ChineseRemainderTheoremForPolynomialCoefficients(g, gp, P, p);
        P = P.multiply(p);
        g = g.mod2(P); //does not work (?), the number of iteration is small anyway (?)

        if (P.compareTo(M) < 0 && oldG.equals(g)) {
          // optimization from the book:
          // "Whenever g remains unchanged for a series of iterations through the while–loop, we might apply the test in step (5) and exit if the outcome is positive."
          g = g.primitivePart(); // TODO: scale a and b instead (?) for the test

          if (a.isDivisibleBy(g) && b.isDivisibleBy(g)) {
            //console.log('counter:', counter);
            return g;
          }

          g = oldG; //TODO: ???
        } else {//debugger;
          }
      } //console.debug(counter, g.primitivePart().toString(), P.toString());

    }

    g = g.primitivePart();

    if (!a.isDivisibleBy(g) || !b.isDivisibleBy(g)) {
      g = null;
    }
  } //console.debug('counter:', counter);


  return g;
}

Polynomial._gcdByModularAlgorithm = gcdByModularAlgorithm;
var nextId = 0;

function gcdByMultivariateModularAlgorithm(a, b) {
  var originalA = a;
  var originalB = b; // https://www3.risc.jku.at/education/courses/ws2011/ca/3-gcd.pdf
  //if (a._hasIntegerLikeCoefficients() && b._hasIntegerLikeCoefficients()) {
  //  throw new RangeError();
  //}
  //var y = new Expression.Symbol('y');//TODO: ???

  var x = new Expression.Symbol('$x_' + ++nextId); //TODO: !!!

  var y = getY(a) || getY(b);

  if (y == null) {
    return Polynomial.polynomialGCD(a, b);
  }

  var M = Math.min(a.getDegree(), b.getDegree()); //TODO: +1 like in the book - ?

  a = a.primitivePart();
  b = b.primitivePart();
  a = a.map(function (c) { return new Expression.Polynomial(Polynomial.toPolynomial(c, y)); });
  b = b.map(function (c) { return new Expression.Polynomial(Polynomial.toPolynomial(c, y)); });
  var aByY = a.calcAt(new Expression.Polynomial(Polynomial.of(x))).polynomial;
  var bByY = b.calcAt(new Expression.Polynomial(Polynomial.of(x))).polynomial;
  var degreeOfAByY = aByY.getDegree();
  var degreeOfBByY = bByY.getDegree();
  var lcOfAByY = Polynomial.toPolynomial(aByY.getLeadingCoefficient(), x);
  var lcOfBByY = Polynomial.toPolynomial(bByY.getLeadingCoefficient(), x);

  var toPolynomialByVar = function (p, y, x) {
    return p.map(function (c) { return new Expression.Polynomial(Polynomial.toPolynomial(c, y)); }).calcAt(new Expression.Polynomial(Polynomial.of(x))).polynomial;
  };

  var c = aByY.getContent().gcd(bByY.getContent());

  if (!c.equals(Expression.ONE)) {
    //TODO: optimize - ?
    c = Polynomial.toPolynomial(c, x).primitivePart();
    return gcdByMultivariateModularAlgorithm(originalA.divideAndRemainder(c, "throw").quotient, originalB.divideAndRemainder(c, "throw").quotient).multiply(c);
  }

  console.assert(c.toString() === '1', 'content', c.toString()); //TODO: ?

  var d = degreeOfAByY === 0 && degreeOfAByY === 0 ? Polynomial.of(Expression.ONE) : Polynomial.polynomialGCD(lcOfAByY, lcOfBByY);
  var r = Expression.ZERO;
  var g = null;

  do {
    if (r !== Expression.ZERO) {
      //throw new Error();//TODO: ?
      if (r.compareTo(Expression.TWO) > 0) {
        console.error("!");
      }
    }

    var m = 0;
    NewtonInterpolation.setField(Expression._FIELD);
    var polynomialInterpolation = NewtonInterpolation();
    polynomialInterpolation.next();

    while (m <= M) {
      var pa = null;
      var pb = null;

      do {
        r = Expression.Integer.fromNumber(r.toNumber() + 1);
        pa = a.calcAt(r).polynomial;
        pb = b.calcAt(r).polynomial;
      } while (pa.getDegree() !== degreeOfAByY || pb.getDegree() !== degreeOfBByY);

      var g_r = Polynomial.polynomialGCD(pa, pb);

      if (!(degreeOfAByY === 0 && degreeOfAByY === 0)) {
        //console.log(g_r.getLeadingCoefficient(), r);
        g_r = g_r.scale(d.calcAt(r)).scale(g_r.getLeadingCoefficient().inverse());
      }

      var oldG = g;
      g = Polynomial.from(polynomialInterpolation.next([r.toNumber(), g_r.calcAt(y)]).value); //console.log(y.symbol, g.toString(), r, g_r.calcAt(y).toString());

      if (g_r.getDegree() === 0) {
        return Polynomial.of(Expression.ONE); // as content by y is 1 (?)
      }

      if (g_r.getDegree() > Math.min(degreeOfAByY, degreeOfBByY) - 2) {//?
        //return Polynomial.polynomialGCD(originalA, originalB);
      }

      m += 1;

      if (m > 0) {
        if (oldG != null && oldG.equals(g)) {
          g = g.primitivePart();
          g = toPolynomialByVar(toPolynomialByVar(g, y, x).primitivePart(), x, y);
          g = g.primitivePart(); //???

          if (a.map(function (c) { return c.polynomial.calcAt(y); }).isDivisibleBy(g) && b.map(function (c) { return c.polynomial.calcAt(y); }).isDivisibleBy(g)) {
            //g = g.primitivePart();
            //TODO: should we just return g - ?
            //return g.multiply(gcdByMultivariateModularAlgorithm(a.map(function (c) { return c.polynomial.calcAt(y); }).divideAndRemainder(g, "throw").quotient,
            //                                                    b.map(function (c) { return c.polynomial.calcAt(y); }).divideAndRemainder(g, "throw").quotient));
            return g;
          }

          g = oldG;
        }
      }
    } //console.log(g.toString());


    g = g.primitivePart();
    g = toPolynomialByVar(toPolynomialByVar(g, y, x).primitivePart(), x, y); //console.log(g.toString());

    g = g.primitivePart(); //?
  } while (!a.map(function (c) { return c.polynomial.calcAt(y); }).isDivisibleBy(g) || !b.map(function (c) { return c.polynomial.calcAt(y); }).isDivisibleBy(g)); //if (g._hasIntegerLikeCoefficients()) {


  return g; //} else {
  //  throw new RangeError();
  //}
  //throw new RangeError();
  //return g;
}

;
Polynomial._gcdByMultivariateModularAlgorithm = gcdByMultivariateModularAlgorithm;

Polynomial.prototype.calcAt = function (point) {
  //!!!
  if (point instanceof Expression.Division && point.getNumerator() instanceof Expression.Integer && point.getDenominator() instanceof Expression.Integer && this.hasIntegerCoefficients()) {
    var n = this.getDegree();

    var p = this._scaleRoots(point.getDenominator());

    return p.calcAt(point.getNumerator()).divide(point.getDenominator()._pow(n));
  }

  var n = Expression.ZERO;
  var lastDegree = -1;

  for (var i = 0; i < this.a.size; i += 1) {
    var degree = this.a.degree(i);
    var coefficient = this.a.coefficient(i);

    if (!n.equals(Expression.ZERO)) {
      n = Expression.pow(point, lastDegree - degree).multiply(n).add(coefficient);
    } else {
      n = coefficient;
    }

    lastDegree = degree;
  }

  if (!n.equals(Expression.ZERO)) {
    n = Expression.pow(point, lastDegree - 0).multiply(n);
  }

  return n;
};

Polynomial.prototype.getContent = function () {
  if (this.a.size === 0) {
    return Expression.ONE;
  }

  var denominator = Expression.ONE;
  var numerator = Expression.ZERO;

  for (var i = 0; i < this.a.size; i += 1) {
    var y = this.a.coefficient(i);
    denominator = denominator.lcm(y.getDenominator());
    numerator = numerator.gcd(y.getNumerator());
  }

  var c = numerator.divide(denominator);
  var x = this.a.coefficient(0);
  return x.isNegative() && !numerator.isNegative() || numerator.isNegative() && !x.isNegative() ? c.negate() : c;
}; // add, multiply, divideAndRemainder


Polynomial.prototype.negate = function () {
  //TODO: fix
  return this.map(function (coefficient) { return coefficient.negate(); });
};

Polynomial.prototype.subtract = function (l) {
  return this.add(l.negate());
};

Polynomial.prototype.scale = function (x) {
  if (x.equals(Expression.ONE)) {
    return this;
  }

  if (Expression.has(x, Expression.Matrix) || Expression.has(x, Expression.MatrixSymbol)) {
    throw new TypeError();
  }

  return this.map(function (coefficient) { return coefficient.multiply(x); });
};

Polynomial.fromTerms = function (terms) {
  var newData = new PolynomialData(terms.length);

  for (var i = 0; i < terms.length; i += 1) {
    var term = terms[i];
    newData.add(term.degree, term.coefficient);
  }

  return new Polynomial(newData);
};

Polynomial.toPolynomial = function (e, v) {
  if (e instanceof Expression.Division) {
    throw new RangeError();
  }

  var terms = Expression.getCoefficients(e, v);
  return Polynomial.fromTerms(terms);
};

Polynomial.prototype.toExpression = function (variableSymbol) {
  var result = undefined;

  for (var i = 0; i < this.a.size; i += 1) {
    var degree = this.a.degree(i);
    var coefficient = this.a.coefficient(i);
    var v = degree === 0 ? undefined : degree === 1 ? variableSymbol : new Expression.Exponentiation(variableSymbol, Expression.Integer.fromNumber(degree));
    var current = v == undefined ? coefficient : coefficient.equals(Expression.ONE) ? v : new Expression.Multiplication(coefficient, v);
    result = result == undefined ? current : new Expression.Addition(result, current);
  }

  return result == undefined ? Expression.ZERO : result;
}; // return a first founded root to simplify and as the next call may be called with reduced coefficients


Polynomial.prototype.doRationalRootTest = function () {
  var np = this;

  if (np.getCoefficient(0).equals(Expression.ZERO)) {
    return Expression.ZERO; //!TODO: test
  }

  var an = np.getLeadingCoefficient();
  var a0 = np.getCoefficient(0);
  a0 = Expression._expandTrigonometry(a0); //!

  if (np.getDegree() === 1) {
    return a0.negate().divide(an);
  } //TODO: http://en.wikipedia.org/wiki/Polynomial_remainder_theorem
  // http://scask.ru/g_book_mav.php?id=26


  var hasIntegerCoefficients = np.hasIntegerCoefficients(); // f(k) = q(k)(k - a)

  var fp1 = null;
  var fm1 = null;

  if (hasIntegerCoefficients) {
    fp1 = np.calcAt(Expression.ONE);

    if (fp1.equals(Expression.ZERO)) {
      return Expression.ONE;
    }

    fm1 = np.calcAt(Expression.ONE.negate());

    if (fm1.equals(Expression.ZERO)) {
      return Expression.ONE.negate();
    }
  }

  var filter = function (n, d) {
    if (fp1 != null) {
      if (d.subtract(n).equals(Expression.ZERO)) {
        return false;
      }

      if (!fp1.remainder(d.subtract(n)).equals(Expression.ZERO)) {
        return false;
      }
    }

    if (fm1 != null) {
      if (d.add(n).equals(Expression.ZERO)) {
        return false;
      }

      if (!fm1.remainder(d.add(n)).equals(Expression.ZERO)) {
        return false;
      }
    }

    return true;
  }; //!new 2020-01-13


  if (hasIntegerCoefficients) {
    //var tmp = np.squareFreeFactors();
    //if (tmp.a0.getDegree() > 0) {
    //  return tmp.a0.doRationalRootTest() || tmp.a1.doRationalRootTest();
    //}
    var toInteger = function (zero, scale) {
      //TODO: ?
      var fraction = zero instanceof Expression.ExpressionPolynomialRoot ? zero.root._root.toDecimal(0).a : zero.toDecimal().a;
      return scale.multiply(fraction.getNumerator()).add(fraction.getDenominator().truncatingDivide(Expression.TWO)).truncatingDivide(fraction.getDenominator());
    };

    var zeros = np.getZeros(an.abs().bitLength()); // note: for fractionDigits (!)

    for (var i = 0; i < zeros.length; i += 1) {
      var zero = zeros[i];

      if (i === 0 || zero !== zeros[i - 1]) {
        var candidate = zero.root != null ? toInteger(zero, an).divide(an) : zero.getNumerator() instanceof Expression.Integer && zero.getDenominator() instanceof Expression.Integer ? zero : Expression.ZERO;

        if (filter(candidate.getNumerator(), candidate.getDenominator()) && np.calcAt(candidate).equals(Expression.ZERO)) {
          return candidate;
        }
      }
    }

    return null;
  }
  /*
  TODO:
  k = k
  f(k) = fk
  t = x + k
  x = t - k
  f(t) = f(x + k) = an * x**n + ... + f(k)
  */


  var result = null; // p/q
  //TODO: forEach -> some ?

  Expression.everyDivisor(a0, function (p) {
    return Expression.everyDivisor(an, function (q) {
      var sign = -3;

      while ((sign += 2) < 3) {
        var sp = sign === -1 ? p.negate() : p;

        if ( //sp.gcd(q).equals(Expression.ONE) &&
        filter(sp, q)) {
          //?
          var x = Polynomial.of(sp.negate(), q);
          var z = np.divideAndRemainder(x, "undefined");
          var r = z == undefined ? undefined : z.remainder.map(function (x) {
            return x.simplifyExpression();
          });

          if (r != undefined && r.equals(Polynomial.ZERO)) {
            result = sp.divide(q);
            return false;
          }
        }
      }

      return true;
    });
  });
  return result;
};

Polynomial.prototype._testCoefficients = function (f) {
  for (var i = 0; i < this.a.size; i += 1) {
    if (!f(this.a.coefficient(i))) {
      return false;
    }
  }

  return true;
};

Polynomial.prototype.hasIntegerCoefficients = function () {
  return this._testCoefficients(function (c) { return c instanceof Expression.Integer; });
};

Polynomial.prototype.hasComplexCoefficients = function () {
  return this._testCoefficients(function (c) { return c instanceof Expression.Complex || c instanceof Expression.Integer; });
};

var isIntegerLike = function (c) {
  if (c instanceof Expression.Integer) {
    return true;
  }

  if (c instanceof Expression.Symbol) {
    if (c instanceof Expression.ExpressionWithPolynomialRoot) {
      //TODO: ?
      return false;
    }

    if (c instanceof Expression.ExpressionPolynomialRoot) {
      //TODO: ?
      return false;
    }

    if (c instanceof Expression.PolynomialRootSymbol) {
      //TODO: remove
      return true;
    }

    return true;
  }

  if (c instanceof Expression.Addition) {
    return isIntegerLike(c.a) && isIntegerLike(c.b);
  }

  if (c instanceof Expression.Multiplication) {
    return isIntegerLike(c.a) && isIntegerLike(c.b);
  }

  if (c instanceof Expression.Exponentiation) {
    return isIntegerLike(c.a) && c.b instanceof Expression.Integer && c.b.compareTo(Expression.TWO) >= 0;
  }

  return false;
}; //Expression._isIntegerLike = isIntegerLike;


Polynomial._isIntegerLike = isIntegerLike;

Polynomial.prototype._hasIntegerLikeCoefficients = function () {
  return this._testCoefficients(function (c) { return Polynomial._isIntegerLike(c); });
};

Polynomial.prototype._canBeFactored = function (depth) {
  // https://en.wikipedia.org/wiki/Eisenstein%27s_criterion
  if (!this.hasIntegerCoefficients()) {
    //throw new Error();
    return true;
  }

  if (this.getCoefficient(0).equals(Expression.ZERO)) {
    return true;
  }

  var content = this.getContent();

  if (!content.equals(Expression.ONE) && !content.equals(Expression.ONE.negate())) {
    return this.scale(content.inverse())._canBeFactored();
  } // p divides each a_i for 0 ≤ i < n


  var g = this.subtract(Polynomial.of(this.getLeadingCoefficient()).shift(this.getDegree())).getContent(); // p does not divide a_n

  var x = null;

  do {
    x = g.gcd(this.getLeadingCoefficient());
    g = g.truncatingDivide(x);
  } while (!x.equals(Expression.ONE));

  var x = null;
  g = g.abs(); //?

  while (!g.equals(Expression.ONE)) {
    var p = g.primeFactor(); // p**2 does not divide a_0

    if (!this.getCoefficient(0).remainder(p._pow(2)).equals(Expression.ZERO)) {
      return false;
    }

    g = g.truncatingDivide(p);
  }

  if (depth == undefined) {
    // see https://en.wikipedia.org/wiki/Eisenstein%27s_criterion#Indirect_(after_transformation)
    //TODO: ?
    if (!this._translateRoots(Expression.Integer.fromNumber(3).negate())._canBeFactored(1)) {
      return false;
    } //TODO: (too slow)
    //if (!this._exponentiateRoots(-1)._canBeFactored(1)) {
    //  return false;
    //}

  }

  return true;
};

Polynomial.prototype.isEven = function () {
  return this.getGCDOfTermDegrees() % 2 === 0;
};

Polynomial.prototype._factorByKroneckersMethod = function () {
  // https://ru.wikipedia.org/wiki/Метод_Кронекера
  // https://ru.wikipedia.org/wiki/Интерполяционный_многочлен_Лагранжа
  // https://en.wikipedia.org/wiki/Vandermonde_matrix
  var np = this;

  if (np.getDegree() < 2) {
    return undefined;
  }

  if (!np._hasIntegerLikeCoefficients()) {
    return undefined;
  }

  var n = np.getDegree();
  var ys = new Array(n);
  var total = 1;

  var x = function (i) {
    if (np.isEven()) {
      return Expression.Integer.fromNumber(i % 2 === 0 ? 0 - i / 2 : (i + 1) / 2);
    }

    return Expression.Integer.fromNumber(i);
  };

  var findSomeSmallIntegerPoints = function (polynomial, count) {
    var candidates = [];

    for (var j = 0; j < count * 2; j += 1) {
      var i = x(j);
      candidates.push({
        i: i,
        y: np.calcAt(i)
      });
    }

    if (polynomial.hasIntegerCoefficients()) {
      var d = function (n) {
        var count = 0;

        if (n.abs().toNumber() > 3317044064679887385961981) {
          return 1 / 0;
        }

        Expression.everyDivisor(n.abs(), function (d) {
          count += 1;
          return true;
        });
        return count;
      }; //var zeros = polynomial.multiply(polynomial).derive().getZeros();


      var zeros = polynomial.getZeros().concat(polynomial.derive().getZeros());

      for (var iteratorzero = zeros[globalThis.Symbol.iterator](), zero = iteratorzero.next().value; zero != null; zero = iteratorzero.next().value) {
        var i = Expression.Integer.fromString(toDecimalStringInternal(zero.root != null ? zero.root : zero, {
          fractionDigits: 0
        })); //TODO: siblings

        for (var v = -n; v <= n; v += 1) {
          var y = np.calcAt(i.add(Expression.Integer.fromNumber(v)));
          candidates.push({
            i: i.add(Expression.Integer.fromNumber(v)),
            y: y
          });
        }
      }

      candidates.sort(function (a, b) { return a.i.compareTo(b.i); }); // remove duplicates:

      var unique = [];

      for (var i = 0; i < candidates.length; i += 1) {
        if (unique.length === 0 || !candidates[i].i.equals(unique[unique.length - 1].i)) {
          unique.push(candidates[i]);
        }
      }

      candidates = unique; //candidates.sort(function (a, b) { return a.y._pow(2).compareTo(b.y._pow(2)); });

      candidates = candidates.map(function (c) {
        return {
          i: c.i,
          ni: c.i.toNumber(),
          y: c.y.toNumber(),
          d: d(c.y)
        };
      });
      candidates.sort(function (a, b) { return a.d - b.d || Math.abs(a.y) - Math.abs(b.y); });
    }

    return candidates.map(function (c) { return c.i; });
  };

  var integerPoints = findSomeSmallIntegerPoints(np, Math.floor(n / 2) + 1);

  for (var i = 0; i <= Math.floor(n / 2); i += 1) {
    var bi = integerPoints[i];
    var y = np.calcAt(bi);

    if (y.equals(Expression.ZERO)) {
      return Polynomial.of(bi.negate(), Expression.ONE);
    }

    var attachNegative = function (array) {
      var result = new Array(array.length * 2);

      for (var i = 0; i < array.length; i += 1) {
        result[i * 2] = array[i];
        result[i * 2 + 1] = array[i].negate();
      }

      return result;
    };

    if (Expression.isConstant(y) && y.abs() instanceof Expression.Integer && y.abs().toNumber() > Math.pow(2, 106)) {
      //!
      throw new Error("TOO SLOW");
    }

    var divisors = [];
    Expression.everyDivisor(y, function (d) {
      divisors.push(d);
      return true;
    }); // var the first be positive as two sets with different signs give polynomials that differ only in sign of coefficients

    ys[i] = i === 0 ? divisors : attachNegative(divisors);
    total *= ys[i].length;
    var V = Matrix.Zero(i + 1, i + 1).map(function (e, i, j) {
      return integerPoints[i]._pow(j);
    });
    var inv = V.inverse(); //scale?

    inv = inv.scale(V.determinant()); //?

    var u = new Array(i + 1);

    for (var j = 0; j < i + 1; j += 1) {
      u[j] = 0;
    }

    u[0] = -1;

    for (var j = 0; j < total; j += 1) {
      if (j > 1e5) throw new Error("TOO SLOW");
      var k = 0;
      u[k] += 1;

      while (u[k] === ys[k].length) {
        u[k] = 0;
        k += 1;
        u[k] += 1;
      }

      var y = Matrix.Zero(i + 1, 1).map(function (e, i, j) {
        return ys[i][u[i]];
      });
      var s = inv.multiply(y);

      var polynomialFromVector = function (s) {
        var c = new Array(s.rows());

        for (var j = 0; j < s.rows(); j += 1) {
          c[j] = s.e(j, 0);
        }

        return Polynomial.from(c);
      };

      var g = polynomialFromVector(s); //if (g.getDegree() > 0 && np.divideAndRemainder(g).remainder.equals(Polynomial.ZERO)) {
      //  return g;
      //}

      if (g.getDegree() > 0) {
        var gc = g.getContent();

        if (!gc.equals(Expression.ONE) && !gc.equals(Expression.ONE.negate())) {
          //?
          g = g.primitivePart();

          if (np.isDivisibleBy(g)) {
            return g;
          }
        }
      }
    }
  }

  return undefined;
};

var counter = 0; //TODO: remove

Polynomial.prototype.getGCDOfTermDegrees = function () {
  if (this.equals(Polynomial.ZERO)) {
    return 0;
  }

  var g = this.getDegree();

  for (var i = 1; i <= this.getDegree() && g >= 2; i += 1) {
    if (!this.getCoefficient(i).equals(Expression.ZERO)) {
      g = Math.gcd(g, i);
    }
  }

  return g;
};

Polynomial.prototype.getroots = function (callback) {
  //TODO: merge hit and callback
  callback = callback || undefined;
  var np = this;
  var roots = []; //!new 2018-12-24
  //TODO: fix (?Polynomial#getContent()?)

  var ct = Expression.ONE;
  var t = Expression.ZERO;

  while (t != null) {
    var t = Expression.getConjugate(np.getLeadingCoefficient());

    if (t != undefined) {
      np = np.scale(t);
      ct = ct.multiply(t);
    }
  } //!
  //!new 2020-07-11


  np = np.map(function (x) {
    return x.simplifyExpression();
  }); //!

  var content = np.getContent();

  if (!content.equals(Expression.ONE)) {
    np = np.scale(content.getDenominator()).divideAndRemainder(Polynomial.of(content.getNumerator()), "throw").quotient; //np = np.divideAndRemainder(Polynomial.of(content), "throw").quotient;
  }

  if (!ct.equals(Expression.ONE)) {
    content = content.divide(ct);
  } // x = 0


  while (np.getCoefficient(0).equals(Expression.ZERO)) {
    np = np.divideAndRemainder(Polynomial.of(Expression.ZERO, Expression.ONE), "throw").quotient;
    roots.push(Expression.ZERO);
  }

  if (!content.equals(Expression.ONE) && !content.equals(Expression.ONE.negate()) || roots.length > 0) {
    if (roots.length > 0) {
      if (typeof hit === "function") {
        hit({
          getroots: {
            special: "0"
          }
        });
      }
    }

    if (callback != undefined) {
      callback({
        content: content,
        roots: roots,
        newPolynomial: np,
        type: "factorOutTheGreatestCommonFactor"
      });
    }
  }

  if (np.getDegree() === 1) {
    roots.push(np.getCoefficient(0).negate().divide(np.getCoefficient(1)));
    np = Polynomial.of(np.getLeadingCoefficient());

    if (typeof hit === "function") {
      hit({
        getroots: {
          linear: ""
        }
      });
    }

    if (callback != undefined) {
      callback({
        content: content,
        roots: roots,
        newPolynomial: np,
        type: "solveLinearEquation"
      });
    }

    return roots;
  }

  var nthRootInternal = function (n, x) {
    if (x instanceof Expression.ExpressionWithPolynomialRoot) {
      //TODO: !?
      return undefined; //?
      //return x._nthRoot(n);
    }

    if (x instanceof Expression.ExpressionPolynomialRoot) {
      //return undefined;//?
      return x._nthRoot(n);
    }

    if (x instanceof Expression.Division) {
      var sa1 = nthRootInternal(n, x.a);
      var sb1 = nthRootInternal(n, x.b);
      return sa1 == undefined || sb1 == undefined ? undefined : sa1.divide(sb1);
    }

    if (x instanceof Expression.Exponentiation) {
      var N = Expression.Integer.fromNumber(n);

      if (x.b instanceof Expression.Integer) {
        if (x.b.remainder(N).equals(Expression.ZERO)) {
          return x.a.pow(x.b.divide(N));
        } //return undefined;

      }

      if (x.a instanceof Expression.Integer || x.a === Expression.E) {
        //?
        return x.a.pow(x.b.divide(N));
      }

      if (x.b instanceof Expression.Division && x.b.a instanceof Expression.Integer && x.b.a.remainder(N).equals(Expression.ZERO)) {
        //TODO:
        return x.a.pow(x.b.divide(N));
      }
    }

    if (x instanceof Expression.Multiplication) {
      var sa = nthRootInternal(n, x.a);
      var sb = nthRootInternal(n, x.b);
      return sa == undefined || sb == undefined ? undefined : sa.multiply(sb);
    }

    if (x instanceof Expression.Complex || Expression.isConstant(x) && Expression.has(x, Expression.Complex)) {
      //TODO: - ?
      //var real = x.real;
      //var imaginary = x.imaginary;
      var c = Expression.getComplexConjugate(x);
      var real = x.add(c).divide(Expression.TWO);
      var imaginary = x.subtract(c).multiply(Expression.I.negate()).divide(Expression.TWO);

      if (n === 2) {
        var m = real.multiply(real).add(imaginary.multiply(imaginary)).squareRoot();
        var a = nthRootInternal(2, real.add(m).divide(Expression.TWO));

        if (a != undefined) {
          var b = imaginary.divide(Expression.TWO.multiply(a));
          var result = a.add(b.multiply(Expression.I));
          return result;
        }
      }

      if (real.equals(Expression.ZERO) && n % 2 === 0) {
        var c = nthRootInternal(Math.floor(n / 2), x);

        if (c != undefined) {
          return nthRootInternal(2, c);
        }
      }

      if (real.equals(Expression.ZERO) && n % 2 === 1) {
        //?
        var c = nthRootInternal(n, imaginary);

        if (c != undefined) {
          return c.multiply(n % 4 === 1 ? Expression.I : Expression.I.negate());
        }
      } //!new 2020-07-24


      if (x instanceof Expression.Complex && !imaginary.equals(Expression.ZERO)) {
        //?TODO: ?
        // https://en.wikipedia.org/wiki/Complex_number#Modulus_and_argument
        var rho = real._pow(2).add(imaginary._pow(2)).squareRoot();

        try {
          var phi = Expression.TWO.multiply(imaginary.divide(rho.add(real)).arctan());
          return rho._nthRoot(n).multiply(Expression.I.multiply(phi.divide(Expression.Integer.fromNumber(n))).exp());
        } catch (error) {
          //TODO: ?
          console.debug(error);
        }
      }
    }

    if (x instanceof Expression.Addition) {
      var lastFactor = undefined;
      var e = 0;
      var result = Expression.ONE;
      var rest = Expression.ONE;
      var t = x;

      while (!t.equals(Expression.ONE) && !t.equals(Expression.ONE.negate())) {
        var f = Expression.simpleDivisor(t);

        if (e === 0) {
          lastFactor = f;
          e += 1;
        } else if (f.equals(lastFactor)) {
          e += 1;

          if (e === n) {
            e = 0;
            result = result.multiply(lastFactor);
          }
        } else if (e !== 0) {
          rest = rest.multiply(Expression.pow(lastFactor, e));
          lastFactor = f;
          e = 1;
        }

        t = t.divide(f);
      }

      if (result !== Expression.ONE) {
        if (e !== 0) {
          rest = rest.multiply(Expression.pow(lastFactor, e));
        }

        if (t.equals(Expression.ONE.negate())) {
          rest = rest.multiply(t);
        }

        var rn = nthRootInternal(n, rest);

        if (rn != undefined) {
          return result.multiply(rn);
        }
      }
    }

    if (x instanceof Expression.Exponentiation && x.a instanceof Expression.Symbol) {
      var b = x.b.divide(Expression.Integer.fromNumber(n));
      return b.equals(Expression.ONE) ? x.a : new Expression.Exponentiation(x.a, b);
    }

    if (!Expression.isConstant(x) && x.isNegative() && (n === 2 || n % 2 !== 0)) {
      x = x.negate();
      var c = nthRootInternal(n, x);
      return c == null ? null : Expression.ONE.negate()._nthRoot(n).multiply(c);
    }

    if ((x instanceof Expression.Integer || x instanceof Expression.Complex) && x.isNegative() && n % 2 === 0) {
      //?
      var c = x instanceof Expression.Integer ? x._nthRoot(2) : nthRootInternal(2, x);
      return c == null ? null : nthRootInternal(n / 2, c);
    }

    if (Expression.has(x, Expression.Sin) || Expression.has(x, Expression.Cos)) {
      //?
      var tmp = nthRootInternal(2, Expression._replaceSinCos(x));

      if (tmp != null) {
        return Expression._replaceBySinCos(tmp).simplifyExpression(); //?
      }
    }

    var y = undefined;

    try {
      y = x._nthRoot(n);
    } catch (error) {
      //TODO:
      console.error(error);
    }

    if (y == undefined) {
      //?
      var a = x; //TODO: different cases (1+sqrt(2)+sqrt(3)) - (?)

      var ac = Expression.getConjugateExpression(a.getNumerator());

      if ((n === 3 || n === 2) && ac instanceof Expression.Integer) {
        //TODO: ?
        if (n === 2 && Expression._isPositive(x.negate())) {
          return Expression.I.multiply(nthRootInternal(2, x.negate()));
        } //TODO: a > 0 - ?


        var a = x;

        var tmp = new Expression.Symbol('x')._pow(n).subtract(a).getNumerator();

        var polynomial = Polynomial.toPolynomial(Expression.getConjugateExpression(tmp), new Expression.Symbol('x'));
        var tmp2 = polynomial.getZeros(); //TODO: ?

        for (var iteratorzero = tmp2[globalThis.Symbol.iterator](), zero = iteratorzero.next().value; zero != null; zero = iteratorzero.next().value) {
          if (zero._pow(n).equals(x)) {
            return zero;
          }
        } //TODO: fix


        return null;
      }
    }

    return y;
  };

  var nthRoot = function (n, x, np) {
    if (n === 1) {
      return x;
    }

    var y = nthRootInternal(n, x);

    if (y == undefined) {
      if (!(x instanceof Expression.Integer)) {
        if (typeof hit === "function") {
          hit({
            nthRoot: (n === 2 ? "squareRoot" : n === 3 ? "cubeRoot" : n + "-root") + ":" + x.toString() + ":" + np.toString()
          });
        }
      }
    }

    return y;
  };

  var continueWithNewPolynomial = function (roots, np, newPolynomialVariable) {
    var rs = np.getroots(callback != undefined ? function (info) {
      var xxx = Object.assign({}, info, {
        content: content.multiply(info.content),
        roots: roots.concat(info.roots),
        newPolynomialVariable: newPolynomialVariable
      });
      callback(xxx);
    } : undefined);

    for (var i = 0; i < rs.length; i += 1) {
      roots.push(rs[i]);
    }
  };

  if (np.getDegree() >= 2) {
    var g = np.getGCDOfTermDegrees();

    if (g >= 2) {
      var allZeros = g === np.getDegree();

      if (typeof hit === "function") {
        if (g === np.getDegree()) {
          hit({
            getroots: {
              allZeros: ""
            }
          });
        } else {
          hit({
            getroots: g % 2 === 0 ? np.getDegree() === 4 ? {
              biquadratic: ""
            } : {
              even: ""
            } : {
              xyz: np.toString()
            }
          });
        }
      } // t = x^g


      var newData = new Array(Math.floor((np.getDegree() + g) / g));
      var k = 0;

      for (var i = 0; i <= np.getDegree(); i += g) {
        newData[k] = np.getCoefficient(i);
        k += 1;
      }

      var q = Polynomial.from(newData);
      var qRoots = [];

      if (!allZeros) {
        if (callback != undefined) {
          callback({
            content: content,
            roots: roots,
            newPolynomial: q,
            type: "t = x^g",
            g: g,
            newPolynomialVariable: new Expression.Symbol('t')
          }); //TODO: ?
        }

        continueWithNewPolynomial(qRoots, q, new Expression.Symbol('t'));
      } else {
        qRoots = q.getroots();
      }

      var n = np.getDegree(); //TODO: 2018-02-04
      //var ok = false;//?

      for (var k = 0; k < qRoots.length; k += 1) {
        var qRoot = qRoots[k];
        var s = nthRoot(g, qRoot, np);

        if (s != undefined) {
          var d = null;

          if ((!allZeros || g >= 5 || !np.hasIntegerCoefficients()) && (g <= 24 && (17896830 >> g) % 2 === 1 || g === 48)) {
            d = Polynomial.of(Expression.ONE).shift(g).add(Polynomial.of(qRoot.negate())); // https://en.wikipedia.org/wiki/Root_of_unity

            var c = Expression.E.pow(Expression.I.multiply(Expression.TWO.multiply(Expression.PI)).divide(Expression.Integer.fromNumber(g)));

            for (var i = 0; i < g; i += 1) {
              var root = Expression.pow(c, i).multiply(s);
              roots.push(root);
            }
          } else {
            roots.push(s);
            d = Polynomial.of(s.negate(), Expression.ONE);

            if (g % 2 === 0) {
              roots.push(s.negate());
              d = Polynomial.of(s.multiply(s).negate(), Expression.ZERO, Expression.ONE);
            }
          }

          var quotient = np.divideAndRemainder(d).quotient;
          console.assert(np.subtract(quotient.multiply(d)).map(function (c) { return c.simplifyExpression(); }).getDegree() < 0);
          np = quotient;
        } //ok = ok || Expression.has(qRoot, Expression.Complex);//?

      }

      if (!allZeros) {
        if (callback != undefined) {
          callback({
            content: content,
            roots: roots,
            newPolynomial: np,
            type: "x = t^(1/g)",
            g: g
          }); //TODO: ?
        }
      } else {
        var type = g === 2 ? "applyDifferenceOfSquaresRule" : g === 3 ? "applyDifferenceOfCubesRule" : "applyDifferenceOfNthPowersRule";

        if (callback != undefined) {
          callback({
            content: content,
            roots: roots,
            newPolynomial: np,
            type: type,
            g: g
          }); //TODO: ?
        }
      }

      var ok = true;

      if (n !== np.getDegree() && ok && np.getDegree() > 0) {
        continueWithNewPolynomial(roots, np);
      }

      return roots;
    }
  } //! new: solution of quadratic equations


  if (np.getDegree() === 2) {
    var a = np.getCoefficient(2);
    var b = np.getCoefficient(1);
    var c = np.getCoefficient(0);
    var D = b.multiply(b).subtract(Expression.TWO.multiply(Expression.TWO).multiply(a).multiply(c));
    D = D.simplifyExpression();
    var sD = nthRoot(2, D, np);

    if (typeof hit === "function") {
      hit({
        getroots: {
          quadratic: sD == undefined ? D instanceof Expression.Integer ? D.compareTo(Expression.ZERO) : "?" + D.toString() : "OK"
        }
      });
    }

    if (sD != undefined) {
      if (sD.equals(Expression.ZERO)) {
        var x12 = b.negate().divide(Expression.TWO.multiply(a));
        roots.push(x12);
        roots.push(x12); //TODO: different details (?)
      } else {
        var x1 = b.negate().subtract(sD).divide(Expression.TWO.multiply(a));
        var x2 = b.negate().add(sD).divide(Expression.TWO.multiply(a));
        roots.push(x1);
        roots.push(x2);
      }

      np = Polynomial.of(np.getLeadingCoefficient());

      if (callback != undefined) {
        callback({
          content: content,
          roots: roots,
          newPolynomial: np,
          type: "solveQuadraticEquation"
        });
      }

      return roots;
    }
  } //TODO: odd degrees ?


  if (np.getDegree() >= 4 && np.getDegree() % 2 === 0) {
    var middle = Math.floor(np.getDegree() / 2);
    var j = 1;

    while (j < middle + 1 && np.getCoefficient(middle + j).equals(Expression.ZERO) && np.getCoefficient(middle - j).equals(Expression.ZERO)) {
      j += 1;
    }

    if (j < middle + 1 && !np.getCoefficient(middle + j).equals(Expression.ZERO) && !np.getCoefficient(middle - j).equals(Expression.ZERO)) {
      var jj = Expression.Integer.fromNumber(j);
      var mj = np.getCoefficient(middle + j).divide(np.getCoefficient(middle - j));
      var isQuasiPalindromic = true;

      for (var i = 2; i < middle + 1 && isQuasiPalindromic; i += 1) {
        isQuasiPalindromic = isQuasiPalindromic && np.getCoefficient(middle + i).pow(jj).subtract(np.getCoefficient(middle - i).pow(jj).multiply(mj.pow(Expression.Integer.fromNumber(i)))).equals(Expression.ZERO);
      }

      if (isQuasiPalindromic) {
        //TODO: fix
        if (typeof hit === "function") {
          hit({
            getroots: {
              quasiPalindromic: np.getDegree()
            }
          });
        }
      }

      if (isQuasiPalindromic && np.getDegree() <= Math.log2(Number.MAX_SAFE_INTEGER + 1)) {
        var substitute = function (m, np) {
          // t = mx + 1 / x
          // https://stackoverflow.com/a/15302448/839199
          var choose = function (n, k) {
            return k === 0 ? 1 : Math.floor(n * choose(n - 1, k - 1) / k);
          };

          var p = function (n, i, mpi) {
            return n - 2 * i >= 0 ? p(n - 2 * i, 1, m).scale(Expression.Integer.fromNumber(choose(n, i)).multiply(mpi).negate()).add(p(n, i + 1, mpi.multiply(m))) : Polynomial.of(Expression.ONE).shift(n);
          };

          var f = function (n, i) {
            return i <= n ? p(n - i, 1, m).scale(np.getCoefficient(i)).add(f(n, i + 1)) : Polynomial.ZERO;
          };

          return f(Math.floor(np.getDegree() / 2), 0);
        };

        var m = j === 1 ? mj : nthRoot(j, mj, np); // TODO: check the result of nthRoot - ?
        // t = mx + 1 / x

        var pt = substitute(m, np); //var pt = Polynomial.of(np.getCoefficient(2).subtract(Expression.ONE.add(Expression.ONE).multiply(m).multiply(np.getCoefficient(0))), np.getCoefficient(1), np.getCoefficient(0));

        var ptRoots = pt.getroots();

        for (var i = 0; i < ptRoots.length; i += 1) {
          var ptRoot = ptRoots[i]; // mx^2 - tx + 1 = 0

          var u = Polynomial.of(Expression.ONE, ptRoot.negate(), m);
          var uRoots = u.getroots();

          for (var j = 0; j < uRoots.length; j += 1) {
            var root = uRoots[j]; //np = np.divideAndRemainder(Polynomial.of(root.negate(), Expression.ONE)).quotient;//TODO: optimize

            roots.push(root);
          }

          np = np.divideAndRemainder(u.scale(u.getLeadingCoefficient().inverse())).quotient; //TODO: multiply by "newU"
        }

        if (callback != undefined) {
          callback({
            content: content,
            roots: roots,
            newPolynomial: np,
            type: "solvePalindromicEquaion"
          });
        }

        return roots;
      }
    }
  }

  if (np.getDegree() >= 2) {
    //?
    // (ax+b)**n = a**n*x**n + n*a**(n-1)*x**(n-1)*b + ...
    //?
    // a**n
    // n*a**(n-1)*b
    var n = np.getDegree();

    var hasZeroCoefficient = function (np) {
      for (var i = 0; i <= np.getDegree(); i += 1) {
        if (np.getCoefficient(i).equals(Expression.ZERO)) {
          return true;
        }
      }

      return false;
    };

    if (!hasZeroCoefficient(np)) {
      var g = np.getCoefficient(n - 1).divide(np.getCoefficient(n)).divide(Expression.Integer.fromNumber(n));
      var ok = true;

      for (var k = np.getDegree() - 1; k >= 1 && ok; k -= 1) {
        ok = g.equals(np.getCoefficient(k - 1).divide(np.getCoefficient(k)).multiply(Expression.Integer.fromNumber(n - k + 1)).divide(Expression.Integer.fromNumber(k)));
      }

      if (ok) {
        var root = g.negate();

        for (var k = 0; k < n; k += 1) {
          roots.push(root);
        }

        np = Polynomial.of(np.getLeadingCoefficient());

        if (callback != undefined) {
          callback({
            content: content,
            roots: roots,
            newPolynomial: np,
            type: "(ax+b)**n"
          }); //TODO:
        }

        return roots;
      }
    }
  }

  if (np.getDegree() >= 2) {
    var root = np.doRationalRootTest();

    if (root != null) {
      //np = np.divideAndRemainder(Polynomial.of(root.getNumerator().negate(), root.getDenominator())).quotient;
      np = np.divideAndRemainder(Polynomial.of(root.negate(), Expression.ONE)).quotient;
      roots.push(root);

      if (typeof hit === "function") {
        hit({
          getroots: {
            rational: ""
          }
        });
      }

      if (callback != undefined) {
        callback({
          content: content,
          roots: roots,
          newPolynomial: np,
          type: "useTheRationalRootTest"
        });
      }

      if (np.getDegree() > 0) {
        continueWithNewPolynomial(roots, np);
      }

      return roots;
    }
  } //TODO: depressed for all degrees (?) in Polynomial#getZeros() - ?


  if (!np.hasIntegerCoefficients() && np.getDegree() === 3) {
    //?
    // convert to depressed (?)
    // x = t - b / (n * a)
    var h = np._getShiftToDepressed();

    if (!h.equals(Expression.ZERO)) {
      var p = np._translateRoots(h);

      if (p.hasIntegerCoefficients()) {
        //?
        var zeros = p.getroots();

        if (zeros.length === 0) {
          //?
          zeros = p.getZeros();
          debugger;
        }

        if (zeros.length === np.getDegree()) {
          //?
          for (var iteratorzero = zeros[globalThis.Symbol.iterator](), zero = iteratorzero.next().value; zero != null; zero = iteratorzero.next().value) {
            roots.push(zero.subtract(h));
          }

          np = Polynomial.of(np.getLeadingCoefficient());

          if (callback != undefined) {
            callback({
              content: content,
              roots: roots,
              newPolynomial: np,
              type: "solveCubicEquation"
            });
          }

          return roots;
        } else {
          debugger;
        }
      }
    }
  }

  if (np.hasIntegerCoefficients()) {
    //?
    // convert to depressed (?)
    // x = t - b / (n * a)
    var n = np.getDegree();
    var a = np.getLeadingCoefficient();
    var b = np.getCoefficient(n - 1);

    if (!b.equals(Expression.ZERO)) {
      var h = b.divide(Expression.Integer.fromNumber(n).multiply(a));

      var depressed = np._translateRoots(h);

      var depressedRoots = [];

      if (callback != undefined) {
        //HACK:
        var originalCallback = callback;

        callback = function (info) {
          // https://en.wikipedia.org/wiki/Algebraic_equation#Elimination_of_the_sub-dominant_term
          originalCallback({
            content: content.multiply(depressed.getLeadingCoefficient().divide(np.getLeadingCoefficient()).inverse()),
            roots: roots,
            newPolynomial: depressed,
            type: "eliminationOfTheSubDominantTerm",
            b: b,
            n: n,
            a: a,
            newPolynomialVariable: new Expression.Symbol('t')
          });
          originalCallback(info);
          callback = originalCallback;
        };
      }

      continueWithNewPolynomial(depressedRoots, depressed, new Expression.Symbol('t')); //TODO: ?

      for (var iteratordepressedRoot = depressedRoots[globalThis.Symbol.iterator](), depressedRoot = iteratordepressedRoot.next().value; depressedRoot != null; depressedRoot = iteratordepressedRoot.next().value) {
        roots.push(depressedRoot.subtract(h));
      }

      if (depressedRoots.length = depressed.getDegree()) {
        np = Polynomial.of(np.getLeadingCoefficient());
      } else {
        //?
        throw new TypeError();
      } //TODO: back substitution:
      //if (callback != undefined) {
      //  callback({content: content, roots: roots, newPolynomial: np, type: "t = x - b/(n*a)", g: "?"});//TODO: ?
      //}


      return roots;
    }
  }

  if (np.getDegree() === 3) {
    // https://en.wikipedia.org/wiki/Cubic_function#Algebraic_solution
    var a = np.getCoefficient(3);
    var b = np.getCoefficient(2);
    var c = np.getCoefficient(1);
    var d = np.getCoefficient(0);
    var THREE = Expression.Integer.fromNumber(3);
    var h = b.divide(THREE.multiply(a));

    var substitute = function (y) {
      return y.subtract(h);
    };

    var tmp = np._translateRoots(h);

    var depressed = tmp.scale(tmp.getLeadingCoefficient().inverse());
    var p = depressed.getCoefficient(1);
    var q = depressed.getCoefficient(0);

    var discriminant = p.divide(THREE)._pow(3).add(q.divide(Expression.TWO)._pow(2));

    if (typeof hit === "function") {
      hit({
        getroots: {
          cubic: (discriminant instanceof Expression.Integer ? discriminant.compareTo(Expression.ZERO) : "?") + "-" + (p instanceof Expression.Integer ? p.compareTo(Expression.ZERO) : "?")
        }
      });
    }

    var minusOneOverTwo = Expression.ONE.negate().divide(Expression.TWO);
    var iSqrtOfThreeOverTwo = Expression.I.multiply(THREE.squareRoot()).divide(Expression.TWO);
    var cbrtOfMinusOne1 = minusOneOverTwo.subtract(iSqrtOfThreeOverTwo); // (-1-sqrt(3)*i)/2

    var cbrtOfMinusOne2 = minusOneOverTwo.add(iSqrtOfThreeOverTwo); // (-1+sqrt(3)*i)/2

    if (q.equals(Expression.ZERO) && p.equals(Expression.ZERO)) {
      //TODO: link to a^3+3a^2b+3ab^2+b^3=0 - ?
      // -b/(3*a)
      var root = substitute(Expression.ZERO);
      roots.push(root);
      roots.push(root);
      roots.push(root);
      np = Polynomial.of(np.getLeadingCoefficient());

      if (callback != undefined) {
        callback({
          content: content,
          roots: roots,
          newPolynomial: np,
          type: "solveCubicEquation"
        });
      }

      return roots;
    } else if (q.equals(Expression.ZERO)) {
      roots.push(substitute(Expression.ZERO));
      var tmp = nthRoot(2, p.negate(), np);
      roots.push(substitute(tmp));
      roots.push(substitute(tmp.negate()));
      np = Polynomial.of(np.getLeadingCoefficient());

      if (callback != undefined) {
        callback({
          content: content,
          roots: roots,
          newPolynomial: np,
          type: "solveCubicEquation"
        });
      }

      return roots;
    } else if (p.equals(Expression.ZERO)) {
      //TODO: should not reach this point (?) - should be solved by previous methods
      var tmp = nthRoot(3, q.negate(), np);
      roots.push(substitute(tmp));
      roots.push(substitute(tmp.multiply(cbrtOfMinusOne1)));
      roots.push(substitute(tmp.multiply(cbrtOfMinusOne2)));
      np = Polynomial.of(np.getLeadingCoefficient());

      if (callback != undefined) {
        callback({
          content: content,
          roots: roots,
          newPolynomial: np,
          type: "solveCubicEquation"
        });
      }

      return roots;
    } else if (discriminant.equals(Expression.ZERO)) {
      // https://github.com/nicolewhite/algebra.js/blob/master/src/equations.js
      // https://en.wikipedia.org/wiki/Cubic_equation#Multiple_root
      // a double root
      var t23 = THREE.multiply(q).divide(Expression.TWO.multiply(p)).negate();
      var root23 = substitute(t23);
      roots.push(root23);
      roots.push(root23);
      var t1 = t23.multiply(Expression.TWO).negate();
      var root1 = substitute(t1);
      roots.push(root1);
      np = Polynomial.of(np.getLeadingCoefficient());

      if (callback != undefined) {
        callback({
          content: content,
          roots: roots,
          newPolynomial: np,
          type: "solveCubicEquation"
        });
      }

      return roots;
    } else {
      // https://en.wikipedia.org/wiki/Cubic_equation#Cardano's_formula
      // 2*b^3-9*a*b*c+27*a^2*d
      var tmp = nthRoot(2, discriminant, np);

      if (tmp != undefined) {
        var C = nthRoot(3, q.negate().divide(Expression.TWO).add(tmp), np);

        if (C != undefined) {
          var rootFromC = function (C) {
            return substitute(C.subtract(p.divide(THREE.multiply(C))));
          };

          roots.push(rootFromC(C));
          roots.push(rootFromC(C.multiply(cbrtOfMinusOne1)));
          roots.push(rootFromC(C.multiply(cbrtOfMinusOne2)));
          np = Polynomial.of(np.getLeadingCoefficient());

          if (callback != undefined) {
            callback({
              content: content,
              roots: roots,
              newPolynomial: np,
              type: "solveCubicEquation"
            });
          }

          return roots;
        }
      }
    }
  } //!2018-12-23


  if (np.getDegree() > 2) {
    // https://en.wikipedia.org/wiki/Square-free_polynomial
    var tmp = np.squareFreeFactors();
    var a0 = tmp.a0;
    var a1 = tmp.a1;

    if (a0.getDegree() > 0) {
      //TODO: merge with a code for Kronecker's method
      //TODO: factorization - ?
      var newA0 = a0;
      var a0r = a0.getroots(function (x) {
        newA0 = x.newPolynomial;
      });
      var previousRoot = null;

      for (var i = 0; i < a0r.length; i += 1) {
        var root = a0r[i];
        roots.push(root);

        if (previousRoot == null || !previousRoot.equals(root)) {
          roots.push(root);
        }

        previousRoot = root;
      } // find roots of a1 at first (for better performance):


      var newA1 = a1;
      var a1Roots = a1.getroots(function (x) {
        newA1 = x.newPolynomial;
      });

      for (var i = 0; i < a1Roots.length; i += 1) {
        roots.push(a1Roots[i]);
      }

      if (newA0 != null) {
        //TODO: test
        np = newA1.multiply(newA0).multiply(Polynomial.polynomialGCD(newA0, np));
      }

      if (a0r.length > 0 || a1Roots.length > 0) {
        if (typeof hit === "function") {
          hit({
            getroots: {
              squareFreeFactorization: np.toString()
            }
          });
        }

        if (callback != undefined) {
          //TODO: better details, t = sqrt(3), show the polynomial, ...
          callback({
            content: content,
            roots: roots,
            newPolynomial: np,
            type: "squareFreeFactorization"
          }); //?
        } //continueWithNewPolynomial(roots, np);


        return roots;
      }
    }
  } //!


  if (np.getDegree() >= 4) {
    if (true) {
      //TODO: !!! show correct method name in details
      var g = np.factorize();

      if (g != undefined) {
        var h = np.divideAndRemainder(g).quotient;
        var gNew = null;
        var gRoots = g.getroots(function (x) {
          gNew = x.newPolynomial.scale(x.content);
        });

        for (var i = 0; i < gRoots.length; i += 1) {
          roots.push(gRoots[i]); //np = np.divideAndRemainder(Polynomial.of(gRoots[i].negate(), Expression.ONE)).quotient;//TODO: optimize somehow - ?
        }

        if (gRoots.length > 0) {
          np = np.divideAndRemainder(g.divideAndRemainder(gNew).quotient).quotient;
        }

        var hNew = null;
        var hRoots = h.getroots(function (x) {
          hNew = x.newPolynomial.scale(x.content);
        });

        for (var i = 0; i < hRoots.length; i += 1) {
          roots.push(hRoots[i]); //np = np.divideAndRemainder(Polynomial.of(hRoots[i].negate(), Expression.ONE)).quotient;//TODO: optimize somehow - ?
        }

        if (hRoots.length > 0) {
          np = np.divideAndRemainder(h.divideAndRemainder(hNew).quotient).quotient;
        }

        if (hRoots.length > 0 || gRoots.length > 0) {
          if (typeof hit === "function") {
            hit({
              getroots: {
                methodOfKronecker: np.toString()
              }
            });
          }

          if (callback != undefined) {
            //TODO: better details
            callback({
              content: content,
              roots: roots,
              newPolynomial: np,
              type: "methodOfKronecker"
            }); //?
          }
        }

        return roots;
      }
    }
  } //TODO: ???
  //TODO: move up


  if (np.getDegree() >= 3) {
    for (var i = 0; i <= np.getDegree(); i += 1) {
      if (Expression.has(np.getCoefficient(i), Expression.SquareRoot)) {
        var c = null;

        Expression._map(function (x) {
          if (c == null) {
            //TODO: fix - ?
            if (x instanceof Expression.SquareRoot && x.a instanceof Expression.Integer) {
              c = x;
            }
          }

          return x;
        }, np.getCoefficient(i));

        if (c != null) {
          var tmp = new Expression.Symbol('_t'); //?
          // substitute

          var p = np.map(function (coefficient) {
            var s1 = Expression.ZERO; // Expression._map does not work here as it goes into Expression.Exponentiation: x**2 -> x**(t**2). It throws an exception.

            for (var iterators = coefficient.summands()[globalThis.Symbol.iterator](), s = iterators.next().value; s != null; s = iterators.next().value) {
              var t = Expression.ONE;

              for (var iteratorx = s.factors()[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
                if (x.equals(c)) {
                  t = t.multiply(tmp);
                } else if (x instanceof Expression.Integer) {
                  var exp = 0;

                  while (x.gcd(c.a).equals(c.a)) {
                    exp += 2;
                    x = x.divide(c.a);
                  }

                  t = t.multiply(x.multiply(tmp._pow(exp))); //?
                  //var q = x.truncatingDivide(c.a);
                  //var r = x.subtract(q.multiply(c.a));
                  //return q.multiply(tmp.multiply(tmp)).add(r);
                } else {
                  t = t.multiply(x);
                }
              }

              s1 = s1.add(t);
            }

            return s1;
          });
          var a = "_x" + ++counter;
          var newp = Polynomial.toPolynomial(p.calcAt(new Expression.Symbol(a)), tmp); //!2020-12-11

          var g = newp.getGCDOfTermDegrees();

          if (g >= 2) {
            var newData = new Array(Math.floor((newp.getDegree() + g) / g));
            var k = 0;

            for (var i1 = 0; i1 <= newp.getDegree(); i1 += g) {
              newData[k] = newp.getCoefficient(i1).multiply(c._pow(i1 - k));
              k += 1;
            }

            newp = Polynomial.from(newData);
          } //!


          if (newp.getDegree() > 1) {
            var roots1 = [];
            var rr = null; //TODO: ?

            while ((rr = newp.doRationalRootTest()) != null) {
              roots1.push(rr);
              newp = newp.divideAndRemainder(Polynomial.of(rr.negate(), Expression.ONE), "throw").quotient;
            } //TODO: details - ?
            //var roots1 = newp.getroots();


            var rootsCount = roots.length;

            for (var j = 0; j < roots1.length; j += 1) {
              //TODO: check
              var roots2 = Polynomial.toPolynomial(roots1[j].subtract(c).getNumerator(), new Expression.Symbol(a)).getroots();

              for (var k = 0; k < roots2.length; k += 1) {
                var root = roots2[k];
                roots.push(root);
                np = np.divideAndRemainder(Polynomial.of(root.negate(), Expression.ONE)).quotient; //TODO: optimize somehow - ?
              }
            }

            if (roots.length > rootsCount) {
              if (typeof hit === "function") {
                hit({
                  getroots: {
                    methodOfIntroducingANewVariable: ""
                  }
                });
              }

              if (callback != undefined) {
                //TODO: better details, t = sqrt(3), show the polynomial, ...
                callback({
                  content: content,
                  roots: roots,
                  newPolynomial: np,
                  type: "methodOfIntroducingANewVariable",
                  t: c
                }); //?
              }

              continueWithNewPolynomial(roots, np);
              return roots; //TODO: when it is not all roots
            }
          }
        }
      }
    }
  }

  if (np.getDegree() === 4) {
    // https://en.wikipedia.org/wiki/Quartic_function
    // 1. coverting to a depressed quartic:
    var a_4 = np.getCoefficient(4);
    var p = np.scale(a_4.inverse());
    var b = p.getCoefficient(3);
    var y = new Expression.Symbol('$y');

    var substitute = function (y) {
      return y.subtract(b.divide(Expression.Integer.fromNumber(4)));
    };

    var e = p.calcAt(substitute(y));
    var sp = Polynomial.toPolynomial(e.getNumerator(), y); //TODO: ?

    var p = sp.getCoefficient(2);
    var q = sp.getCoefficient(1);
    var r = sp.getCoefficient(0); //var Q = nthRootInternal(3, );
    //var root = y0.subtract(b.divide(Expression.Integer.fromNumber(4)));
    // https://en.wikipedia.org/wiki/Quartic_function#Descartes'_solution

    var pU = Polynomial.of(q._pow(2).negate(), p._pow(2).subtract(Expression.TWO.add(Expression.TWO).multiply(r)), Expression.TWO.multiply(p), Expression.ONE); //TODO: when depressed cubic equation (?)
    //TODO: only one cubic equation root (?)

    var pURoots = pU.getCoefficient(1).equals(Expression.ZERO) && pU.getCoefficient(2).equals(Expression.ZERO) || pU.getCoefficient(0).equals(Expression.ZERO) ? pU.getroots() : [pU.doRationalRootTest() || Expression.ZERO];

    for (var iteratorU = pURoots[globalThis.Symbol.iterator](), U = iteratorU.next().value; U != null; U = iteratorU.next().value) {
      var u = nthRootInternal(2, U);

      if (!U.equals(Expression.ZERO) && u != null) {
        var s = u.negate();
        var t = p.add(u._pow(2)).add(q.divide(u)).divide(Expression.TWO);
        var v = p.add(u._pow(2)).subtract(q.divide(u)).divide(Expression.TWO); //TODO: details (factorization of two quadratic)

        var p1 = Polynomial.of(t, s, Expression.ONE);
        var p2 = Polynomial.of(v, u, Expression.ONE);
        var p12 = Polynomial.of(Expression.ONE);

        for (var iteratorroot = p1.getroots()[globalThis.Symbol.iterator](), root = iteratorroot.next().value; root != null; root = iteratorroot.next().value) {
          var s = substitute(root);
          roots.push(s);
          p12 = p12.multiply(Polynomial.of(s.negate(), Expression.ONE));
        }

        for (var iteratorroot = p2.getroots()[globalThis.Symbol.iterator](), root = iteratorroot.next().value; root != null; root = iteratorroot.next().value) {
          var s = substitute(root);
          roots.push(s);
          p12 = p12.multiply(Polynomial.of(s.negate(), Expression.ONE));
        }

        if (p12.getDegree() > 0) {
          np = np.divideAndRemainder(p12).quotient;

          if (callback != undefined) {
            callback({
              content: content,
              roots: roots,
              newPolynomial: np,
              type: "solveQuarticEcuation"
            }); //?
          }

          continueWithNewPolynomial(roots, np);
          return roots;
        }
      }
    } //debugger;
    //console.log(pURoots);

  }

  if (!np.hasIntegerCoefficients() && np.getDegree() > 2) {
    //?new
    var variable = new Expression.Symbol('$$');
    var e = np.calcAt(variable);
    var c = Expression.getConjugate(e);

    if (c != null) {
      var result = [];
      var newP = null;
      var ceRoots = Polynomial.toPolynomial(c.multiply(e), variable).getSquareFreePolynomial().getroots(function (x) {
        newP = x.newPolynomial;
      }); //TODO: details - ?

      for (var i = 0; i < ceRoots.length; i += 1) {
        var root = ceRoots[i];

        if (np.calcAt(root).equals(Expression.ZERO)) {
          roots.push(root); //TODO: this also filters out duplicate roots (?)
          //TODO: factorization may be not good, so this also needed to calc polynomial to continue the factorization

          np = np.divideAndRemainder(Polynomial.of(root.negate(), Expression.ONE)).quotient; //TODO: optimize somehow - ?
        } else {
          //TODO:?
          console.debug(root);
        }
      }

      if (ceRoots.length > 0) {
        if (callback != undefined) {
          //TODO: better details, t = sqrt(3), show the polynomial, ...
          callback({
            content: content,
            roots: roots,
            newPolynomial: np,
            type: "multiplyByConjugates",
            t: c
          }); //?
        }

        continueWithNewPolynomial(roots, np);
      }

      return roots;
    }
  }

  if (np.getDegree() >= 0) {
    //TODO: fix
    if (typeof hit === "function") {
      hit({
        getroots: {
          other: np.getDegree()
        }
      });
    }
  }

  return roots;
};

Polynomial.prototype.derive = function () {
  var newData = new PolynomialData(this.a.size);

  for (var i = 0; i < this.a.size; i += 1) {
    var n = this.a.degree(i);
    var c = this.a.coefficient(i);

    if (n >= 1) {
      var nc = Expression.Integer.fromNumber(n).multiply(c);

      if (!nc.equals(Expression.ZERO)) {
        newData.add(n - 1, nc);
      }
    }
  }

  return new Polynomial(newData);
};

Polynomial.prototype.getSquareFreePolynomial = function () {
  //TODO: remove (it is not good for performance of the factoring)
  return this.divideAndRemainder(this.squareFreeFactors().a0).quotient;
};

Polynomial.prototype.isSquareFreePolynomial = function () {
  return this.squareFreeFactors().a0.equals(Polynomial.of(Expression.ONE));
}; // f = a_1 * a_2**2 * a_3**3 * ... * a_n**n
// a1 = a_1
// a0 = a_2**1 * a_3**2 * ... * a_n**(n-1)
// returns factor a1 - square free factor, a0 - a factor where the degree of every coprime factor is less by one


Polynomial.prototype.squareFreeFactors = function () {
  // https://en.wikipedia.org/wiki/Square-free_polynomial
  var p = this;
  var zero = 0;

  while (p.getCoefficient(zero).equals(Expression.ZERO)) {
    zero += 1;
  }

  p = p.divideAndRemainder(Polynomial.of(Expression.ONE).shift(zero), "throw").quotient;

  if (p.getDegree() !== 0) {
    var f = p;
    var d = f.derive();
    var a0 = Polynomial.polynomialGCD(f, d);

    if (a0.getDegree() !== 0) {
      if (Expression.isConstant(a0.getLeadingCoefficient())) {
        //TODO: ?
        a0 = a0.scale(a0.getLeadingCoefficient().inverse()); //TODO: ?
      }

      if (f.hasIntegerCoefficients()) {
        //?
        a0 = a0.scale(a0.getContent().inverse()); //?
      } //TODO: ?


      var b1 = f._hasIntegerLikeCoefficients() ? f.divideAndRemainder(a0, "throw").quotient : f.divideAndRemainder(a0).quotient;
      var g1 = Polynomial.polynomialGCD(b1, a0);
      var a1 = b1._hasIntegerLikeCoefficients() ? b1.divideAndRemainder(g1, "throw").quotient : b1.divideAndRemainder(g1).quotient;
      return {
        a1: a1.shift(zero === 1 ? 1 : 0),
        a0: a0.shift(zero > 1 ? zero - 1 : 0)
      };
    }
  }

  return {
    a1: p.shift(zero === 1 ? 1 : 0),
    a0: Polynomial.of(Expression.ONE).shift(zero > 1 ? zero - 1 : 0)
  };
};

self.Polynomial = Polynomial;

Polynomial.prototype._findGoodSubstitution = function () {
  var g = this.getCoefficient(0).abs();

  for (var i = 0; i < this.getDegree(); i += 1) {
    g = g.gcd(this.getCoefficient(i).abs());
  }

  if (g.toNumber() > Math.pow(2, 53)) {
    return null; //!!!
  }

  if (g.toNumber() === 1) {
    return null;
  }

  var p = g.primeFactor();

  var before = this._log2hypot();

  var after = this._scaleRoots(p.inverse());

  after = after.scale(after.getContent().inverse());
  after = after._log2hypot();

  if (after < before) {
    return p;
  }
  /*
  var g = this.getCoefficient(0).abs();
  for (var i = 1; i <= this.getDegree(); i += 1) {
    g = g.gcd(this.getCoefficient(i).abs());
  }
  g = g.abs();
  //while (!g.equals(Expression.ONE)) {
    //var p = g.primeFactor();
    //g = g.truncatingDivide(p);
  //}
  var g = Expression.getConstant(this.getCoefficient(0).abs().gcd(g._pow(this.getDegree()))._nthRoot(this.getDegree()));
  for (var i = 1; i < this.getDegree(); i += 1) {
    var c = this.getCoefficient(i).gcd(g._pow(this.getDegree() - i));
    if (!c.equals(Expression.ZERO)) {
      g = g.gcd(Expression.getConstant(c.abs()._nthRoot(this.getDegree() - i)));
    }
  }
  if (!g.equals(Expression.ONE)) {
    //debugger;
    return g;
  }
  //TODO: denominator
  return null;*/

};

Polynomial.prototype._getShiftToDepressed = function () {
  // for testing (?)
  var n = this.getDegree();
  var a = this.getLeadingCoefficient();
  var b = this.getCoefficient(n - 1);
  var h = b.divide(Expression.Integer.fromNumber(n).multiply(a)); //var depressed = this._translateRoots(h);
  //console.log(depressed);

  return h;
};

Polynomial.prototype.factorize = function () {
  //if (this.getDegree() !== 3 && !this._canBeFactored()) {//TODO: ?
  //TODO: details - ?
  //  return undefined;
  //}
  if (this.getCoefficient(0).equals(Expression.ZERO)) {
    //?
    return Polynomial.of(Expression.ZERO, Expression.ONE);
  }

  if (this.getDegree() === 3) {//console.log(this.toString());
  }

  var content = this.getContent(); //?TODO: ?

  if (!content.equals(Expression.ONE) && !content.equals(Expression.ONE.negate())) {
    throw new RangeError();
  }

  if (this.getDegree() === 1) {
    return null;
  }

  if (this.getDegree() === 2) {
    var discriminant = function (p) {
      console.assert(p.getDegree() === 2);
      var a = p.getCoefficient(2);
      var b = p.getCoefficient(1);
      var c = p.getCoefficient(0);
      return b.multiply(b).subtract(Expression.Integer.fromNumber(4).multiply(a).multiply(c));
    };

    var d = discriminant(this); //TODO: not integer discriminants (?)

    if (d instanceof Expression.Integer && !d._isPerfectSquare()) {
      return null;
    }
  }

  var tmp = this.squareFreeFactors();

  if (tmp.a0.getDegree() > 0) {
    //TODO: ?
    if (tmp.a1.getDegree() > 0) {
      return tmp.a1;
    }

    return tmp.a0;
  }

  if (this.getDegree() < 2) {
    return null;
  } //!new


  if (this.hasIntegerCoefficients() && false) {
    var k = this._findGoodSubstitution();

    if (k != null) {
      var newp = this._scaleRoots(k.inverse());

      newp = newp.scale(newp.getContent().inverse());
      var f = newp.factorize();

      if (f != undefined) {
        return f._scaleRoots(k);
      }

      return null; //!?
    }
  }

  var n = this.getDegree();
  var b = this.getCoefficient(n - 1);

  if (!b.equals(Expression.ZERO) && !this.hasIntegerCoefficients()) {
    // conversion to depressed is slow (!) (large coefficients)
    var a = this.getLeadingCoefficient();
    var shift = b.divide(Expression.Integer.fromNumber(n).multiply(a));

    var depressed = this._translateRoots(shift);

    depressed = depressed.primitivePart(); //TODO: ?

    var factor = depressed.factorize();

    if (factor != null) {
      return factor._translateRoots(shift.negate()).primitivePart();
    }

    return null;
  } //!
  //!new


  if (this.isEven()) {
    if (this.hasIntegerCoefficients() && (!this.getCoefficient(0).abs()._isPerfectSquare() || !this.getCoefficient(this.getDegree()).abs()._isPerfectSquare())) {
      var f = this._exponentiateRoots(2).factorize();

      if (f != undefined) {
        return f._exponentiateRoots(1 / 2);
      }

      return null;
    } //TODO: it should be factored into a product of (ax**(n/2)+...+bx+c) and (ax**(n/2)+...-bx+c)
    //if (this._factorByKroneckersMethod() != undefined) {
    //  debugger;
    //}

  }

  var g = this.getGCDOfTermDegrees();

  if (g > 2) {
    var f = this._exponentiateRoots(g).factorize();

    if (f != undefined) {
      return f._exponentiateRoots(1 / g);
    } //?

  } //!


  if (this.getDegree() < 4 || !this.hasIntegerCoefficients()) {
    //? avoid Polynomial#getZeros(...)
    var root = this.doRationalRootTest();

    if (root != null) {
      return Polynomial.of(root.getNumerator(), root.getDenominator().negate());
    }

    if (this.getDegree() < 4) {
      // https://math.stackexchange.com/questions/1138416/how-do-i-show-a-cubic-polynomial-does-not-factorise#answer-1138428
      return null;
    }
  } //!


  var np = this; //console.time('Kronecker\'s method');
  //TODO: ?

  if (!np.hasIntegerCoefficients()) {
    return np._factorByKroneckersMethod();
  }

  return np._factorizeOverTheIntegers(); //console.timeEnd('Kronecker\'s method');
};

Polynomial.prototype.primitivePart = function () {
  //return this.divideAndRemainder(Polynomial.of(this.getContent()), "throw").quotient;
  //TODO: test if this is faster:
  //var content = this.getContent();
  //return this.scale(content.getDenominator()).divideAndRemainder(Polynomial.of(content.getNumerator()), "throw").quotient;
  return this.scale(this.getContent().inverse());
};

Function.prototype.debug = function () {
  var f = this;
  var lastT = 10;
  return function () {
    var start = Date.now();
    var result = f.apply(this, arguments);
    var end = Date.now();
    var t = end - start;

    if (t > lastT * 1.5) {
      lastT = t;
      console.log(t);
      console.log([this].concat(Array.from(arguments)).join(', '));
    }

    return result;
  };
};

Polynomial.prototype.modularInverse = function (m) {
  var g = Math.gcd(this.getGCDOfTermDegrees(), m.getGCDOfTermDegrees());

  if (g > 1) {
    return this._exponentiateRoots(g).modularInverse(m._exponentiateRoots(g))._exponentiateRoots(1 / g);
  }

  if (this.hasIntegerCoefficients() && m.hasIntegerCoefficients()) {//TODO: ???
  } //TODO: ?
  // https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Polynomial_extended_Euclidean_algorithm


  var a = this;
  var oldR = m;
  var r = a.getDegree() >= m.getDegree() ? Polynomial.pseudoRemainder(a, m).primitivePart() : a; //? faster then swap (?)
  //var r = a;

  /*if (oldR.getDegree() < r.getDegree()) {
    var tmp = oldR;
    oldR = r;
    r = tmp;
  }*/

  var oldT = Polynomial.of(Expression.ZERO);
  var t = Polynomial.of(Expression.ONE); //var oldS = Polynomial.of(Expression.ONE);
  //var s = Polynomial.of(Expression.ZERO);
  //TODO: fix for different sequences (?)

  var type = this.hasIntegerCoefficients() && m.hasIntegerCoefficients() ? "primitive" : "subresultant";

  for (var iteratortmp = Polynomial._pseudoRemainderSequence(oldR, r, type)[globalThis.Symbol.iterator](), tmp = iteratortmp.next().value; tmp != null; tmp = iteratortmp.next().value) {
    //?
    var scale = r.getLeadingCoefficient()._pow(oldR.getDegree() - r.getDegree() + 1);

    var quotient = tmp.q;
    var α = tmp.α;
    var newT = oldT.scale(scale).subtract(quotient.multiply(t));

    if (type === "primitive") {
      newT = newT.scale(α.inverse());
    } else {
      newT = newT.divideAndRemainder(Polynomial.of(α), "throw").quotient;
    }

    var $newoldT = t;
    var $newt = newT;
    oldT = $newoldT;
    t = $newt; //var newS = oldS.scale(scale).subtract(quotient.multiply(s)).divideAndRemainder(Polynomial.of(α), "throw").quotient;
    //var $newoldS = s; var $news =  newS; oldS = $newoldS; s = $news;

    var newR = tmp.R;
    var $newoldR = r;
    var $newr = newR;
    oldR = $newoldR;
    r = $newr;
  }

  var gcd = oldR; //TODO: FIX

  if (gcd.getDegree() !== 0) {
    throw new TypeError(); //?
  }

  oldT = oldT.primitivePart().scale(m.getLeadingCoefficient());
  var r = oldT.multiply(this).divideAndRemainder(m, "throw").remainder;

  if (r.getDegree() !== 0) {
    throw new TypeError(); //?
  }

  oldT = oldT.scale(r.getCoefficient(0).inverse()); //oldT = oldT.scale(gcd.getLeadingCoefficient().inverse());
  //oldS = oldS.primitivePart().scale(m.getLeadingCoefficient());
  //var r = oldS.multiply(this).divideAndRemainder(m, "throw").remainder;
  //if (r.getDegree() !== 0) {
  //  throw new TypeError();//?
  //}
  //oldS = oldS.scale(r.getCoefficient(0).inverse());
  //oldS = oldS.scale(gcd.getLeadingCoefficient().inverse());

  return oldT;
}.debug();
})();
(function () {
"use strict";
/*jslint plusplus: true, vars: true, indent: 2 */

  

  //    API same as http://sylvester.jcoglan.com/api/matrix.html
  //    new Matrix([
  //      [1, 2, 3],
  //      [5, 6, 7],
  //      [7, 8,-1]
  //    ]);

  function Matrix(data) {
    this.a = data;
  }

  Matrix.Zero = function (rows, cols) {
    var row = new Array(cols);
    for (var j = 0; j < cols; j += 1) {
      row[j] = Expression.ZERO;
    }
    var a = new Array(rows);
    for (var i = 0; i < rows; i += 1) {
      a[i] = row;
    }
    return new Matrix(a);
  };

  // identity n x n;
  Matrix.I = function (n) {
    return Matrix.Zero(n, n).map(function (element, i, j) {
      return (i === j ? Expression.ONE : Expression.ZERO);
    });
  };

  //Matrix.Diagonal = function (elements) {
  //  var n = elements.length;
  //  return Matrix.Zero(n, n).map(function (element, i, j) {
  //    return i === j ? elements[i] : Expression.ZERO;
  //  });
  //};

  Matrix.prototype.rows = function () {
    return this.a.length;
  };

  Matrix.prototype.cols = function () {
    return this.a.length > 0 ? this.a[0].length : 0;
  };

  Matrix.prototype.e = function (i, j) {
    return this.a[i][j];
  };

  Matrix.prototype.isSquare = function () {
    return this.rows() > 0 && this.rows() === this.cols();//?
  };

  Matrix.prototype.map = function (callback) {
    var rows = this.rows();
    var cols = this.cols();
    var c = new Array(rows);
    var i = -1;
    while (++i < rows) {
      var x = new Array(cols);
      var j = -1;
      while (++j < cols) {
        var e = callback.call(undefined, this.e(i, j), i, j, this);
        x[j] = e.simplifyExpression();//?
      }
      c[i] = x;
    }
    return new Matrix(c);
  };

  Matrix.prototype.transpose = function () {
    var that = this;
    return Matrix.Zero(that.cols(), that.rows()).map(function (element, i, j) {
      return that.e(j, i);
    });
  };

  Matrix.prototype.scale = function (k) {
    return this.map(function (element, i, j) {
      return element.multiply(k);
    });
  };

  Matrix.prototype.multiply = function (b) {
    var a = this;
    if (a.cols() !== b.rows()) {
      throw new RangeError("DimensionMismatchException");
    }
    return Matrix.Zero(a.rows(), b.cols()).map(function (element, i, j) {
      var rows = b.rows();
      var k = -1;
      while (++k < rows) {
        //! this code is used to show not simplified expressions
        var current = a.e(i, k).multiply(b.e(k, j));
        element = k === 0 ? current : element.add(current);
      }
      return element;
    });
  };

  Matrix.prototype.add = function (b) {
    var a = this;
    if (a.rows() !== b.rows() || a.cols() !== b.cols()) {
      throw new RangeError("MatrixDimensionMismatchException");
    }
    return a.map(function (elem, i, j) {
      return elem.add(b.e(i, j));
    });
  };

  Matrix.prototype.augment = function (b) { // ( this | m )  m.rows() ==== this.rows()
    if (this.rows() !== b.rows()) {
      //TODO: fix exception
      throw new RangeError("NonSquareMatrixException");
    }
    var a = this;
    return Matrix.Zero(a.rows(), a.cols() + b.cols()).map(function (element, i, j) {
      return (j < a.cols() ? a.e(i, j) : b.e(i, j - a.cols()));
    });
  };

  Matrix.prototype.rowReduce = function (targetRow, pivotRow, pivotColumn, currentOrPreviousPivot) {
    var rows = this.rows();
    var cols = this.cols();
    var c = new Array(rows);
    var i = -1;
    while (++i < rows) {
      if (targetRow === i) {
        var x = new Array(cols);
        var f = currentOrPreviousPivot == undefined ? this.e(targetRow, pivotColumn).divide(this.e(pivotRow, pivotColumn)) : undefined;
        var j = -1;
        while (++j < cols) {
          // (e_ij - e_ic * e_rj / e_rc) * (e_rc / cpp)
          var e = undefined;
          if (currentOrPreviousPivot == undefined) {
            e = this.e(targetRow, j).subtract(f.multiply(this.e(pivotRow, j)));
          } else {
            e = this.e(pivotRow, pivotColumn).multiply(this.e(targetRow, j)).subtract(this.e(targetRow, pivotColumn).multiply(this.e(pivotRow, j))).divide(currentOrPreviousPivot);
            //TODO: 
            //if (e instanceof Expression.Division) {
            //  debugger;
            //}
          }
          x[j] = e.simplifyExpression();
        }
        c[i] = x;
      } else {
        c[i] = this.a[i];
      }
    }
    return new Matrix(c);
  };

  Matrix.prototype.swapRows = function (pivotRow, targetRow, preserveDeterminant) {
    var m = this;
    return m.map(function (e, i, j) {
      if (i === pivotRow) {
        return m.e(targetRow, j);
      }
      if (i === targetRow) {
        return preserveDeterminant ? m.e(pivotRow, j).negate() : m.e(pivotRow, j);
      }
      return e;
    });
  };

  var notEqualsZero = function (e, condition) {//TODO: - ?
    if (condition != undefined) {
      //!update from 2018-16-07
      return condition.andZero(e).isFalse();
    }
    return !e.equals(Expression.ZERO);
  };

  Matrix.check = function (usage, matrix, from, to, condition) {
    for (var i = from; i < to; i += 1) {
      if (usage !== "solving" || notEqualsZero(matrix.e(i, matrix.cols() - 1), condition)) {
        var endColumnIndex = usage === "solving" ? matrix.cols() - 1 : (usage === "determinant" ? matrix.cols() : (usage === "inverse" ? Math.floor(matrix.cols() / 2) : -1));
        var j = 0;
        while (j < endColumnIndex && matrix.e(i, j).equals(Expression.ZERO)) {
          j += 1;
        }
        if (j === endColumnIndex) {
          return i;
        }
      }
    }
    return -1;
  };

  Matrix.toRowEchelonStep = function (m, pivotRow, pivotColumn, pivotOriginRow, previousPivot, options, condition) {
    var oldMatrix = undefined;
    var coefficient = undefined;
    var targetRow = 0;
    if (pivotOriginRow !== pivotRow) {
      oldMatrix = m;
      m = m.swapRows(pivotRow, pivotOriginRow, options.usage === "determinant");
      if (options.callback != undefined) {
        options.callback({previousPivot: undefined, newMatrix: m, oldMatrix: oldMatrix, type: options.usage === "determinant" ? "swap-negate" : "swap", targetRow: pivotRow, pivotRow: pivotOriginRow, pivotColumn: pivotColumn});
      }
    }
    // making zeros under the main diagonal
    if (options.method === Matrix.GaussJordan) {
      if (!m.e(pivotRow, pivotColumn).equals(Expression.ONE)) {
        oldMatrix = m;
        coefficient = Expression.ONE.divide(m.e(pivotRow, pivotColumn));
        m = m.map(function (e, i, j) {
          if (i !== pivotRow) {
            return e;
          }
          return e.multiply(coefficient);
        });
        if (options.callback != undefined) {
          options.callback({previousPivot: undefined, newMatrix: m, oldMatrix: oldMatrix, type: "divide", targetRow: pivotRow, pivotRow: pivotRow, pivotColumn: pivotColumn});
        }
      }
    }
    if (options.method === Matrix.Gauss || options.method === Matrix.GaussJordan) {
      targetRow = pivotRow;
      while (++targetRow < m.rows()) {
        if (!m.e(targetRow, pivotColumn).equals(Expression.ZERO)) {
          oldMatrix = m;
          m = m.rowReduce(targetRow, pivotRow, pivotColumn);
          if (options.callback != undefined) {
            options.callback({previousPivot: undefined, newMatrix: m, oldMatrix: oldMatrix, type: "reduce", targetRow: targetRow, pivotRow: pivotRow, pivotColumn: pivotColumn});
          }
          var stoppedAtRow = Matrix.check(options.usage, m, targetRow, targetRow + 1, condition);
          if (stoppedAtRow !== -1) {
            return {stoppedAtRow: stoppedAtRow, matrix: m};
          }
        }
      }
    }
    if (options.method === Matrix.GaussMontante) {
      oldMatrix = m;
      targetRow = -1;
      while (++targetRow < m.rows()) {
        if (targetRow !== pivotRow) {
          m = m.rowReduce(targetRow, pivotRow, pivotColumn, previousPivot);
        }
      }
      if (options.callback != undefined) {
        options.callback({previousPivot: previousPivot, newMatrix: m, oldMatrix: oldMatrix, type: "pivot", targetRow: -1, pivotRow: pivotRow, pivotColumn: pivotColumn});
      }
      var stoppedAtRow = Matrix.check(options.usage, m, 0, m.rows(), condition);
      if (stoppedAtRow !== -1) {
        return {stoppedAtRow: stoppedAtRow, matrix: m};
      }
    }
    return {stoppedAtRow: -1, matrix: m};
  };

  Matrix.toRowEchelonBackSubstitution = function (m, pivotRow, options) {
    // back-substitution
    if (options.method === Matrix.GaussJordan) {
      while (--pivotRow >= 0) {
        var pivotColumn = 0;
        while (pivotColumn < m.cols() && m.e(pivotRow, pivotColumn).equals(Expression.ZERO)) {
          pivotColumn += 1;
        }
        if (pivotColumn < m.cols()) {
          var targetRow = pivotRow;
          while (--targetRow >= 0) {
            if (!m.e(targetRow, pivotColumn).equals(Expression.ZERO)) {
              var oldMatrix = m;
              m = m.rowReduce(targetRow, pivotRow, pivotColumn);
              if (options.callback != undefined) {
                options.callback({previousPivot: undefined, newMatrix: m, oldMatrix: oldMatrix, type: "reduce", targetRow: targetRow, pivotRow: pivotRow, pivotColumn: pivotColumn});
              }
            }
          }
        }
      }
    }
    return m;
  };

  var isConditionValid = function (condition, matrix) {
    for (var i = 0; i < matrix.rows(); i++) {
      for (var j = 0; j < matrix.cols(); j++) {
        var e = matrix.e(i, j);
        if (!Polynomial._isIntegerLike(e)) {
          if (Polynomial._isIntegerLike(e.getNumerator())) {//!!! for performance
            e = e.getDenominator().inverse();
          }
          if (condition.andZero(e).isFalse() && condition.andNotZero(e).isFalse()) {
            return false;
          }
        }
      }
    }
    return true;
  };

  Matrix.Gauss = "Gauss";
  Matrix.GaussJordan = "Gauss-Jordan";
  Matrix.GaussMontante = "Gauss-Montante";

  function ToRowEchelonOptions(method, usage, callback) {
    if (usage !== "determinant" && usage !== "inverse" && usage !== "solving" && usage !== "LU-decomposition" && usage !== "" && usage !== "row-reduction") {
      throw new RangeError();
    }
    if (method !== Matrix.Gauss && method !== Matrix.GaussJordan && method !== Matrix.GaussMontante) {
      throw new RangeError();
    }
    this.method = method;
    this.usage = usage;
    this.callback = callback;
  }

  Matrix.ToRowEchelonOptions = ToRowEchelonOptions;

  // method === Matrix.GaussJordan - make zeros under diagonal and divide by pivot element, also swap row instead of addition
  // method === Matrix.Montante - https://es.wikipedia.org/wiki/M%C3%A9todo_Montante
  // private
  var COLUMN_LOOP = 0;
  var ZERO = 1;
  var NOT_ZERO = 2;
  Matrix.prototype.toRowEchelon = function (method, usage, callback) {
    var options = new Matrix.ToRowEchelonOptions(method, usage, callback);
    return this.toRowEchelonInternal(options, 0, -1, -1, Expression.ONE, COLUMN_LOOP, undefined);
  };
  Matrix.prototype.toRowEchelonXXX = function (method, usage, callback, condition) {
    var options = new Matrix.ToRowEchelonOptions(method, usage, callback);
    return this.toRowEchelonInternal(options, 0, -1, -1, Expression.ONE, COLUMN_LOOP, condition);
  };
  Matrix.prototype.toRowEchelonInternal = function (options, pivotRow, pivotColumn, pivotOriginRow, previousPivot, state, condition) {
    var matrix = this;

    //2018-09-29
    if (condition != undefined && !condition.isTrue()) {
      matrix = matrix.map(function (e, i, j) {
        // x == 0 && x**2 != 0 is false
        // x == 0 && x**2 == 0 is false
        // x == 0 && y/x != 0 is false
        // x == 0 && y/x == 0 is false
        return condition.updateExpression(e)
      });
      previousPivot = condition.updateExpression(previousPivot);
    }

    var stoppedAtRow = Matrix.check(options.usage, matrix, 0, matrix.rows(), condition);
    if (stoppedAtRow !== -1) {
      return {stoppedAtRow: stoppedAtRow, matrix: matrix, condition: condition};
    }
    if (false) {
      //TODO: remove
    //!2018-16-07 (from trash)
    if (options.usage === "solving" && pivotColumn === matrix.cols() - 1) {
      //TODO: test
      //TODO: test if condition == undefined
      var c = condition.andZero(matrix.e(pivotRow, pivotColumn));
      return {stoppedAtRow: -1, matrix: matrix, condition: c};
    }
    //!
    }
    while (true) {
      switch (state) {
        case COLUMN_LOOP:
          pivotColumn += 1;
          if (pivotColumn >= matrix.cols()) {
            matrix = Matrix.toRowEchelonBackSubstitution(matrix, pivotRow, options);
            return {stoppedAtRow: -1, matrix: matrix, condition: condition};
          }
          if (pivotColumn > pivotRow && (options.usage === "determinant" || options.usage === "inverse")) {
            if (pivotColumn >= Math.floor(matrix.cols() / 2) && options.usage === "inverse") {//TODO: fix
              matrix = Matrix.toRowEchelonBackSubstitution(matrix, pivotRow, options);
              return {stoppedAtRow: -1, matrix: matrix, condition: condition};
            }
            return {stoppedAtRow: pivotRow, matrix: matrix, condition: condition};//? TODO: details - ?
          }
          pivotOriginRow = pivotRow - 1;
          state = ZERO;
        break;
        case ZERO:
          // pivot searching
          // not zero element in a column (starting from the main diagonal);
          if (condition == undefined) {
            pivotOriginRow += 1;
            if (pivotOriginRow < matrix.rows()) {
              if (matrix.e(pivotOriginRow, pivotColumn).equals(Expression.ZERO)) {
                state = ZERO;
              } else {
                state = NOT_ZERO;
              }
            } else {
              state = COLUMN_LOOP;
            }
          } else {
            if (pivotOriginRow >= pivotRow) {
              matrix = pivotRow >= matrix.rows() || matrix.e(pivotRow, pivotColumn).equals(Expression.ZERO) ? matrix : matrix.map(function (e, i, j) { //?
                //return i === pivotOriginRow && j === pivotColumn ? Expression.ZERO : condition.updateExpression(e);
                return condition.updateExpression(e);
              });
              previousPivot = condition.updateExpression(previousPivot);
            }
            var found = false;
            if (pivotOriginRow === pivotRow - 1) {//!
              var row = pivotRow;
              while (row < matrix.rows() && !((condition.andZero(matrix.e(row, pivotColumn)).isFalse() || options.usage === "LU-decomposition") && !matrix.e(row, pivotColumn).equals(Expression.ZERO))) {
                row += 1;
              }
              if (row < matrix.rows()) {
                pivotOriginRow = row;
                found = true;
              }
            }//!
            if (!found) {
              pivotOriginRow += 1;
              if (pivotOriginRow < matrix.rows()) {
                var candidate = matrix.e(pivotOriginRow, pivotColumn);
                var c1 = condition.andNotZero(candidate);
                var c2 = condition.andZero(candidate);

                if (!c2.isFalse()) {
                //!new 2020-01-03
                // condition: r = 0, element = 1/r
                if (!isConditionValid(c2, matrix)) {
                  debugger;
                  c2 = Condition.FALSE;//!!!
                  condition = c1;//!
                }
                //!
                }

                if (c2.isFalse()) {
                  state = NOT_ZERO;
                } else if (c1.isFalse()) {
                  state = ZERO;
                } else {
                  if (options.usage === "row-reduction") {
                    var tmp = Matrix.toRowEchelonStep(matrix, pivotRow, pivotColumn, pivotOriginRow, previousPivot, Object.assign({}, options, {callback: null}), condition);
                    var m = tmp.matrix.slice(pivotOriginRow + 1, matrix.rows(), pivotColumn, matrix.cols()).map(function (e, i, j) {
                      return c2.updateExpression(e);
                    });
                    if (m.eql(Matrix.Zero(m.rows(), m.cols()))) {
                      return matrix.toRowEchelonInternal(options, pivotRow, pivotColumn, pivotOriginRow, previousPivot, NOT_ZERO, condition);
                    }
                  }
                  return {
                    matrix: matrix,
                    c1: c1,
                    a1: function () {
                      return matrix.toRowEchelonInternal(options, pivotRow, pivotColumn, pivotOriginRow, previousPivot, NOT_ZERO, c1);
                    },
                    c2: c2,
                    a2: function () {
                      return matrix.toRowEchelonInternal(options, pivotRow, pivotColumn, pivotOriginRow, previousPivot, ZERO, c2);
                    }
                  };
                }
              } else {
                state = COLUMN_LOOP;
              }
            } else {
              state = NOT_ZERO;
            }
          }
        break;
        case NOT_ZERO:
          var tmp = Matrix.toRowEchelonStep(matrix, pivotRow, pivotColumn, pivotOriginRow, previousPivot, options, condition);
          var stoppedAtRow = tmp.stoppedAtRow;
          matrix = tmp.matrix;
          if (stoppedAtRow !== -1) {
            return {stoppedAtRow: stoppedAtRow, matrix: matrix, condition: condition};
          }
          previousPivot = matrix.e(pivotRow, pivotColumn);
          pivotRow += 1;
          state = COLUMN_LOOP;
        break;
      }
    }
  };

  Matrix.prototype.determinant = function () { // m == n  // via row echelon form
    var n = this.rows();
    if (!this.isSquare() || n === 0) {
      throw new RangeError("NonSquareMatrixException");
    }
    if (false && !Expression.has(this.e(0, 0), Expression.Polynomial)) {
      var tmp = this.toRowEchelon(Matrix.Gauss, "determinant", undefined);
      var stoppedAtRow = tmp.stoppedAtRow;
      var rowEchelonMatrix = tmp.matrix;
      if (stoppedAtRow !== -1) {
        return Expression.ZERO;
      }
      var det = rowEchelonMatrix.e(0, 0);
      for (var j = 1; j < rowEchelonMatrix.rows(); j += 1) {
        det = det.multiply(rowEchelonMatrix.e(j, j));
      }
      return det;
    }
    var tmp = this.toRowEchelon(Matrix.GaussMontante, "determinant", undefined);
    var stoppedAtRow = tmp.stoppedAtRow;
    var rowEchelonMatrix = tmp.matrix;
    if (stoppedAtRow !== -1) {
      return Expression.ZERO;
    }
    return rowEchelonMatrix.e(n - 1, n - 1);
  };

  Matrix.prototype.rank = function () {
    // rank === count of non-zero rows after bringing to row echelon form ...
    //var m = this.toRowEchelon(Matrix.Gauss, "", undefined).matrix;
    var m = this.toRowEchelon(Matrix.GaussMontante, "", undefined).matrix;
    var result = 0;
    var pivotRow = 0;
    var pivotColumn = 0;
    while (pivotRow < m.rows()) {
      while (pivotColumn < m.cols() && m.e(pivotRow, pivotColumn).equals(Expression.ZERO)) {
        pivotColumn += 1;
      }
      if (pivotColumn < m.cols()) {
        result += 1;
      }
      pivotRow += 1;
    }
    return result;
  };

  Matrix.prototype.inverse = function () { // m == n by augmention ...
    if (!this.isSquare()) {
      throw new RangeError("NonSquareMatrixException");
    }
    if (this.rows() === 2) {
      var a = this.e(0, 0);
      var b = this.e(0, 1);
      var c = this.e(1, 0);
      var d = this.e(1, 1);
      var det = a.multiply(d).subtract(b.multiply(c));
      if (det.equals(Expression.ZERO)) {
        throw new RangeError("SingularMatrixException");
      }
      return Matrix.Zero(this.rows(), this.rows()).map(function (e, i, j) {
        return (i === 0 ? (j === 0 ? d : b.negate()) : (j === 0 ? c.negate() : a)).divide(det);
      });
    }
    var m = this.augment(Matrix.I(this.rows()));
    //m = m.toRowEchelon(Matrix.GaussJordan, "inverse", undefined).matrix;
    m = m.toRowEchelon(Matrix.GaussMontante, "inverse", undefined).matrix;

    return Matrix.Zero(m.rows(), m.rows()).map(function (element, i, j) { // splitting to get the second half
      var e = m.e(i, i);
      if (e.equals(Expression.ZERO)) {
        throw new RangeError("SingularMatrixException");
      }
      var x = m.e(i, j + m.rows());
      return e.equals(Expression.ONE) ? x : x.divide(e);
    });
  };

  Matrix.prototype.toString = function (options) {
    var result = "";
    var rows = this.rows();
    var cols = this.cols();
    var j = -1;
    result += "{";
    while (++j < rows) {
      if (j !== 0) {
        result += ",";
      }
      result += "{";
      var i = -1;
      while (++i < cols) {
        if (i !== 0) {
          result += ",";
        }
        result += this.e(j, i).toString(options);
      }
      result += "}";
    }
    result += "}";
    return result;
  };

  Matrix.prototype.negate = function () {
    return this.map(function (element, i, j) {
      return element.negate();
    });
  };

  Matrix.prototype.subtract = function (b) {
    return this.add(b.negate());
  };

  //?
  // returns an array of arrays of strings
  Matrix.prototype.getElements = function () {
    var rows = this.rows();
    var cols = this.cols();
    var elements = new Array(rows);
    for (var i = 0; i < rows; i += 1) {
      var row = new Array(cols);
      for (var j = 0; j < cols; j += 1) {
        row[j] = this.e(i, j).toString();
      }
      elements[i] = row;
    }
    return elements;
  };

  Matrix.prototype.slice = function (rowsStart, rowsEnd, colsStart, colsEnd) {
    var that = this;
    return Matrix.Zero(rowsEnd - rowsStart, colsEnd - colsStart).map(function (e, i, j) {
      return that.e(i + rowsStart, j + colsStart);
    });
  };

  //TODO:
  Matrix.prototype.isExact = function () {
    var rows = this.rows();
    var cols = this.cols();
    for (var i = 0; i < rows; i += 1) {
      for (var j = 0; j < cols; j += 1) {
        if (!this.e(i, j).isExact()) {
          return false;
        }
      }
    }
    return true;
  };

  Matrix.prototype.eql = function (b) {
    var a = this;
    if (a.rows() !== b.rows() || a.cols() !== b.cols()) {
      return false;
    }
    for (var i = 0; i < a.rows(); i += 1) {
      for (var j = 0; j < a.cols(); j += 1) {
        if (!a.e(i, j).equals(b.e(i, j))) {
          return false;
        }
      }
    }
    return true;
  };

  Matrix.prototype.pow = function (n) {
    if (!(n >= 0 && n <= Number.MAX_SAFE_INTEGER)) {
      throw new RangeError();
    }
    var pow = function (x, count, accumulator) {
      return (count < 1 ? accumulator : (2 * Math.floor(count / 2) !== count ? pow(x, count - 1, accumulator.multiply(x)) : pow(x.multiply(x), Math.floor(count / 2), accumulator)));
    };
    return pow(this, n, Matrix.I(this.rows()));
  };

  /*
  // TODO: remove
  Matrix.prototype.stripZeroRows = function () {
    var rows = this.rows();
    var cols = this.cols();
    var i = rows;
    var j = cols;
    while (j === cols && --i >= 0) {
      j = 0;
      while (j < cols && this.e(i, j).equals(Expression.ZERO)) {
        j += 1;
      }
    }
    i += 1;
    var that = this;
    return i === rows ? this : Matrix.Zero(i, cols).map(function (e, i, j) {
      return that.e(i, j);
    });
  };
  */

  // string -> array of array of strings, find `extraPositionOffset`
  Matrix.split = function (input) {
    input = input.replace(/\b(sin|cos)\x20/g, '$1\u200B');
    var result = [];
    var m = input;
    if (/^\s*\[[^\[\]]*\]\s*$/.exec(m) != undefined) {//!
      m = m.replace(/\[/g, " ");
      m = m.replace(/\]/g, " ");
    }//!
    if (m.replace(/^\s+|\s+$/g, "") !== "") {
      m = m.replace(/;/g, "\n");//? ; -> \n
      m = m.replace(/\r/g, "\n");
      var row = [];
      result.push(row);
      var position = 0;
      var match = undefined;
      while ((match = /^\s*\S+/.exec(m.slice(position))) != undefined) {
        var t = match[0];
        if (t.indexOf("\n") !== -1 && row.length !== 0) {
          row = [];
          result.push(row);
          t = t.replace(/\n/g, " ");
        }
        row.push(t);
        position += t.length;
      }
    }
    return result;
  };

  Matrix.padRows = function (array, convertFunction) {
    var rows = array.length;
    var cols = 0;
    for (var k = 0; k < array.length; k += 1) {
      cols = Math.max(cols, array[k].length);
    }
    var data = new Array(rows);
    for (var i = 0; i < rows; i += 1) {
      var y = array[i];
      var x = new Array(cols);
      for (var j = 0; j < cols; j += 1) {
        x[j] = j < y.length ? (convertFunction != null ? convertFunction(y[j]) : y[j]) : Expression.ZERO;
      }
      data[i] = x;
    }
    return new Matrix(data);
  };

  Matrix.solveByGaussNext = function (m, callback) {
    var pivotRows = new Array(m.cols() - 1);
    for (var k = 0; k < m.cols() - 1; k += 1) {
      pivotRows[k] = -1;
    }
    for (var i = m.rows() - 1; i >= 0; i -= 1) {
      var j = 0;
      while (j < m.cols() - 1 && m.e(i, j).equals(Expression.ZERO)) {
        j += 1;
      }
      // first not zero in a row - main variable
      if (j < m.cols() - 1) {
        pivotRows[j] = i;
        var oldMatrix1 = m;
        // reduce i-th row
        for (var k = j + 1; k < m.cols() - 1; k += 1) {
          if (!m.e(i, k).equals(Expression.ZERO)) {
            var pivotRow = pivotRows[k];
            if (pivotRow !== -1) {
              m = m.rowReduce(i, pivotRow, k);
            }
          }
        }
        var oldMatrix2 = m;
        // divide i-th row by m.e(i, j)
        if (!m.e(i, j).equals(Expression.ONE)) {
          var c = m.e(i, j);
          m = m.map(function (e, row, column) {
            return row === i ? e.divide(c) : e;
          });
        }
        if (callback != undefined) {
          callback(m, oldMatrix1, oldMatrix2, i, j);
        }
      }
    }
    return m;
  };

  //TODO: ?
  Matrix.getPivotRow = function (m, k) {
    var i = m.rows() - 1;
    while (i >= 0 && m.e(i, k).equals(Expression.ZERO)) {
      i -= 1;
    }
    if (i >= 0) {
      var j = k - 1;
      while (j >= 0 && m.e(i, j).equals(Expression.ZERO)) {
        j -= 1;
      }
      if (j < 0) {
        return i;
      }
    }
    return -1;
  };

  //TODO: fix
  Matrix.getSolutionSet = function (m) {
    var result = {
      basisVectors: [],
      variables: []
    };
    for (var k = 0; k < m.cols() - 1; k += 1) {
      if (Matrix.getPivotRow(m, k) === -1) {
        // a basis vector for k-th variable
        var bx = new Array(m.cols() - 1);
        for (var j = 0; j < m.cols() - 1; j += 1) {
          var i = Matrix.getPivotRow(m, j); // a solution row for j-th variable, -1 if it is a free variable
          bx[j] = i !== -1 ? m.e(i, k).negate() : (j === k ? Expression.ONE : Expression.ZERO);
        }
        var basisVector = new Vector(bx);
        result.basisVectors.push(basisVector);
        result.variables.push(k);
      }
    }
    return result;
  };

  Matrix.prototype.minorMatrix = function (k, l) {
    var that = this;
    return Matrix.Zero(this.rows() - 1, this.cols() - 1).map(function (e, i, j) {
      return that.e(i < k ? i : i + 1, j < l ? j : j + 1);
    });
  };

  Matrix.toRowEchelonWithCallback = function (matrix, method, usage, changeCallback, resultCallback) {
    var result = matrix.toRowEchelonXXX(method, usage, changeCallback, Condition.TRUE);
    var w = function (result) {
      if (result.c1 == undefined && result.c2 == undefined) {
        resultCallback(result);
      } else {
        w(result.a1());
        w(result.a2());
      }
    };
    w(result);
  };

  Matrix.prototype.isDiagonal = function () {
    return this.eql(this.map(function (e, i, j) {
      return i !== j ? Expression.ZERO : e;
    }));
  };
  Matrix.prototype.isNilpotent = function () {
    var x = this.map(function (e, i, j) {
      return j <= i ? Expression.ZERO : e;
    });
    if (this.eql(x)) {
      //! This method only tests if it nilpotent based on a property and so may return false for the positive result
      return true;
    }
    //TODO: test case for non-triangular - ?
    return this.pow(this.cols()).eql(Matrix.Zero(this.cols(), this.cols()));
  };
  //TODO: use in solution steps (?)
  Matrix.prototype.isJordanMatrix = function () {//TODO: fix
    var that = this;
    return this.eql(this.map(function (e, i, j) {
      return i === j ? e : (j === i + 1 && that.e(i, i).equals(that.e(i + 1, i + 1)) && !that.e(i, j).equals(Expression.ZERO) ? Expression.ONE : Expression.ZERO);
    }));
  };
  Matrix.prototype.isZero = function () {
    return this.eql(Matrix.Zero(this.rows(), this.cols()));
  };

  function Vector(elements) {
    this.elements = elements;
  }

  Vector.prototype.e = function (index) {
    return this.elements[index];
  };

  Vector.prototype.dimensions = function () {
    return this.elements.length;
  };

  //TODO: ?
  Vector.prototype.rows = function () {
    return this.dimensions();
  };
  Vector.prototype.cols = function () {
    return 1;
  };
  Vector.prototype.isExact = function () {
    for (var i = 0; i < this.dimensions(); i += 1) {
      if (!this.e(i).isExact()) {
        return false;
      }
    }
    return true;
  };

  Vector.prototype.toString = function (options) {
    return Matrix.prototype.toString.call(this, options);
  };

  Vector.prototype.dot = function (other) {
    var result = Expression.ZERO;
    for (var i = 0; i < Math.max(this.dimensions(), other.dimensions()); i += 1) {
      var s = this.e(i).multiply(other.e(i).getNumerator() instanceof Expression.Complex ? other.e(i).getNumerator().conjugate().divide(other.e(i).getDenominator()) : other.e(i));
      result = result === Expression.ZERO ? s : result.add(s);
    }
    return result;
  };
  Vector.prototype.toUnitVector = function () {
    var norm = this.dot(this).squareRoot();
    return this.scale(norm.inverse());
  };

  Vector.prototype.scale = function (s) {
    return new Vector(this.elements.map(function (e) { return s.multiply(e); }));
  };
  Vector.prototype.subtract = function (other) {
    if (this.dimensions() !== other.dimensions()) {
      throw new RangeError("MatrixDimensionMismatchException");
    }
    return new Vector(this.elements.map(function (e, i) { return e.subtract(other.e(i)); }));
  };

  Vector.prototype.eql = function (other) {
    if (this.dimensions() !== other.dimensions()) {
      throw new RangeError("MatrixDimensionMismatchException");
    }
    for (var i = 0; i < this.dimensions(); i += 1) {
      if (!this.e(i).equals(other.e(i))) {
        return false;
      }
    }
    return true;
  };
  Vector.Zero = function (n) {
    return new Vector(new Array(n).fill(Expression.ZERO));
  };

  Matrix.Vector = Vector;

  Matrix.prototype.row = function (i) {
    var elements = new Array(this.cols());
    for (var j = 0; j < this.cols(); j += 1) {
      elements[j] = this.e(i, j);
    }
    return new Vector(elements);
  };
  Matrix.prototype.col = function (j) {
    var elements = new Array(this.rows());
    for (var i = 0; i < this.rows(); i += 1) {
      elements[i] = this.e(i, j);
    }
    return new Vector(elements);
  };

  self.Matrix = Matrix;

})();
(function () {
"use strict";

// https://lowrey.me/es6-javascript-combination-generator/
// https://www.npmjs.com/package/combinations-generator

function combinations (elements, k) {
  var n = elements.length;
  var indexes = new Array(k + 1).fill(-1);
  var result = new Array(k).fill(undefined);
  var depth = 0;
  var iterator = {
    next: function () {
      while (depth >= 0) {
        if (depth < k) {
          var i = indexes[depth];
          if (i < n - k + depth) {
            indexes[depth] = i + 1;
            result[depth] = elements[i + 1];
            depth += 1;
            indexes[depth] = i + 1;
          } else {
            depth -= 1;
          }
        } else {
          depth -= 1;
          return {value: result.slice(0), done: false};
        }
      }
      return {value: undefined, done: true};
    }
  };
  iterator[globalThis.Symbol.iterator] = function () {
    return this;
  };
  return iterator;
}

self.combinations = combinations;

})();
(function () {
"use strict";







// Books:
// Henri Cohen "A Course in Computational Algebraic Number Theory"
// "Computer algebra and symbolic computation Mathematical Methods" Joel S. Cohen
// "The art of computer programming. Vol.2: Seminumerical algorithms" Donald E. Knuth
// https://en.wikipedia.org/wiki/Finite_field
// https://en.wikipedia.org/wiki/Factorization_of_polynomials_over_finite_fields
// https://en.wikipedia.org/wiki/Factorization_of_polynomials#Factoring_univariate_polynomials_over_the_integers


var nextPrime = primeFactor._nextPrime;

function ExtendedEuclideanAlgorithm(A, B, p) {
  // U * A + V * B = gcd(A, B) (mod p)
  A = A.mod(p);
  B = B.mod(p);
  // https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Pseudocode
  var $newold_r = A; var $newr =  B; var old_r = $newold_r; var r = $newr;
  var ONE = Polynomial.of(Expression.ONE);//TODO: ?
  var $newold_s = ONE; var $news =  Polynomial.ZERO; var old_s = $newold_s; var s = $news;
  var $newold_t = Polynomial.ZERO; var $newt =  ONE; var old_t = $newold_t; var t = $newt;
  while (!r.equals(Polynomial.ZERO)) {
    var multiplier = r.getLeadingCoefficient().modInverse(p);
    var quotient = old_r.scale(multiplier).mod(p).divideAndRemainderModP(r.scale(multiplier).mod(p), "throw", p).quotient;
    var $newold_r = r; var $newr =  old_r.subtract(quotient.multiply(r)).mod(p); old_r = $newold_r; r = $newr;
    var $newold_s = s; var $news =  old_s.subtract(quotient.multiply(s)).mod(p); old_s = $newold_s; s = $news;
    var $newold_t = t; var $newt =  old_t.subtract(quotient.multiply(t)).mod(p); old_t = $newold_t; t = $newt;
  }
  var k = old_r.getLeadingCoefficient().modInverse(p);
  var gcd = old_r.scale(k).mod(p);
  var U = old_s.scale(k).mod(p);
  var V = old_t.scale(k).mod(p);
  return {
    U: U,
    V: V,
    gcd: gcd
  };
}


// https://en.wikipedia.org/wiki/Factorization_of_polynomials_over_finite_fields#Equal-degree_factorization

Expression.Integer.prototype.modulo = function modulo(p) {
  var r = this.remainder(p);
  return r.compareTo(Expression.ZERO) < 0 ? r.add(p) : r;
};

Polynomial.prototype.modPow = function (n, m, q) {
  var p = this;
  var accumulator = null;
  while (n.compareTo(Expression.ZERO) > 0) {
    if (n.remainder(Expression.TWO).compareTo(Expression.ZERO) !== 0) {
      n = n.subtract(Expression.ONE);
      accumulator = (accumulator == null ? p : accumulator.multiply(p).mod(q)).divideAndRemainderModP(m, "throw", q).remainder;
    } else {
      n = n.truncatingDivide(Expression.TWO);
      p = p.multiply(p).mod(q).divideAndRemainderModP(m, "throw", q).remainder;
    }
  }
  return accumulator;
};

function distinctDegreeFactorization(f, p) {
  f = f.mod(p);
  // copy-paste of pseudo code from Wikipedia - https://en.wikipedia.org/wiki/Factorization_of_polynomials_over_finite_fields#Distinct-degree_factorization
  var i = 1;
  var S = [];
  var fStar = f;
  fStar = toMonic(fStar, p);
  var q = p;
  var x = Polynomial.of(Expression.ONE).shift(1);//TODO: ?
  var xInQInI = x.modPow(q, fStar, q); // x**(q**i)
  while (fStar.getDegree() >= 2 * i) {
    //TODO: see the Wikipedia page for some optimizations - ?
    var h = xInQInI.subtract(x).divideAndRemainderModP(fStar, "throw", q).remainder;
    var g = gcdOfPolynomialsOverFiniteField(fStar, h, q);
    if (g.getDegree() !== 0) {
      S.push({factor: g, degree: i});
      fStar = fStar.divideAndRemainderModP(g, "throw", q).quotient;
    }
    i = i + 1;
    xInQInI = xInQInI.modPow(q, fStar, q);
  }
  if (fStar.getDegree() > 0) {
    S.push({factor: fStar, degree: fStar.getDegree()});
  }
  if (S.length === 0) {
    S.push({factor: f, degree: 1});
  }
  return S;
}

function randomBigInt(size, random) {
random = random == undefined ?  Math.random : random;

  console.assert(Math.floor(size) === size);
  if (size <= 52) {
    return Math.floor(random() * Math.pow(2, size));
  }
  var q = Math.ceil(size / (2 * 52)) * 52;
  return (BigInt(randomBigInt(size - q, random)) << BigInt(q)) + BigInt(randomBigInt(q, random));
}
function randomPolynomial(maxCoefficient, maxDegree, random) {
  var maxCoefficientSize = maxCoefficient.bitLength();
  var coefficients = new Array(maxDegree);
  for (var i = 0; i < maxDegree; i += 1) {
    coefficients[i] = Expression.Integer.fromBigInt(randomBigInt(maxCoefficientSize, random)).remainder(maxCoefficient);
  }
  return Polynomial.from(coefficients);
}
Polynomial.random = randomPolynomial;//TODO: remove - ?

function CantorZassenhausAlgorithm(f, p, factorsDegree) {
  f = f.mod(p);
  f = toMonic(f, p);//TODO: is it needed here, test - ?
  // copy-paste of pseudo code from Wikipedia - https://en.wikipedia.org/wiki/Factorization_of_polynomials_over_finite_fields#Cantor–Zassenhaus_algorithm
  var n = f.getDegree();
  var d = factorsDegree;
  var r = n / d;
  var q = p;
  var Factors = [];
  Factors.push(f);
  var random = new Math.seedrandom('hello.');
  while (Factors.length < r) {
    var h = randomPolynomial(q, n, random);
    var ONE = Polynomial.of(Expression.ONE);
    var g = h.modPow((q._pow(d).subtract(Expression.ONE)).truncatingDivide(Expression.TWO), f, q).subtract(ONE).divideAndRemainderModP(f, "throw", q).remainder;
    var updatedFactors = [];
    for (var iteratoru = Factors[globalThis.Symbol.iterator](), u = iteratoru.next().value; u != null; u = iteratoru.next().value) {
      var gcd = gcdOfPolynomialsOverFiniteField(g, u, q);
      if (gcd.getDegree() !== 0 && gcd.getDegree() !== u.getDegree()) {
        updatedFactors.push(gcd);
        updatedFactors.push(u.divideAndRemainderModP(gcd, "throw", q).quotient);
      } else {
        updatedFactors.push(u);
      }
    }
    Factors = updatedFactors;
  }
  return Factors;
}


function factorizeOverTheFiniteField(f, p) {
  if (!isFactorizationOverZpSquareFree(f, p)) {
    throw new RangeError("implemented only for square-free polynomials");
  }
  var factorization = [];
  var distinctDegreeFactors = distinctDegreeFactorization(f, p);
  for (var iteratorddf = distinctDegreeFactors[globalThis.Symbol.iterator](), ddf = iteratorddf.next().value; ddf != null; ddf = iteratorddf.next().value) {
    var equalDegreeFactors = CantorZassenhausAlgorithm(ddf.factor, p, ddf.degree);
    factorization = factorization.concat(equalDegreeFactors);
  }
  return factorization;
}


Polynomial.prototype.mod = function (m) {
  return this.map(function (c) { return c.modulo(m); });
};
Polynomial.prototype.mod2 = function (m) {
  return this.mod(m).map(function (c) { return c.subtract(m).add(c).compareTo(Expression.ZERO) < 0 ? c : c.subtract(m); });
};

function toMonic(f, p) {
  if (f.getLeadingCoefficient().compareTo(Expression.ZERO) === 0) {
    return f;
  }
  var scale = f.getLeadingCoefficient().modInverse(p);
  return f.map(function (c) { return c.multiply(scale).modulo(p); });
}

//@private
Polynomial.prototype.divideAndRemainderModP = function (divisor, w, p) {
  if (w !== "throw") {
    throw new RangeError();
  }
  //var tmp = this.divideAndRemainder(divisor, "throw");
  //return {quotient: tmp.quotient.mod(p), remainder: tmp.remainder.mod(p)};
  var dividend = this;
  var divisorLeadingCoefficient = divisor.getLeadingCoefficient();
  if (divisorLeadingCoefficient.compareTo(Expression.ONE) !== 0) {
    throw new RangeError();
  }
  var divisorDegree = divisor.getDegree();
  //if (!divisor.mod(p).equals(divisor)) {
  //  throw new RangeError();//TODO: REMOVE
  //}
  //var remainder = dividend;
  var remainder = new Array(dividend.getDegree() + 1).fill(Expression.ZERO);
  for (var i = 0; i < dividend.a.size; i += 1) {
    remainder[dividend.a.degree(i)] = dividend.a.coefficient(i);
  }
  //var remainderDegree = remainder.getDegree();
  var remainderDegree = remainder.length - 1;
  var quotient = new Array(Math.max(remainderDegree - divisorDegree + 1, 0)).fill(Expression.ZERO);
  while (remainderDegree >= divisorDegree) {
    var n = remainderDegree - divisorDegree;
    var q = remainder[remainderDegree];
    //var q = remainder.getLeadingCoefficient();
    quotient[n] = q;
    //TODO: optimize
    //remainder = remainder.subtract(divisor.shift(n).scale(q)).mod(p);
    for (var j = 0; j < divisor.a.size; j += 1) {
      var degree = divisor.a.degree(j);
      var coefficient = divisor.a.coefficient(j);
      remainder[degree + n] = remainder[degree + n].subtract(q.multiply(coefficient)).modulo(p);
    }
    while (remainderDegree >= 0 && remainder[remainderDegree].compareTo(Expression.ZERO) === 0) {
      remainderDegree -= 1;
    }
  }
  return {quotient: Polynomial.from(quotient), remainder: Polynomial.from(remainder)};
};

function gcdOfPolynomialsOverFiniteField(a, b, p) {
  a = a.mod(p);
  b = b.mod(p);
  b = toMonic(b, p);
  //TODO: make monic - ?
  while (!b.equals(Polynomial.ZERO)) {
    var r = a.divideAndRemainderModP(b, "throw", p).remainder;
    r = toMonic(r, p);
    a = b;
    b = r;
  }
  return a;
}

function isFactorizationOverZpSquareFree(u, prime) {
  var f = u;
  return gcdOfPolynomialsOverFiniteField(f, f.derive(), prime).getDegree() === 0;
}

// The art of computer programming. Vol.2: Seminumerical algorithms, page 452
function factorizeOverTheIntegers(u, useHenselLifting) {
useHenselLifting = useHenselLifting == undefined ?  true : useHenselLifting;

  var polynomial = u;
  if (u.getCoefficient(0).equals(Expression.ZERO)) {
    return Polynomial.of(Expression.ZERO, Expression.ONE);
  }
  if (u.getCoefficient(0).abs().bitLength() - u.getLeadingCoefficient().abs().bitLength() < -50) {//?
    var factor = factorizeOverTheIntegers(u._exponentiateRoots(-1), useHenselLifting);
    return factor == null ? null : factor._exponentiateRoots(-1);
  }
  var checkBothVariants = true;
  var getBound = function (p) {
    if (checkBothVariants) {
      return Math.min(p._log2OfBoundForCoefficientsOfFactor(Math.floor(p.getDegree() / 2), p.getLeadingCoefficient().abs()),
                      p._log2OfBoundForCoefficientsOfFactor(p.getDegree(), Expression.Integer.fromBigInt(nthRoot(p.getLeadingCoefficient().abs().toBigInt(), 2))));
    }
    return p._log2OfBoundForCoefficientsOfFactor(p.getDegree(), p.getLeadingCoefficient().abs());
  };
  var B = Math.min(getBound(u), getBound(u._exponentiateRoots(-1)));//TODO: REMOVE

  var prime = undefined;
  var nextGoodPrime = function (integer) {
    var p = integer;
    do {
      p = Expression.Integer.fromBigInt(nextPrime(p.toBigInt()));
    } while (u.getLeadingCoefficient().remainder(p).compareTo(Expression.ZERO) === 0 || !isFactorizationOverZpSquareFree(u, p));
    return p;
  };
  var log2 = function (b) {
    //TODO: ?
    var e = b.bitLength();
    return Math.log2(b.truncatingDivide(Expression.TWO._pow(Math.max(0, e - 53))).toNumber()) + Math.max(0, e - 53);
  };
  //var useHenselLifting = true;//TODO: ?
  if (!useHenselLifting) {
    prime = nextGoodPrime(Expression.TWO._pow(Math.ceil(1 + log2(u.getLeadingCoefficient().abs()) + B)));
  } else {
    prime = nextGoodPrime(Expression.TWO);
  }
  var tryMultiplePrimes = !useHenselLifting ? 0 : 2;
  if (tryMultiplePrimes !== 0) {
    var best = prime;
    var bestFactorsNumber = 1 / 0;
    for (var tries = 0; tries < tryMultiplePrimes; tries += 1) {
      var factorsNumber = 0;
      for (var iteratorentry = distinctDegreeFactorization(u, prime)[globalThis.Symbol.iterator](), entry = iteratorentry.next().value; entry != null; entry = iteratorentry.next().value) {
        factorsNumber += (entry.factor.getDegree() / entry.degree);
      }
      if (bestFactorsNumber > factorsNumber) {
        best = prime;
        bestFactorsNumber = factorsNumber;
      }
      prime = nextGoodPrime(prime);
    }
    prime = best;
  }
  var factors = factorizeOverTheFiniteField(u, prime);
  var q = prime;
  if (useHenselLifting) {
    var e = Math.ceil((1 + log2(u.getLeadingCoefficient().abs()) + B) / Math.log2(prime.toNumber()));
    if (useQuadraticHenselLift) {
      e = Math.pow(2, Math.ceil(Math.log2(e)));
    }
    factors = HenselLifting(u, factors, prime, e);
    q = prime._pow(e);
  }
  //!!! (number of factors depends on the choise of prime numbers)
  //TODO: how to reduce number of iterations (?) (see Donald Knuth's book)
  var c = 0;
  for (var countOfFactors = 1; countOfFactors <= (checkBothVariants ? factors.length - 1 : Math.floor(factors.length / 2)); countOfFactors += 1) {
    var combinationsIterator = combinations(factors, countOfFactors);
    var combination = null;
    while ((combination = combinationsIterator.next().value) != null) {
      c += 1;
      // an optimization from the Donald Knuth's book, page 452
      var productTrailingCoefficient = u.getLeadingCoefficient();
      for (var iteratorf = combination[globalThis.Symbol.iterator](), f = iteratorf.next().value; f != null; f = iteratorf.next().value) {
        productTrailingCoefficient = productTrailingCoefficient.multiply(f.getCoefficient(0)).modulo(q);
      }
      productTrailingCoefficient = Polynomial.of(productTrailingCoefficient).mod2(q).getCoefficient(0);
      if (u.getCoefficient(0).multiply(u.getLeadingCoefficient()).remainder(productTrailingCoefficient).equals(Expression.ZERO)) {
        var v = productModQ(combination, q);
        console.assert(v.getLeadingCoefficient().compareTo(Expression.ONE) === 0);
        v = v.scale(u.getLeadingCoefficient());
        v = v.mod2(q);
        //TODO: test, we need to try w(x) = productModQ(factors.filter(function (factor) { return combination.indexOf(factor) === -1; }), q) as well (see Donald Knuth's book) - ?
        console.assert(v.getDegree() < u.getDegree());
        //if (v.getDegree() <= u.getDegree() / 2 || v.getDegree() < u.getDegree()) {
          //v = v.primitivePart();
          var tmp = u.scale(u.getLeadingCoefficient()).divideAndRemainder(v, "undefined");
          if (tmp != undefined && tmp.remainder.equals(Polynomial.ZERO)) {
            v = v.primitivePart();
            factors = factors.filter(function (factor) { return combination.indexOf(factor) === -1; });
            combinationsIterator = combinations(factors, countOfFactors);//!?
            u = tmp.quotient;
            return v;
          }
        //}
      }
    }
  }
if (c > 16) {
  console.debug(c);
}
  if (!polynomial.subtract(u).equals(Polynomial.ZERO)) {
    u = u.primitivePart();//?
    return u;
  }
  return null;
}


function HenselLift(C, A, B, U, V, q, r) { // q -> q * r
  /*
  // https://www.csd.uwo.ca/~mmorenom/CS874/Lectures/Newton2Hensel.html/node17.html#eq:FactorizationLiftingProblem
  //C = C.map(function (c) { return new IntegerModuloPrimeNumber(c, Expression.Integer.fromBigInt(p**2)); })
  //TODO: ?
  var e = C.subtract(A.multiply(B));
  var A1 = A.add(U.multiply(e));
  var B1 = B.add(V.multiply(e));
  return {A1: A1, B1: B1};
  */
  // http://tomlr.free.fr/Math%E9matiques/Math%20Complete/Number%20theory/A%20course%20in%20computational%20algebraic%20number%20theory%20-%20Cohen%20H..pdf
  // Algorithm 3.5.5 (Hensel Lift).
  // A,B,C are polynomials over Integers:
  console.assert(A.hasIntegerCoefficients());
  console.assert(B.hasIntegerCoefficients());
  console.assert(C.hasIntegerCoefficients());
  var f = C.subtract(A.multiply(B)).scale(q.inverse()).mod(r);
  var t = V.multiply(f).mod(r).divideAndRemainderModP(A, "throw", r).quotient;
  var A0 = V.multiply(f).subtract(A.multiply(t)).mod(r);
  var B0 = U.multiply(f).add(B.multiply(t)).mod(r);
  var A1 = A.add(A0.scale(q));
  var B1 = B.add(B0.scale(q));
  return {A1: A1.mod(q.multiply(r)), B1: B1.mod(q.multiply(r))};
}
function QuadraticHenselLift(C, A, B, U, V, q, p) {
  // http://tomlr.free.fr/Math%E9matiques/Math%20Complete/Number%20theory/A%20course%20in%20computational%20algebraic%20number%20theory%20-%20Cohen%20H..pdf
  // Algorithm 3.5.6 
  var tmp = HenselLift(C, A, B, U, V, q, p);
  var A1 = tmp.A1;
  var B1 = tmp.B1;
  var g = Polynomial.of(Expression.ONE).subtract(U.multiply(A1)).subtract(V.multiply(B1)).scale(p.inverse()).mod(p);
  var t = V.multiply(g).mod(q).divideAndRemainderModP(A1.mod(q), "throw", q).quotient;
  var U0 = U.multiply(g).add(B1.multiply(t)).mod(q);
  var V0 = V.multiply(g).subtract(A1.multiply(t)).mod(q);
  var U1 = U.add(U0.scale(p));
  var V1 = V.add(V0.scale(p));
  //return HenselLift(C, A1, B1, U1, V1, BigInt(q) * BigInt(p.toBigInt()), BigInt(p.toBigInt()) * BigInt(p.toBigInt()));
  return {A1: A1, B1: B1, U1: U1.mod(q.multiply(p)), V1: V1.mod(q.multiply(p))};
}
var useQuadraticHenselLift = true;
function HenselLiftingOfTwoFactors(C, A, B, p, k) {
  if (useQuadraticHenselLift && k === Math.pow(2, Math.ceil(Math.log2(k)))) { // TODO: any degree
    //TODO: ???
    var q = p;
    var tmp1 = ExtendedEuclideanAlgorithm(A, B, p);
    console.assert(tmp1.gcd.getDegree() === 0);
    var U = tmp1.U;
    var V = tmp1.V;
    for (var i = 1; i < k / 2; i *= 2) {
      var tmp = QuadraticHenselLift(C, A, B, U, V, q, p);
      A = tmp.A1;
      B = tmp.B1;
      U = tmp.U1;
      V = tmp.V1;
      q = q.multiply(q);
      p = p.multiply(p);
    }
    var tmp = HenselLift(C, A, B, U, V, q, p);
    A = tmp.A1;
    B = tmp.B1;
    return {A1: A, B1: B};
  }
  //TODO: ?
  var q = p;
  for (var i = 1; i < k; i += 1) {
    var tmp1 = ExtendedEuclideanAlgorithm(A, B, p);
    console.assert(tmp1.gcd.getDegree() === 0);
    var tmp = HenselLift(C, A, B, tmp1.U, tmp1.V, q, p);
    A = tmp.A1;
    B = tmp.B1;
    q = q.multiply(p);
  }
  return {A1: A, B1: B};
}
//function product(factors) {
//  console.assert(factors.length > 0);
//  return factors.length > 1 ? product(factors.slice(0, Math.ceil(factors.length / 2))).multiply(product(factors.slice(Math.ceil(factors.length / 2)))) : factors[0];
//}
function productModQ(factors, q) {
  console.assert(factors.length > 0);
  return factors.length > 1 ? productModQ(factors.slice(0, Math.ceil(factors.length / 2)), q).multiply(productModQ(factors.slice(Math.ceil(factors.length / 2)), q)).mod(q) : factors[0];
}
function HenselLifting(f, factors, p, e) {
  // https://scholar.rose-hulman.edu/cgi/viewcontent.cgi?article=1163&context=math_mstr
  // "2.3 Factoring mod p e: Hensel Lifting"
  var C = f;
  var newFactors = [];
  var c = C.getLeadingCoefficient().modulo(p);
  if (c.compareTo(Expression.ONE) !== 0) {
    factors = factors.concat([Polynomial.of(c)]);
  }
  if (true && factors.length > 1) {
    //TODO: check this code !!!
    // divide and conquer
    var A = factors.slice(0, Math.ceil(factors.length / 2));
    var B = factors.slice(Math.ceil(factors.length / 2));
    var tmp = HenselLiftingOfTwoFactors(C, productModQ(A, p), productModQ(B, p), p, e);
    if (c.compareTo(Expression.ONE) !== 0) {
      B = B.slice(0, -1);
    }
    return HenselLifting(tmp.A1, A, p, e).concat(HenselLifting(tmp.B1, B, p, e));
  }
  for (var i = 0; i < factors.length - 1; i += 1) {
    var A = factors[i];
    var tmp = HenselLiftingOfTwoFactors(C, A, productModQ(factors.slice(i + 1), p), p, e);
    newFactors.push(tmp.A1);
    C = tmp.B1;
  }
  if (C.getDegree() > 0) {
    newFactors.push(C);
  } else {
    console.assert(c.compareTo(Expression.ONE) !== 0);
  }
  var pInE = p._pow(e);
  newFactors = newFactors.map(function (factor) { return toMonic(factor.mod(pInE), pInE); });//TODO: ?
  return newFactors;
}

//  
Polynomial.prototype._factorizeOverTheIntegers = function () {
  //return factorizeOverTheIntegers(this).next().value;
  return factorizeOverTheIntegers(this);
};
Polynomial._gcdOfPolynomialsOverFiniteField = gcdOfPolynomialsOverFiniteField;//TODO: ?

self.factorizeOverTheIntegers = factorizeOverTheIntegers;

factorizeOverTheIntegers.testables = {
  gcdOfPolynomialsOverFiniteField: gcdOfPolynomialsOverFiniteField,
  distinctDegreeFactorization: distinctDegreeFactorization,
  CantorZassenhausAlgorithm: CantorZassenhausAlgorithm,
  factorizeOverTheFiniteField: factorizeOverTheFiniteField,
  ExtendedEuclideanAlgorithm: ExtendedEuclideanAlgorithm,
  HenselLift: HenselLift,
  HenselLifting: HenselLifting,
  randomBigInt: randomBigInt
};

})();
(function () {
"use strict";
/*
Copyright 2019 David Bau.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/

(function (global, pool, math) {
//
// The following constants are related to IEEE 754 limits.
//

var width = 256,        // each RC4 output is 0 <= x < 256
    chunks = 6,         // at least six RC4 outputs for each double
    digits = 52,        // there are 52 significant digits in a double
    rngname = 'random', // rngname: name for Math.random and Math.seedrandom
    startdenom = math.pow(width, chunks),
    significance = math.pow(2, digits),
    overflow = significance * 2,
    mask = width - 1,
    nodecrypto;         // node.js crypto module, initialized at the bottom.

//
// seedrandom()
// This is the seedrandom function described above.
//
function seedrandom(seed, options, callback) {
  var key = [];
  options = (options == true) ? { entropy: true } : (options || {});

  // Flatten the seed string or build one from local entropy if needed.
  var shortseed = mixkey(flatten(
    options.entropy ? [seed, tostring(pool)] :
    (seed == null) ? autoseed() : seed, 3), key);

  // Use the seed to initialize an ARC4 generator.
  var arc4 = new ARC4(key);

  // This function returns a random double in [0, 1) that contains
  // randomness in every bit of the mantissa of the IEEE 754 value.
  var prng = function() {
    var n = arc4.g(chunks),             // Start with a numerator n < 2 ^ 48
        d = startdenom,                 //   and denominator d = 2 ^ 48.
        x = 0;                          //   and no 'extra last byte'.
    while (n < significance) {          // Fill up all significant digits by
      n = (n + x) * width;              //   shifting numerator and
      d *= width;                       //   denominator and generating a
      x = arc4.g(1);                    //   new least-significant-byte.
    }
    while (n >= overflow) {             // To avoid rounding up, before adding
      n /= 2;                           //   last byte, shift everything
      d /= 2;                           //   right using integer math until
      x >>>= 1;                         //   we have exactly the desired bits.
    }
    return (n + x) / d;                 // Form the number within [0, 1).
  };

  prng.int32 = function() { return arc4.g(4) | 0; }
  prng.quick = function() { return arc4.g(4) / 0x100000000; }
  prng.double = prng;

  // Mix the randomness into accumulated entropy.
  mixkey(tostring(arc4.S), pool);

  // Calling convention: what to return as a function of prng, seed, is_math.
  return (options.pass || callback ||
      function(prng, seed, is_math_call, state) {
        if (state) {
          // Load the arc4 state from the given state if it has an S array.
          if (state.S) { copy(state, arc4); }
          // Only provide the .state method if requested via options.state.
          prng.state = function() { return copy(arc4, {}); }
        }

        // If called as a method of Math (Math.seedrandom()), mutate
        // Math.random because that is how seedrandom.js has worked since v1.0.
        if (is_math_call) { math[rngname] = prng; return seed; }

        // Otherwise, it is a newer calling convention, so return the
        // prng directly.
        else return prng;
      })(
  prng,
  shortseed,
  'global' in options ? options.global : (this == math),
  options.state);
}

//
// ARC4
//
// An ARC4 implementation.  The constructor takes a key in the form of
// an array of at most (width) integers that should be 0 <= x < (width).
//
// The g(count) method returns a pseudorandom integer that concatenates
// the next (count) outputs from ARC4.  Its return value is a number x
// that is in the range 0 <= x < (width ^ count).
//
function ARC4(key) {
  var t, keylen = key.length,
      me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];

  // The empty key [] is treated as [0].
  if (!keylen) { key = [keylen++]; }

  // Set up S using the standard key scheduling algorithm.
  while (i < width) {
    s[i] = i++;
  }
  for (i = 0; i < width; i++) {
    s[i] = s[j = mask & (j + key[i % keylen] + (t = s[i]))];
    s[j] = t;
  }

  // The "g" method returns the next (count) outputs as one number.
  (me.g = function(count) {
    // Using instance members instead of closure state nearly doubles speed.
    var t, r = 0,
        i = me.i, j = me.j, s = me.S;
    while (count--) {
      t = s[i = mask & (i + 1)];
      r = r * width + s[mask & ((s[i] = s[j = mask & (j + t)]) + (s[j] = t))];
    }
    me.i = i; me.j = j;
    return r;
    // For robust unpredictability, the function call below automatically
    // discards an initial batch of values.  This is called RC4-drop[256].
    // See http://google.com/search?q=rsa+fluhrer+response&btnI
  })(width);
}

//
// copy()
// Copies internal state of ARC4 to or from a plain object.
//
function copy(f, t) {
  t.i = f.i;
  t.j = f.j;
  t.S = f.S.slice();
  return t;
};

//
// flatten()
// Converts an object tree to nested arrays of strings.
//
function flatten(obj, depth) {
  var result = [], typ = (typeof obj), prop;
  if (depth && typ == 'object') {
    for (prop in obj) {
      try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
    }
  }
  return (result.length ? result : typ == 'string' ? obj : obj + '\0');
}

//
// mixkey()
// Mixes a string seed into a key that is an array of integers, and
// returns a shortened string seed that is equivalent to the result key.
//
function mixkey(seed, key) {
  var stringseed = seed + '', smear, j = 0;
  while (j < stringseed.length) {
    key[mask & j] =
      mask & ((smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++));
  }
  return tostring(key);
}

//
// autoseed()
// Returns an object for autoseeding, using window.crypto and Node crypto
// module if available.
//
function autoseed() {
  try {
    var out;
    if (nodecrypto && (out = nodecrypto.randomBytes)) {
      // The use of 'out' to remember randomBytes makes tight minified code.
      out = out(width);
    } else {
      out = new Uint8Array(width);
      (global.crypto || global.msCrypto).getRandomValues(out);
    }
    return tostring(out);
  } catch (e) {
    var browser = global.navigator,
        plugins = browser && browser.plugins;
    return [+new Date, global, plugins, global.screen, tostring(pool)];
  }
}

//
// tostring()
// Converts an array of charcodes to a string
//
function tostring(a) {
  return String.fromCharCode.apply(0, a);
}

//
// When seedrandom.js is loaded, we immediately mix a few bits
// from the built-in RNG into the entropy pool.  Because we do
// not want to interfere with deterministic PRNG state later,
// seedrandom will not call math.random on its own again after
// initialization.
//
mixkey(math.random(), pool);

//
// Nodejs and AMD support: export the implementation as a module using
// either convention.
//
if ((typeof module) == 'object' && module.exports) {
  module.exports = seedrandom;
  // When in node.js, try using crypto package for autoseeding.
  try {
    nodecrypto = require('crypto');
  } catch (ex) {}
} else if ((typeof define) == 'function' && define.amd) {
  define(function() { return seedrandom; });
} else {
  // When included as a plain script, set up Math.seedrandom global.
  math['seed' + rngname] = seedrandom;
}


// End anonymous scope, and pass initial values.
})(
  // global: `self` in browsers (including strict mode and web workers),
  // otherwise `this` in Node and other environments
  (typeof self !== 'undefined') ? self : this,
  [],     // pool: entropy pool starts empty
  Math    // math: package containing random, pow, and seedrandom
);

})();
(function () {
"use strict";
 // API:
// a class for real algebraic numbers
// Operations are implemented as described at https://en.wikipedia.org/wiki/Resultant#Number_theory
// "AbstractPolynomialRoot":
//  #toDecimal(precision)
//  #scale(k), k is an "algebraic expression constant"
//  #translate(k), k is an "algebraic expression constant"
//  #multiply(otherPolynomialRoot)
//  #add(otherPolynomialRoot)
//  #negate()
//  #inverse()
//  #sign()
//  #_pow(n), n is an integer
//  #_nthRoot(n), n is an integer
//  #equals(otherPolynomialRoot)
// PolynomialRoot implements AbstractPolynomialRoot - a basic class to represent real algebraic number exactly
//   .polynomial
//   .interval
// LazyPolynomialRoot implements AbstractPolynomialRoot - a class to represent real algebraic number as a rational expression (see https://en.wikipedia.org/wiki/Algebraic_expression )
//   .e
//   ._root
//TODO: remove references to Expression.ExpressionPolynomialRoot (?)

var isRational = function (e) {
  return e.getNumerator() instanceof Expression.Integer && e.getDenominator() instanceof Expression.Integer;
};

var isPowerOf2 = function (i) {
  return Expression.TWO._pow(primeFactor.bitLength(i.toBigInt()) - 1).equals(i);
};

function SimpleInterval(a, b) {
  console.assert(isRational(a));
  console.assert(isRational(b));
  console.assert(a.getDenominator().multiply(b.getNumerator()).compareTo(b.getDenominator().multiply(a.getNumerator())) >= 0); //TODO: a.getDenominator() is a power of two and b.getDenominator() is a power of two
  //console.assert(isPowerOf2(a.getDenominator()));
  //console.assert(isPowerOf2(b.getDenominator()));

  this.a = a;
  this.b = b;
}

SimpleInterval.prototype.negate = function () {
  return new SimpleInterval(this.b.negate(), this.a.negate());
};

SimpleInterval.prototype.add = function (other) {
  return new SimpleInterval(this.a.add(other.a), this.b.add(other.b));
};

SimpleInterval.prototype.multiply = function (other) {
  var sign = function (e) {
    return e.getNumerator().compareTo(Expression.ZERO);
  };

  if (sign(this.a) === sign(this.b) && sign(other.a) === sign(other.b)) {
    if (sign(this.a) < 0) {
      return this.negate().multiply(other).negate();
    }

    if (sign(other.a) < 0) {
      return this.multiply(other.negate()).negate();
    }

    return new SimpleInterval(this.a.multiply(other.a), this.b.multiply(other.b));
  } //TODO: add a test


  var a = this.a.multiply(other.a);
  var b = this.b.multiply(other.a);
  var c = this.a.multiply(other.b);
  var d = this.b.multiply(other.b);
  var tmp = [a, b, c, d];
  tmp.sort(function (x1, x2) { return x1.subtract(x2).getNumerator().compareTo(Expression.ZERO); });
  return new SimpleInterval(tmp[0], tmp[3]);
};

SimpleInterval.prototype.scale = function (s) {
  return this.multiply(new SimpleInterval(s, s)); //TODO: ?
};

SimpleInterval.prototype.inverse = function () {
  var sign = function (e) {
    return e.getNumerator().compareTo(Expression.ZERO);
  };

  if (sign(this.a) < 0 && sign(this.b) > 0) {
    throw new RangeError();
  }

  return new SimpleInterval(this.b.inverse(), this.a.inverse());
};

SimpleInterval.prototype.toString = function () {
  return '[' + this.a + ';' + this.b + ']';
};

SimpleInterval.intersection = function (a, b) {
  var cmp = function (x1, x2) {
    return x1.subtract(x2).getNumerator().compareTo(Expression.ZERO);
  };

  var max = function (x1, x2) {
    return cmp(x1, x2) < 0 ? x2 : x1;
  };

  var min = function (x1, x2) {
    return cmp(x1, x2) < 0 ? x1 : x2;
  }; // https://scicomp.stackexchange.com/a/26260


  if (cmp(b.a, a.b) > 0 || cmp(a.a, b.b) > 0) {
    return null;
  }

  return {
    a: max(a.a, b.a),
    b: min(a.b, b.b)
  };
};

var toSimpleInterval = function (e, precision) {
  if (isRational(e)) {
    //TODO: REMOVE
    return new SimpleInterval(e.getNumerator(), e.getNumerator()).scale(e.getDenominator().inverse());
  }

  var tmp = ExpressionParser.parse(toDecimalStringInternal(e, {
    significantDigits: precision
  }));
  var epsilonInterval = new SimpleInterval(ExpressionParser.parse('1-5*10**-' + precision), ExpressionParser.parse('1+5*10**-' + precision));
  var result = epsilonInterval.scale(tmp); //var result2 = toSimpleIntervalNew(e, precision);
  //if (SimpleInterval.intersection(result, result2) == null) {
  //  debugger;
  //}

  return result;
}; // TODO:


var toSimpleIntervalNew = function (e, precision) {
  if (e instanceof Expression.Integer) {
    return new SimpleInterval(e, e);
  } else if (e instanceof Expression.BinaryOperation) {
    var a = toSimpleIntervalNew(e.a, precision);
    var b = toSimpleIntervalNew(e.b, precision);
    var s = e.getS();

    if (s === "+") {
      return a.add(b);
    } else if (s === "-") {
      return a.add(b.negate());
    } else if (s === "*") {
      return a.multiply(b);
    } else if (s === "/") {
      //- why was it commented out - ?
      return a.multiply(b.inverse());
    } else {
      debugger;
    }
  } else if (e instanceof Expression.NthRoot) {
    if (e.a instanceof Expression.Integer) {
      var a = e.a;
      var n = e.n;

      var scale = Expression.TWO._pow(precision);

      return new SimpleInterval(nthRoot(a.multiply(scale._pow(n)).toBigInt(), n), scale);
    } //var a = toSimpleInterval(e.a, precision);
    //return a._nthRoot(e.n);


    debugger;
  } else {} //TODO: REMOVE(?)


  if (e instanceof Expression.PolynomialRootSymbol) {
    return e.toDecimal(precision);
  }

  if (e instanceof Expression.ExpressionPolynomialRoot) {
    return e.toDecimal(precision);
  }

  debugger;
  throw new TypeError("?");
};

function Helper(polynomial) {
  this.squareFreeFactors = [];
  var tmp = null;
  var ONE = Polynomial.of(Expression.ONE);

  do {
    tmp = polynomial.squareFreeFactors();

    if (!tmp.a1.equals(ONE)) {
      //TODO: ?
      this.squareFreeFactors.push(tmp.a1);
    }

    if (tmp.a0.getDegree() !== 0) {
      polynomial = tmp.a0;
    } else {
      polynomial = null;
    }
  } while (polynomial != null);
}

Helper.prototype.calcAt = function (point) {
  var result = Expression.ONE;

  for (var iteratorfactor = this.squareFreeFactors[globalThis.Symbol.iterator](), factor = iteratorfactor.next().value; factor != null; factor = iteratorfactor.next().value) {
    result = result.multiply(factor.calcAt(point));
  }

  return result;
};

Helper.prototype.numberOfRoots = function (interval) {
  var result = 0;
  var newFactors = [];

  for (var iteratorfactor = this.squareFreeFactors[globalThis.Symbol.iterator](), factor = iteratorfactor.next().value; factor != null; factor = iteratorfactor.next().value) {
    var n = factor.numberOfRoots(interval);
    result += n;

    if (n > 0) {
      newFactors.push(factor);
    }
  }

  this.squareFreeFactors = newFactors;
  return result;
};

Helper.get = function (that, interval) {
  //TODO: do not call twice
  //for (var iteratorfactor = that.squareFreeFactors[globalThis.Symbol.iterator](), factor = iteratorfactor.next().value; factor != null; factor = iteratorfactor.next().value) {
  //  if (factor.numberOfRoots(interval) > 0) {
  //    return factor;
  //  }
  //}
  //return null;
  return that.squareFreeFactors.length === 1 ? that.squareFreeFactors[0] : null;
};

var calculateNewInterval = function (newPolynomial, zeroFunction) {
  if (!newPolynomial.hasIntegerCoefficients()) {
    throw new RangeError("just a check");
  }

  newPolynomial = new Helper(newPolynomial); //!?!?TODO: REMOVE

  var precision = 1;
  var guess = zeroFunction(precision);

  while (guess.a.getNumerator().sign() !== guess.b.getNumerator().sign() && !newPolynomial.calcAt(Expression.ZERO).equals(Expression.ZERO) || newPolynomial.numberOfRoots(guess) > 1) {
    precision *= 2;
    guess = zeroFunction(precision);
    if (precision > 1024) throw new Error(); //TODO: ?
  }

  var newInterval = guess;
  newPolynomial = Helper.get(newPolynomial, guess);
  return new PolynomialRoot(newPolynomial, newInterval);
};

function PolynomialRoot(polynomial, interval, options) {
options = options == undefined ?  {} : options;

  if (!polynomial.hasIntegerCoefficients()) {
    throw new TypeError();
  }

  if (polynomial.getLeadingCoefficient().compareTo(Expression.ZERO) < 0) {
    return new PolynomialRoot(polynomial.negate(), interval);
  }

  var content = polynomial.getContent();

  if (!content.equals(Expression.ONE)) {
    return new PolynomialRoot(polynomial.scale(content.inverse()), interval);
  }

  if (!options.skipFactorization) {
    //!
    var factor = polynomial.factorize(); //TODO: pass the zero to help the factorization to return the correct factor:
    // var factor = polynomial.factorize({zero: new PolynomialRoot(polynomial, interval)});

    if (factor != null && !factor.equals(polynomial)) {
      if (factor.numberOfRoots(interval) !== 0) {
        return new PolynomialRoot(factor, interval);
      } else {
        var otherFactor = polynomial.divideAndRemainder(factor, "throw").quotient;
        return new PolynomialRoot(otherFactor, interval);
      }
    }
  }

  if (!(interval instanceof SimpleInterval)) {
    throw new TypeError();
  }

  if (interval.a.subtract(interval.b).getNumerator().compareTo(Expression.ZERO) > 0) {
    throw new TypeError();
  } // how to represent zero - ?
  //if ((interval.a.getNumerator().sign() || interval.b.getNumerator().sign()) !== (interval.b.getNumerator().sign() || interval.a.getNumerator().sign())) {
  //  throw new TypeError();
  //}


  if (polynomial.numberOfRoots(interval) !== 1) {
    throw new TypeError();
  }

  if (!polynomial.getContent().equals(Expression.ONE)) {
    throw new TypeError();
  } //TODO: factorization


  this.polynomial = polynomial; //TODO: https://www.wolframalpha.com/input/?i=x**5%2B7x**3%2Bx**2%2Bx%2B1%3D0

  this.interval = interval;
}

PolynomialRoot.prototype.toDecimal = function (precision) {
  var tmp = this.polynomial.getZero(this.interval, precision);
  return new SimpleInterval(tmp.a, tmp.b);
};

PolynomialRoot.prototype.toString = function () {
  // for debugging (?)
  return "[root of " + this.polynomial + " near " + this.interval.a.add(this.interval.b).divide(Expression.TWO).toString() + "]";
}; //TODO: remove (?)


PolynomialRoot.prototype.scale = function (k) {
  //console.assert(k instanceof Expression.Integer || isRational(k));
  // z = k * x, x = z / k
  var newPolynomial = this.polynomial._scaleRoots(k).primitivePart();

  if (!isRational(k)) {
    // TODO: remove
    var root = this;
    newPolynomial = toPolynomialWithIntegerCoefficients(newPolynomial);
    return calculateNewInterval(newPolynomial, function (precision) {
      return root.toDecimal(precision).multiply(toSimpleInterval(k, precision));
    });
  }

  var newInterval = this.interval.scale(k);
  return new PolynomialRoot(newPolynomial, newInterval);
}; //TODO: remove (?)


PolynomialRoot.prototype.translate = function (k) {
  //console.assert(k instanceof Expression.Integer || isRational(k));//TODO: ???
  // z = x + k, x = z - k
  var newPolynomial = this.polynomial._translateRoots(k).primitivePart(); // to avoid intervals, which include zero


  var root = this;
  var newInterval = null;

  if (!isRational(k)) {
    // TODO: remove
    newPolynomial = toPolynomialWithIntegerCoefficients(newPolynomial);
    return calculateNewInterval(newPolynomial, function (precision) {
      return root.toDecimal(precision).add(toSimpleInterval(k, precision));
    });
  } // to avoid intervals, which include zero


  return calculateNewInterval(newPolynomial, function (precision) {
    return root.toDecimal(precision).add(toSimpleInterval(k, precision));
  });
};

PolynomialRoot.prototype.multiply = function (other) {
  //TODO: remove
  if (true) {
    var that = this;
    var g = Math.gcd(that.polynomial.getGCDOfTermDegrees(), other.polynomial.getGCDOfTermDegrees());

    if (g > 1) {
      var tmp = that._pow(g).multiply(other._pow(g))._nthRoot(g); //TODO: TEST!!!


      if (g % 2 === 0 && that.sign() * other.sign() < 0) {
        tmp = tmp.negate();
      }

      return tmp;
    }
  } // z = x * y, y = z / x
  //TODO: variable names


  var $z = new Expression.Symbol("z");

  var second = other.polynomial._exponentiateRoots(-1)._scaleRoots($z);

  var newPolynomial = Polynomial.resultant(that.polynomial, second, "z").primitivePart();
  return calculateNewInterval(newPolynomial, function (precision) {
    return that.toDecimal(precision).multiply(other.toDecimal(precision));
  });
};

PolynomialRoot.prototype.add = function (other) {
  var x = this;
  var y = other;

  if (x.polynomial.isEven() && x.polynomial.equals(y.polynomial) && x.interval.a.equals(y.interval.b.negate()) && x.interval.b.equals(y.interval.a.negate())) {
    return new PolynomialRoot(Polynomial.of(Expression.ONE).shift(1), new SimpleInterval(Expression.ONE.negate(), Expression.ONE));
  } // z = x + y, y = z - x
  //TODO: variable names


  var $z = new Expression.Symbol("z");

  var second = y.polynomial._scaleRoots(Expression.ONE.negate())._translateRoots($z);

  var newPolynomial = Polynomial.resultant(x.polynomial, second, "z").primitivePart();
  return calculateNewInterval(newPolynomial, function (precision) {
    return x.toDecimal(precision).add(y.toDecimal(precision));
  });
}; //TODO: remove (?)


PolynomialRoot.prototype.negate = function () {
  return new PolynomialRoot(this.polynomial._scaleRoots(Expression.ONE.negate()), this.interval.negate());
}; //TODO: remove (?)


PolynomialRoot.prototype.inverse = function () {
  // z = 1/y, y = 1/z
  var newPolynomial = this.polynomial._exponentiateRoots(-1);

  console.assert(this.interval.a.getNumerator().sign() === this.interval.b.getNumerator().sign());
  var newInterval = new SimpleInterval(this.interval.b.inverse(), this.interval.a.inverse());
  return new PolynomialRoot(newPolynomial, newInterval);
};

PolynomialRoot.prototype.sign = function () {
  if (this.polynomial.getCoefficient().equals(Expression.ZERO)) {
    if (this.interval.a.getNumerator().sign() <= 0 && this.interval.b.getNumerator().sign() >= 0) {
      return 0;
    }

    throw new TypeError("should not happen");
  }

  if (this.interval.a.getNumerator().compareTo(Expression.ZERO) >= 0) {
    return +1;
  }

  if (this.interval.b.getNumerator().compareTo(Expression.ZERO) <= 0) {
    return -1;
  }
};

PolynomialRoot.prototype._pow = function (n) {
  var pow = function (x, count, accumulator) {
    if (!(count >= 0)) {
      throw new RangeError();
    }

    if (count > Number.MAX_SAFE_INTEGER) {
      throw new RangeError("NotSupportedError");
    }

    return count < 1 ? accumulator : 2 * Math.floor(count / 2) !== count ? pow(x, count - 1, accumulator.multiply(x)) : pow(x._pow(2), Math.floor(count / 2), accumulator);
  };

  if (n === 0) {
    return new PolynomialRoot(Polynomial.of(Expression.ONE.negate(), Expression.ONE), new SimpleInterval(Expression.ZERO, Expression.TWO)); // x-1=0
  }

  var g = Math.gcd(n, this.polynomial.getGCDOfTermDegrees());

  if (g === 1) {
    //return Expression.prototype._pow.call(this, n);//TODO: ?
    return pow(this, n - 1, this);
  }

  if (g < n) {
    return this._pow(g)._pow(n / g);
  } //TODO: faster method


  var newInterval = undefined;

  if (n % 2 === 0 && this.interval.b.getNumerator().compareTo(Expression.ZERO) <= 0) {
    newInterval = {
      a: this.interval.b._pow(n),
      b: this.interval.a._pow(n)
    };
  } else {
    newInterval = {
      a: this.interval.a._pow(n),
      b: this.interval.b._pow(n)
    };
  }

  return new PolynomialRoot(this.polynomial._exponentiateRoots(n), new SimpleInterval(newInterval.a, newInterval.b));
};

PolynomialRoot.prototype._nthRoot = function (n) {
  var newPolynomial = this.polynomial._exponentiateRoots(1 / n);

  var root = this;
  return calculateNewInterval(newPolynomial, function (precision) {
    //TODO: 
    //return root.toDecimal(precision).nthRoot(n);
    return toSimpleInterval(Expression.NthRoot.makeRoot(new Expression.ExpressionPolynomialRoot(new LazyPolynomialRoot(new Expression.Symbol('α'), root)), n), precision);
  });
};

PolynomialRoot.prototype.equals = function (other) {
  if (this === other) {
    return true;
  }

  if (this.polynomial.getDegree() !== other.polynomial.getDegree()) {
    return false;
  }

  if (this.polynomial.equals(other.polynomial) && this.interval.a.equals(other.interval.a) && this.interval.b.equals(other.interval.b)) {
    return true;
  }

  if (SimpleInterval.intersection(this.interval, other.interval) == null) {
    return false;
  } //TODO: ?
  //return this.polynomial.equals(other.polynomial) && intersection(this.interval, other.interval) != null && this.add(other.negate()).equals(Expression.ZERO);


  var interval = this.add(other.negate()).interval;
  return interval.a.getNumerator().compareTo(Expression.ZERO) <= 0 && interval.b.getNumerator().compareTo(Expression.ZERO) >= 0;
};

PolynomialRoot._calculateNewInterval = calculateNewInterval; //TODO: remove

LazyPolynomialRoot._calculateNewInterval = calculateNewInterval; //TODO: remove

PolynomialRoot._toSimpleInterval = toSimpleInterval; //TODO: remove

LazyPolynomialRoot._toSimpleInterval = toSimpleInterval; //TODO: remove

function LazyPolynomialRoot(e, _root) {
  console.assert(e instanceof Expression);
  console.assert(_root instanceof PolynomialRoot); //TODO:
  //console.assert(Expression.isConstant(e) && !Expression.has(e, Expression.Complex));

  this.e = e; // internal symbolic expression with a "root" as a symbol

  this._root = _root;
}

LazyPolynomialRoot.prototype.toDecimal = function (precision) {
  var calcAt = function (polynomial, x, precision) {
    var result = toSimpleInterval(Expression.ZERO, precision);

    for (var i = polynomial.getDegree(); i >= 0; i--) {
      result = result.multiply(x);
      var tmp = toSimpleInterval(polynomial.getCoefficient(i), Math.max(1, precision)); //TODO: ?
      //if (tmp === "CANNOT_DIVIDE" || tmp == undefined) {
      //  return tmp;
      //}

      result = result.add(tmp);
    }

    return result;
  };

  var alphaValue = this._root.toDecimal(precision);

  var alphaExpression = this.e;
  var p1 = Polynomial.toPolynomial(alphaExpression.getNumerator(), new Expression.Symbol('α'));
  var p2 = Polynomial.toPolynomial(alphaExpression.getDenominator(), new Expression.Symbol('α'));
  var a = calcAt(p1, alphaValue, precision); //if (a === "CANNOT_DIVIDE" || a == undefined) {
  //  return a;
  //}

  var b = calcAt(p2, alphaValue, precision); //if (b === "CANNOT_DIVIDE" || b == undefined) {
  //  return b;
  //}

  return a.multiply(b.inverse());
};

LazyPolynomialRoot.prototype.toString = function () {
  return "[" + this.e + ", where " + this._root + "]"; // for debugging
};

function makeExpressionWithPolynomialRoot(e, root, variable) {
  //TODO: use cases - ?
  if (e instanceof Expression.Integer) {
    return e;
  }

  if (e instanceof Expression.Division && e.a instanceof Expression.Integer && e.b instanceof Expression.Integer) {
    return e;
  } //!


  if (e.getNumerator().equals(Expression.ZERO)) {
    return Expression.ZERO;
  }

  var v = root;

  if (true) {
    if (!(e.getDenominator() instanceof Expression.Integer)) {
      var p = Polynomial.toPolynomial(e.getDenominator(), variable);

      if (p.getDegree() > 0) {
        return makeExpressionWithPolynomialRoot(e.getNumerator().multiply(p.modularInverse(root.polynomial).calcAt(variable)), root, variable);
      }
    }
  }

  var c = function (x) {
    //!new 2020-08-27
    //TODO: remove
    if (true && !(x instanceof Expression.Integer) && !(x instanceof Expression.Multiplication && x.a === Expression.I && x.b === v)) {
      var p1 = Polynomial.toPolynomial(x.subtract(new Expression.Symbol('$n')), variable); //var test = v.polynomial.divideAndRemainder(p1).remainder;

      if (p1.getDegree() >= v.polynomial.getDegree()) {
        p1 = Polynomial.pseudoRemainder(p1, v.polynomial);
      }

      var test = v.polynomial.getDegree() >= p1.getDegree() ? Polynomial.pseudoRemainder(v.polynomial, p1) : v.polynomial;

      if (test.getDegree() === 0) {
        //(x**2-2)(x**2+x-1) = 0
        var pn0 = Polynomial.toPolynomial(test.calcAt(Expression.ZERO).getNumerator(), new Expression.Symbol('$n'));
        var pn = Polynomial.toPolynomial(Expression.getConjugateExpression(test.calcAt(Expression.ZERO).getNumerator()), new Expression.Symbol('$n')); //pn = pn.scale(pn.getLeadingCoefficient().inverse());

        pn = pn.primitivePart();
        var tmp = pn.squareFreeFactors();
        var f = tmp.a0;

        if (tmp.a0.getDegree() === 0) {
          f = tmp.a1;
        }

        if (f.getDegree() <= 2) {
          //TODO: ?
          var roots = f.getroots();
          var c = [];
          var fractionDigits = 3;

          do {
            c.splice(0, c.length);

            for (var iteratorroot = roots[globalThis.Symbol.iterator](), root = iteratorroot.next().value; root != null; root = iteratorroot.next().value) {
              if (Expression.has(root, Expression.Complex) === Expression.has(x, Expression.Complex)) {
                if (root.getNumerator().toMathML({
                  rounding: {
                    fractionDigits: fractionDigits
                  }
                }) === new Expression.Multiplication(x, root.getDenominator()).toMathML({
                  rounding: {
                    fractionDigits: fractionDigits
                  }
                })) {
                  c.push(root);
                }
              }
            }

            fractionDigits *= 2;
          } while (c.length > 2);

          if (c.length === 1) {
            return c[0];
          }
        }

        var lc = pn.getLeadingCoefficient();

        if (lc instanceof Expression.Integer && Expression.isConstant(x)) {
          //TODO: ? - this is a filter to avoid infinite computation
          var s = toDecimalStringInternal(x.multiply(lc), {
            fractionDigits: 0
          });
          var n = Number(s); //TODO: complex - ?

          if (!Number.isNaN(n)) {
            var q = Expression.Integer.fromString(s).divide(lc);

            if (pn.calcAt(q).equals(Expression.ZERO)) {
              var tmp = Expression.ONE.divide(Expression.TWO).divide(lc);

              if (pn0.numberOfRoots({
                a: q.subtract(tmp),
                b: q.add(tmp)
              }) === 1) {
                console.debug(q.toString());
                return q;
              }
            }
          }
        }
      }
    }

    var px = Polynomial.toPolynomial(x, variable);

    if (false) {
      if (v.polynomial.getDegree() === 6 && v.polynomial.getCoefficient(1).equals(Expression.ZERO) && v.polynomial.getCoefficient(2).equals(Expression.ZERO) && v.polynomial.getCoefficient(4).equals(Expression.ZERO) && v.polynomial.getCoefficient(5).equals(Expression.ZERO)) {
        if (px.getDegree() >= 3) {
          var alpha = c(v._pow(3));
          var dv = Polynomial.of(alpha.negate(), Expression.ZERO, Expression.ZERO, Expression.ONE);
          return px.divideAndRemainder(dv).remainder.calcAt(variable);
        }
      }
    } //!


    return px.divideAndRemainder(v.polynomial).remainder.calcAt(variable);
  };

  var oldE = e;
  e = c(e.getNumerator()).divide(c(e.getDenominator()));

  if (!oldE.equals(e)) {
    var tmp = !(oldE.getDenominator() instanceof Expression.Integer) || !(e.getDenominator() instanceof Expression.Integer);

    if (tmp) {
      //console.log('tmp', tmp);
      var oldE1 = e;
      e = c(e.getNumerator()).divide(c(e.getDenominator())); // something may change after the previous step

      if (!oldE1.equals(e)) {//debugger;
      }
    }
  } //TODO: use polynomial from the start - ?


  if (Polynomial.toPolynomial(e.getNumerator(), variable).hasRoot(v)) {
    //Note: slow
    return Expression.ZERO;
  }

  return e;
}

PolynomialRoot._makeExpressionWithPolynomialRoot = makeExpressionWithPolynomialRoot;
LazyPolynomialRoot._makeExpressionWithPolynomialRoot = makeExpressionWithPolynomialRoot;

function simplifyExpressionWithPolynomialRoot(e, root) {
  //var variable = new Expression.Symbol('α');
  //TODO: ... see makeExpressionWithPolynomialRoot
  //var p = Polynomial.toPolynomial(e, variable);
  //p = p.divideAndRemainder(root.polynomial).remainder;
  //e = p.calcAt(variable);
  //return new LazyPolynomialRoot(e, root);
  return new LazyPolynomialRoot(makeExpressionWithPolynomialRoot(e, root, new Expression.Symbol('α')), root);
}

PolynomialRoot.SimpleInterval = SimpleInterval;
LazyPolynomialRoot.SimpleInterval = SimpleInterval;

PolynomialRoot.create = function (polynomial, interval, options) {
  return new PolynomialRoot(polynomial, interval, options);
};

LazyPolynomialRoot.create = function (polynomial, interval, options) {
  return new LazyPolynomialRoot(new Expression.Symbol('α'), new PolynomialRoot(polynomial, interval, options));
};

function fromRoot(root) {
  return new LazyPolynomialRoot(new Expression.Symbol('α'), root);
}

LazyPolynomialRoot.prototype.scale = function (k) {
  console.assert(Expression.isConstant(k)); //TODO: ??? only some constants

  return simplifyExpressionWithPolynomialRoot(this.e.multiply(k), this._root);
};

LazyPolynomialRoot.prototype.translate = function (k) {
  console.assert(Expression.isConstant(k)); //TODO: ??? only some constants

  return simplifyExpressionWithPolynomialRoot(this.e.add(k), this._root);
};

var toPolynomialWithIntegerCoefficients = function (polynomial) {
  if (!polynomial.hasIntegerCoefficients()) {
    var variable = new Expression.Symbol('$$');
    var e = polynomial.calcAt(variable);
    var c = Expression.getConjugateExpression(e);

    if (c != null && !c.equals(e)) {
      //TODO: what if multiple (?) - ?
      return Polynomial.toPolynomial(c, variable);
    }
  }

  return polynomial;
};

function upgrade(lazyRoot) {
  var root = lazyRoot._root;
  var e = lazyRoot.e;
  var variable = new Expression.Symbol('α');

  if (e.equals(variable)) {
    // short path
    return root;
  }

  if (e.getNumerator().equals(variable)) {
    // short path 2
    return root.scale(e.getDenominator().inverse());
  } //TODO: modInverse or upgrade numerator and denominator separately - ?


  var p = Polynomial.toPolynomial(e.getNumerator(), variable);
  var p2 = Polynomial.toPolynomial(e.getDenominator(), variable);
  var scale = Expression.ONE;

  if (p2.getDegree() === 0 && p2.hasIntegerCoefficients()) {
    scale = p2.getLeadingCoefficient();
    p2 = Polynomial.of(Expression.ONE);
  }

  var polynomial = p.subtract(Polynomial.of(new Expression.Symbol('β')).multiply(p2));
  polynomial = toPolynomialWithIntegerCoefficients(polynomial); //TODO: ???

  var newPolynomial = Polynomial.resultant(polynomial, root.polynomial, 'β').primitivePart();

  if (scale !== Expression.ONE) {
    // "unscale"
    newPolynomial = newPolynomial._scaleRoots(scale.inverse()).primitivePart();
  }

  return PolynomialRoot._calculateNewInterval(newPolynomial, function (precision) {
    return toSimpleInterval(new Expression.ExpressionPolynomialRoot(lazyRoot), precision);
  });
}

LazyPolynomialRoot.prototype.multiply = function (other) {
  if (this._root.equals(other._root)) {
    return simplifyExpressionWithPolynomialRoot(this.e.multiply(other.e), this._root);
  }

  var root = upgrade(this).multiply(upgrade(other));
  return fromRoot(root);
};

LazyPolynomialRoot.prototype.add = function (other) {
  if (this._root.equals(other._root)) {
    return simplifyExpressionWithPolynomialRoot(this.e.add(other.e), this._root);
  }

  var root = upgrade(this).add(upgrade(other));
  return fromRoot(root);
};

LazyPolynomialRoot.prototype.negate = function () {
  return new LazyPolynomialRoot(this.e.negate(), this._root);
};

LazyPolynomialRoot.prototype.inverse = function () {
  return simplifyExpressionWithPolynomialRoot(this.e.inverse(), this._root);
};

LazyPolynomialRoot.prototype.sign = function () {
  if (this.e.equals(Expression.ZERO)) {
    return 0;
  } //return this.e;
  //?
  //TODO: ???


  var s = toDecimalStringInternal(new Expression.ExpressionPolynomialRoot(this), {
    significantDigits: 1
  });
  return s.startsWith('-') ? -1 : +1;
};

LazyPolynomialRoot.prototype._pow = function (n) {
  //TODO: modular exponentiation (?)
  return simplifyExpressionWithPolynomialRoot(this.e.getNumerator()._pow(n), this._root).multiply(simplifyExpressionWithPolynomialRoot(this.e.getDenominator()._pow(n), this._root).inverse());
};

LazyPolynomialRoot.prototype._nthRoot = function (n) {
  //?
  if (this.e.equals(new Expression.Symbol('α'))) {
    //TODO: ?
    if (this._root.interval.a.getNumerator().compareTo(Expression.ZERO) < 0) {
      throw new RangeError();
    }

    var newRoot = this._root._nthRoot(n);

    return new LazyPolynomialRoot(new Expression.Symbol('α'), newRoot);
  }

  if (!(this.e instanceof Expression.Exponentiation)) {
    if (true && n === 2) {
      return this.upgrade()._nthRoot(n);
    }
  }

  return simplifyExpressionWithPolynomialRoot(this.e._nthRoot(n), this._root);
};

LazyPolynomialRoot.prototype.equals = function (other) {
  if (this._root.equals(other._root)) {
    //TODO:? ?
    return this.e.equals(other.e) || simplifyExpressionWithPolynomialRoot(this.e.subtract(other.e), this._root).e.equals(Expression.ZERO);
  } //!TODO: remove (hack to avoid error)


  if (toDecimalStringInternal(new Expression.ExpressionPolynomialRoot(this), {
    significantDigits: 3
  }) !== toDecimalStringInternal(new Expression.ExpressionPolynomialRoot(other), {
    significantDigits: 3
  })) {
    return false;
  } //!


  var result = upgrade(this).equals(upgrade(other));
  return result;
};

PolynomialRoot.prototype.toPolynomialRoot = function () {
  //TODO: rename - ?
  return this;
};

LazyPolynomialRoot.prototype.toPolynomialRoot = function () {
  //TODO: rename - ?
  return upgrade(this);
};

PolynomialRoot.prototype.upgrade = function () {
  return this;
};

LazyPolynomialRoot.prototype.upgrade = function () {
  return fromRoot(upgrade(this));
}; //LazyPolynomialRoot.PolynomialRoot = PolynomialRoot;//TODO: REMOVE!!!


globalThis.testables = globalThis.testables || {};
globalThis.testables.LazyPolynomialRoot = LazyPolynomialRoot;
globalThis.testables.PolynomialRoot = PolynomialRoot;

if (false) {
  //TODO: move to tests
  console.assert(Object.keys(PolynomialRoot).join(' ') === Object.keys(LazyPolynomialRoot).join(' '));
  console.assert(Object.keys(PolynomialRoot.prototype).join(' ') === Object.keys(LazyPolynomialRoot.prototype).join(' '));
  console.assert(PolynomialRoot.prototype.__proto__ === LazyPolynomialRoot.prototype.__proto__);
}

self.LazyPolynomialRoot = LazyPolynomialRoot;
})();
(function () {
"use strict";







var SimpleInterval = LazyPolynomialRoot.SimpleInterval;
//var PolynomialRoot = LazyPolynomialRoot.PolynomialRoot;


function PolynomialRootSymbol(polynomial, interval) {
  Expression.Symbol.call(this, "[root of " + polynomial + " near " + interval.a.add(interval.b).divide(Expression.TWO).toString() + "]");
  this.polynomial = polynomial;
  //TODO: https://www.wolframalpha.com/input/?i=x**5%2B7x**3%2Bx**2%2Bx%2B1%3D0
  this.interval = interval;
}
PolynomialRootSymbol.prototype = Object.create(Expression.Symbol.prototype);

PolynomialRootSymbol.prototype.toDecimal = function (precision) {
  var tmp = this.polynomial.getZero(this.interval, precision);
  return new SimpleInterval(tmp.a, tmp.b);
};

PolynomialRootSymbol.prototype.isExact = function () {
  //TODO: fix - ?
  return false;
};


PolynomialRootSymbol.prototype.toMathML = function (options) {
  options = options || {};
  if (options.fractionDigits != null) {
    throw new TypeError('options.fractionDigits is deprecated, please use options.rounding');
  }
  var rounding = options.rounding || {fractionDigits: 3};
  var tmp = toDecimalStringInternal(this, rounding, Expression._decimalToMathML, Expression._complexToMathML);
  return tmp;
};


Expression.PolynomialRootSymbol = PolynomialRootSymbol;

function isSameRoot(x, y) {
  return x instanceof Expression.PolynomialRootSymbol && y instanceof Expression.PolynomialRootSymbol && x.polynomial.equals(y.polynomial) && x.interval.a.equals(y.interval.a) && x.interval.b.equals(y.interval.b);
}

function ExpressionWithPolynomialRoot(e, root) {
  this.e = e; // internal symbolic expression with a "root" as a symbol
  this.root = root;
}




ExpressionWithPolynomialRoot.prototype = Object.create(Expression.Symbol.prototype);

/*
ExpressionWithPolynomialRoot.prototype.compare4Multiplication = function (y) {
  return y.compare4MultiplicationExpressionWithPolynomialRoot(this);
};
ExpressionWithPolynomialRoot.prototype.compare4MultiplicationExpressionWithPolynomialRoot = function (x) {
  return 0;//?
};
Expression.prototype.compare4MultiplicationExpressionWithPolynomialRoot = function (x) {
  return this.compare4MultiplicationSymbol(x);//?
};
Expression.Symbol.prototype.compare4MultiplicationExpressionWithPolynomialRoot = function (x) {
  return -1;
};
ExpressionWithPolynomialRoot.prototype.compare4MultiplicationSymbol = function (x) {
  return +1;
};
*/

//Expression.prototype.isExact = function () {
//  return true;
//};
ExpressionWithPolynomialRoot.prototype.isExact = function () {
  //TODO: fix - ?
  return false;
};

function simplifyExpressionWithPolynomialRoot(e, root) {
  var e1 = LazyPolynomialRoot._makeExpressionWithPolynomialRoot(e, root, root);
  if (Polynomial.toPolynomial(e1.getNumerator(), root).getDegree() <= 0 && Polynomial.toPolynomial(e1.getDenominator(), root).getDegree() <= 0) {
    return e1;
  }
  return new ExpressionWithPolynomialRoot(e1, root);
}

ExpressionWithPolynomialRoot.prototype.negate = function () {
  //return simplifyExpressionWithPolynomialRoot(this.e.negate(), this.root);
  return new ExpressionWithPolynomialRoot(this.e.negate(), this.root); // for performance
};
ExpressionWithPolynomialRoot.prototype.equals = function (other) {
  //!TODO: remove (hack to avoid error)
  if (this instanceof ExpressionWithPolynomialRoot && other instanceof ExpressionWithPolynomialRoot) {
    if (!isSameRoot(this.root, other.root)) {
      //var s1 = toDecimalStringInternal(new Expression.Addition(this.e, other.e.negate()), {fractionDigits: 3});
      //if (s1 != undefined && !s1.endsWith('000')) {
      //  return false;
      //}
      if (this.toMathML({rounding: {fractionDigits: 3}}) !== other.toMathML({rounding: {fractionDigits: 3}})) {
        return false;//?
      }
      if (true) {
        return this.upgrade().subtract(other.upgrade()).equals(Expression.ZERO);
      }
      var s = toDecimalStringInternal(new Expression.Addition(this.e, other.e.negate()), {significantDigits: 1});
      //TODO: will it hang for zero?
      return s === '0';
    }
  }
  //!
  //if (Expression.has(other, Expression.NthRoot)) {
  //  return this.upgrade().equals(Expression.toPolynomialRoot(other));//!?
  //}
  // optimization
  var s = other instanceof Expression.Integer && other.equals(Expression.ZERO) ? this : this.subtract(other);
  return s instanceof ExpressionWithPolynomialRoot ? false : s.equals(Expression.ZERO);
};
ExpressionWithPolynomialRoot.prototype.simplifyExpression = function () {
  return this;
};

var _isSimpleForUpgrade = function (e, root) {
  if (e instanceof Expression.Addition && !(e.a instanceof Expression.Addition)) {
    return _isSimpleForUpgrade(e.a, root) && _isSimpleForUpgrade(e.b, root);
  }
  //TODO: other variants (?)
  return e.equals(root) ||
         e instanceof Expression.Integer || e instanceof Expression.Complex ||
         e instanceof Expression.Multiplication ||
         e instanceof Expression.Division && _isSimpleForUpgrade(e.getNumerator(), root);
};

ExpressionWithPolynomialRoot.prototype.toString = function (options) {
  options = options || {};
  if (_isSimpleForUpgrade(this.e, this.root)) {
    return this.upgrade().toString(options);
  }
  //TODO: return 'polynomial-root of x**2+2x+1 on [a; b]';
  //TODO:
  if (this.equals(Expression.ZERO)) {
    return Expression.ZERO.toString(options);
  }
  //return this.e.toString(options);
  if (options.fractionDigits != null) {
    throw new TypeError('options.fractionDigits is deprecated, please use options.rounding');
  }
  var rounding = options.rounding || {fractionDigits: 3};
  //if (true) {
  //  return Expression.toDecimalString(this.e, Object.assign({}, options, {rounding: rounding}));
  //}
  if (!Expression.isConstant(this.e)) {
    return this.upgrade().toString(options);
  }
  var tmp = toDecimalStringInternal(this.e, rounding, undefined, undefined);
  return tmp;
};

ExpressionWithPolynomialRoot.prototype.toMathML = function (options) {
  options = options || {};
  if (_isSimpleForUpgrade(this.e, this.root)) {
    return this.upgrade().toMathML(options);
  }
  //TODO:
  if (this.equals(Expression.ZERO)) {
    return Expression.ZERO.toMathML(options);
  }
  //return this.e.toMathML(options);
  if (options.fractionDigits != null) {
    throw new TypeError('options.fractionDigits is deprecated, please use options.rounding');
  }
  var rounding = options.rounding || {fractionDigits: 3};
  if (true) {
    //return Expression.toDecimalString(this.e, );
    return this.e.toMathML(Object.assign({}, options, {rounding: rounding}));
  }
  var tmp = toDecimalStringInternal(this.e, rounding, Expression._decimalToMathML, Expression._complexToMathML);
  return tmp;
};

var calculateNewInterval = LazyPolynomialRoot._calculateNewInterval;//TODO: remove
var toSimpleInterval = LazyPolynomialRoot._toSimpleInterval;//TODO: remove

function upgrade(e, root) {
  if (e.equals(Expression.ZERO)) {
    return e;
  }
  if (e instanceof Expression.Integer) {
    return e;
  }
  var variable = root;
    //!new 2021-04-03
  if (true) {
  //if (e.getDenominator().equals(Expression.ONE)) {
    //var root = Expression.getVariable(e.getNumerator());
    //var root2 = Expression.getVariable(e.getDenominator());
    //root = root || root2;
    //root2 = root2 || root;
    //if (root instanceof PolynomialRootSymbol && root === root2) {
      var p = Polynomial.toPolynomial(e.getNumerator(), variable);
      var p2 = Polynomial.toPolynomial(e.getDenominator(), variable);
      if (p.hasIntegerCoefficients() && p2.hasIntegerCoefficients()) {
        if (e.getDenominator() instanceof Expression.Integer && !e.getDenominator().equals(Expression.ONE)) {
          //TODO: optimize (?)
          return upgrade(e.getNumerator(), root).divide(e.getDenominator());
        }
        //debugger;
        var resultant = Polynomial.resultant(p.subtract(Polynomial.of(new Expression.Symbol('β')).multiply(p2)), root.polynomial, 'β').primitivePart();
        var tmp = calculateNewInterval(resultant, function (precision) {
          return toSimpleInterval(e, precision);
        });
        var interval = tmp.interval;
        var newPolynomial = tmp.polynomial;
        return Expression.ExpressionPolynomialRoot._create(newPolynomial, interval);
      }
      //!new 2021-05-14 (TODO: CHECK)
      if (p2.hasIntegerCoefficients() && p.hasComplexCoefficients()) {
        return upgrade(p.map(function (c) { return c instanceof Expression.Integer ? c : c.real; }).calcAt(variable).divide(p2.calcAt(variable)), root).add(upgrade(p.map(function (c) { return c instanceof Expression.Integer ? Expression.ZERO : c.imaginary; }).calcAt(variable).divide(p2.calcAt(variable)), root).multiply(Expression.I));
      }
      //!
      //TODO: using grouping
    //}
    //debugger;
  //} else {
  //  return upgrade(e.getNumerator(), root).divide(upgrade(e.getDenominator(), root));
  //}
  }
  //!
  
  var cache = null;//TODO: ?
  var root = null;
  return Expression._map(function (x) {
    return x instanceof Expression.PolynomialRootSymbol && !(x instanceof Expression.ExpressionPolynomialRoot) ? (x === cache ? root : (cache = x, root = Expression.ExpressionPolynomialRoot._create(x.polynomial, x.interval))) : x;
  }, e);
}

ExpressionWithPolynomialRoot.prototype.multiply = function (other) {
  if (other instanceof ExpressionWithPolynomialRoot) {
    if (this.root !== other.root && !isSameRoot(this.root, other.root)) {
      return this.upgrade().multiply(other.upgrade());
    }
    return this.multiply(other.e);
  }
  if (Expression.has(other, Expression.ExpressionPolynomialRoot)) {//TODO: ?
    return this.upgrade().multiply(other);
  }
  return simplifyExpressionWithPolynomialRoot(this.e.multiply(other), this.root);
};
ExpressionWithPolynomialRoot.prototype.divide = function (other) {
  if (other.equals(Expression.ONE)) {
    return this;
  }
  if (other instanceof ExpressionWithPolynomialRoot) {
    if (this.root !== other.root && !isSameRoot(this.root, other.root)) {
      return this.upgrade().divide(other.upgrade());
    }
    var a = this.divide(other.e);
    //var b = this.multiply(other.inverse());
    //console.log(a.e.toString().replaceAll(a.root.symbol, 'x'));
    //console.log(b.e.toString().replaceAll(b.root.symbol, 'x'));
    return a;
  }
  if (Expression.has(other, Expression.ExpressionPolynomialRoot)) {//TODO: ?
    return this.upgrade().divide(other);
  }
  return simplifyExpressionWithPolynomialRoot(this.e.divide(other), this.root);
};
ExpressionWithPolynomialRoot.prototype.add = function (other) {
  if (other instanceof ExpressionWithPolynomialRoot) {
    if (this.root !== other.root && !isSameRoot(this.root, other.root)) {
      return this.upgrade().add(other.upgrade());
    }
    return this.add(other.e);
  }
  if (Expression.has(other, Expression.ExpressionPolynomialRoot)) {//TODO: ?
    return this.upgrade().add(other);
  }
  return simplifyExpressionWithPolynomialRoot(this.e.add(other), this.root);
};

ExpressionWithPolynomialRoot.prototype.divideExpression = function (other) {
  if (Expression.has(other, Expression.ExpressionPolynomialRoot)) {//TODO: ?
    return other.divide(this.upgrade());
  }
  return simplifyExpressionWithPolynomialRoot(other.divide(this.e), this.root);
};
ExpressionWithPolynomialRoot.prototype.multiplyExpression = function (other) {
  if (other.equals(Expression.ONE)) {
    return this;
  }
  if (Expression.has(other, Expression.ExpressionPolynomialRoot)) {//TODO: ?
    return other.multiply(this.upgrade());
  }
  return simplifyExpressionWithPolynomialRoot(other.multiply(this.e), this.root);
};
ExpressionWithPolynomialRoot.prototype.addExpression = function (other) {
  if (Expression.has(other, Expression.ExpressionPolynomialRoot)) {//TODO: ?
    return other.add(this.upgrade());
  }
  return simplifyExpressionWithPolynomialRoot(other.add(this.e), this.root);
};

ExpressionWithPolynomialRoot.prototype.getPrecedence = function () {
  if (Expression.isReal(this)) {
    return 1000;
  }
  //return this.e.getPrecedence();//? - division
  return 2; // it can be a complex number
};
ExpressionWithPolynomialRoot.prototype.isRightToLeftAssociative = function () {
  return true;
};
ExpressionWithPolynomialRoot.prototype.isUnaryPlusMinus = function () {
  if (Expression.isReal(this)) {
    return false;
  }
  return true;
};

ExpressionWithPolynomialRoot.prototype.isNegative = function () {
  //TODO: ?
  if (Expression.isReal(this)) {
    return !Expression._isPositive(this);
  }
  return this.e.isNegative();
};


ExpressionWithPolynomialRoot.prototype._nthRoot = function (n) {//?
  if (this.e === this.root) {//TODO: ?
    // PolynomialRootSymbol#_nthRoot - ?
    if (this.root.interval.a.getNumerator().compareTo(Expression.ZERO) < 0) {
      //TODO: check
      var newRoot = new Expression.PolynomialRootSymbol(this.root.polynomial._scaleRoots(Expression.ONE.negate()), {a: this.root.interval.b.negate(), b: this.root.interval.a.negate()});
      return Expression.I.multiply(new ExpressionWithPolynomialRoot(newRoot, newRoot)._nthRoot(n));
    }
    var precision = 3;
    var a = null;
    var b = null;
    do {
      a = ExpressionParser.parse(toDecimalStringInternal(this.root.interval.a._nthRoot(n), {significantDigits: precision}));
      b = ExpressionParser.parse(toDecimalStringInternal(this.root.interval.b._nthRoot(n), {significantDigits: precision}));
      precision *= 2;
      if (precision > 128) {
        debugger;
        throw new TypeError();
      }
    //TODO: fix !!!
    } while (a.equals(b));
    var newRoot = new Expression.PolynomialRootSymbol(this.root.polynomial._exponentiateRoots(1 / n), {a: a, b: b});
    if (newRoot.polynomial.numberOfRoots(newRoot.interval) === 1) {
      return new ExpressionWithPolynomialRoot(newRoot, newRoot);
    } else {
      console.assert(false);
      debugger;
    }
  }
  if (!(this.e instanceof Expression.Exponentiation)) {
    if (true && n === 2) {
      return this.upgrade()._nthRoot(n);
    }
  }
  return simplifyExpressionWithPolynomialRoot(this.e._nthRoot(n), this.root);
};
ExpressionWithPolynomialRoot.prototype.pow = function (count) {
  if (count instanceof Expression.Integer) {
    return simplifyExpressionWithPolynomialRoot(this.e._pow(count.value), this.root);
  } else {
    if (count instanceof Expression.Division && count.getDenominator() instanceof Expression.Integer) {
      return simplifyExpressionWithPolynomialRoot(this.e.pow(count.getNumerator()), this.root)._nthRoot(count.getDenominator().value);
    }
    //TODO: upgrade (?)
    return simplifyExpressionWithPolynomialRoot(this.e.pow(count), this.root);
  }
};
ExpressionWithPolynomialRoot.prototype._pow = function (count) {
  return simplifyExpressionWithPolynomialRoot(this.e.getNumerator()._pow(count), this.root).divide(simplifyExpressionWithPolynomialRoot(this.e.getDenominator()._pow(count), this.root));
};

//TODO: remove
ExpressionWithPolynomialRoot.prototype.upgrade = function () {
  return upgrade(this.e, this.root);
};

ExpressionWithPolynomialRoot.prototype.complexConjugate = function () {
  return simplifyExpressionWithPolynomialRoot(this.e.complexConjugate(), this.root);
};

ExpressionWithPolynomialRoot.prototype.toDecimal = function (precision) {
precision = precision == undefined ?  0 : precision;

  return this.e === this.root ? this.root.toDecimal(precision) : this.upgrade().toDecimal(precision);
};

self.ExpressionWithPolynomialRoot = ExpressionWithPolynomialRoot;

})();
(function () {
"use strict";












Expression.ExpressionWithPolynomialRoot = ExpressionWithPolynomialRoot;


// wrapper around PolynomialRoot
function ExpressionPolynomialRoot(root) {
  var polynomial = root instanceof LazyPolynomialRoot ? root._root.polynomial : root.polynomial;
  var interval = root instanceof LazyPolynomialRoot ? root._root.interval : root.interval;
  if (root.e != null && Expression.isConstant(root.e)) {
    return root.e;
  }
  if (polynomial.getDegree() === 1 || polynomial.getDegree() === 2 || (polynomial.getDegree() === 4 && false) || polynomial.getDegree() === polynomial.getGCDOfTermDegrees()) {//TODO: other - ? like biqudratic - ?
    var roots = polynomial.getroots();
    for (var iteratorrr = roots[globalThis.Symbol.iterator](), rr = iteratorrr.next().value; rr != null; rr = iteratorrr.next().value) {
      if (!Expression.has(rr, ExpressionPolynomialRoot)) {//?
        if (Expression._isPositive(rr.subtract(interval.a)) && Expression._isPositive(rr.subtract(interval.b).negate()) || rr.equals(interval.b)) {
          if (root.e == null || root.e instanceof Expression.Symbol && root.e.symbol === 'α') {//TODO: ???
            return rr;//TODO: MOVE!
          } else {
            var n = Polynomial.toPolynomial(root.e.getNumerator(), new Expression.Symbol('α')).calcAt(rr);
            var d = Polynomial.toPolynomial(root.e.getDenominator(), new Expression.Symbol('α')).calcAt(rr);
            return n.divide(d);
          }
        }
      }
    }
  }
  if (polynomial.getDegree() < 3) {
    throw new TypeError();
  }
  if (polynomial.getDegree() > 64 * 2) {
    throw new Error();//TODO: too long
  }
  Expression.Symbol.call(this, root.toString());
  this.root = root;
  Object.freeze(this);
}
ExpressionPolynomialRoot.prototype = Object.create(Expression.Symbol.prototype);

ExpressionPolynomialRoot.SimpleInterval = LazyPolynomialRoot.SimpleInterval;

ExpressionPolynomialRoot._create = function (polynomial, interval) {
  return new ExpressionPolynomialRoot(LazyPolynomialRoot.create(polynomial, new LazyPolynomialRoot.SimpleInterval(interval.a, interval.b)));
  //TODO: WHY NOT TO CREATE LAZYPOLYNOMIALROOT - ?
  //debugger;
  //return new ExpressionPolynomialRoot(new LazyPolynomialRoot.PolynomialRoot(polynomial, new LazyPolynomialRoot.SimpleInterval(interval.a, interval.b)));
};

ExpressionPolynomialRoot.prototype.multiplyInteger = function (x) {
  return x.multiplyPolynomialRoot(this);
};
ExpressionPolynomialRoot.prototype.multiply = function (e) {
  return e.multiplyPolynomialRoot(this);
};
ExpressionPolynomialRoot.prototype.multiplyExpression = function (e) {
  if (e.equals(Expression.ONE)) {
    return this;
  }
  //?
  //TODO: fix
  if (Expression.isConstant(e) && !Expression.has(e, Expression.Complex)) {
    return this.multiply(e);
  }
  return Expression.Symbol.prototype.multiplyExpression.call(this, e);
};
ExpressionPolynomialRoot.prototype.multiplyAddition = function (e) { // for performance (?) when `e` is a constant
  if (Expression.isConstant(e) && !Expression.has(e, Expression.Complex)) {
    return this.multiplyExpression(e);
  }
  return Expression.Symbol.prototype.multiplyAddition.call(this, e);
};
Expression.prototype.multiplyPolynomialRoot = function (root) {
  if (Expression.isConstant(this) && !Expression.has(this, Expression.ExpressionWithPolynomialRoot) && !(Expression.has(this, Expression.Complex)) && !(Expression.has(this, Expression.Exponentiation))) {
    var k = this;
    if (k.equals(Expression.ZERO)) {
      return k;
    }
    if (k.equals(Expression.ONE)) {
      return root;
    }
    return new ExpressionPolynomialRoot(root.root.scale(k));
  }
  if (this instanceof Expression.Complex && !this.imaginary.equals(Expression.ONE)) {
    return this.divide(this.imaginary).multiply(this.imaginary.multiply(root));
  }
  //TODO: ?
  //throw new Error();
  return this.multiplyExpression(root);
};
ExpressionPolynomialRoot.prototype._pow = function (n) {
  return new ExpressionPolynomialRoot(this.root._pow(n));
};
ExpressionPolynomialRoot.prototype.pow = function (e) {
  if (e instanceof Expression.Integer) {
    return this._pow(e.toNumber());
  }
  //TODO: ?
  if (e instanceof Expression.Division && e.getDenominator() instanceof Expression.Integer) {
    //TODO: verify
    return this._nthRoot(e.getDenominator().toNumber()).pow(e.getNumerator());
  }
  return Expression.Symbol.prototype.pow.call(this, e);
};
ExpressionPolynomialRoot.prototype.multiplyPolynomialRoot = function (x) {
  var y = this;
  return new ExpressionPolynomialRoot(x.root.multiply(y.root));
};
ExpressionPolynomialRoot.prototype.add = function (e) {
  return e.addPolynomialRoot(this);
};
ExpressionPolynomialRoot.prototype.addPolynomialRoot = function (x) {
  var y = this;
  return new ExpressionPolynomialRoot(x.root.add(y.root));
};
Expression.prototype.addPolynomialRoot = function (root) {
  if (Expression.isConstant(this) && !Expression.has(this, Expression.ExpressionWithPolynomialRoot) && !(Expression.has(this, Expression.Complex)) && !(Expression.has(this, Expression.Exponentiation))) {
    var k = this;
    if (k.equals(Expression.ZERO)) { // for performance
      return root;
    }
    return new ExpressionPolynomialRoot(root.root.translate(k));
  }
  //throw new Error();
  return this.addExpression(root);
};
ExpressionPolynomialRoot.prototype.addExpression = function (e) {
  return this.add(e);//!?
};
ExpressionPolynomialRoot.prototype.divide = function (e) {
  //if (e.equals(Expression.ONE)) {
  //  return this;
  //}
  //if (!(e instanceof ExpressionPolynomialRoot) && !Expression.isConstant(e) || Expression.has(e, Expression.Matrix) || Expression.has(e, Expression.MatrixSymbol)) {
    //TODO: why - ?
  //  throw new Error();
  //}
  if (e instanceof Expression.Exponentiation) {
    return e.divideExpression(this);//?TODO: HACKs
  }
  if (e instanceof Expression.Multiplication && e.a instanceof Expression.Integer && e.b instanceof Expression.Exponentiation) {//TODO: ?
    return this.multiply(e.a.inverse()).divide(e.b);
  }
  return this.multiply(e.inverse());
};
ExpressionPolynomialRoot.prototype.divideExpression = function (x) {
  return x.multiply(this.inverse());
};
ExpressionPolynomialRoot.prototype.inverse = function () {
  return new ExpressionPolynomialRoot(this.root.inverse());
};
ExpressionPolynomialRoot.prototype.sign = function () {
  return this.root.sign();
};
var toRadicalExpression = function (polynomialRoot) {
  if (polynomialRoot.polynomial.getDegree() === 1) {
    //TODO: ???
    return polynomialRoot.polynomial.getroots()[0];
  }
  //TODO: ?
  var g = polynomialRoot.polynomial.getGCDOfTermDegrees();
  if (g > 1) {
    var v = toRadicalExpression(polynomialRoot._pow(g));
    if (v != null) {
      if (g % 2 === 1 || polynomialRoot.sign() > 0) {
        return Expression.NthRoot.makeRoot(v, g);
      } else {
        return new Expression.Negation(Expression.NthRoot.makeRoot(v, g));
      }
    }
  }
  // convert to depressed:
  var h = polynomialRoot.polynomial._getShiftToDepressed();
  if (!h.equals(Expression.ZERO)) {
    var tmp = toRadicalExpression(polynomialRoot.translate(h));
    if (tmp != null) {
      return new Expression.Addition(tmp, h.negate());
    }
  }
  return null;
};
ExpressionPolynomialRoot.prototype.toString = function (options) {
  //return new ExpressionWithPolynomialRoot(this, this).toString(options);
  options = options || {};
  if (options.rounding == null) {
    var p = (this.root instanceof LazyPolynomialRoot ? this.root._root : this.root).polynomial;
    if (p.getDegree() / p.getGCDOfTermDegrees() < 10) { //TODO: REMOVE !!!
      var re = toRadicalExpression(this.root.toPolynomialRoot());
      if (re != null) {
        return re.toString(options);
      }
    }
  }
  return toDecimalStringInternal(this, options.rounding || {fractionDigits: 3});
};
ExpressionPolynomialRoot.prototype.equals = function (other) {
  if (other instanceof ExpressionPolynomialRoot) {
    return this.root.equals(other.root);
  }
  // optimization
  if (other instanceof Expression.Integer) {
    return false;
  }
  if (!Expression.isRealAlgebraicNumber(other)) {//to avoid bugs with i**n
    return false;
  }
  /*if (Expression.isConstant(other)) {
    if (!this.root.polynomial.calcAt(other).equals(Expression.ZERO)) {
      return false;
    }
    var withinInterval = function (x, interval) {
      return Expression._isPositive(x.subtract(interval.a)) && Expression._isPositive(x.subtract(interval.b).negate());
    };
    return withinInterval(other, this.interval);
  }*/
  //TODO: optimize
  return this.subtract(other).equals(Expression.ZERO);
};
ExpressionPolynomialRoot.prototype.compare4MultiplicationComplex = function (x) {
  return -1;
  //return +1;
};
ExpressionPolynomialRoot.prototype.compare4MultiplicationNthRoot = function (x) {
  return 0;
};
ExpressionPolynomialRoot.prototype.compare4Multiplication = function (y) {
  if (y instanceof Expression.Complex) {
    return +1;
    //return -1;
  }
  if (y instanceof Expression.Integer) {
    return +1;
  }
  if (y instanceof ExpressionPolynomialRoot) {
    return 0;
  }
  if (y instanceof Expression.NthRoot) {
    return 0;//?
  }
  if (y instanceof Expression.Symbol) {
    return -1;
  }
  return Expression.Symbol.prototype.compare4Multiplication.call(this, y);
};
ExpressionPolynomialRoot.prototype.compare4MultiplicationSymbol = function (x) {
  return +1;
};
ExpressionPolynomialRoot.prototype.compare4Addition = function (y) {
  if (y instanceof ExpressionPolynomialRoot) {
    return 0;//?
  }
  if (y instanceof Expression.Symbol) {
    return +1;
  }
  if (y instanceof Expression.NthRoot) {
    return 0;//?
  }
  if (Expression.isRealAlgebraicNumber(y)) {
    return 0;//?
  }
  return Expression.Symbol.prototype.compare4Addition.call(this, y);
};
ExpressionPolynomialRoot.prototype.compare4AdditionSymbol = function (x) {
  return -1;
};

ExpressionPolynomialRoot.prototype._nthRoot = function (n) {//?
  if (this.root.sign() < 0) {
    //TODO: check
    return Expression.I.multiply(this.negate()._nthRoot(n));
  }
  return new ExpressionPolynomialRoot(this.root._nthRoot(n));
};

ExpressionPolynomialRoot.prototype.upgrade = function () {
  return new ExpressionPolynomialRoot(this.root.upgrade());//TODO: ?
};

ExpressionPolynomialRoot.prototype.isNegative = function () {
  return this.root.sign() < 0;
};

Expression.prototype.upgrade = function () { //TODO: remove !!!
  return this;
};

ExpressionPolynomialRoot.prototype.isExact = function () {
  //TODO: fix - ?
  return false;
};

ExpressionPolynomialRoot.prototype.negate = function () {
  return new ExpressionPolynomialRoot(this.root.negate()); // for performance
};

ExpressionPolynomialRoot.prototype.simplifyExpression = function () {//TODO: remove - ?
  return this;
};

ExpressionPolynomialRoot.prototype.toMathML = function (options) {
  options = options || {};
  if (options.rounding == null) {
    var p = (this.root instanceof LazyPolynomialRoot ? this.root._root : this.root).polynomial;
    if (p.getDegree() / p.getGCDOfTermDegrees() < 10) { //TODO: REMOVE !!!
      var re = toRadicalExpression(this.root.toPolynomialRoot());
      if (re != null) {
        return re.toMathML(options);
      }
    }
  }
  return toDecimalStringInternal(this, options.rounding || {fractionDigits: 3}, Expression._decimalToMathML, Expression._complexToMathML);
};

//TODO: ?????
ExpressionPolynomialRoot.prototype.getPrecedence = function () {
  return 1000;
};
ExpressionPolynomialRoot.prototype.isRightToLeftAssociative = function () {
  return true;
};
ExpressionPolynomialRoot.prototype.isUnaryPlusMinus = function () {
  return true;//TODO: !?
};

//ExpressionPolynomialRoot.prototype.complexConjugate = function () {//TODO: test
//  return this;
//};

Expression.ExpressionPolynomialRoot = ExpressionPolynomialRoot;

Expression.toPolynomialRoot = function (e) {
  var x = e instanceof Expression.NthRoot ? e.a : e;//TODO: remove
  var n = e instanceof Expression.NthRoot ? e.n : 1;//TODO: remove
  var symbol = new Expression.Symbol('x');
  if (!(x.getDenominator() instanceof Expression.Integer)) {
    throw new TypeError();
  }
  var p = Polynomial.toPolynomial(Expression.getConjugateExpression(symbol._pow(n).subtract(x).getNumerator()), symbol);
  //TODO: remove:
  if (p.getDegree() <= 8 && (true || isSmall(p))) {//TODO: ?
    var factor = p.factorize();
    if (factor != null && factor.getDegree() < p.getDegree() && factor.getDegree() === 4) {//?
      var roots = Polynomial.polynomialGCD(factor, Polynomial.toPolynomial(symbol._pow(n).subtract(x), symbol)).getroots();
      for (var iteratorroot = roots[globalThis.Symbol.iterator](), root = iteratorroot.next().value; root != null; root = iteratorroot.next().value) {
        if (root._pow(n).equals(x)) {
          //debugger;
          return Expression._isPositive(root) || n % 2 !== 0 ? root : root.negate();
        }
      }
    }
  }
  if (true) {
    //var root = Expression.toPolynomialRoot(x)._nthRoot(n);
    
    //TODO: Expression#toPolynomialRoot() - ?
    //TODO: move up (!?)
    p = p.squareFreeFactors().a1;//TODO: which one (?)
    var isComplex = n === 2 && Expression.has(e.radicand, Expression.Complex);
    var zeros = p.getZeros(undefined, isComplex);
    if (n % 2 === 0 && zeros.length === 2) {
      //TODO: remove
      if (Expression._isPositive(zeros[1]) && Expression._isPositive(x)) {
        return zeros[1];
      }
    }
    //TODO: find zero only on interval
    for (var iteratorzero = zeros[globalThis.Symbol.iterator](), zero = iteratorzero.next().value; zero != null; zero = iteratorzero.next().value) {
      if (zero.root != null && Expression._isPositive(zero) || isComplex && Expression._isPositive(Expression.getComplexNumberParts(zero).real)) {
        if (zero._pow(n).equals(x)) {
          return zero;
        }
      }
    }
    //TODO: ?
  }
  console.error(e.toString());
  return undefined;
};



globalThis.SturmSequence = SturmSequence;//TODO: ???

  // https://math.stackexchange.com/questions/309178/polynomial-root-finding
  function SturmSequence(f) {
    f = f.primitivePart();
    var d = f.derive();
    //d = d.primitivePart();
    d = d.scale(d.getContent().abs());// do not change the sign
      // https://en.wikipedia.org/wiki/Sturm%27s_theorem#Use_of_pseudo-remainder_sequences
    var s = [];
    s.push(f);
    s.push(d);
    // "subresultant" is slower
    //TODO: is primitive pseudo-remainder sequence always working?
    for (var iteratortmp = Polynomial._pseudoRemainderSequence(f, d, "primitive", true)[globalThis.Symbol.iterator](), tmp = iteratortmp.next().value; tmp != null; tmp = iteratortmp.next().value) {
      if (tmp.R.getDegree() >= 0) {
        s.push(tmp.R);
      }
    }
    var gcd = s[s.length - 1];
    if (gcd.getDegree() > 0) {
      console.error("it is faster to use square-free polynomials");
    }
    this.s = s;
  }

  SturmSequence.prototype.signChanges = function (x) {
    var result = 0;
    var sign = 0;
    for (var i = 0; i < this.s.length; i += 1) {
      var p = this.s[i];
      //var v = p.calcAt(x);
      var v = p._scaleRoots(x.getDenominator()).calcAt(x.getNumerator());
      var s = v.compareTo(Expression.ZERO);
      if (s !== 0) {
        if (sign === 0) {
          sign = s;
        } else {
          if (sign !== s) {
            sign = s;
            result += 1;
          }
        }
      }
    }
    return result;
  };

  // return the number of distict roots on the half-open interval (a, b] (see Wikipedia's article)
  // the polynomial should be square free or should not have roots on interval ends
  SturmSequence.prototype.numberOfRoots = function (interval) {
    if (interval.a.equals(interval.b)) {
      throw new TypeError();
    }
    return this.signChanges(interval.a) - this.signChanges(interval.b);
  };

  
  Polynomial.prototype.getRootIntervals3 = function () {
    if (!this.isSquareFreePolynomial()) {
      throw new RangeError();
    }
    if (this.calcAt(Expression.ZERO).equals(Expression.ZERO)) {
      throw new RangeError();
    }
    var polynomial = this;
    var sturmSequence = new SturmSequence(this);
    var interval = {a: this._scaleRoots(Expression.ONE.negate()).getPositiveRealRootsBound().negate(), b: this.getPositiveRealRootsBound()};
    var getIntervals = function (interval, rootsAfterA, rootsAfterB, valueAtA, valueAtB) {
      //var n = sturmSequence.numberOfRoots(interval);
      var n = rootsAfterA - rootsAfterB;
      if (valueAtA.equals(Expression.ZERO)) {
        if (n > 0) {
          n = 1/0;
        }
      }
      if (valueAtB.equals(Expression.ZERO)) {
        if (n === 1) {
          return [{a: interval.b, b: interval.b}];
        }
        console.assert(n > 1);
      }
      if (n === 1) {
        return [interval];
      }
      if (n > 1) {
        var middle = interval.a.add(interval.b).divide(Expression.TWO);
        var rootsAfterM = sturmSequence.signChanges(middle);
        var valueAtM = polynomial.calcAt(middle);
        var a = getIntervals({a: interval.a, b: middle}, rootsAfterA, rootsAfterM, valueAtA, valueAtM);
        var b = getIntervals({a: middle, b: interval.b}, rootsAfterM, rootsAfterB, valueAtM, valueAtB);
        return a.concat(b);
      }
      return [];
    };
    var negative = getIntervals({a: interval.a, b: Expression.ZERO}, sturmSequence.signChanges(interval.a), sturmSequence.signChanges(Expression.ZERO), polynomial.calcAt(interval.a), polynomial.calcAt(Expression.ZERO));
    var positive = getIntervals({a: Expression.ZERO, b: interval.b}, sturmSequence.signChanges(Expression.ZERO), sturmSequence.signChanges(interval.b), polynomial.calcAt(Expression.ZERO), polynomial.calcAt(interval.b));
    return negative.concat(positive);
  };

  Polynomial.prototype.signVariations = function () {
    var result = 0;
    var sign = 0;
    for (var i = this.a.size - 1; i >= 0; i -= 1) {
      var s = this.a.coefficient(i).sign();
      if (s !== 0) {
        if (sign === 0) {
          sign = s;
        } else {
          if (sign !== s) {
            sign = s;
            result += 1;
          }
        }
      }
    }
    return result;
  };

  Polynomial.prototype._getNonNegativeRealRootIntervals = function () {
    // The polynomial should be square free, the check is commented out for performance
    //if (!this.isSquareFreePolynomial()) {
    //  throw new RangeError();
    //}
    // https://en.wikipedia.org/wiki/Real-root_isolation#Pseudocode
    var B = this.getPositiveRealRootsBound();
    if (B.equals(Expression.ZERO)) {
      return [];
    }
    // https://en.wikipedia.org/wiki/Real-root_isolation#Bisection_method
    var p = this._scaleRoots(B.inverse()); // map [0; B] to [0; 1]
    var maxPositiveRealRoots = (this.getCoefficient(0).equals(Expression.ZERO) ? 1 : 0) + this.signVariations();
    var L = function (a, b, q) { // get root intervals of q on [0; 1]
      var newQ = q.getCoefficient(0).equals(Expression.ZERO) ? q.divideAndRemainder(Polynomial.of(Expression.ZERO, Expression.ONE), "throw").quotient : q;
      var qq = newQ._exponentiateRoots(-1)._translateRoots(Expression.ONE.negate());
      //TODO: what is wrong with Wikipedia - ?
      var v = qq.signVariations();
      if (v === 1 && q.getCoefficient(0).equals(Expression.ZERO)) {
        v = 0/0;//!?
      }
      if (v === 0 && q.getCoefficient(0).equals(Expression.ZERO)) {
        return [{a: a, b: a}];
      }
      if (v === 1 && (qq.getCoefficient(0).equals(Expression.ZERO) ? 1 : 0)) {
        v = 0/0;//!?
      }
      if (v === 1) {
        return [{a: a, b: b}];
      } else if (v !== 0) {
        var firstQ = q._scaleRoots(Expression.TWO);
        var middle = a.add(b).divide(Expression.TWO);
        var first = L(a, middle, firstQ);
        if (first.length >= maxPositiveRealRoots) {
          return first;//!
        }
        var secondQ = firstQ._translateRoots(Expression.ONE.negate());
        var second = L(middle, b, secondQ);
        return first.concat(second);
      }
      return [];
    };
    return L(Expression.ZERO, Expression.ONE, p).map(function (entry) { return ({a: entry.a.multiply(B), b: entry.b.multiply(B)}); });
  };

  Polynomial.prototype.getRootIntervals = function () {
    return this._scaleRoots(Expression.ONE.negate())._getNonNegativeRealRootIntervals().map(function (entry) { return ({a: entry.b.negate(), b: entry.a.negate()}); }).reverse().concat(this._getNonNegativeRealRootIntervals());
  };

  Polynomial.prototype.getPositiveRealRootsBound = function () {
    //TODO: only integer coefficients (?)
    // https://en.wikipedia.org/wiki/Sturm%27s_theorem#Number_of_real_roots
    // https://en.wikipedia.org/wiki/Geometrical_properties_of_polynomial_roots#Bounds_of_positive_real_roots
    var M = null;
    //TODO: fix the iteration
    var n = this.getDegree();
    var an = this.getLeadingCoefficient();
    for (var i = 0; i <= this.getDegree() - 1; i += 1) {
      var v = this.getCoefficient(i).negate().truncatingDivide(an);
      if (v.sign() >= 0) {
        var c = Expression.TWO.multiply(Expression.Integer.fromBigInt(nthRoot(v.toBigInt(), n - i)).add(Expression.ONE));
        if (M == null || M.compareTo(c) < 0) {
          M = c;
        }
      }
    }
    if (M == null) {
      return Expression.ZERO;
    }
    //!2020-12-19
    // round to a power of two:
    M = Expression.TWO._pow(M.getNumerator().bitLength() - M.getDenominator().bitLength() + 1);
    //!
    return M;
  };

  //TODO: BigDecimal - ?, rounding - ?
  Polynomial.prototype.getZero = function (interval, precision) {
    var floorDiv = function (a, b) {
      if (b.compareTo(Expression.ZERO) < 0) {
        a = a.negate();
        b = b.negate();
      }
      return a.compareTo(Expression.ZERO) >= 0 ? a.truncatingDivide(b) : a.add(Expression.ONE).truncatingDivide(b).subtract(Expression.ONE);
    };
    var roundFloor = function (point, e) {
      var n = point.getNumerator().multiply(e);
      var d = point.getDenominator();
      return floorDiv(n, d);
    };
    var sign = function (v) {
      return Math.sign(v.getNumerator().compareTo(Expression.ZERO));
    };
    //var BASE = Expression.TEN;
    var BASE = Expression.TWO;
    var e = Expression.pow(BASE, precision); // epsilon^-1
    if (!(e instanceof Expression.Integer)) {
      throw new RangeError("epsilon^-1 is not an integer");
    }
    var a = interval.a;
    var b = interval.b;
    // (b - a) * Math.pow(10, precision) > min(abs(a), abs(b))
    // (b - a) * Math.pow(10, fractionDigits) > 1
    //TODO: fix to use precision, not fractionDigits
    // e * (b - a) > 0:
    if (e.multiply(a.getDenominator().multiply(b.getNumerator()).subtract(b.getDenominator().multiply(a.getNumerator()))).compareTo(b.getDenominator().multiply(a.getDenominator())) > 0) {
      //TODO:
      var tmp = true && precision >= 16 / Math.log10(BASE.toNumber()) ? this.getZero(interval, Math.floor(precision / 4)) : interval;
      a = tmp.a;
      b = tmp.b;

      var n = this.getDegree();
      var p = this._scaleRoots(e);
      //p = p.primitivePart();//?
      var sa = roundFloor(a, e).add(Expression.ONE); // a.getNumerator().multiply(e).truncatingDivide(a.getDenominator()).add(Expression.ONE);//?
      var sb = roundFloor(b, e); // b.getNumerator().multiply(e).truncatingDivide(b.getDenominator());//?
      console.assert(sa.multiply(a.getDenominator()).subtract(a.getNumerator().multiply(e)).compareTo(Expression.ZERO) >= 0); // sa/e >= a
      console.assert(sb.multiply(b.getDenominator()).subtract(b.getNumerator().multiply(e)).compareTo(Expression.ZERO) <= 0); // sb/e <= b
      //TODO: bigdecimal - ?
      // remember values at boundaries to reuse in the loop:
      var pa = p.calcAt(sa);
      var pb = p.calcAt(sb);
      var spb = sign(pb);
      var spa = sign(pa);
      if (spa === 0) {
        return {a: sa.divide(e), b: sa.divide(e)};
      }
      if (spb === 0) {
        return {a: sb.divide(e), b: sb.divide(e)};
      }
      if (spa === spb) {
        if (spa !== (sign(this.calcAt(a)) || sign(this.calcAt(b).negate()) || spa)) {
          return {a: a, b: sa.divide(e)};
        }
        if (spb !== sign(this.calcAt(b))) {
          return {a: sb.divide(e), b: b};
        }
        throw new RangeError();//?
      }
      a = sa;
      b = sb;
      // bisection method
      var cc = 0;
      var d = p.derive();
      var width = b.subtract(a);
      while (width.compareTo(Expression.ONE) > 0) {// b - a > 1
        var middle = a.add(width.truncatingDivide(Expression.TWO));
        //console.log(eval(a.divide(e).toString()) + ' - ' + eval(b.divide(e).toString()));
        //?
        if (cc % 3 !== 2 && width.compareTo(a.abs()) < 0) {// TODO: test for the case when a < 0
          // TODO: better guesses
          // Newton's method
          var x = cc % 3 === 1 ? a : b;
          var px = x === a ? pa : (x === b ? pb : undefined);
          var c = d.calcAt(x);
          if (!c.equals(Expression.ZERO)) {
            x = x.subtract(px.truncatingDivide(c));
            if (x.compareTo(a) <= 0) {
              x = a.add(Expression.ONE);
            }
            if (x.compareTo(b) >= 0) {
              x = b.subtract(Expression.ONE);
            }
            //console.log("N: " + a + "  - " + x);
            middle = x;
          }
        }
        cc += 1;
        //?
        var v = p.calcAt(middle);
        var sv = sign(v);
        if (sv === spb) {
          b = middle;
          pb = v;
        } else if (sv === spa) {
          a = middle;
          pa = v;
        } else {
          a = middle;
          b = middle;
          pa = v;
          pb = v;
        }
        width = b.subtract(a);
      }
      //console.debug(cc);
      a = a.divide(e);
      b = b.divide(e);
    }
    return {a: a, b: b};
  };

  Polynomial.prototype.hasRoot = function (polynomialRoot) {
    var f = this;
    if (f.equals(Polynomial.ZERO)) {
      return true;
    }
    //!new 2021-02-20 (TODO: CHECK)
    if (!f.hasIntegerCoefficients() && f.hasComplexCoefficients()) {
      return f.map(function (c) { return c instanceof Expression.Integer ? c : c.real; }).hasRoot(polynomialRoot) && f.map(function (c) { return c instanceof Expression.Integer ? Expression.ZERO : c.imaginary; }).hasRoot(polynomialRoot);
    }
    //!
    var p = polynomialRoot.polynomial;
    var g = null;
    //!
    if (!f.hasIntegerCoefficients()) {
      var variable = new Expression.Symbol('~');
      var ff = f.calcAt(variable);
      var tmp = Expression.getMultivariatePolynomial(ff);
      if (tmp != null && !tmp.v.equals(variable) && tmp.v instanceof Expression.Symbol) {
        g = Polynomial.polynomialGCD(Polynomial.toPolynomial(tmp.p.getContent(), variable), p);
      }
    }
    if (g == null) {
      g = Polynomial.polynomialGCD(f, p);
    }
    //!
    if (g.getDegree() < 1) {
      return false;
    }
    var i = polynomialRoot.interval;

    if (!g.hasIntegerCoefficients()) {
      //TODO: BUG?
      //?new
      var variable = new Expression.Symbol('$$');
      var e = g.calcAt(variable);
      var c = Expression.getComplexConjugate(e);
      if (c != null) {
        g = Polynomial.toPolynomial(c.multiply(e), variable).getSquareFreePolynomial();
      }
      //?
    }

    return g.numberOfRoots(i) === 1;
  };

  // get number of distinct roots on the closed interval [a, b]
  Polynomial.prototype.numberOfRoots3 = function (interval) {
interval = interval == undefined ?  null : interval;

    if (interval == null) {
      interval = {a: this._scaleRoots(Expression.ONE.negate()).getPositiveRealRootsBound().negate(), b: this.getPositiveRealRootsBound()};//TODO: use (-1/0; +1/0)
    }
    var p = this;
    var aIsARoot = false;
    while (p.calcAt(interval.a).equals(Expression.ZERO)) {
      p = p.divideAndRemainder(Polynomial.of(interval.a.getNumerator().negate(), interval.a.getDenominator())).quotient;
      aIsARoot = true;
    }
    var bIsARoot = false;
    while (p.calcAt(interval.b).equals(Expression.ZERO)) {
      p = p.divideAndRemainder(Polynomial.of(interval.b.getNumerator().negate(), interval.b.getDenominator())).quotient;
      bIsARoot = true;
    }
    var sturmSequence = new SturmSequence(p);
    return (aIsARoot ? 1 : 0) + (bIsARoot ? 1 : 0) + sturmSequence.numberOfRoots(interval);
  };

  // get number of distinct roots on the closed interval [a, b]
  Polynomial.prototype.numberOfRoots = function (interval) {
interval = interval == undefined ?  null : interval;

    if (!this.hasIntegerCoefficients()) {
      //debugger;
      return this.numberOfRoots3(interval);
    }
    if (interval == null) {
      interval = {a: this._scaleRoots(Expression.ONE.negate()).getPositiveRealRootsBound().negate(), b: this.getPositiveRealRootsBound()};
    }
    var p = this;
    if (!interval.a.equals(Expression.ZERO)) {
      p = p._scaleRoots(interval.a.inverse())
           ._translateRoots(Expression.ONE.negate());
      interval = {
        a: Expression.ZERO,
        b: interval.b.divide(interval.a).subtract(Expression.ONE)
      };
      if (interval.b.getNumerator().sign() < 0) {
        interval = {a: interval.a, b: interval.b.negate()};
        p = p._scaleRoots(Expression.ONE.negate());
      }
    }
    console.assert(interval.a.equals(Expression.ZERO));
    var zeros = 0;
    while (p.getCoefficient(zeros).equals(Expression.ZERO)) {
      zeros += 1;
    }
    if (zeros > 0) {
      p = p.divideAndRemainder(Polynomial.of(Expression.ONE).shift(zeros), "throw").quotient;
    }
    return zeros + 
           p._exponentiateRoots(-1)
            ._scaleRoots(interval.b)
            ._translateRoots(Expression.ONE.negate())
            ._getNonNegativeRealRootIntervals().length;
  };

  // Polynomial.toPolynomial(ExpressionParser.parse("x^3-8x^2+21x-18"), ExpressionParser.parse("x")).getZeros(3).toString()
  Polynomial.prototype.getZeros = function (precision, complex) {
precision = precision == undefined ?  0 : precision;
complex = complex == undefined ?  false : complex;

    if (this.getCoefficient(0).equals(Expression.ZERO)) {
      if (this.getLeadingCoefficient().equals(Expression.ZERO)) {
        throw new TypeError();
      }
      var i = 0;
      while (this.getCoefficient(i).equals(Expression.ZERO)) {
        i += 1;
      }
      var tmp = this.divideAndRemainder(Polynomial.of(Expression.ONE).shift(i)).quotient.getZeros(precision, complex);
      return tmp.concat(new Array(i).fill(Expression.ZERO));
    }
    //TODO: test
    var content = this.getContent();
    var f = this.scale(content.getDenominator()).divideAndRemainder(Polynomial.of(content.getNumerator()), "throw").quotient;

    // https://en.wikipedia.org/wiki/Square-free_polynomial
    var tmp = f.squareFreeFactors();
    var a0 = tmp.a0;
    var a1 = tmp.a1;

    if (a0.getDegree() !== 0) {
      var tmp1 = a1.getZeros(precision, complex); // roots with multiplicity = 1 (?)
      var tmp2 = a0.getZeros(precision, complex);
      var result = [];
      var previous = undefined;
      for (var i = 0; i < tmp2.length; i += 1) {
        var zero = tmp2[i];
        if (zero !== previous) {
          result.push(zero);
          previous = zero;
        }
        result.push(zero);
      }
      return tmp1.concat(result);
    }

    var p = f;
    if (p.getDegree() === 0) {
      return [];
    }

    //!
    p = p.scale(p.getContent().inverse());
    //!

    if (!f.hasIntegerCoefficients()) {
      //?new
      var variable = new Expression.Symbol('$$')
      var e = f.calcAt(variable);
      var c = Expression.getConjugateExpression(e);
      if (c != null && !e.equals(c)) {
        var result = [];
        var tmp = Polynomial.toPolynomial(c, variable).getZeros(precision, complex);
        console.time('checking roots');
        for (var i = 0; i < tmp.length; i += 1) {
          var zero = tmp[i];
          if (zero instanceof ExpressionPolynomialRoot && zero.root.e.equals(new Expression.Symbol('α')) ? f.hasRoot(zero.root._root) :
              zero instanceof ExpressionWithPolynomialRoot && zero.e === zero.root ? f.hasRoot(zero.root) :
              f.calcAt(zero).equals(Expression.ZERO)) {
            result.push(zero);
          } else {
            //TODO:?
            console.debug(zero.root);
          }
        }
        console.timeEnd('checking roots');
        return result;
      }
      //!new
      // u * x + v = t
      // u**n*x**n = a_n*x**n, u = a_n**(1/n)
      // u**(n-1)*x**(n-1)*v*n+u**(n-1)*x**(n-1) = a_(n-1)*x**(n-1)
      var u = Polynomial.of(Expression.ONE).shift(f.getDegree()).subtract(Polynomial.of(f.getLeadingCoefficient())).getroots();
      if (u.length !== 0) {
        u = u[0];
        var v = f.getCoefficient(f.getDegree() - 1).divide(u._pow(f.getDegree() - 1)).subtract(Expression.ZERO).divide(Expression.Integer.fromNumber(f.getDegree()));
        var x = new Expression.Symbol('$$');//?
        var pt = Polynomial.toPolynomial(p.calcAt(x.subtract(v).divide(u)).getNumerator(), x);
        if (pt.hasIntegerCoefficients()) {//TODO: ?
          return pt.getZeros(precision, complex).map(function (zero) {
            return zero.subtract(v).divide(u);
          });
        }
      }
      //!
      //?
      return [];
    }

    //!new
    if (p.getDegree() === 3) {
      //?
    }
    //!

    // https://en.wikipedia.org/wiki/Sturm%27s_theorem
    var intervals = p.getRootIntervals();

    // https://math.stackexchange.com/questions/309178/polynomial-root-finding
    // "it is guaranteed that there is a sign change inside every interval (because there are no repeated zeroes)"
    var result = new Array(intervals.length);
    var enableNewClass = false;//TODO: ?
    for (var i = 0; i < intervals.length; i += 1) {
      var zero = p.getZero(intervals[i], precision);
      if (zero.a.equals(zero.b)) {
        result[i] = zero.a;//TODO: fix
      } else {
        //! p, not f, as f may have roots with multiplicity > 1
        if (!enableNewClass) {
          var root = new Expression.PolynomialRootSymbol(p, zero);
          result[i] = new ExpressionWithPolynomialRoot(root, root);
        } else {
          var root = new ExpressionPolynomialRoot(LazyPolynomialRoot.create(p, new LazyPolynomialRoot.SimpleInterval(zero.a, zero.b), {skipFactorization: true}));
          //result[i] = new ExpressionWithPolynomialRoot(new Expression.Symbol('$α'), root);
          result[i] = root;
        }
      }
    }
    //return result;

    //!new
    //var p = np;
    if (intervals.length !== p.getDegree() && true && complex) {
      //!new
      if (p.getDegree() > 4) {//?
        var factor = p.factorize();
        if (factor != null) {
          //TODO: remove double work
          return factor.getZeros(precision, complex).concat(p.divideAndRemainder(factor, "throw").quotient.getZeros(precision, complex));
        }
      }
      //!
      if (p.isEven()) {
        //debugger;
        var zeros = p._exponentiateRoots(2).getZeros(precision, complex);
        for (var iteratorzero = zeros[globalThis.Symbol.iterator](), zero = iteratorzero.next().value; zero != null; zero = iteratorzero.next().value) {
          //var z = zero.squareRoot();
          // https://en.wikipedia.org/wiki/Complex_number#Square_root
          var squareRoot = function (z) {
            var tmp = Expression.getComplexNumberParts(z);
            var a = tmp.real;
            var b = tmp.imaginary;
            var aapbb = a._pow(2).add(b._pow(2)).squareRoot();
            var γ = a.add(aapbb).divide(Expression.TWO).squareRoot();
            var sign = (b.compareTo(Expression.ZERO) > 0 ? Expression.ONE : Expression.ONE.negate());
            var tmp = a.negate().add(aapbb).divide(Expression.TWO);
            //debugger;
            var δ = sign.multiply(tmp.squareRoot());
            return γ.add(δ.multiply(Expression.I));
          };
          //zero = zero instanceof ExpressionWithPolynomialRoot ? zero.upgrade() : zero;
          if (!Expression._isPositive(zero)) {
            var z = squareRoot(zero.e != null ? zero.upgrade() : zero);
            result.push(z);
            result.push(z.negate());
          }
        }
        return result;
      }
      //var p = stringToPolynomial("x^5+2*x^2+2*x+3");

      var e = p.calcAt(new Expression.Symbol("a").add(new Expression.Symbol("b").multiply(Expression.I)));
      var ce = Expression.getComplexConjugate(e);
      var pa = ce.add(e);//TODO: ?
      var pb = ce.subtract(e).multiply(Expression.I).divide(new Expression.Symbol('b'));
      var cpa = pa;
      var cpb = pb;
      var getZeros1 = function (p) {//TODO: !? use everywhere (?)
        var factor = p.factorize();
        if (factor != null) {
          //TODO: remove double work
          return factor.getZeros(undefined, false).concat(p.divideAndRemainder(factor, "throw").quotient.getZeros(undefined, false));
        }
        return p.getZeros(undefined, false);
      };
    if (true) {
      pa = Polynomial.toPolynomial(pa, new Expression.Symbol('a'));
      pb = Polynomial.toPolynomial(pb, new Expression.Symbol('a'));
      while (pa.getCoefficient(0).equals(Expression.ZERO)) {
        pa = pa.divideAndRemainder(Polynomial.of(Expression.ONE).shift(1)).quotient;//TODO: simplify
      }
      while (pb.getCoefficient(0).equals(Expression.ZERO)) {
        // a = 0, p(b*i) = 0
        var candidates = Polynomial.toPolynomial(pa.calcAt(Expression.ZERO), new Expression.Symbol('b')).getZeros(undefined, false);
        for (var iteratorc = candidates[globalThis.Symbol.iterator](), c = iteratorc.next().value; c != null; c = iteratorc.next().value) {
          var root = c.multiply(Expression.I);
          if (p.calcAt(root).equals(Expression.ZERO)) {
            result.push(root);
          }
        }
        pb = pb.divideAndRemainder(Polynomial.of(Expression.ONE).shift(1)).quotient;//TODO: simplify
      }
      //TODO: verify that no roots are lost
      console.assert(pa.getContent() instanceof Expression.Integer);
      pa = pa.divideAndRemainder(Polynomial.of(pa.getContent()), "throw").quotient;
      //TODO: verify that no roots are lost
      console.assert(pb.getContent() instanceof Expression.Integer);
      pb = pb.divideAndRemainder(Polynomial.of(pb.getContent()), "throw").quotient;

      var walk = function (p1, p2, condition) {
        if (p2.getDegree() > 0) {
          var lc = p2.getLeadingCoefficient();
          var c1 = condition.andZero(lc);
          var simplifyCoefficients = function (p, condition) {
            if (condition.array.length === 1 && condition.array[0].operator === " == 0") {
              //console.assert(condition.array.length === 1 && condition.array[0].operator === " == 0");
              var varB = new Expression.Symbol('b');
              var zero = Polynomial.toPolynomial(condition.array[0].expression, varB);
              return p.map(function (coefficient) {
                var n = Polynomial.toPolynomial(coefficient.getNumerator(), varB).divideAndRemainder(zero).remainder.calcAt(varB);
                var d = Polynomial.toPolynomial(coefficient.getDenominator(), varB).divideAndRemainder(zero).remainder.calcAt(varB);
                return n.divide(d);
              });
            }
            return p;
          };
          if (!c1.isFalse()) {
            walk(simplifyCoefficients(p1, c1), simplifyCoefficients(p2, c1), c1);
          }
          var c2 = condition.andNotZero(lc);
          if (!c2.isFalse()) {
            console.assert(result.length < p.getDegree());
            var newp2 = p2.scale(p2.getContent().inverse());
            p1 = p1.scale(p1.map(function (c) { return c.getDenominator().inverse(); }).getContent().inverse());
            var r = Polynomial.pseudoRemainder(p1, newp2);
            walk(newp2, simplifyCoefficients(r, c2), c2);
          }
        } else {
          //TODO: ?
          condition = condition.andZero(p2.getLeadingCoefficient());
          if (!condition.isFalse()) {
            console.assert(condition.array.length === 1 && condition.array[0].operator === " == 0");
            var bPolynomial = Polynomial.toPolynomial(condition.array[0].expression, new Expression.Symbol('b'));
            //TODO: fix for higher degrees (?)
            var candidates = bPolynomial.getDegree() < 3 ? bPolynomial.getroots() : getZeros1(bPolynomial);
            candidates = candidates.filter(function (c) { return Expression._isPositive(c); });//!?
            for (var iteratorb = candidates[globalThis.Symbol.iterator](), b = iteratorb.next().value; b != null; b = iteratorb.next().value) {
              var pp = p1.map(function (coefficient) { return Polynomial.toPolynomial(coefficient.getNumerator(), new Expression.Symbol('b')).calcAt(b).divide(Polynomial.toPolynomial(coefficient.getDenominator(), new Expression.Symbol('b')).calcAt(b)); });
              if (pp.getDegree() === 1 || pp.getCoefficient(1).equals(Expression.ZERO) && pp.getDegree() < 3) {
                var roots = pp.getroots();
                for (var iteratora = roots[globalThis.Symbol.iterator](), a = iteratora.next().value; a != null; a = iteratora.next().value) {
                  if (!Expression.has(a, Expression.Complex)) {
                    result.push(a.add(b.multiply(Expression.I)));
                    result.push(a.add(b.negate().multiply(Expression.I)));
                  }
                }
              }
            }
          }
        }
      };
      if (p.getDegree() < 16) {//!!!TODO: ?
      walk(pa, pb, Condition.TRUE);
      }
      //console.log(pa + '', pb + '');
    }
      //!TODO: 
      //!new 2021-01-03
      if (result.length < p.getDegree()) {
        console.count('yyy');
        //debugger;
        var resultant = function (v1, v2) {
          var A = Polynomial.toPolynomial(cpa, new Expression.Symbol(v1));
          var B = Polynomial.toPolynomial(cpb, new Expression.Symbol(v1));
          return Polynomial.resultant(A, B, v2).primitivePart();
        };
        var bCandidates = getZeros1(resultant('a', 'b'));
        var aCandidates = getZeros1(resultant('b', 'a'));
        var unique = function (array) {
          //return Array.from(new Set(array));
          var result = [];
          for (var iteratorelement = array[globalThis.Symbol.iterator](), element = iteratorelement.next().value; element != null; element = iteratorelement.next().value) {
            if (result.indexOf(element) === -1) {
              result.push(element);
            }
          }
          return result;
        };
        bCandidates = unique(bCandidates);
        aCandidates = unique(aCandidates);
        bCandidates = bCandidates.filter(function (c) { return Expression._isPositive(c); });//!?
        //!new
        if (true) {
          var A = Polynomial.toPolynomial(cpa, new Expression.Symbol('a')).map(function (c) { return Polynomial.toPolynomial(c, new Expression.Symbol('b')); });
          var B = Polynomial.toPolynomial(cpb, new Expression.Symbol('a')).map(function (c) { return Polynomial.toPolynomial(c, new Expression.Symbol('b')); });
          //var g0 = Polynomial.polynomialGCD(A, B);
          //console.log(g0.toString());
          for (var iteratorb = bCandidates[globalThis.Symbol.iterator](), b = iteratorb.next().value; b != null; b = iteratorb.next().value) {
            var A1 = A.map(function (c) { return c.calcAt(b); });
            var B1 = B.map(function (c) { return c.calcAt(b); });
            var g = Polynomial.polynomialGCD(A1, B1);
            //console.log(g.toString());
            //throw new Error();
            //TODO: g.getDegree() > 1 is possible (!!!)
            if (g.getDegree() <= 2) {
              for (var iteratora = g.getroots()[globalThis.Symbol.iterator](), a = iteratora.next().value; a != null; a = iteratora.next().value) {
                var candidate = a.add(b.multiply(Expression.I));
                result.push(candidate);
                result.push(candidate.complexConjugate());
              }
            } else {
              debugger;
              //TODO: ?
            }
          }
        }
        
        if (result.length < p.getDegree()) {
          
        //!
        //console.log(bCandidates.map(function (x) { return typeof x.upgrade === 'function' ?  x.upgrade() : x; }).toString());
        //console.log(aCandidates.map(function (x) { return typeof x.upgrade === 'function' ?  x.upgrade() : x; }).toString());
        // https://en.wikipedia.org/wiki/Resultant#Application_to_polynomial_systems
        //debugger;
        for (var iteratora = aCandidates[globalThis.Symbol.iterator](), a = iteratora.next().value; a != null; a = iteratora.next().value) {
          for (var iteratorb = bCandidates[globalThis.Symbol.iterator](), b = iteratorb.next().value; b != null; b = iteratorb.next().value) {
            var candidate = a.add(b.multiply(Expression.I));
            if (p.calcAt(candidate).equals(Expression.ZERO)) {
              result.push(candidate);
              result.push(candidate.complexConjugate());
            }
          }
        }
        
        }
      }
    }
    //!

    if (intervals.length !== p.getDegree() && true && complex) {
      //TODO: FIX!!!
      var strings = result.map(function (x) { return x.toMathML({rounding: {fractionDigits: 3}}); });
      result = result.filter(function (x, index) {
        for (var j = index - 1; j >= 0; j -= 1) {
          if (strings[j] === strings[index]) {
            if (result[j].equals(result[index])) {
              return false;
            }
          }
        }
        return true;
      });
    }

    return result;
  };

Polynomial.getSylvesterMatrix = function (p, q) {
  var m = p.getDegree();
  var n = q.getDegree();
  if (m < 0 || n < 0) {
    throw new RangeError();
  }
  return Matrix.Zero(n + m, n + m).map(function (element, i, j) {
    var index1 = m - (j - i);
    var index2 = n - (j - (i - n));
    return i < n ? (index1 < 0 || index1 > m ? Expression.ZERO : p.getCoefficient(index1)) : (index2 < 0 || index2 > n ? Expression.ZERO : q.getCoefficient(index2));
  });
};

Polynomial._resultantByDeterminant = function (p, q, v2) {
  if (p.getDegree() === 0 && q.getDegree() === 0) {
    return Expression.ONE;
  }
  //return Polynomial.toPolynomial(Polynomial.getSylvesterMatrix(p, q).determinant(), new Expression.Symbol(v2));
  var d = Polynomial.getSylvesterMatrix(p, q).map(function (e) { return new Expression.Polynomial(Polynomial.toPolynomial(e, new Expression.Symbol(v2))); }).determinant();
  return d.polynomial != null ? d.polynomial : d;
};

function pseudoRemainderSequence(A, B, type, produceSturmSequence) {
type = type == undefined ?  "primitive" : type;
produceSturmSequence = produceSturmSequence == undefined ?  false : produceSturmSequence;

  var g = Math.gcd(A.getGCDOfTermDegrees(), B.getGCDOfTermDegrees());
  if (g > 1) {
    console.error('g > 1');
  }
  var first = true;
  var phi = Expression.ONE;
  var iterator = {
    next: function () {
      console.assert(A.getDegree() >= B.getDegree());
      if (!B.equals(Polynomial.ZERO)) {
        var d = A.getDegree() - B.getDegree();
        var scale = B.getLeadingCoefficient()._pow(d + 1);
        var tmp = A.scale(produceSturmSequence ? scale.abs() : scale).divideAndRemainder(B, "throw");
        var q = tmp.quotient;
        var r = tmp.remainder;
        var α = Expression.ONE;
        if (type === "trivial") {
          // https://en.wikipedia.org/wiki/Polynomial_greatest_common_divisor#Trivial_pseudo-remainder_sequence
          α = Expression.ONE;
        } else if (type === "primitive") {
          // https://en.wikipedia.org/wiki/Polynomial_greatest_common_divisor#Primitive_pseudo-remainder_sequence
          α = r.getContent();
        } else if (type === "subresultant") {
          // For the explanation and proof see Donald E. Knuth The Art of computer programming Third Edition, Volume 2 (Seminumerical algorithms), page 428.
          // https://en.wikipedia.org/wiki/Polynomial_greatest_common_divisor#Subresultant_pseudo-remainder_sequence
          α = first ? Expression.ONE : A.getLeadingCoefficient().multiply(phi._pow(d));
          first = false;
          phi = d === 0 ? phi : B.getLeadingCoefficient()._pow(d).divide(phi._pow(d).divide(phi));
        } else {
          throw new RangeError(type);
        }
        var R = (produceSturmSequence ? r.negate() : r).divideAndRemainder(Polynomial.of(produceSturmSequence ? α.abs() : α), "throw").quotient;
        var value = {R: R, q: q, α: α};
        A = B;
        B = R;
        return {value: value, done: false};
      }
      return {value: undefined, done: true};
    }
  };
  iterator[globalThis.Symbol.iterator] = function () {
    return this;
  };
  return iterator;
}

Polynomial._pseudoRemainderSequence = pseudoRemainderSequence;

Polynomial._resultantUsingSubresultantPseudoRemainderSequence = function (A, B, v2) {
  if (A.getDegree() === Polynomial.ZERO.getDegree() || B.getDegree() === Polynomial.ZERO.getDegree()) {
    return v2 !== "NO_VARIABLE" ? Polynomial.ZERO : Expression.ZERO;
  }
  var g = Math.gcd(A.getGCDOfTermDegrees(), B.getGCDOfTermDegrees());
  if (g > 1) {
    // why is this true?
    var tmp = Polynomial._resultantUsingSubresultantPseudoRemainderSequence(A._exponentiateRoots(g), B._exponentiateRoots(g), v2);
    //TODO: ?
    return tmp._pow(g);
  }
  var AA = A;
  var BB = B;
  var start = Date.now();
  if (v2 !== "NO_VARIABLE") {
  A = A.map(function (c) { return new Expression.Polynomial(Polynomial.toPolynomial(c, new Expression.Symbol(v2))); });
  B = B.map(function (c) { return new Expression.Polynomial(Polynomial.toPolynomial(c, new Expression.Symbol(v2))); });
  }
  var resultantSign = 1;
  if (A.getDegree() < B.getDegree()) {
    var tmp = A;
    A = B;
    B = tmp;
    resultantSign *= Math.pow(Math.pow(-1, A.getDegree()), B.getDegree()); // https://en.wikipedia.org/wiki/Resultant#Characterizing_properties
  }
  var resultant2 = [];
  resultant2.push({base: Expression.ONE, exponent: -2 * B.getDegree()});
  var isPseudoRemainderSequence = true;
  for (var iteratortmp = Polynomial._pseudoRemainderSequence(A, B, "subresultant")[globalThis.Symbol.iterator](), tmp = iteratortmp.next().value; tmp != null; tmp = iteratortmp.next().value) {
    //var A = tmp.A;
    //var B = tmp.B;
    var R = tmp.R;
    var α = tmp.α;
    // https://en.wikipedia.org/wiki/Resultant#Properties
    // b_0**(deg(A - Q * B) - deg(A)) * res(A, B) = res(A - Q * B, B)
    // res(A, B) = (-1)**(deg(A) * deg(B)) * res(B, A)
    //resultant = resultant.multiply(B.getLeadingCoefficient()._pow(A.getDegree() - Math.max(R.getDegree(), 0)));
    //resultant = resultant.multiply(α._pow(B.getDegree()));
    //resultant = resultant.divide(scale._pow(B.getDegree()));
    //resultant = resultant.multiply(Expression.ONE.negate()._pow(A.getDegree() * B.getDegree()));
    
    if (B.getDegree() > 0) {
      if (R.getDegree() < 0) {
        resultant2.push({base: Expression.ZERO, exponent: 1});
      } else {
        var previous = resultant2.pop();
        console.assert(previous.exponent === -2 * B.getDegree());
        resultant2.push({base: α.divide(previous.base._pow(2)), exponent: B.getDegree()});
        resultant2.push({base: B.getLeadingCoefficient(), exponent: Math.max(R.getDegree(), 0) + (isPseudoRemainderSequence ? (1 - B.getDegree()) * (A.getDegree() - B.getDegree()) : A.getDegree())});
        resultant2.push({base: B.getLeadingCoefficient(), exponent: 0 - 2 * Math.max(R.getDegree(), 0)});
        resultantSign *= Math.pow(Math.pow(-1, A.getDegree()), B.getDegree()); // https://en.wikipedia.org/wiki/Resultant#Characterizing_properties
      }
    } else {
      console.assert(B.getDegree() === 0);
      resultant2.push({base: B.getLeadingCoefficient(), exponent: A.getDegree()});
    }
    A = B;
    B = R;
  }
  var resultant = resultantSign === -1 ? Expression.ONE.negate() : Expression.ONE;
  //if (A.getDegree() !== 0) {
    //TODO: check
    //TODO: add a test
    //console.error("TEST");
    //resultant = Expression.ZERO;
  //}
  if (v2 !== "NO_VARIABLE") {
    resultant = new Expression.Polynomial(Polynomial.of(resultant));
  }
  for (var iteratorx = resultant2[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
    if (x.exponent < 0) {
      resultant = resultant.divide(x.base._pow(-x.exponent));
    } else if (x.exponent > 0) {
      resultant = resultant.multiply(x.base._pow(x.exponent));
    }
  }
  if (v2 !== "NO_VARIABLE") {
  if (resultant.polynomial != undefined) {//TODO:
    resultant = resultant.polynomial;
  } else {
    throw new RangeError();
  }
  }
  //resultant = Polynomial.toPolynomial(resultant, new Expression.Symbol(v2));
  var end = Date.now();
  if (end - start > 250) {
    console.log(end - start, AA.toString(), BB.toString());
  }
  return resultant;
};

Expression._FIELD = {
  ONE: Expression.ONE,
  add: function (a, b) { return a.add(b); },
  sub: function (a, b) { return a.subtract(b); },
  mul: function (a, b) { return a.multiply(b); },
  scale: function (a, s) { return a.multiply(Expression.Integer.fromBigInt(s)); },
  unscale: function (a, s) { return a.divide(Expression.Integer.fromBigInt(s)); },
  div: function (a, b) { return a.divide(b); },
  parse: function (a) { return Expression.Integer.fromNumber(a); },
  equals: function (a, b) { return a.equals(b); }
};

Polynomial._resultantByModularAlgorithm = function (A, B, v2, internalResultant) {
internalResultant = internalResultant == undefined ?  null : internalResultant;

  if (A.getDegree() === Polynomial.ZERO.getDegree() || B.getDegree() === Polynomial.ZERO.getDegree()) {
    return Polynomial.ZERO;
  }
  var g = Math.gcd(A.getGCDOfTermDegrees(), B.getGCDOfTermDegrees());
  if (g > 1) {
    // why is this true?
    var tmp = Polynomial._resultantByModularAlgorithm(A._exponentiateRoots(g), B._exponentiateRoots(g), v2, internalResultant);
    //TODO: ?
    return tmp._pow(g);
  }
  internalResultant = internalResultant || Polynomial._resultantUsingSubresultantPseudoRemainderSequence;
  //TODO: A and B - two-variable polynomials with integer coefficients
  console.assert(A._hasIntegerLikeCoefficients() && B._hasIntegerLikeCoefficients());
  var v1 = new Expression.Symbol('x');
  v2 = new Expression.Symbol(v2);
  var Av2 = Polynomial.toPolynomial(A.calcAt(v1), v2).map(function (c) { return new Expression.Polynomial(Polynomial.toPolynomial(c, v1)); });
  var Bv2 = Polynomial.toPolynomial(B.calcAt(v1), v2).map(function (c) { return new Expression.Polynomial(Polynomial.toPolynomial(c, v1)); });
  var r = 0;
  NewtonInterpolation.setField(Expression._FIELD);
  var polynomialInterpolation = NewtonInterpolation();
  polynomialInterpolation.next();
  var Res = null;
  var d = Bv2.getDegree()*A.getDegree()+Av2.getDegree()*B.getDegree(); //TODO: ???
  for (var i = 0; i <= d; i += 1) {
    //r += 1;
    r = Expression.Integer.fromNumber(i - Math.floor(d / 2));//?
    var Av2_r = Av2.calcAt(r).polynomial;
    var Bv2_r = Bv2.calcAt(r).polynomial;
    var Res_r = internalResultant(Av2_r, Bv2_r, "NO_VARIABLE");
    Res = polynomialInterpolation.next([r.toNumber(), Res_r]).value;
  }
  return Polynomial.from(Res);
};

Polynomial.resultant = function (p, q, v2) {
  //TODO: do not multiply
  return Polynomial._resultantByModularAlgorithm(p, q, v2);
  //return Polynomial._resultantUsingSubresultantPseudoRemainderSequence(p, q, v2);
};


//TODO: remove (use Polynomial#_scaleRoots, Polynomial#_exponentiateRoots, Polynomial#_translateRoots instead)
//Polynomial.prototype.subs = function (variableMapFunction) {
//  var variable = new Expression.Symbol('$x');//TODO:
//  return Polynomial.toPolynomial(this.calcAt(variableMapFunction(variable)).getNumerator(), variable);
//};


function GramSchmidtOrthogonalization(vectors) {
  if (false) {
    var V = vectors;
    var n = V[0].dimensions();
    var k = V.length;
    var U = new Array(k).fill(null).map(function (x) { return new Matrix.Vector(new Array(n).fill(Expression.ZERO)); });;
    U[0] = V[0];
    for (var i = 1; i < k; i += 1) {
        U[i] = V[i];
        for (var j = 0; j < i; j += 1) {
            U[i] = U[i].subtract(U[j].scale(U[j].dot(U[i]).divide(U[j].dot(U[j]))));
        }
    }
    return U;
  }
  // https://en.wikipedia.org/wiki/Gram%E2%80%93Schmidt_process#Via_Gaussian_elimination
  var rowVectorsMatrix = Matrix.fromVectors(vectors).transpose();
  var A = rowVectorsMatrix;
  var matrix = A.multiply(A.transpose()).augment(A).toRowEchelon(Matrix.Gauss, "row-reduction").matrix;
  var tmp = matrix.slice(0, matrix.rows(), A.rows(), matrix.cols());
  var result = new Array(tmp.rows());
  for (var i = 0; i < tmp.rows(); i += 1) {
    result[i] = tmp.row(i);
  }
  return result;
}

globalThis.GramSchmidtOrthogonalization = GramSchmidtOrthogonalization;

Expression.Complex.prototype.abs = function () {
  // https://en.wikipedia.org/wiki/Absolute_value#Complex_numbers
  return this.multiply(this.conjugate()).squareRoot();
};
Expression.Division.prototype.abs = function () {
  return this.getNumerator().abs().divide(this.getDenominator().abs());
};
Expression.prototype.abs = function () {//TODO: remove - ?
  if (this.compareTo(Expression.ZERO) < 0) {
    return this.negate();
  }
  return this;
};
Expression.prototype.compareTo = function (other) {//TODO: remove - ?
  if (other.equals(Expression.ZERO)) {
    if (Expression._isPositive(this)) {
      return +1;
    }
    if (Expression._isPositive(this.negate())) {
      return -1;
    }
    throw new TypeError(this.toString());
  }
  return this.subtract(other).getNumerator().compareTo(Expression.ZERO);
};
Expression.prototype.round = function () {//TODO: remove - ?
  //TODO: half away from zero - ?
  //console.log(this.getNumerator(), this.getDenominator());
  //return this.getNumerator().add(this.getDenominator().truncatingDivide(Expression.TWO)).truncatingDivide(this.getDenominator());
  return ExpressionParser.parse(toDecimalStringInternal(this, {fractionDigits: 0}));
};

//console.assert(GramSchmidtOrthogonalization(new Matrix([[Expression.Integer.fromNumber(3), Expression.Integer.fromNumber(1)], [Expression.Integer.fromNumber(2), Expression.Integer.fromNumber(2)]])).toString() === '{{3,1},{-2/5,6/5}}');
//console.assert(GramSchmidtOrthogonalization(new Matrix([[Expression.Integer.fromNumber(3), Expression.Integer.fromNumber(1)], [Expression.Integer.fromNumber(2), Expression.Integer.fromNumber(2)], [new Expression.Integer(0), new Expression.Integer(0)]])).toString() === '{{3,1},{-2/5,6/5},{0,0}}');
//throw new Error();


// Math.log2(Math.hypot.apply(null, coefficients))
Polynomial.prototype._log2hypot = function () {
  var polynomial = this;
  var max = Expression.ZERO;
  for (var i = 0; i < polynomial.a.size; i += 1) {
    var c = polynomial.a.coefficient(i).abs();
    if (c.compareTo(max) > 0) {
      max = c;
    }
  }
  //var maxBitLength = Math.max.apply(null, coefficients.map(function (c) { return c.equals(Expression.ZERO) ? 0 : primeFactor._bitLength(c.abs().toBigInt()); }));
  var maxBitLength = max.toNumber() < 1 / 0 ? 0 : max.bitLength();
  var k = maxBitLength < 1024 ? maxBitLength : Math.min(Math.floor(Math.log2(Number.MAX_SAFE_INTEGER + 1)), maxBitLength);
  var scale = Expression.TWO._pow(maxBitLength - k);
  var p2k = Math.pow(2, k);
  var coefficients = new Array(polynomial.a.size);
  for (var i = 0; i < polynomial.a.size; i += 1) {
    coefficients[i] = polynomial.a.coefficient(i).truncatingDivide(scale).toNumber() / p2k;
  }
  var hypot = Math.hypot.apply(null, coefficients);
  var log2hypot = maxBitLength + Math.log2(hypot);
  return log2hypot;
};

Polynomial.prototype._log2OfBoundForCoefficientsOfFactor = function (factorDegreeBound, factorLeadingCoefficientBound) {
  // https://en.wikipedia.org/wiki/Geometrical_properties_of_polynomial_roots#:~:text=This%20bound%20is%20also%20useful%20to%20bound%20the%20coefficients%20of%20a%20divisor%20of%20a%20polynomial%20with%20integer%20coefficients:
  // see also
  // The art of computer programming. Vol.2: Seminumerical algorithms
  // exersize 20, page 458
  // which gives better result (~2 times smaller)
  if (factorDegreeBound == undefined) {
    factorDegreeBound = this.getDegree();
  }
  if (factorDegreeBound === 0) {
    return 0;
  }
  if (factorLeadingCoefficientBound == undefined) {
    factorLeadingCoefficientBound = this.getLeadingCoefficient().abs();
  }
  var log2 = function (integer) {
    var e = integer.bitLength();
    if (e <= 53) {
      return Math.log2(integer.toNumber());
    }
    return (e - 53) + Math.log2(integer.truncatingDivide(Expression.TWO._pow(e - 53)).toNumber());
  };
  var centralBinomialCoefficientBound = function (n) {
    return (n - Math.log2(Math.sqrt(Math.PI * Math.ceil(n / 2))));
  };
  var m = factorDegreeBound;
  var e = centralBinomialCoefficientBound(m) + (log2(factorLeadingCoefficientBound.abs()) - log2(this.getLeadingCoefficient().abs())) + this._log2hypot();
  return e;
};


Polynomial.prototype.isDivisibleBy = function (guess) {
  var w = undefined;
  var s = Expression.ONE;
  if (this._hasIntegerLikeCoefficients() &&
      guess._hasIntegerLikeCoefficients()) {
    // for performance
    // https://en.wikipedia.org/wiki/Gauss%27s_lemma_(polynomials) - ?
    w = "undefined";
    s = guess.getContent();
  }
  var tmp = this.scale(s).divideAndRemainder(guess, w);
  return tmp != null && tmp.remainder.equals(Polynomial.ZERO);
};


})();
(function () {
"use strict";



// https://ca.wikipedia.org/wiki/Forma_canònica_de_Jordan

// https://es.wikipedia.org/wiki/Forma_canónica_de_Jordan

Expression.getFormaDeJordan = function (matrix, eigenvalues, multiplicities, hack) {
  function getSolutionSet(matrix) {
    var fullMatrix = matrix.augment(Matrix.Zero(matrix.cols(), 1));
    var result = fullMatrix.toRowEchelon(Matrix.GaussMontante, "solving", undefined);
    var tmp = Matrix.solveByGaussNext(result.matrix);
    var currentEigenvectors = Matrix.getSolutionSet(tmp).basisVectors;
    return currentEigenvectors;//?
  }
  function matrixFromBlocks(blocks) {
    var start = 0;
    var J = Matrix.Zero(n, n);
    for (var i = 0; i < blocks.length; i += 1) {
      var b = blocks[i];
      J = J.map(function (e, i, j) {
        if (i >= start && i < start + b.size) {
          return i === j ? b.eigenvalue : (i !== start + b.size - 1 && j === i + 1 ? Expression.ONE : Expression.ZERO);
        }
        return e;
      });
      start += b.size;
    }
    return J;
  }
  function isSolution(coefficientMatrix, vector) {
    var f = coefficientMatrix.multiply(vector);
    return f.eql(Matrix.Zero(f.rows(), 1));
  }
  function isLinearlyIndependentSet(basis, vectors) {
    // https://math.stackexchange.com/questions/412563/determine-if-vectors-are-linearly-independent
    return Matrix.fromVectors(basis.concat(vectors)).rank() === basis.length + vectors.length;
  }

  //!TODO: remove
  if (eigenvalues.length === matrix.rows()) {
    var eigenvectors = Expression.getEigenvectors(matrix, eigenvalues).eigenvectors;
    var tmp = Expression.diagonalize(matrix, eigenvalues, multiplicities, eigenvectors);
    var P = tmp.T;
    var J = tmp.L;
    var P_INVERSED = tmp.T_INVERSED;
    //console.log("P=" + P.toString() + ", J=" + J.toString());
    return {
      P: P,
      J: J,
      P_INVERSED: P_INVERSED
    };
  }
  //!

  var A = matrix;
  var n = A.rows();

  var basis = [];
  var blocks = [];
  for (var i = 0; i < eigenvalues.length; i += 1) {
    // https://en.wikipedia.org/wiki/Generalized_eigenvector#Computation_of_generalized_eigenvectors
    var basisCorrespondingToTheEigenvalue = []; // TODO: optimize (n**3 -> n**2)
    var eigenvalue = eigenvalues[i];
    var algebraicMultiplicity = multiplicities[i];
    var B = A.subtract(Matrix.I(n).scale(eigenvalue));
    var m = 1;
    while (B.pow(m).rank() > n - algebraicMultiplicity) {
      m += 1;
    }
    m += 1;
    while (--m >= 1) {
      //var z = 0;
      //var pm = B.pow(m - 1).rank() - 2 * B.pow(m).rank() + B.pow(m + 1).rank();
      var solutionSet = getSolutionSet(B.pow(m));  // "kernel of A"
      for (var j = 0; j < solutionSet.length; j += 1) {
        var solution = solutionSet[j];
        //if (z < pm) {
        //console.log(B.pow(m).augment(solution).rank(), m, n);
        if (!isSolution(B.pow(m - 1), solution)) {
          var chain = [];
          var s = solution;
          for (var k = 0; k < m; k += 1) {
            chain.push(s);
            s = B.multiply(s).col(0);
          }
          chain.reverse();
          if (isLinearlyIndependentSet(basisCorrespondingToTheEigenvalue, chain)) {
            //z += 1;
            basis = basis.concat(chain);
            basisCorrespondingToTheEigenvalue = basisCorrespondingToTheEigenvalue.concat(chain);
            blocks.push({
              size: m,
              eigenvalue: eigenvalue
            });
          }
        }
        //}
      }
    }
  }
  var J = matrixFromBlocks(blocks);
  if (basis.length !== n) {
    throw new TypeError("assertion failed");
  }
  var P = Matrix.fromVectors(basis);
  //console.log("P=" + P.toString() + ", J=" + J.toString());
  //var P_INVERSED = P.inverse();
  var P_INVERSED = P.isExact() ? P.inverse() : (hack ? null : getInverse(A, eigenvalues, multiplicities, P));
  if (!hack && P.isExact()) {
  if (A.toString() !== P.multiply(J).multiply(P_INVERSED).toString()) {
    throw new TypeError("assertion failed");
  }
  }
  return {
    P: P,
    J: J,
    P_INVERSED: P_INVERSED
  };
};

// A = P*J*P^-1
// A^T = (P^-1)^T*J^T*P^T
// Note:
// (0 0 0 1)         (0 0 0 1)
// (0 0 1 0)         (0 0 1 0)
// (0 1 0 0) * J^T * (0 1 0 0) = J
// (1 0 0 0)         (1 0 0 0)
// where on the left we are doing row spaws, then doing column swaps.
// Note: the inverse of the anti-diagonal unitary matrix is the matrix itself.
// A^T = X*Y*X^-1
// (P^-1)^T*J^T*P^T = X*Y*X^-1
// (P^-1)^T*B^-1*J*B*P^T = X*Y*X^-1
// Then P^-1 = (X*B)^T .

var getInverse = function (A, eigenvalues, multiplicities, P) {
  // https://en.wikipedia.org/wiki/Diagonalizable_matrix : The row vectors of P^−1 are the left eigenvectors of A
  // https://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors#Left_and_right_eigenvectors :  a left eigenvector of A is the same as the transpose of a right eigenvector of A^T, with the same eigenvalue
  var AT = A.transpose();
  var tmp2 = Expression.getFormaDeJordan(AT, eigenvalues, multiplicities, true);
  var J = tmp2.J;
  var X = tmp2.P;

  var n = A.cols();
  var B = Matrix.Zero(n, n).map(function (e, i, j) {
    function getCurrentBlock() {
      var s = i;
      while (s - 1 >= 0 && s < n && J.e(s - 1, s).equals(Expression.ONE)) {
        s -= 1;
      }
      var e = i;
      while (e + 1 < n && J.e(e, e + 1).equals(Expression.ONE)) {
        e += 1;
      }
      return {s: s, e: e};
    }
    var tmp = getCurrentBlock();
    return tmp.s + tmp.e === i + j ? Expression.ONE : Expression.ZERO;
  });

  var P_INVESRED = X.multiply(B).transpose();
  return Expression._unscaleInverseMatrix(P_INVESRED, P);
};
Expression._getInverse = getInverse;

})();
(function () {
"use strict";




Expression.getPolynomialRootsWithSteps = function (polynomial, fractionDigits, callback) {
  var roots = polynomial.getroots(callback);

  //TODO: tests
  //!2018-05-28
  //!2018-07-11
  // experimental code
  var zeros = [];
  if (typeof polynomial.getZeros === "function" && roots.length !== polynomial.getDegree()) {
    var p = Polynomial.of(Expression.ONE);
    for (var i = 0; i < roots.length; i += 1) {
      p = p.multiply(Polynomial.of(roots[i].negate(), Expression.ONE));
    }
    var r = polynomial.divideAndRemainder(p).quotient;
    var precision = Math.max(fractionDigits || 0, 5);
    zeros = r.getZeros(precision, true);
    if (callback != undefined) {
      if (zeros.length === r.getDegree()) {//TODO: !!!
        callback({content: Expression.ONE, roots: roots.concat(zeros), newPolynomial: Polynomial.of(polynomial.getLeadingCoefficient()), type: "realRootIsolationAndNewton'sMethod"});
      }
    }
  }
  //!

  // removing of duplicates
  var uniqueRoots = [];
  var multiplicities = [];
  for (var i = 0; i < roots.length; i += 1) {
    var root = roots[i];
    var isDuplicate = false;
    var j = -1;
    while (++j < uniqueRoots.length) {
      if (uniqueRoots[j].equals(root)) {
        isDuplicate = true;
        multiplicities[j] += 1;
      }
    }
    if (!isDuplicate) {
      uniqueRoots.push(root);
      multiplicities.push(1);
    }
  }

  var m = 0;
  for (var i = 0; i < zeros.length; i += 1) {
    m += 1;
    var zero = zeros[i];
    var next = i + 1 < zeros.length ? zeros[i + 1] : undefined;
    if (next !== zero) {
      uniqueRoots.push(zero);
      multiplicities.push(m);
      m = 0;
    }
  }

  return {
    uniqueRoots: uniqueRoots,
    multiplicities: multiplicities
  };
};

Expression.getEigenvalues = function (matrix, fractionDigits, callback) {

  if (!matrix.isSquare()) {
    throw new RangeError("NonSquareMatrixException");
  }
  // TODO: remove Polynomial

  var determinant = matrix.map(function (e, i, j) {
    var p = i === j ? Polynomial.of(e, Expression.ONE.negate()) : (e.equals(Expression.ZERO) ? Polynomial.ZERO : Polynomial.of(e));
    return new Expression.Polynomial(p);
  }).determinant();
  determinant = determinant.polynomial;

  //!new (sin/cos)
  //TODO: fix
  determinant = determinant.map(function (e) { return e.simplifyExpression(); });

  var characteristicPolynomial = determinant;//!TODO: fix

  var tmp = Expression.getPolynomialRootsWithSteps(characteristicPolynomial, fractionDigits, callback);
  var uniqueRoots = tmp.uniqueRoots;
  var multiplicities = tmp.multiplicities;

  var eigenvalues = uniqueRoots;
  return {
    characteristicPolynomial: characteristicPolynomial,
    eigenvalues: eigenvalues,
    multiplicities: multiplicities
  };
};

Expression.getEigenvectors = function (matrix, eigenvalues) {
  var eigenvectors = [];
  for (var i = 0; i < eigenvalues.length; i += 1) {
    var n = matrix.cols();
    // matrix - E * eigenvalue
    var fullMatrix = matrix.subtract(Matrix.I(n).scale(eigenvalues[i])).augment(Matrix.Zero(n, 1));
    //TODO: Matrix.GaussMontante
    var result = fullMatrix.toRowEchelon(Matrix.GaussJordan, "solving", undefined);
    var tmp = Matrix.solveByGaussNext(result.matrix);
    var currentEigenvectors = Matrix.getSolutionSet(tmp).basisVectors;
    eigenvectors = eigenvectors.concat(currentEigenvectors);//?
  }
  return {
    eigenvectors: eigenvectors
  };
};

var getInverse = function (A, eigenvalues, T) {
  // https://en.wikipedia.org/wiki/Diagonalizable_matrix : The row vectors of P^−1 are the left eigenvectors of A
  // https://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors#Left_and_right_eigenvectors :  a left eigenvector of A is the same as the transpose of a right eigenvector of A^T, with the same eigenvalue
  var AT = A.transpose();
  var tmp2 = Expression.getEigenvectors(AT, eigenvalues);
  var eigenvectors = tmp2.eigenvectors;
  var T_INVERSED = Matrix.fromVectors(eigenvectors).transpose();
  return _unscaleInverseMatrix(T_INVERSED, T);
};

var _unscaleInverseMatrix = function (T_INVERSED, T) {
  // we know, that the result is {{s_1, 0, 0, 0}, {0, s_2, 0, 0}, {0, 0, s_3, 0}, {0, 0, 0, s_4}}
  var trickyMultiply = function (a, b) {
    var n = a.rows();
    return Matrix.Zero(n, n).map(function (element, i, j) {
      if (i !== j) {
        return Expression.ZERO;
      }
      var rows = n;
      var k = -1;
      while (++k < rows) {
        var current = a.e(i, k).multiply(b.e(k, j));
        element = k === 0 ? current : element.add(current);
      }
      return element;
    });
  };

  var S = trickyMultiply(T_INVERSED, T);
  var S_INVERSED = S.map(function (e, i, j) {
    return i === j ? e.inverse() : Expression.ZERO;
  });

  return S_INVERSED.multiply(T_INVERSED);
};
Expression._unscaleInverseMatrix = _unscaleInverseMatrix;//TODO: make private

// A = T^-1 L T ,T-matrix of own vectors, L - matrix of own values

Expression.diagonalize = function (matrix, eigenvalues, multiplicities, eigenvectors) {
  if (!matrix.isSquare()) {
    throw new RangeError("NonSquareMatrixException");
  }
  if (Expression.sum(multiplicities) !== matrix.cols()) {
    throw new RangeError();
  }
  if (eigenvectors.length !== matrix.cols()) {
    throw new RangeError();
  }
  // https://en.wikipedia.org/wiki/Jordan_normal_form
  // A is diagonalizable if and only if, for every eigenvalue λ of A, its geometric and algebraic multiplicities coincide.

  // TODO: text
  //!!!
  var diagonal = [];
  for (var i = 0; i < eigenvalues.length; i += 1) {
    diagonal = diagonal.concat(new Array(multiplicities[i]).fill(eigenvalues[i]));
  }
  var L = Matrix.I(matrix.cols()).map(function (element, i, j) {
    return (i === j ? diagonal[i] : Expression.ZERO);
  });
  var T = Matrix.fromVectors(eigenvectors);

  //var T_INVERSED = T.inverse();
  var T_INVERSED = T.isExact() ? T.inverse() : getInverse(matrix, eigenvalues, T);

  return {T: T, L: L, T_INVERSED: T_INVERSED};
};

Expression.LUDecomposition = function (matrix) {
  //https://en.wikipedia.org/wiki/LU_decomposition#Code_examples
  //TODO: remove(?) - matrix.toRowEchelon(...)
  var N = matrix.rows();
  var a = matrix;
  var Lower = Matrix.I(N);
  var P = Matrix.I(N);
  var swapFlag = false;
  var pivotRow = 0;
  for (var n = 0; n < matrix.cols(); n += 1) {
    if (pivotRow < N) {
      var c = pivotRow;
      if (a.e(pivotRow, n).equals(Expression.ZERO)) {
        for (var k = pivotRow + 1; k < N && c === pivotRow; k += 1) {
          if (!a.e(k, n).equals(Expression.ZERO)) {
            c = k;
          }
        }
        if (c !== pivotRow) {
          var S = Matrix.I(N);
          S = S.map(function (element, i, j) {
            return i === pivotRow ? S.e(c, j) : (i === c ? S.e(pivotRow, j) : element);
          });
          a = S.multiply(a);
          Lower = S.multiply(Lower.subtract(Matrix.I(N))).add(Matrix.I(N));
          P = S.multiply(P);
          swapFlag = true;
        }
      }
      if (!a.e(pivotRow, n).equals(Expression.ZERO)) {
        var L = Matrix.I(N).map(function (element, i, j) {
          return j === pivotRow && i >= pivotRow + 1 ? a.e(i, n).divide(a.e(pivotRow, n)).negate() : element;
        });
        a = L.multiply(a);
        Lower = Lower.multiply(L);
        pivotRow += 1;
      }
    }
  }
  Lower = Lower.map(function (element, i, j) {
    return i === j ? element : element.negate();
  });
  return {
    swapFlag: swapFlag,
    P: new Expression.Matrix(P),
    A: new Expression.Matrix(matrix),
    L: new Expression.Matrix(Lower),
    U: new Expression.Matrix(a)
  };
};

Expression.isReal = function (e) {
  var isReal = function (e) {
    if (e instanceof Expression.Integer) {
      return true;
    }
    if (e instanceof Expression.NthRoot) {
      return isReal(e.a);
    }
    if (e instanceof Expression.BinaryOperation) {
      return isReal(e.a) && isReal(e.b);
    }
    if (e === Expression.E || e === Expression.PI) {
      return true;
    }
    if (e instanceof Expression.Function) {
      return isReal(e.a);
    }
    if (e instanceof Expression.PolynomialRootSymbol) {
      return true;//TODO: ?
    }
    if (e instanceof Expression.ExpressionWithPolynomialRoot) {
      return isReal(e.e);
    }
    if (e instanceof Expression.ExpressionPolynomialRoot) {
      return true;
    }
    return false;
  };
  return isReal(e);
};
Expression.isRealMatrix = function (A) {
  for (var i = 0; i < A.rows(); i += 1) {
    for (var j = 0; j < A.cols(); j += 1) {
      if (!Expression.isReal(A.e(i, j))) {
        return false;
      }
    }
  }
  return true;
};
Expression.CholeskyDecomposition = function (matrix) {
  var A = matrix;

  // check if A is square
  if (!A.isSquare()) {
    throw new RangeError("NonSquareMatrixException");
  }

  var n = A.rows();

  // check if A from R
  var isReal = Expression.isRealMatrix(A);

  // check if A is symmetric
  for (var i = 0; i < n; i += 1)  {
    for (var j = i; j < n; j += 1) {
      if (!A.e(i, j).equals(A.e(j, i).complexConjugate())) {
        if (isReal) {
          throw new RangeError("NonSymmetricMatrixException");
        } else {
          throw new RangeError("NonHermitianMatrixException");
        }
      }
    }
  }

  var L = new Array(n);
  for (var i = 0; i < n; i += 1) {
    L[i] = new Array(n);
    for (var j = 0; j < n; j += 1) {
      L[i][j] = Expression.ZERO;
    }
  }

  for (var j = 0; j < n; j += 1) {
    for (var i = j; i < n; i += 1) {
      var e = null;
      if (j === i) {
        var sum = null;
        for (var k = 0; k < j; k += 1) {
          var s = L[j][k].multiply(L[j][k].complexConjugate());
          sum = sum == null ? s : sum.add(s);
        }
        var x = sum == null ? A.e(j, j) : A.e(j, j).subtract(sum);
        //TODO: fix
        if (!Expression._isPositive(x)) {
          throw new RangeError("NonPositiveDefiniteMatrix");
        }
        e = x.squareRoot();
      } else {
        var sum = null;
        for (var k = 0; k < j; k += 1) {
          var x = L[i][k].multiply(L[j][k].complexConjugate());
          sum = sum == null ? x : sum.add(x);
        }
        e = (sum == null ? A.e(i, j) : A.e(i, j).subtract(sum)).divide(L[j][j]);
      }
      L[i][j] = e;
      console.log("l_%d%d = %s", i + 1, j + 1, L[i][j].toString());
    }
  }
  return {
    L: Matrix.padRows(L, null)
  };
};


Matrix.prototype.conjugateTranspose = function () {
  return this.transpose().map(function (e) { return e.complexConjugate(); });
};

Matrix.fromVectors = function (vectors) {
  if (vectors.length === 0) {
    throw new RangeError();
  }
  var dimensions = vectors[0].dimensions();
  for (var i = 0; i < vectors.length; i += 1) {
    if (vectors[i].dimensions() !== dimensions) {
      throw new RangeError();
    }
  }
  return Matrix.Zero(dimensions, vectors.length).map(function (e, i, j) { return vectors[j].e(i); });
};

Expression.SVDDecomposition =
Expression.SVDecomposition = function (matrix) {
  //TODO: use T - for real, * - for complex
  var link1 = 'https://people.math.carleton.ca/~kcheung/math/notes/MATH1107/wk12/12_singular_value_decomposition.html';
  var link3 = 'https://www.youtube.com/watch?v=yA66KsFqUAE';
  var link2 = 'https://en.wikipedia.org/wiki/Matrix_decomposition';
  console.info('[Singular Value Decomposition](' + link1 + ')[*](' + link3 + ') is a [decomposition](' + link2 + ') `A = U*Σ*V^T`, where `U` and `V` are unitary matrices (`U*U^T=U^T*U=I` and `V*V^T=V^T*V=I`), `Σ` - a matrix with non-negative diagonal entries');
  console.info('`A^T*A*V=(U*Σ*V^T)^T*U*Σ*V^T*V=V*Σ^2`, which means, that `A^T*A*v_i=v_i*σ_i^2` (where `v_i` - is a column vector of `V`), which means `v_i` is an eigenvector of `A^T*A`');//TODO: !?
  console.info('A=%s', matrix);
  console.info('1. Find eigenvalues and eigenvectors of `A^T*A`:');

  // TODO: see email 
  // https://en.wikipedia.org/wiki/Singular_value_decomposition#Calculating_the_SVD
  // TODO: see https://web.mit.edu/be.400/www/SVD/Singular_Value_Decomposition.htm
  // The left-singular vectors of M are a set of orthonormal eigenvectors of MM*.
  var helper = function (matrix, eigenvalue) {
    var tmp = Expression.getEigenvectors(matrix, [eigenvalue]);
    var eigenvectors = tmp.eigenvectors;
    //console.info('We need to orthonormalize eigenvectors so the matrix with those vectors as columns will be unitary:');
    if (eigenvectors.length > 1) {//TODO: https://math.stackexchange.com/questions/82467/eigenvectors-of-real-symmetric-matrices-are-orthogonal#answer-82471
      eigenvectors = GramSchmidtOrthogonalization(eigenvectors);
    } else {
      //console.debug('Eigenvectors of real symmetric matrices corresponding to distinct eigenvalues are orthogonal'); // no need to show (?)
    }
    return eigenvectors.map(function (vector) { return vector.toUnitVector(); });
  };
  var MstarM = matrix.conjugateTranspose().multiply(matrix);
  var tmp = Expression.getEigenvalues(MstarM); // use MstarM to have zero eigenvalues to make the set of eigenvectors full for V
  var eigenvalues = tmp.eigenvalues;
  //!
  eigenvalues = eigenvalues.map(function (eigenvalue) { return eigenvalue instanceof Expression.ExpressionWithPolynomialRoot || eigenvalue instanceof Expression.ExpressionPolynomialRoot ? eigenvalue.upgrade() : eigenvalue; });
  //!

  eigenvalues = eigenvalues.slice(0).reverse().sort(function (a, b) { return a.subtract(b).compareTo(Expression.ZERO) > 0 ? -1 : 1; });

  //var Vstar = ExpressionParser.parse(matrix.toString()).transformEquality(ExpressionParser.parse(U.multiply(Sigma).toString() + '*' + 'X', ExpressionParser.parse.c).simplify());
  
  //console.info('M^{*}M (M^T*M) has the same non-negative eigenvalues as M*M^{*} (M*M^T)')
  var V = [];
  var diagonal = [];
  //TODO:
  //console.info('   eigenvectors: ');
  for (var iteratoreigenvalue = eigenvalues[globalThis.Symbol.iterator](), eigenvalue = iteratoreigenvalue.next().value; eigenvalue != null; eigenvalue = iteratoreigenvalue.next().value) {
    V = V.concat(helper(MstarM, eigenvalue));
    var entry = eigenvalue.squareRoot();
    // https://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors#Eigenspaces,_geometric_multiplicity,_and_the_eigenbasis_for_matrices
    // https://people.math.carleton.ca/~kcheung/math/notes/MATH1107/wk12/12_singular_value_decomposition.html
    // it says, that geometric multiplicity of a _positive_ eigenvalue of A*A^T is the same as geometric multiplicity of A^T*A and same as algebraic multipliciy.
    // and those matrices has the same eigenvalues
    //var geometricMultiplicity = multiplicities[i] === 1 ? 1 : MMstar.cols() - MMstar.subtract(Matrix.I(MMstar.cols()).scale(eigenvalue)).rank();//?
    var geometricMultiplicity = V.length - diagonal.length;
    diagonal = diagonal.concat(new Array(geometricMultiplicity).fill(entry));
  }
  console.info('   Orthonormalized eigenvectors: ' + '?'); // v_1 = ..., v_2 = ... - column vectors
  for (var i = 0; i < V.length; i += 1) {
    console.info('   - v_' + (i + 1) + ' = %s', V[i]);
  }
  //TODO: property that distict eigenvalues have orthogonalized eigenvalues for symmetric matrices is used (link)

  console.info('2. Construct matrix `Σ` from square roots of the eigenvalues corresponding to eigenvectors: ');
  var Sigma = Matrix.Zero(matrix.rows(), matrix.cols()).map(function (e, i, j) { return (i === j && i < diagonal.length ? diagonal[i] : Expression.ZERO); });
  console.info('   Σ = %s ', Sigma);//TODO: [sqrt(lambda_i)]

  // see https://www.d.umn.edu/~mhampton/m4326svd_example.pdf
  //TODO: compute V or U using the property instead of the current variant of computation (?)
  
  console.info('3. Find column vectors of `U`:');
  console.info('   `A = U*Σ*V^T`, if we multiply both sides by `V`, then `A*V = U*Σ` (as `V^T*V=I`), so `A*v_i = u_i*σ_i`, and `u_i = A*v_i/σ_i`'); //TODO: link to better explanation (or just use the "column" vectors to show better)
  console.time('U');
  var U = [];
  for (var i = 0; i < Sigma.rows() && i < Sigma.cols() && !Sigma.e(i, i).equals(Expression.ZERO); i += 1) {
    //TODO: another method when multiplicity is 1 - ? (for performance)
    var u_i = matrix.multiply(V[i]).col(0).scale(Sigma.e(i, i).inverse());
    U.push(u_i);
    console.info('   - u_' + (i + 1) + ' = %s', u_i);
  }
  if (U.length < matrix.rows()) {
    console.info('   We need to find few more vectors to build matrix `U`:');//?
    console.info('   We find eigenvectors of `A*A^T` for zero eigenvalue:');
    //TODO: details
    console.time('U1');
    var MMstar = matrix.multiply(matrix.conjugateTranspose());
    var U2b = helper(MMstar, Expression.ZERO);
    console.info('   orthonormalized eigenvectors: ' + '?'); // v_1 = ..., v_2 = ... - column vectors

    console.timeEnd('U1');
    console.assert(U.length + U2b.length === matrix.rows());
    U = U.concat(U2b);
  }
  console.timeEnd('U');

  //var Vstar = s.multiply(U.inverse().multiply(matrix));
  //var Vstar = U.conjugateTranspose().multiply(matrix);
  //console.log(U.multiply(U.conjugateTranspose()).toString());
  //console.log(Vstar.multiply(Vstar.conjugateTranspose()).toString());

  console.info('   It can be shown that the vectors of `U` are orthonormalized.');//?
  U = Matrix.fromVectors(U);
  V = Matrix.fromVectors(V);
  console.info('U = %s, Σ = %s, V = %s', U, Sigma, V);
  return {U: U, Sigma: Sigma, Vstar: V.conjugateTranspose()};
};

Expression.QRDecomposition = function (matrix) {
  var A = matrix;
  // https://en.wikipedia.org/wiki/QR_decomposition#Example
  var columnVectors = new Array(A.cols()).fill(undefined).map(function (e, i) { return A.col(i); });
  var U = GramSchmidtOrthogonalization(columnVectors).filter(function (vector) { return !vector.eql(Matrix.Vector.Zero(vector.dimensions())); });
  var Q = Matrix.fromVectors(U.map(function (vector) { return vector.toUnitVector(); }));
  var R = Q.transpose().multiply(A);
  console.log(Q);
  return {
    Q: Q,
    R: R
  };
};


})();
(function () {
"use strict";



function Condition(array) {
  Object.freeze(array);
  this.array = array;
}

Condition.NEZ = " != 0";
Condition.EQZ = " == 0";

Condition.GTZ = " > 0";
//Condition.GTEZ = " >= 0";

Condition.prototype._and = function (operator, e) {
  if (operator !== Condition.NEZ && operator !== Condition.EQZ && operator !== Condition.GTZ) {
    throw new TypeError();
  }
  if (e == undefined) {
    throw new RangeError();
  }
  if (this === Condition.FALSE) {
    return this;
  }

  var contains = function (array, operator, e) {
    for (var i = 0; i < array.length; i += 1) {
      if (array[i].operator === operator && array[i].expression.equals(e)) {
        return true;
      }
    }
    return false;
  };

  if (e instanceof Expression.GF2Value) {
    return this._and(operator, e.value === 0 ? Expression.ZERO : Expression.ONE);//?
  }

  var add = function (oldArray, y) {

    //TODO: y is const
    if (contains(oldArray, y.operator, y.expression)) {//!TODO: it should work even without this (?)
      return oldArray;
    }
    if (contains(oldArray, y.operator === Condition.EQZ ? Condition.NEZ : Condition.EQZ, y.expression)) {
      return null;
    }

    var operator = null;// to not use a variable from scope accidently
    var e = y.expression;//!

  //!new 2019-12-15:
  //!substitute:  x = 0, sin(x) != 0
  if (Expression.has(e, Expression.Sin) ||
      Expression.has(e, Expression.Cos) ||
      Expression.has(e, Expression.Exponentiation) ||
      Expression.has(e, Expression.Arctan) ||
      Expression.has(e, Expression.Logarithm)) {
    if (oldArray.length > 0) {//TODO: test, fix
    e = Expression._map(function (x) {
      if (x instanceof Expression.Function && !(x instanceof Expression.NthRoot) ||
          x instanceof Expression.Exponentiation && (!(x.b instanceof Expression.Integer) || !(x.a instanceof Expression.Symbol))) {
        var r = x instanceof Expression.Exponentiation ? x.b : x.a;
        var arg = null;
        var array = null;
        if (!(r instanceof Expression.Symbol)) {
          arg = new Expression.Symbol('arg');
          array = add(oldArray, {expression: arg.subtract(r), operator: Condition.EQZ});
          if (array == null) {
            //! TODO: fix, should not happen
            return x;
          }
        } else {
          arg = r;
          array = oldArray;
        }
        for (var i = 0; i < array.length; i += 1) {//TODO: fix
          var y = array[i];
          if (y.operator === Condition.EQZ) {
            var polynomial = Polynomial.toPolynomial(y.expression, arg);
            if (polynomial.getDegree() === 1) {
              var yy = polynomial.getCoefficient(0).negate().divide(polynomial.getCoefficient(1));
              if (!Expression.has(yy, Expression.Function)) {// sin(yy)/cos(yy) is supported
              if (yy.compare4Addition(arg) < 0 && !(yy instanceof Expression.Division) || Expression.isConstant(yy) || Expression.isConstant(yy.divide(Expression.PI))) {//TODO: fix
                if (x instanceof Expression.Exponentiation) {
                  //?TODO: tests
                  return x.a.pow(yy);
                } else if (x instanceof Expression.Arctan) {
                  return yy.arctan();
                } else if (x instanceof Expression.Logarithm) {
                  return yy.logarithm();
                } else {
                  yy = Expression.isConstant(yy) && !(yy.equals(Expression.ZERO)) && !(yy instanceof Expression.Radians) && !Expression.has(yy, Expression.Symbol) ? new Expression.Radians(yy) : yy;
                  if (x instanceof Expression.Sin) {
                    return yy.sin();
                  } else if (x instanceof Expression.Cos) {
                    return yy.cos();
                  } else {
                    throw new TypeError("NotSupportedError");
                  }
                }
              }
              }
            }
          }
        }
        return x;
      }
      return x;
    }, e);
    y = {expression: e, operator: y.operator};//TODO: fix
    }
  }
  //!

    //!new
    if (e.isNegative() && (y.operator === Condition.EQZ || y.operator === Condition.NEZ)) {
      return add(oldArray, {expression: e.negate(), operator: y.operator});
    }

    // (x-1)^(1/2)
    if (e instanceof Expression.Exponentiation// &&
        //e.b.getNumerator() instanceof Expression.Integer &&
        //!e.b.getDenominator().equals(Expression.ONE)
        ) {
      if (y.operator === Condition.EQZ || y.operator === Condition.NEZ) {
        return add(oldArray, {expression: e.a, operator: y.operator});
      }
    }

    // (4*k+1)^(1/2)+1
    if (e instanceof Expression.Addition &&
        e.a instanceof Expression.Exponentiation &&
        Expression.isConstant(e.b) && //!
        e.a.b.getDenominator() instanceof Expression.Integer &&
        !e.a.b.getDenominator().equals(Expression.ONE)) {
      if (e.a.b.getDenominator().remainder(Expression.TWO).equals(Expression.ZERO) && !e.b.isNegative()) {
        return add(oldArray, {expression: Expression.ONE, operator: y.operator});
      }
      //if (!e.b.negate().pow(e.a.b.inverse()).pow(e.a.b).equals(e.b.negate())) {
      //  return add(oldArray, {expression: Expression.ONE, operator: y.operator});
      //}
      //TODO: fix
      return add(oldArray, {expression: e.a.a.pow(e.a.b.getNumerator()).subtract(e.b.negate().pow(e.a.b.getDenominator())), operator: y.operator});
    }

    if (y.expression instanceof Expression.Multiplication && y.expression.b instanceof Expression.IdentityMatrix) {
      return add(oldArray, {expression: y.expression.a, operator: y.operator});
    }
    if (y.expression instanceof Expression.Division) {
      var tmp = oldArray;
      tmp = add(tmp, {expression: y.expression.a, operator: y.operator});
      if (tmp == null) {
        return null;
      }
      tmp = add(tmp, {expression: y.expression.b, operator: Condition.NEZ});
      return tmp;
    }
    /*if (y.expression instanceof Expression.Division && Expression.isConstant(y.expression.b)) {
      y = {
        expression: y.expression.a,
        operator: y.operator
      };
    }*/
    if (y.expression instanceof Expression.Integer || y.expression instanceof Expression.Complex) {
      if (y.operator === Condition.NEZ && y.expression.equals(Expression.ZERO) ||
          y.operator === Condition.EQZ && !y.expression.equals(Expression.ZERO)) {
        return null;
      }
      if (y.operator === Condition.GTZ && y.expression.equals(Expression.ZERO)) {//TODO: fix
        return null;
      }
      if (y.operator === Condition.GTZ && y.expression instanceof Expression.Integer && y.expression.compareTo(Expression.ZERO) < 0) {//TODO: fix
        return null;
      }
      return oldArray;
    }
    //TODO: check code coverage, remove extra branches
    if (Expression.isConstant(y.expression) && !y.expression.equals(Expression.ZERO)) {
      if (y.operator === Condition.NEZ) {
        return oldArray;
      }
      if (y.operator === Condition.EQZ) {
        return null;
      }
    }
    if (y.expression instanceof Expression.Matrix) {
      if (y.expression.matrix.isZero()) {
        if (y.operator === Condition.EQZ) {
          return oldArray;
        }
        if (y.operator === Condition.NEZ) {
          return null;
        }
      }
    }
    if (y.expression instanceof Expression.NthRoot) {
      return add(oldArray, {expression: y.expression.a, operator: y.operator});
    }
    if (y.expression instanceof Expression.Multiplication) {
      if (y.operator === Condition.EQZ) {
        if (y.expression.a instanceof Expression.Integer && !y.expression.a.equals(Expression.ZERO)) {
          //TODO: fix - ?
          y = {
            expression: y.expression.b,
            operator: y.operator
          };
          return add(oldArray, y);
        }
      }
      if (y.operator === Condition.NEZ) {
        var tmp = oldArray;
        tmp = add(tmp, {expression: y.expression.a, operator: Condition.NEZ});
        if (tmp == null) {
          return null;
        }
        tmp = add(tmp, {expression: y.expression.b, operator: Condition.NEZ});
        return tmp;
      }
    }

    var p = Expression.getMultivariatePolynomial(y.expression);
    if (p != null) {
      //!new 2018-12-24
      //TODO: fix (?Polynomial#getContent()?)
        var t = Expression.getNthRootConjugate(p.p.getLeadingCoefficient());
        if (t != undefined && Expression.isConstant(t)) {//TODO: fix
          return add(oldArray, {expression: t.multiply(y.expression), operator: y.operator});
        }
      //!
      var content = p.p.getContent();
      if (!content.equals(Expression.ONE) && !content.equals(Expression.ONE.negate())) {
        // content * y.expression.divide(content)
        if (y.operator === Condition.NEZ) {
          var tmp = add(oldArray, {expression: y.expression.divide(content), operator: Condition.NEZ});
          if (tmp == null) {
            return null;
          }
          return add(tmp, {expression: content, operator: Condition.NEZ});
        }
        while (p != null) {
          if (y.operator === Condition.EQZ) {
            var sf = p.p.getSquareFreePolynomial();
            if (sf.getDegree() !== p.p.getDegree()) {
              //?
              return add(oldArray, {expression: y.expression.divide(p.p.divideAndRemainder(sf).quotient.calcAt(p.v)), operator: Condition.EQZ});
            }
          }
          content = p.p.getContent();
          p = Expression.getMultivariatePolynomial(content);
        }
        //!new
        if (Expression.isConstant(content)) {
          if (!content.equals(Expression.ONE) && !content.equals(Expression.ONE.negate())) {
            return add(oldArray, {expression: y.expression.divide(content), operator: Condition.EQZ});
          }
        }
        //y = {
        //  expression: y.expression.divide(content),
        //  operator: y.operator
        //};
      }
      if (p != null && p.p.getDegree() > 1 && p.p.getCoefficient(0).equals(Expression.ZERO)) {
        if (y.operator === Condition.NEZ) {
          var tmp = add(oldArray, {expression: p.v, operator: Condition.NEZ});
          if (tmp == null) {
            return null;
          }
          return add(tmp, {expression: y.expression.divide(p.v), operator: Condition.NEZ});
        }
      }
    }

    //!new 2019-12-24:
    var p = Expression.getMultivariatePolynomial(y.expression);
    if (p != null && p.p.getDegree() > 1) {
      var sf = p.p.getSquareFreePolynomial();
      if (sf.getDegree() !== p.p.getDegree()) {//TODO: test, fix
        if (y.operator === Condition.EQZ || y.operator === Condition.NEZ) {
          return add(oldArray, {expression: sf.calcAt(p.v), operator: y.operator});
        }
      }
    }
    //!

    var addRest = function (newArray, oldArray, i, other) {
      if (newArray == null) {
        return null;
      }
      for (var j = i + 1; j < oldArray.length; j += 1) {
        newArray = add(newArray, oldArray[j]);
        if (newArray == null) {
          return null;
        }
      }
      if (other != null) {
        newArray = add(newArray, other);
      }
      return newArray;
    };


    var newArray = [];
    for (var i = 0; i < oldArray.length; i += 1) {
      var x = oldArray[i]; // TODO: const


      // (e**(tx)-e**(-tx))/(2i)
      // (e**(tx)+e**(-tx))/2

      // sin(x)=0, cos(x)=0
      //!new 2020-01-01:
      if (Expression.has(x.expression, Expression.Sin) || Expression.has(x.expression, Expression.Cos)) {
        if (Expression.has(y.expression, Expression.Sin) || Expression.has(y.expression, Expression.Cos)) {
          var xx = {
            operator: x.operator,
            expression: Expression._replaceSinCos(x.expression)
          };
          var yy = {
            operator: y.operator,
            expression: Expression._replaceSinCos(y.expression)
          };
          var tmp1 = add([], xx);
          if (tmp1 == null) {
            return null;
          }
          var tmp = add(tmp1, yy);
          if (tmp == null) {
            return null;
          }
          if (tmp.length === 0) {
            return [];//TODO: remove
          }
          if (tmp.length === 1) {
            return addRest(newArray, oldArray, i, {operator: tmp[0].operator, expression: Expression._replaceBySinCos(tmp[0].expression)});
          }
          //TODO: ?
          //for (var i = 0; i < tmp.length; i++) {
          //  newArray = add(newArray, {operator: tmp[i].operator, expression: Expression._replaceBySinCos(tmp[i].expression)});
          //}
          //return addRest(newArray, oldArray, i, {operator: Condition.EQZ, expression: Expression.ZERO});

          // cos(y)=0, r*sin(y)=0
          for (var i = 0; i < tmp.length; i++) {
            if (!Expression.has(tmp[i], Expression.Exponentiation)) {//TODO: ?
              if (tmp[i].expression.gcd(y.expression).equals(tmp[i].expression)) {
                newArray = add(newArray, x);
                return addRest(newArray, oldArray, i, {operator: tmp[i].operator, expression: Expression._replaceBySinCos(tmp[i].expression)});
              }
            }
          }

        }
      }
      //!
      if (Expression.has(x.expression, Expression.Function) || Expression.has(x.expression, Expression.Exponentiation)) {
        if (!(Expression.has(y.expression, Expression.Function) || Expression.has(y.expression, Expression.Exponentiation))) {
          return addRest(add(newArray, y), oldArray, i, x);
        }
      }

      if ((x.operator === Condition.NEZ && y.operator === Condition.EQZ ||
           x.operator === Condition.EQZ && y.operator === Condition.NEZ) &&
           (Expression.isSingleVariablePolynomial(x.expression.multiply(y.expression)) || true)) {
        var g = x.expression.polynomialGCD(y.expression);
        //var g = x.expression.gcd(y.expression);
        while (!g.equals(Expression.ONE) && !g.equals(Expression.ONE.negate())) {
          if (x.operator === Condition.EQZ) {
            x = {
              operator: x.operator,
              expression: x.expression.divide(g)
            };
            // the change may affect all previous conditions:
          } else { // y.operator === Condition.EQZ
            y = {
              operator: y.operator,
              expression: y.expression.divide(g)
            };
            // we have not checked the y agains the branches in the beginning of the "add"
          }
          newArray = add(newArray, x);
          if (newArray == null) {
            return null;
          }
          return addRest(newArray, oldArray, i, y);
          //g = x.expression.gcd(y.expression);
        }
        //if (x.operator === Condition.EQZ) {
        //  var tmp = y;
        //  y = x;
        //  x = tmp;
        //}
        if (x.operator === Condition.EQZ && Expression.isConstant(x.expression)) {
          return null;
        }
        if (y.operator === Condition.EQZ && Expression.isConstant(y.expression)) {
          return null;
        }
        //if (!Expression.isSingleVariablePolynomial(x.expression.multiply(y.expression))) {
        //  if (x.operator === Condition.EQZ) {
        //    newArray.push(y);
        //  } else {
        //    newArray.push(x);
        //  }
        //}
      }
      var newMethodEnabled = true;
      var singleVariablePolynomials = Expression.isSingleVariablePolynomial(x.expression) &&
                                      Expression.isSingleVariablePolynomial(y.expression) &&
                                      Expression.isSingleVariablePolynomial(x.expression.multiply(y.expression));
      if (x.operator === Condition.NEZ && y.operator === Condition.EQZ && singleVariablePolynomials) {
        y = y;
      } else if (x.operator === Condition.EQZ && y.operator === Condition.NEZ && singleVariablePolynomials) {
        y = x;
      } else if (x.operator === Condition.EQZ && y.operator === Condition.EQZ && singleVariablePolynomials) {
        var g = x.expression.polynomialGCD(y.expression);
        //var g = x.expression.gcd(y.expression);
        if (g instanceof Expression.Integer) {
          return null;
        }
        y = {
          operator: y.operator,
          expression: g
        };
        return addRest(newArray, oldArray, i, y);
      } else if (x.operator === Condition.NEZ && y.operator === Condition.NEZ && singleVariablePolynomials) {
        var g = x.expression.gcd(y.expression);
        x = {
          operator: x.operator,
          expression: x.expression.divide(g)
        };
        if (!Expression.isConstant(x.expression)) {
          newArray.push(x);
        }
      } else { // !isSingleVariablePolynomial
        // TODO: use Expression.isSingleVariablePolynomial(x.expression.multiply(y.expression))) here, and remove in the branches above


        //!new 2020-16-02
        var getConstant = function (e) {
          if (e instanceof Expression.Multiplication && e.a instanceof Expression.Matrix) {//TODO: ?
            return e.a.multiply(getConstant(e.b));
          }
          var c = Expression.getConstant(e);
          for (var iteratorf = e.divide(c).factors()[globalThis.Symbol.iterator](), f = iteratorf.next().value; f != null; f = iteratorf.next().value) {
            if (f instanceof Expression.NthRoot && Expression.isConstant(f.a)) {
              c = c.multiply(f);
            }
          }
          return c;
        };
        var collapse = function (e, candidate) { // sqrt(2)*x*y+2*x*y
          var term0 = candidate.divide(getConstant(candidate));
          var result = Expression.ZERO;
          for (var iteratora = e.summands()[globalThis.Symbol.iterator](), a = iteratora.next().value; a != null; a = iteratora.next().value) {
            var term = a.divide(getConstant(a));
            if (term.equals(term0)) {
              result = result.add(a);
            }
          }
          return result;
        };
        var getPivotMonomial = function (e) {
          // https://en.wikipedia.org/wiki/Monomial_order#Lexicographic_order
          //TODO: change compare4Addition (?)
          var getExponent = function (x) {
            return x instanceof Expression.Exponentiation ? x.b : Expression.ONE;
          };
          var getBase = function (x) {
            return x instanceof Expression.Exponentiation ? x.a : x;
          };
          var totalDegree = function (e) {
            var result = Expression.ZERO;
            for (var iteratorf = e.factors()[globalThis.Symbol.iterator](), f = iteratorf.next().value; f != null; f = iteratorf.next().value) {
              if (!Expression.isConstant(f)) {
                var e = getExponent(f);
                //if (e instanceof Expression.Integer) {//?
                  result = result.add(e);
                //}
              }
            }
            return result;
          };
          var compare = function (x, y) {
            //TODO: better order (see Wikipedia)
            var s = totalDegree(x).subtract(totalDegree(y));
            var c = s.isNegative() ? -1 : (s.negate().isNegative() ? +1 : 0);
            if (c !== 0) {
              return c;
            }
            //return x.compare4Addition(y);
            //TODO: change Expression#compare4Addition - ?
            var i = Array.from(x.divide(Expression.getConstant(x)).factors()).reverse().values();
            var j = Array.from(y.divide(Expression.getConstant(y)).factors()).reverse().values();
            var a = i.next().value;
            var b = j.next().value;
            while (a != null && b != null) {
              var c = (0 - getBase(a).compare4Multiplication(getBase(b))) || getExponent(a).compare4Multiplication(getExponent(b));
              if (c !== 0) {
                return c;
              }
              a = i.next().value;
              b = j.next().value;
            }
            return a != null ? +1 : (b != null ? -1 : 0);
          };
          var candidate = null;
          for (var iteratora = e.summands()[globalThis.Symbol.iterator](), a = iteratora.next().value; a != null; a = iteratora.next().value) {
            if (candidate == null || compare(a, candidate) > 0) {
              candidate = a;
            }
          }
          return candidate;
        };
        if (newMethodEnabled && x.operator === Condition.EQZ) {
          var pivot = getPivotMonomial(x.expression);
          var p = pivot.divide(getConstant(pivot))._abs();
          pivot = collapse(x.expression, pivot);
          var newYExpression = y.expression;
          var c1 = 0;
          for (var iteratora = y.expression.summands()[globalThis.Symbol.iterator](), a = iteratora.next().value; a != null; a = iteratora.next().value) {
            if (a.gcd(p)._abs().equals(p)) {
              newYExpression = newYExpression.subtract(a.divide(pivot).multiply(x.expression));
              c1 += 1;
            }
          }
          if (c1 > 0) {
            return addRest(add(newArray, x), oldArray, i, {expression: newYExpression, operator: y.operator});
          }
        }
        if (newMethodEnabled && y.operator === Condition.EQZ) {
          var pivot = getPivotMonomial(y.expression);
          var p = pivot.divide(getConstant(pivot))._abs();
          pivot = collapse(y.expression, pivot);
          for (var iteratora = x.expression.summands()[globalThis.Symbol.iterator](), a = iteratora.next().value; a != null; a = iteratora.next().value) {
            if (a.gcd(p)._abs().equals(p)) {
              return addRest(add(newArray, {expression: x.expression.subtract(a.divide(pivot).multiply(y.expression)), operator: x.operator}), oldArray, i, y);
            }
          }
        }
        if (newMethodEnabled && true) {
          // Condition.TRUE.andNotZero(ExpressionParser.parse('b*c-a*d')).andZero(ExpressionParser.parse('2*b*c-2*a*d+b*c*d+c*d-a*d^2')) + ''
          if (x.operator === Condition.NEZ && y.operator === Condition.EQZ) {
            // consider y = x * q + r, where q is not zero (? and x is not zero)
            // then y != r

            var pivot = getPivotMonomial(x.expression);
            var p = pivot.divide(Expression.getConstant(pivot));
            for (var iteratora = y.expression.summands()[globalThis.Symbol.iterator](), a = iteratora.next().value; a != null; a = iteratora.next().value) {
              if (a.gcd(p).equals(p) || a.gcd(p).equals(p.negate())) {
                var q = a.divide(pivot);
                if (q instanceof Expression.Integer && !q.equals(Expression.ZERO)) {//TODO: when q is a multiplicaiton of other != 0 conditions
                  //?TODO: prevent infinite loop: how?
                  var r = y.expression.subtract(q.multiply(x.expression));
                  var rr = {expression: r, operator: Condition.NEZ};
                  var flag = false;
                  if (true) {
                    //! 2020-07-05
                    var flag = false;
                    for (var ii = 0; ii < oldArray.length; ii++) {
                      var n = oldArray[ii]
                      if (n.operator === Condition.EQZ) {
                        var g = n.expression.gcd(rr.expression);
                        if (!g.equals(Expression.ONE) && !g.equals(Expression.ONE.negate())) {
                          flag = true;
                        }
                      }
                    }
                  }
                  //flag = oldArray.length < add(oldArray.slice(0), rr).length;//?TODO: better way
                  if (flag) {
                    return addRest(add(add(newArray, x), rr), oldArray, i - 1, y);
                  }
                }
              }
            }

          }
        }
        //!
        if (!newMethodEnabled || true) {

        var p = null;
        var pOperator = null;
        var pp = null;
        var other = null;
        var px = Expression.getMultivariatePolynomial(x.expression);
        var py = Expression.getMultivariatePolynomial(y.expression);
        //var xy = Expression.getMultivariatePolynomial(x.expression.multiply(y.expression));

        if (y.operator === Condition.EQZ && py != null && py.p.getDegree() !== 1) {
          var tmp = Expression.getMultivariatePolynomial(py.p.getCoefficient(0));
          if (tmp != null) {
            var v = tmp.v;
            if (v instanceof Expression.Symbol && tmp.p.getDegree() === 1) {
              py = {p: Polynomial.toPolynomial(y.expression, v), v: v};
            }
          }
        }

        //console.assert(px != null && py != null);

        if (//xy != null &&
            //x.operator === Condition.EQZ &&
            //y.operator === Condition.EQZ &&
            px != null && py != null) {


          //!new 2019-24-12
          /*
          //TODO: remove - buggy - ?
          if (!newMethodEnabled && px != null && py != null && px.v.equals(py.v) && px.p.getDegree() !== 1 && py.p.getDegree() !== 1 && x.operator === Condition.EQZ && y.operator === Condition.EQZ) {
            //TODO: test, fix
            var tmp1 = py.p.getDegree() >= px.p.getDegree() ? Polynomial.pseudoRemainder(py.p, px.p) : py.p;
            var tmp2 = tmp1.calcAt(px.v);
            var tmp = {expression: tmp2, operator: y.operator};
            newArray = add(newArray, tmp);
            if (newArray == null) {
              return null;
            }
            return addRest(newArray, oldArray, i, x);
          }
          */
          //!?

          //if (px != null && px.p.getDegree() !== 1 && py == null) {
            //py = {p: Polynomial.toPolynomial(y.expression, px.v), v: px.v};
            //if (xy.v === py.v) {
            //  py = null;
            //}
          //}
          //if (px == null && py != null && py.p.getDegree() !== 1) {
            //px = {p: Polynomial.toPolynomial(x.expression, py.v), v: py.v};
            //if (xy.v === px.v) {
            //  px = null;
            //}
          //}
          //if (px == null && py == null) {//?TODO:
          //  px = {p: Polynomial.toPolynomial(x.expression, xy.v), v: xy.v};
          //  py = {p: Polynomial.toPolynomial(y.expression, xy.v), v: xy.v};
          //}

          if (y.operator === Condition.EQZ && py != null && py.p.getDegree() === 1 &&
              x.operator === Condition.EQZ && px != null && px.p.getDegree() === 1) {
            //TODO: fix !!!
            //TODO: test linear systems
            if (Expression._getReplacement(y.expression, px.v).equals(px.v) && Polynomial.toPolynomial(y.expression, px.v).getDegree() === 0) {
              px = null;
            }
            if (Expression._getReplacement(x.expression, py.v).equals(py.v) && Polynomial.toPolynomial(x.expression, py.v).getDegree() === 0) {
              py = null;
            }

            if (px != null && py != null) { // TODO: ?
              if (!(px.p.getCoefficient(1) instanceof Expression.Integer)) {
                px = null;
              }
              if (!(py.p.getCoefficient(1) instanceof Expression.Integer)) {
                py = null;
              }
            }

            if (px != null && py != null) {

            //if (px.v.symbol < py.v.symbol) {//!
            if (px.v.compare4Addition(py.v) < 0) {
              px = null;
            }
            //}

            }
          }

          if (y.operator === Condition.EQZ && py != null && py.p.getDegree() === 1) {
            pp = py;
            p = x.expression;
            pOperator = x.operator;
            other = y;
          }
          if (x.operator === Condition.EQZ && px != null && px.p.getDegree() === 1) {
            pp = px;
            p = y.expression;
            pOperator = y.operator;
            other = x;
          }
        }
        if (pp != null) {
          var ok = false;
          // x = -b / a if a !== 0
          ok = ok || pp.p.getDegree() === 1 && Expression.isConstant(pp.p.getCoefficient(1)) && Expression.isConstant(pp.p.getCoefficient(0));
          // a * x + 1 = function (0) { return a !== 0 && x !== function (0) { return x = -1 / a; }; }
          ok = ok || pp.p.getDegree() === 1 && Expression.isConstant(pp.p.getCoefficient(0)) && !pp.p.getCoefficient(0).equals(Expression.ZERO) && Expression.has(p, Expression.Exponentiation);
          //if (Expression.isSingleVariablePolynomial(p) && pp.v instanceof Expression.Symbol && Expression.getVariable(pp.p.getCoefficient(0)) != null && Expression.getVariable(pp.p.getCoefficient(0)).compare4Multiplication(pp.v) > 0) {
          //  ok = ok || pp.p.getDegree() === 1 && Expression.isConstant(pp.p.getCoefficient(1));
          //}
          //if ((pp.p.getCoefficient(1) instanceof Expression.Integer || polynomial.divideAndRemainder(pp.p, "undefined") != undefined || (!pp.p.getCoefficient(0).equals(Expression.ZERO) && Expression.isConstant(pp.p.getCoefficient(0)))) &&
          //    (!newMethodEnabled || Expression.isConstant(pp.p.getCoefficient(0)) || (pp.p.getCoefficient(1) instanceof Expression.Integer && Expression.isSingleVariablePolynomial(polynomial.calcAt(pp.p.getCoefficient(0).negate().divide(pp.p.getCoefficient(1)))))) && //!? new 2020-06-18
          //    !(p instanceof Expression.Symbol) || (polynomial.calcAt(pp.p.getCoefficient(0).negate().divide(pp.p.getCoefficient(1))) instanceof Expression.Integer)) {//TODO: replace only if the result is more simple (?): a*v != 0 or b != 0
          if (ok) {
            var alpha = pp.p.getCoefficient(0).negate().divide(pp.p.getCoefficient(1));
            //var polynomial = Polynomial.toPolynomial(p, pp.v);
            //var a = polynomial.calcAt(alpha);
            var a = Expression._substitute(p, pp.v, alpha, {uniqueObject: 1});
            if (!a.equals(p)) {
              var tmp = {
                operator: pOperator,
                expression: a
              };
              newArray = add(newArray, tmp);
              if (newArray == null) {
                return null;
              }
              if (true) {
                return addRest(newArray, oldArray, i, other);
              } else {
                y = other;
              }
            } else {
              newArray.push(x);
            }
          } else {
            newArray.push(x);
          }
        } else {
          newArray.push(x);
        }
        } else {
          newArray.push(x);
        }
      }
    }
    newArray.push(y);

    /*
    var allNEZ = function* (array) {
      for (var i = 0; i < array.length; i += 1) {
        var y = array[i];
        if (y.operator === Condition.EQZ) {
          for (var j = 0; j < array.length; j += 1) {
            var x = array[j];
            if (x.operator === Condition.NEZ) {
              // Condition.TRUE.andNotZero(ExpressionParser.parse('b*c-a*d')).andZero(ExpressionParser.parse('2*b*c-2*a*d+b*c*d+c*d-a*d^2')) + ''
              // consider y = x * q + r, where q is not zero
              // then y != r

              var pivot = getPivotMonomial(x.expression);
              var p = pivot.divide(Expression.getConstant(pivot));
              for (var iteratora = y.expression.summands()[globalThis.Symbol.iterator](), a = iteratora.next().value; a != null; a = iteratora.next().value) {
                if (a.gcd(p).equals(p) || a.gcd(p).equals(p.negate())) {
                  var q = a.divide(pivot);
                  if (q instanceof Expression.Integer && !q.equals(Expression.ZERO)) {//TODO: when q is a multiplicaiton of other != 0 conditions
                    //?TODO: prevent infinite loop: how?
                    var r = y.expression.subtract(q.multiply(x.expression));
                    //if (oldArray.length < add(oldArray.slice(0), {expression: r, operator: Condition.NEZ}).length) {//?TODO: better way
                    //  return addRest(add(add(newArray, x), {expression: r, operator: Condition.NEZ}), oldArray, i - 1, y);
                    //}
                    yield r;
                  }
                }
              }
            }
          }
        }
      }

    };

    for (var i = 0; i < newArray.length; i += 1) {
      var y = newArray[i];
      if (y.operator === Condition.EQZ) {
        for (var iteratornez = allNEZ(newArray)[globalThis.Symbol.iterator](), nez = iteratornez.next().value; nez != null; nez = iteratornez.next().value) {
          var g = y.expression.gcd(nez);
          if (!g.equals(Expression.ONE) && !g.equals(Expression.ONE.negate())) {
            return add(newArray, {expression: y.expression.divide(g), operator: Condition.EQZ});
          }
        }
      }
    }
    */

    //?
    //TODO: only when multiple variables and has `f != 0`
    //TODO: test with replacements
    //TODO: !!!
    if (newMethodEnabled && true) {
    var base = new Condition(newArray);
    for (var i = 0; i < newArray.length; i += 1) {
      var y = newArray[i];
      if (y.operator === Condition.EQZ) {
        var f = y.expression;
        /*
        //if (!Expression.isSingleVariablePolynomial(f)) {// performace (?)
          if (!Expression.isConstant(f.divide(Expression.simpleDivisor(f)))) {
            while (!Expression.isConstant(f)) {
              var d = Expression.simpleDivisor(f);
              var q = f.divide(d);
              if (new Condition(newArray.slice(0, i).concat(newArray.slice(i + 1))).andZero(d).isFalse()) { // TODO: fix
                return add(newArray, {expression: d, operator: Condition.NEZ});
              }
              f = q;
            }
          }
        //}
        */
          var g = null;
          for (var iterators = f.summands()[globalThis.Symbol.iterator](), s = iterators.next().value; s != null; s = iterators.next().value) {
            var a = s.divide(Expression.getConstant(s));
            if (g == null) {
              g = a;
            } else {
              g = g.gcd(a);
            }
          }
          if (!g.equals(Expression.ONE) && f instanceof Expression.Addition) {
            // can g be equal to 0 ?
            if (new Condition(newArray.slice(0, i).concat(newArray.slice(i + 1))).andZero(g).isFalse()) { // TODO: fix
              return add(newArray, {expression: g, operator: Condition.NEZ});
            }
          }

      }
    }
    }
    //?

    return newArray;
  };
  var newArray = add(this.array, {
    operator: operator,
    expression: e
  });
  if (newArray == null) {
    return Condition.FALSE;
  }
  if (newArray.length === 0) {
    return Condition.TRUE;
  }

  return new Condition(newArray);
};

Condition.prototype.andNotZero = function (e) {
  return this._and(Condition.NEZ, e);
};
Condition.prototype.andZero = function (e) {
  return this._and(Condition.EQZ, e);
};
Condition.prototype.andGreaterZero = function (e) {
  return this._and(Condition.GTZ, e);
};
Condition.prototype.and = function (b) {
  if (!(b instanceof Condition)) {
    throw new TypeError();
  }
  var c = this;
  for (var i = 0; i < b.array.length; i += 1) {
    c = c._and(b.array[i].operator, b.array[i].expression);
  }
  return c;
};
Condition.prototype.isFalse = function () {
  return this === Condition.FALSE;
};
Condition.prototype.isTrue = function () {
  return this === Condition.TRUE;
};
Condition.prototype.toString = function (options) {
  if (this === Condition.TRUE || this === Condition.FALSE) {
    // 1) no need; 2) no way to distinguish TRUE and FALSE
    throw new TypeError();
  }
  if (this.array.length === 0) {
    // assertion
    throw new TypeError();
  }
  var s = '';
  for (var i = 0; i < this.array.length; i += 1) {
    s += (i !== 0 ? ', ' : '') + this.array[i].expression.toString(options) + this.array[i].operator;
  }
  return s;
};

Condition.TRUE = new Condition(new Array(0));
Condition.FALSE = new Condition(undefined);


Condition.prototype.getSolutionFor = function (variable) {
  var condition = this;
  if (condition.array == null) {
    return null;
  }
  for (var i = 0; i < condition.array.length; i += 1) {
    var c = condition.array[i];
    if (c.operator === Condition.EQZ) {
      var p = Polynomial.toPolynomial(c.expression, variable);
      if (p.getDegree() === 1) {
        return p.getroots()[0];
      }
    }
  }
  return null;
};

  Condition.prototype.updateExpression = function (e, options) {
    return this.andNotZero(e).isFalse() ? Expression.ZERO : e;
    //var symbol = new Expression.Symbol('$e');
    //var condition = options && options.flag1 ? this : new Condition(this.array.filter(function (x) { return x.expression instanceof Expression.Symbol && x.operator === Condition.EQZ; }));
    //var c2 = condition.andZero(e.subtract(symbol));
    //return c2.getSolutionFor(symbol);
    //return e;
  };

self.Condition = Condition;

})();
(function () {
"use strict";

 //TODO:

 //TODO:

 //TODO:
//TODO: remove - ?

 //!TODO: remove

Polynomial.prototype.toString = function (options) {
  options = options || {};
  return this.toExpression(options.polynomialVariable || new Expression.Symbol("x")).toString(options);
};

Polynomial.prototype.toMathML = function (options) {
  options = options || {};
  return this.toExpression(options.polynomialVariable || new Expression.Symbol("x")).toMathML(options);
};

Expression.Polynomial.prototype.toString = function (options) {
  return this.polynomial.toString(options);
};

Expression.Polynomial.prototype.toMathML = function (options) {
  return this.polynomial.toMathML(options);
}; // coefficient - Expression
// variable - Expression


var printPartOfAddition = function (isLast, isFirst, coefficient, variable, options) {
  if (coefficient.equals(Expression.ZERO)) {
    return isLast && isFirst ? Expression.ZERO.toMathML() : "";
  }

  var isNegative = false;

  if (coefficient.isNegative() && !isFirst) {
    isNegative = true;
    coefficient = coefficient.negateCarefully(); //?
  }

  var precedenceOfMultiptication = new Expression.Multiplication(Expression.ZERO, Expression.ZERO).getPrecedence();
  var areBracketsRequired = coefficient.getPrecedence() < precedenceOfMultiptication; //?

  var c = coefficient.equals(Expression.ONE); //TODO: fix

  return (isFirst ? '' : '') + (!isFirst && isNegative ? '<mo form="infix">&minus;</mo>' : '') + (!isFirst && !isNegative ? '<mo form="infix">+</mo>' : '') + (c ? '' : '<mrow>') + (c || !areBracketsRequired ? '' : '<mrow><mo>(</mo>') + (c ? '' : coefficient.toMathML(options)) + (c || !areBracketsRequired ? '' : '<mo>)</mo></mrow>') + (c ? '' : '<mo>&sdot;</mo>') + variable.toMathML(options) + (c ? '' : '</mrow>');
};

var decimalToMathML = function (decimal) {
  var match = /^([+\-])?(\d+\.?\d*(?:\(\d+\)\d*)?)(?:[eE]\+?(\-?\d+))?$/.exec(decimal);
  var groups = {
    sign: match[1] || "",
    significand: match[2] || "",
    exponent: match[3] || ""
  };
  return (groups.exponent !== "" ? "<mrow>" : "") + (groups.sign !== "" ? "<mrow>" : "") + (groups.sign === "+" ? "<mo>+</mo>" : "") + (groups.sign === "-" ? "<mo>&minus;</mo>" : "") + "<mn>" + numberFormat.format(groups.significand.replace(/[\(\)]/g, '')).replace(/^[\s\S]+$/g, function (p) {
    var a = groups.significand.indexOf('(');
    var b = groups.significand.lastIndexOf(')');

    if (a === -1 || b === -1) {
      return p;
    }

    var digitLength = numberFormat.format('0').trim().length;
    var i = p.length - (groups.significand.length - a - '('.length - ')'.length) * digitLength;
    var j = p.length - (groups.significand.length - b - ')'.length) * digitLength;
    return p.slice(0, i) + '<span style="text-decoration:overline;">' + p.slice(i, j) + '</span>' + p.slice(j);
  }) + "</mn>" + (groups.sign !== "" ? "</mrow>" : "") + (groups.exponent !== "" ? "<mo lspace=\"0\" rspace=\"0\">&sdot;</mo>" + "<msup>" + "<mn>" + numberFormat.format('10') + "</mn>" + decimalToMathML(groups.exponent) + "</msup>" : "") + (groups.exponent !== "" ? "</mrow>" : "");
};

var complexToMathML = function (real, imaginary) {
  if (imaginary.replace(/<[^>]+>/g, '') === '1') {
    return '<mrow>' + real + '<mo>+</mo><mi>&ii;</mi></mrow>';
  }

  if (imaginary.replace(/<[^>]+>/g, '').replace(/&minus;/g, '-') === '-1') {
    return '<mrow>' + real + '<mo>&minus;</mo><mi>&ii;</mi></mrow>';
  }

  if (real === '') {
    return '<mrow>' + imaginary + '<mo>' + (/<msup>/.test(imaginary) || /[^0-9]/.test(imaginary) ? '&sdot;' : '&it;') + '</mo><mi>&ii;</mi></mrow>';
  }

  var signBetween = '+';

  if (/<mrow><mo>&minus;<\/mo><mn>([^<]*)<\/mn><\/mrow>(?!<\/msup>)/.test(imaginary)) {
    signBetween = '-';
    imaginary = imaginary.replace(/<mrow><mo>&minus;<\/mo><mn>([^<]*)<\/mn><\/mrow>(?!<\/msup>)/g, '<mn>$1</mn>');
  }

  return '<mrow>' + real + '<mo>' + (signBetween === '-' ? '&minus;' : '+') + '</mo>' + '<mrow>' + imaginary + '<mo>' + (/<msup>/.test(imaginary) || /[^0-9]/.test(imaginary) ? '&sdot;' : '&it;') + '</mo>' + '<mi>&ii;</mi>' + '</mrow>' + '</mrow>';
};

Expression._decimalToMathML = decimalToMathML;
Expression._complexToMathML = complexToMathML;

function isConstant(e) {
  if (e instanceof Expression.PolynomialRootSymbol) {
    return true;
  }

  if (e instanceof Expression.ExpressionPolynomialRoot) {
    return true;
  }

  if (e instanceof Expression.ExpressionWithPolynomialRoot) {
    return isConstant(e.e);
  }

  if (e instanceof Expression.Symbol) {
    //return false;
    return e === Expression.E || e === Expression.PI;
  }

  if (e instanceof Expression.NonSimplifiedExpression) {
    return false;
  }

  if (e instanceof Expression.Matrix) {
    return false;
  }

  if (e instanceof Expression.Polynomial) {
    return false;
  }

  if (e instanceof Expression.BinaryOperation) {
    //return ((e.a === Expression.E || e.a === Expression.PI) || isConstant(e.a)) && isConstant(e.b);
    return isConstant(e.a) && isConstant(e.b);
  }

  if (e instanceof Expression.Negation) {
    return isConstant(e.b);
  }

  if (e instanceof Expression.Function) {
    return isConstant(e.a);
  }

  if (e instanceof Expression.Radians) {
    return isConstant(e.value);
  }

  return true;
}

var groupByTerm = function (e) {
  if (e instanceof Expression.Division || e instanceof Expression.Addition) {
    var numerator = e.getNumerator();
    var denominator = e.getDenominator(); //TODO: fix

    var denominatorContent = denominator instanceof Expression.Integer ? denominator : (Expression.getMultivariatePolynomial(denominator) || {
      p: {
        getContent: function () {
          return Expression.ONE;
        }
      }
    }).p.getContent();
    var denominatorRest = denominator.divide(denominatorContent);

    if (isConstant(denominatorContent)) {
      //TODO: fix when the content has multiple variables
      var summands = [];

      for (var iteratorsummand = numerator.summands()[globalThis.Symbol.iterator](), summand = iteratorsummand.next().value; summand != null; summand = iteratorsummand.next().value) {
        summands.push(summand);
      }

      var map = {}; //TODO: FIX, test(?)

      summands.reverse();

      for (var i = 0; i < summands.length; i += 1) {
        var summand = summands[i]; //var constant = Expression.getConstant(summand); - ?

        var constant = Expression.ONE;

        for (var iteratorfactor = summand.factors()[globalThis.Symbol.iterator](), factor = iteratorfactor.next().value; factor != null; factor = iteratorfactor.next().value) {
          if (isConstant(factor)) {
            constant = constant.multiply(factor);
          }
        }

        var term = summand.divide(constant);
        var key = "_" + term.toString();
        map[key] = map[key] || {
          constant: Expression.ZERO,
          term: term
        };
        map[key].constant = map[key].constant.add(constant.divide(denominatorContent));
      }

      var result = null;

      for (var key in map) {
        if (Object.prototype.hasOwnProperty.call(map, key)) {
          var constant = map[key].constant;
          var term = map[key].term;
          var s = false;

          if (result != null && constant.isNegative()) {
            constant = constant.negate();
            s = true;
          }

          var x = new NonSimplifiedExpression(term.equals(Expression.ONE) ? constant : constant.equals(Expression.ONE) ? map[key].term : new Expression.Multiplication(constant, map[key].term));
          result = result == null ? x : new Expression.Addition(result, s ? new Expression.Multiplication(Expression.ONE.negate(), x) : x);
        }
      }

      if (!denominatorRest.equals(Expression.ONE)) {
        result = new Expression.Division(result, denominatorRest);
      }

      return new NonSimplifiedExpression(result);
    }
  }

  return undefined;
};

var getRounding = function (options) {
  var rounding = options != undefined ? options.rounding : undefined;

  if (options != undefined && rounding == undefined && options.fractionDigits != undefined && options.fractionDigits !== -1) {
    console.debug('deprecated fractionDigits, use rounding instead');
    rounding = {
      fractionDigits: options.fractionDigits
    };
  }

  return rounding;
}; //TODO: move


Expression.toDecimalString = function (x, options) {
  var rounding = getRounding(options);

  if (rounding != null) {
    if (isConstant(x)) {
      return toDecimalStringInternal(x, rounding, decimalToMathML, complexToMathML);
    } else if (!Expression.has(x, NonSimplifiedExpression)) {
      var grouped = groupByTerm(x);

      if (grouped != undefined) {
        return grouped.toMathML(options);
      }
    }
  }

  return undefined;
};

var getPrecedence = function (x, options) {
  var rounding = getRounding(options);

  if (rounding != null && isConstant(x.unwrap()) && Expression.has(x.unwrap(), Expression.Complex)) {
    if (!x.unwrap().equals(Expression.I)) {
      return new Expression.Addition(Expression.ONE, Expression.ONE).getPrecedence();
    }
  }

  return x.getPrecedence();
};

Expression.idCounter = 0;

Expression.id = function () {
  return (Expression.idCounter += 1).toString();
}; //TODO: ?


Expression.escapeHTML = function (s) {
  return s.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
};

Expression.Matrix.prototype.toMathML = function (options) {
  var x = this.matrix;
  options = Expression.setTopLevel(true, options);
  var useMatrixContainer = options.useMatrixContainer == undefined ? true : options.useMatrixContainer; //TODO: fix!

  var braces = options.useBraces == undefined ? undefined : options.useBraces;
  var columnlines = options.columnlines == undefined ? 0 : options.columnlines;
  var variableNames = options.variableNames == undefined ? undefined : options.variableNames;
  var verticalStrike = options.verticalStrike == undefined ? -1 : options.verticalStrike;
  var horizontalStrike = options.horizontalStrike == undefined ? -1 : options.horizontalStrike;
  var cellIdGenerator = options.cellIdGenerator == undefined ? undefined : options.cellIdGenerator;
  var pivotCell = options.pivotCell == undefined ? undefined : options.pivotCell;
  var isLUDecomposition2 = options.isLUDecomposition2 == undefined ? undefined : options.isLUDecomposition2;
  var highlightRow = options.highlightRow == undefined ? -1 : options.highlightRow;
  var highlightCol = options.highlightCol == undefined ? -1 : options.highlightCol;
  options = Object.assign({}, options, {
    useBraces: undefined,
    columnlines: undefined,
    variableNames: undefined,
    verticalStrike: undefined,
    horizontalStrike: undefined,
    cellIdGenerator: undefined,
    pivotCell: undefined,
    isLUDecomposition2: undefined,
    highlightRow: undefined,
    highlightCol: undefined
  });
  var result = "";
  var rows = x.rows();
  var cols = x.cols();
  var i = -1; //TODO: remove `Expression.id()`

  var containerId = options.idPrefix + "-" + Expression.id();

  if (useMatrixContainer) {
    result += "<munder accentunder=\"true\">"; // <menclose href="#"> will not be supported by MathML Core, so using <mrow>

    result += '<mrow id="' + containerId + '" data-matrix="' + Expression.escapeHTML(x.toString()) + '" draggable="true" tabindex="0" contextmenu="matrix-menu">';
  }

  result += braces == undefined ? '<mrow><mo>(</mo>' : '<mrow>' + (braces[0] === ' ' ? '' : '<mo>' + braces[0] + '</mo>');
  var columnlinesAttribute = "";

  if (columnlines !== 0 && cols - 1 > 0) {
    var k = -1;

    while (++k < cols - 1) {
      columnlinesAttribute += cols - 1 + columnlines === k ? "solid " : "none ";
    } // whitespace


    columnlinesAttribute = columnlinesAttribute.slice(0, -1);
  } //! 2017-07-06 rowspacing="0ex" was added to make it look better with Native MathML (when it is supported) and to have the same style as in mathml.css
  //  rowspacing="0ex" is also needed when verticalStrike !== -1


  var useColumnspacing = verticalStrike !== -1 || horizontalStrike !== -1 || pivotCell != undefined || cellIdGenerator != undefined;
  result += "<mtable" + " rowspacing=\"0ex\"" + (useColumnspacing ? " columnspacing=\"0em\"" : "") + (variableNames != undefined ? " columnalign=\"right\"" : "") + (columnlinesAttribute !== "" ? " columnlines=\"" + columnlinesAttribute + "\"" : "") + ">";

  while (++i < rows) {
    var j = -1;

    if (variableNames != undefined) {
      // TODO: fix?
      //TODO: use code from polynomialToExpression3 (shared)
      var row = "";
      var wasNotZero = false;

      while (++j < cols - 1) {
        // TODO: fix `new Expression.Symbol()`
        row += "<mtd>";
        row += printPartOfAddition(j === cols - 2, !wasNotZero, x.e(i, j), new Expression.Symbol(variableNames[j]), options);
        row += "</mtd>";
        wasNotZero = wasNotZero || !x.e(i, j).equals(Expression.ZERO);
      }

      row += "<mtd><mo>=</mo></mtd><mtd>" + x.e(i, cols - 1).toMathML(options) + "</mtd>";

      if (wasNotZero || !x.e(i, cols - 1).equals(Expression.ZERO)) {
        result += "<mtr>";
        result += row;
        result += "</mtr>";
      }
    } else {
      result += "<mtr>";

      while (++j < cols) {
        result += "<mtd" + (cellIdGenerator != undefined ? " id=\"" + cellIdGenerator(i, j) + "\"" : "") + ">";

        if (pivotCell != undefined && i === pivotCell.i && j === pivotCell.j) {
          result += "<mstyle mathvariant=\"bold\">";
          result += "<menclose notation=\"circle\">";
        }

        if (horizontalStrike === i) {
          result += "<menclose notation=\"horizontalstrike\">";
        }

        if (verticalStrike === j) {
          result += "<menclose notation=\"verticalstrike\">";
        }

        if (useColumnspacing) {
          result += "<mpadded width=\"+0.8em\" lspace=\"+0.4em\">";
        }

        var highlight = j < i && isLUDecomposition2 || highlightRow === i && (columnlines === 0 || j <= cols - 1 + columnlines) || highlightCol === j;

        if (highlight) {
          result += "<mrow mathbackground=\"#80FF80\" mathcolor=\"#3C78C2\">";
        }

        result += x.e(i, j).toMathML(options);

        if (highlight) {
          result += "</mrow>";
        }

        if (useColumnspacing) {
          result += "</mpadded>";
        }

        if (verticalStrike === j) {
          result += "</menclose>";
        }

        if (horizontalStrike === i) {
          result += "</menclose>";
        }

        if (pivotCell != undefined && i === pivotCell.i && j === pivotCell.j) {
          result += "</menclose>";
          result += "</mstyle>";
        }

        result += "</mtd>";
      }

      result += "</mtr>";
    }
  }

  result += "</mtable>";
  result += braces == undefined ? '<mo>)</mo></mrow>' : (braces[1] === ' ' ? '' : '<mo>' + braces[1] + '</mo>') + '</mrow>';

  if (useMatrixContainer) {
    result += '</mrow>';
    result += "<mtext>";
    result += "<button type=\"button\" class=\"matrix-menu-show\" data-for-matrix=\"" + containerId + "\" aria-haspopup=\"true\"></button>";
    result += "</mtext>";
    result += "</munder>";
  }

  return result;
};

Expression.Determinant.prototype.toMathML = function (options) {
  var x = this;

  if (x.a instanceof Expression.Matrix || x.a instanceof NonSimplifiedExpression && x.a.e instanceof Expression.Matrix) {
    options = Object.assign({}, options, {
      useBraces: ["|", "|"]
    }); //TODO: fix

    return x.a.toMathML(options);
  }

  return "<mrow><mo>|</mo>" + x.a.toMathML(options) + "<mo>|</mo></mrow>";
};

Expression.Transpose.prototype.toMathML = function (options) {
  var x = this; //TODO: ^T ?
  // https://www.w3.org/TR/MathML3/chapter4.html#contm.transpose

  var f = this.getPrecedence() >= x.a.getPrecedence();
  return "<msup>" + (f ? "<mrow><mo>(</mo>" : "") + x.a.toMathML(options) + (f ? "<mo>)</mo></mrow>" : "") + "<mi>T</mi>" + "</msup>";
};

Expression.ComplexConjugate.prototype.toMathML = function (options) {
  var x = this; // https://w3c.github.io/mathml/chapter4-d.html#contm.conjugate

  return "<mover accent=\"true\">" + x.a.toMathML(options) + "<mo>¯</mo>" + "</mover>";
};

Expression.SquareRoot.prototype.toMathML = function (options) {
  var d = Expression.toDecimalString(this, options);

  if (d != undefined) {
    return d;
  }

  return "<msqrt>" + this.a.toMathML(Expression.setTopLevel(true, options)) + "</msqrt>";
};

Expression.CubeRoot.prototype.toMathML = function (options) {
  return Expression.NthRoot.prototype.toMathML.call(this, options);
};

Expression.NthRoot.prototype.toMathML = function (options) {
  var d = Expression.toDecimalString(this, options);

  if (d != undefined) {
    return d;
  }

  console.assert(typeof this.n === "number" && Math.floor(this.n) === this.n && this.n >= 3);
  return "<mroot>" + this.a.toMathML(Expression.setTopLevel(true, options)) + "<mn>" + numberFormat.format(this.n.toString()) + "</mn>" + "</mroot>";
};

Expression.denotations = {};

Expression.Function.prototype.toMathML = function (options) {
  var d = Expression.toDecimalString(this, options);

  if (d != undefined) {
    return d;
  }

  var x = this;
  var fa = !(x.a instanceof Expression.Matrix) && !(x.a instanceof NonSimplifiedExpression && x.a.e instanceof Expression.Matrix); //?
  //TODO: fix

  return "<mrow>" + "<mi>" + (Expression.denotations[x.name] || x.name) + "</mi>" + "<mo>&af;</mo>" + (fa ? "<mrow><mo>(</mo>" : "") + x.a.toMathML(Expression.setTopLevel(true, options)) + (fa ? "<mo>)</mo></mrow>" : "") + "</mrow>";
};

Expression.Division.prototype.toMathML = function (options) {
  if (options != null && options.nofractions) {
    return Expression.BinaryOperation.prototype.toMathML.call(this, options);
  }

  var d = Expression.toDecimalString(this, options);

  if (d != undefined) {
    return d;
  }

  var x = this;
  var denominator = x.getDenominator();
  var numerator = x.getNumerator(); //???
  //if (numerator.isNegative()) {
  //  return "<mrow><mo>&minus;</mo>" + x.negateCarefully().toMathML(options) + "</mrow>";
  //}

  return "<mfrac>" + numerator.toMathML(Expression.setTopLevel(true, options)) + denominator.toMathML(Expression.setTopLevel(true, options)) + "</mfrac>";
};

Expression.numberFormat = {
  format: function (string) {
    return string;
  }
}; // only for non-negative integers without groupping, but large

var numberFormat = {
  format: function (string) {
    var getDecimalSeparator = function () {
      var s = Expression.numberFormat.format(1.5).trim();
      var tmp = /[٫,\.]/.exec(s);

      if (tmp == null) {
        console.error(s);
        return '.';
      }

      return tmp[0];
    };

    var getDecimalZeroOffset = function () {
      var codePoint = Expression.numberFormat.format(0).trim().codePointAt(0);
      var isDecimalZero = /[0٠۰߀०০੦૦୦௦౦೦൦෦๐໐༠၀႐០᠐᥆᧐᪀᪐᭐᮰᱀᱐꘠꣐꤀꧐꧰꩐꯰０𐒠𐴰𑁦𑃰𑄶𑇐𑋰𑑐𑓐𑙐𑛀𑜰𑣠𑥐𑱐𑵐𑶠𖩠𖭐𝟎𝟘𝟢𝟬𝟶𞅀𞋰𞥐🯰]/.test(String.fromCodePoint(codePoint));

      if (!isDecimalZero) {
        console.error(codePoint);
        return 0;
      }

      return codePoint - "0".charCodeAt(0);
    }; // This method is needed as native Intl.NumberFormat cannot format strings.
    // https://github.com/tc39/ecma402/issues/334


    var decimalSeparator = string.indexOf('.');

    if (decimalSeparator !== -1) {
      return numberFormat.format(string.slice(0, decimalSeparator)) + getDecimalSeparator() + numberFormat.format(string.slice(decimalSeparator + '.'.length));
    }

    var decimalZeroOffset = getDecimalZeroOffset();

    if (decimalZeroOffset === 0) {
      return string;
    }

    var result = "";

    for (var i = 0; i < string.length; i += 1) {
      result += String.fromCodePoint(decimalZeroOffset + string.charCodeAt(i));
    }

    return result;
  }
};

Expression.Integer.prototype.toMathML = function (options) {
  //var d = Expression.toDecimalString(this, options);
  //if (d != undefined) {
  //  return d;
  //}
  var x = this;
  var sign = x.compareTo(Expression.ZERO) < 0 ? '-' : '';
  var abs = x.compareTo(Expression.ZERO) < 0 ? x.negate() : x;
  var s = abs.value.toString();
  var tmp = numberFormat.format(s);
  return sign === "-" ? "<mrow>" + "<mo>&minus;</mo>" + "<mn>" + tmp + "</mn>" + "</mrow>" : "<mn>" + tmp + "</mn>";
};

Expression.BinaryOperation.prototype.toMathML = function (options) {
  options = options == null ? {} : options;

  if (options != null && options.rounding != null && this.unwrap() instanceof Expression.Exponentiation && this.unwrap().a.unwrap() instanceof Expression.Symbol && this.unwrap().a.unwrap() !== Expression.E && this.unwrap().a.unwrap() !== Expression.PI && !(this.unwrap().a.unwrap() instanceof Expression.PolynomialRootSymbol) && !(this.unwrap().a.unwrap() instanceof Expression.ExpressionPolynomialRoot) && (this.unwrap().b.unwrap() instanceof Expression.Integer || this.unwrap().b.unwrap() instanceof Expression.Negation && this.unwrap().b.unwrap().b.unwrap() instanceof Expression.Integer)) {
    options = Object.assign({}, options, {
      rounding: null
    });
  }

  var d = Expression.toDecimalString(this, options);

  if (d != undefined) {
    return d;
  } //!2019-05-16


  if (this instanceof Expression.Addition && options.printId == undefined) {
    var summands = function (e) {
      //if (true) { return e.summands(); }
      var result = [];

      while (e.unwrap() instanceof Expression.Addition) {
        result.push(e.unwrap().b);
        e = e.unwrap().a;
      }

      result.push(e);
      return result;
    };

    var s = [];
    var b = null;

    for (var iteratorx = summands(this)[globalThis.Symbol.iterator](), x = iteratorx.next().value; x != null; x = iteratorx.next().value) {
      if (b != null) {
        var n = false;

        if (b.isNegative()) {
          n = true;
          b = b.negateCarefully();
        }

        var fence = this.getPrecedence() >= getPrecedence(b, options);
        fence = fence || b.isUnaryPlusMinus();
        s.push((fence ? '<mrow><mo>(</mo>' : '') + b.toMathML(Expression.setTopLevel(fence, options)) + (fence ? '<mo>)</mo></mrow>' : ''));
        s.push(n ? '<mo>&minus;</mo>' : '<mo>+</mo>');
      }

      b = x;
    }

    s = s.reverse().join('');
    var a = b;
    var fence = a.getPrecedence() + (a.isRightToLeftAssociative() ? -1 : 0) < this.getPrecedence();

    if (options != undefined && options.isTopLevel != undefined && options.isTopLevel === false) {
      fence = fence || a.isUnaryPlusMinus();
    }

    s = (fence ? "<mrow><mo>(</mo>" : "") + a.toMathML(Expression.setTopLevel(fence || options == undefined || options.isTopLevel, options)) + (fence ? "<mo>)</mo></mrow>" : "") + s;
    return '<mrow>' + s + '</mrow>';
  } //!


  var a = this.a;
  var b = this.b;
  var isSubtraction = false; // TODO: check

  if (this instanceof Expression.Addition && b.isNegative()) {
    isSubtraction = true;
    b = b.negateCarefully(); //?
  }

  var fa = a.getPrecedence() + (a.isRightToLeftAssociative() ? -1 : 0) < this.getPrecedence();
  var fb = this.getPrecedence() + (this.isRightToLeftAssociative() ? -1 : 0) >= b.getPrecedence();

  if (options != undefined && options.isTopLevel != undefined && options.isTopLevel === false) {
    fa = fa || a.isUnaryPlusMinus();
  }

  fb = fb || b.isUnaryPlusMinus();
  fb = fb || this.unwrap() instanceof Expression.Exponentiation && b.unwrap() instanceof Expression.Exponentiation; // 2^3^4

  fa = fa || this.unwrap() instanceof Expression.Exponentiation && a.unwrap() instanceof Expression.Function; // cos(x)^(2+3)

  fa = fa || options.rounding != null && isConstant(a) && Expression.has(a, Expression.Complex); // sqrt(2)*(1+i)*x

  var s = isSubtraction ? "-" : this.getS();

  if (this instanceof Expression.Exponentiation) {
    if (a.unwrap() === Expression.E && b.unwrap() instanceof Expression.Matrix) {
      return '<mrow><mi>exp</mi><mo>&af;</mo>' + b.toMathML(options) + '</mrow>';
    }

    var boptions = options;

    if (!(a.unwrap() instanceof Expression.Matrix)) {
      boptions = Object.assign({}, options || {}, {
        nofractions: true
      });
    }

    return "<msup>" + (fa ? "<mrow><mo>(</mo>" : "") + a.toMathML(Expression.setTopLevel(fa || options == undefined || options.isTopLevel, options)) + (fa ? "<mo>)</mo></mrow>" : "") + (fb ? "<mrow><mo>(</mo>" : "") + b.toMathML(Expression.setTopLevel(fb, boptions)) + (fb ? "<mo>)</mo></mrow>" : "") + "</msup>";
  }

  if (this.isNegation()) {
    // assert(fa === false);
    return "<mrow><mo>&minus;</mo>" + (fb ? "<mrow><mo>(</mo>" : "") + b.toMathML(Expression.setTopLevel(fb, options)) + (fb ? "<mo>)</mo></mrow>" : "") + "</mrow>";
  } //TODO: fix spaces (matrix parsing)
  // &times; looks better than &it; when multiplying matrices (?)
  // &sdot; looks better than &times;


  var isScalarOrMatrixSymbol = function (e) {
    return Expression.isScalar(e.unwrap()) || e.unwrap() instanceof Expression.MatrixSymbol;
  };

  var base = function (e) {
    return e instanceof Expression.Exponentiation && (e.b.unwrap() instanceof Expression.Integer || e.b.unwrap() instanceof Expression.Symbol && e.b.unwrap().symbol === "T") ? e.a.unwrap() : e;
  };

  var canUseInvisibleTimes = function (e) {
    return !fa && !fb && (e.a.unwrap() instanceof Expression.Integer || base(e.a.unwrap()) instanceof Expression.Symbol || e.a.unwrap() instanceof Expression.Multiplication && base(e.a.unwrap().b.unwrap()) instanceof Expression.Symbol) && (base(e.b.unwrap()) instanceof Expression.Symbol || options.rounding == null && e.b.unwrap() instanceof Expression.SquareRoot); //return options.rounding == null && !fa && !fb && isScalarOrMatrixSymbol(e.a) && isScalarOrMatrixSymbol(e.b) && !(e.a instanceof Expression.Integer && (e.b instanceof Expression.Integer || e.b instanceof Expression.Exponentiation && e.b.a instanceof Expression.Integer))
  }; //!2020-08-02


  if (this instanceof Expression.Multiplication && options.printId == undefined) {
    var f = true;

    for (var x = this; x != null; x = x instanceof Expression.Multiplication ? x.a.unwrap() : null) {
      var factor = x instanceof Expression.Multiplication ? x.b.unwrap() : x;

      if (!(base(factor).unwrap() instanceof Expression.Symbol && Expression.isScalar(factor))) {
        f = false;
      }
    }

    if (f) {
      var s = [];

      for (var x = this; x != null; x = x instanceof Expression.Multiplication ? x.a.unwrap() : null) {
        var factor = x instanceof Expression.Multiplication ? x.b.unwrap() : x;
        s.push(factor.toMathML(Expression.setTopLevel(fence, options)));
      }

      s = s.reverse().join('<mo>&it;</mo>');
      return '<mrow>' + s + '</mrow>';
    }
  }

  return "<mrow>" + (fa ? "<mrow><mo>(</mo>" : "") + a.toMathML(Expression.setTopLevel(fa || options == undefined || options.isTopLevel, options)) + (fa ? "<mo>)</mo></mrow>" : "") + (s === '*' ? canUseInvisibleTimes(this) ? '<mo>&it;</mo>' : '<mo>&sdot;</mo>' : s === '-' ? '<mo>&minus;</mo>' : s === '/' ? '<mo>&#x2215;</mo>' : this instanceof Expression.Comma ? '<mo lspace="0em" rspace="0.55em">' + ',' + '</mo>' : '<mo>' + s + '</mo>') + (fb ? "<mrow><mo>(</mo>" : "") + b.toMathML(Expression.setTopLevel(fb, options)) + (fb ? "<mo>)</mo></mrow>" : "") + "</mrow>";
};

Expression.Symbol.prototype.toMathML = function (options) {
  var x = this;
  var s = x.symbol;
  var i = s.indexOf("_");

  if (i !== -1) {
    var indexes = s.slice(i + 1).replace(/^\(|\)$/g, "").split(",");
    var indexesMathML = "";

    for (var j = 0; j < indexes.length; j += 1) {
      indexesMathML += j !== 0 ? "<mo>,</mo>" : "";
      indexesMathML += /^\d+$/.exec(indexes[j]) != undefined ? Expression.Integer.fromString(indexes[j]).toMathML() : "<mi>" + indexes[j] + "</mi>";
    }

    if (indexes.length > 1) {
      indexesMathML = "<mrow>" + indexesMathML + "</mrow>";
    }

    var isVector = this instanceof Expression.MatrixSymbol && /^[a-z]$/.test(s.slice(0, i));
    return "<msub>" + "<mi" + (isVector ? " mathvariant=\"bold-italic\"" : "") + ">" + s.slice(0, i) + "</mi>" + indexesMathML + "</msub>";
  }

  var isVector = this instanceof Expression.MatrixSymbol && /^[a-z]$/.test(s);
  return "<mi" + (isVector ? " mathvariant=\"bold-italic\"" : "") + ">" + (this instanceof Expression.IdentityMatrix ? '<span class="dotted-underline" title="' + i18n.identityMatrix + '" aria-label="' + i18n.identityMatrix + '">' + s + '</span>' : s) + "</mi>";
};

Expression.Negation.prototype.toMathML = function (options) {
  var b = this.b;
  var fb = this.getPrecedence() + (this.isRightToLeftAssociative() ? -1 : 0) >= b.getPrecedence();
  fb = fb || b.isUnaryPlusMinus(); // assert(fa === false);

  return "<mrow><mo>&minus;</mo>" + (fb ? "<mrow><mo>(</mo>" : "") + b.toMathML(Expression.setTopLevel(fb, options)) + (fb ? "<mo>)</mo></mrow>" : "") + "</mrow>";
};

Expression.Factorial.prototype.toMathML = function (options) {
  var n = this.n.unwrap();
  var fn = !(n instanceof Expression.Integer && n.compareTo(Expression.ZERO) > 0);
  return "<mrow>" + (fn ? "<mrow><mo>(</mo>" : "") + n.toMathML(Expression.setTopLevel(fn, options)) + (fn ? "<mo>)</mo></mrow>" : "") + "<mo>!</mo></mrow>";
};

Condition.prototype.toMathML = function (options) {
  if (this === Condition.TRUE || this === Condition.FALSE) {
    // 1) no need; 2) no way to distinguish TRUE and FALSE
    throw new TypeError();
  }

  if (this.array.length === 0) {
    // assertion
    throw new TypeError();
  }

  var s = '';

  for (var i = 0; i < this.array.length; i += 1) {
    var c = this.array[i];
    s += i !== 0 ? '<mo lspace="0em" rspace="0.55em">,</mo>' : '';
    s += '<mrow>';
    var operator = '<mo>' + (c.operator === Condition.NEZ ? '&ne;' : c.operator === Condition.EQZ ? '=' : c.operator === Condition.GTZ ? '&gt;' : '???') + '</mo>';

    if (c.expression instanceof Expression.Addition && c.expression.a instanceof Expression.Symbol && c.expression.b instanceof Expression.Integer) {
      //TODO: ?
      var left = c.expression.a;
      var right = c.expression.b.negate();
      s += left.toMathML(options) + operator + right.toMathML(options);
    } else {
      s += c.expression.toMathML(options) + operator + Expression.ZERO.toMathML();
    }

    s += '</mrow>';
  }

  return this.array.length === 1 ? s : '<mrow>' + s + '</mrow>';
};

Expression.Complex.prototype.toMathML = function (options) {
  return this.toStringInternal(options, "<mo>&it;</mo>", "<mi>&ii;</mi>", "<mo>&minus;</mo>", "<mo>+</mo>", "<mrow>", "</mrow>", function (x, options) {
    return x.toMathML(options);
  });
};

Expression.GF2.prototype.toMathML = function (options) {
  //TODO: fix
  return this.a.toMathML(options);
};

Expression.GF2Value.prototype.toMathML = function (options) {
  return "<mrow>" + "<mn>" + this.value.toString() + "</mn>" + "</mrow>";
};

Expression.Degrees.prototype.toMathML = function (options) {
  return "<mrow>" + this.value.toMathML(options) + "<mo>&it;</mo><mi>&deg;</mi></mrow>";
};

Expression.Radians.prototype.toMathML = function (options) {
  return "<mrow>" + this.value.toMathML(options) + "<mo>&it;</mo><mi>rad</mi></mrow>";
};

NonSimplifiedExpression.prototype.toMathML = function (options) {
  //?
  //options = options.rounding != null ? Object.assign({}, options, {rounding: null}) : options;
  if (options != null && options.printId != undefined) {
    return "<mrow id=\"" + this.getId() + "\">" + this.e.toMathML(options) + "</mrow>";
  }

  return this.e.toMathML(options);
};

Expression.prototype.toMathML = function (options) {
  throw new TypeError();
};

Expression.DecimalFraction.prototype.toMathML = function (options) {
  return decimalToMathML(this.toString());
};
})();
var maybeJSBI = {
  toNumber: function toNumber(a) {
    return typeof a === "object" ? JSBI.toNumber(a) : Number(a);
  },
  add: function add(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.add(a, b) : a + b;
  },
  subtract: function subtract(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.subtract(a, b) : a - b;
  },
  multiply: function multiply(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.multiply(a, b) : a * b;
  },
  divide: function divide(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.divide(a, b) : a / b;
  },
  remainder: function remainder(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.remainder(a, b) : a % b;
  },
  exponentiate: function exponentiate(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.exponentiate(a, b) : typeof a === "bigint" && typeof b === "bigint" ? new Function("a**b", "a", "b")(a, b) : Math.pow(a, b);
  },
  leftShift: function leftShift(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.leftShift(a, b) : a << b;
  },
  signedRightShift: function signedRightShift(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.signedRightShift(a, b) : a >> b;
  },
  bitwiseAnd: function bitwiseAnd(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.bitwiseAnd(a, b) : a & b;
  },
  bitwiseOr: function bitwiseOr(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.bitwiseOr(a, b) : a | b;
  },
  bitwiseXor: function bitwiseXor(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.bitwiseXor(a, b) : a ^ b;
  },
  lessThan: function lessThan(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.lessThan(a, b) : a < b;
  },
  greaterThan: function greaterThan(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.greaterThan(a, b) : a > b;
  },
  lessThanOrEqual: function lessOrEqualThan(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.lessThanOrEqual(a, b) : a <= b;
  },
  greaterThanOrEqual: function greaterOrEqualThan(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.greaterThanOrEqual(a, b) : a >= b;
  },
  equal: function equal(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.equal(a, b) : a === b;
  },
  notEqual: function notEqual(a, b) {
    return typeof a === "object" && typeof b === "object" ? JSBI.notEqual(a, b) : a !== b;
  },
  unaryMinus: function unaryMinus(a) {
    return typeof a === "object" ? JSBI.unaryMinus(a) : -a;
  },
  bitwiseNot: function bitwiseNot(a) {
    return typeof a === "object" ? JSBI.bitwiseNot(a) : ~a;
  }
};


(function () {
  "use strict"; // https://en.wikipedia.org/wiki/Quadratic_integer
  // https://en.wikipedia.org/wiki/Factorization#Unique_factorization_domains
  // It is possible to use the comparision operators if a is a safe integer or BigIntegerInternal or BigInt and n is a safe integer:
  // a < n
  // a <= n
  // a > n
  // a >= n
  // a == n
  // a != n

  /*
  
        if (qi instanceof QuadraticInteger && qi.a < 0 || qi.b < 0) {
          var c = pow(qi.conjugate(), n, new QuadraticInteger(1, 0, qi.D));
          return qi.multiply(c).toExpression()._nthRoot(n).divide(new QuadraticInteger(Math.abs(qi.a), Math.abs(qi.b), qi.D).toExpression());
        }
  
  */

  function abs(a) {
    return JSBI.lessThan(a, JSBI.BigInt(0)) ? maybeJSBI.unaryMinus(a) : a;
  }

  function ngcd(a, b) {
    return JSBI.BigInt(bigIntGCD(a, b));
  } // (a + b*sqrt(D))/(overTwo ? 2 : 1)
  // a, b, D - integers,
  // D - squarefree integer


  function QuadraticInteger(a, b, D, overTwo) {
    overTwo = overTwo == undefined ? false : overTwo;
    a = typeof a === "number" ? JSBI.BigInt(a) : a;
    b = typeof b === "number" ? JSBI.BigInt(b) : b;
    D = maybeJSBI.toNumber(D); //TODO:

    if (typeof a === "number" && Math.abs(a) > Number.MAX_SAFE_INTEGER) {
      throw new RangeError();
    }

    if (typeof b === "number" && Math.abs(b) > Number.MAX_SAFE_INTEGER) {
      throw new RangeError();
    }

    if (overTwo && D % 4 === 0) {
      throw new RangeError();
    }

    if (overTwo && JSBI.equal(JSBI.remainder(a, JSBI.BigInt(2)), JSBI.BigInt(0)) && JSBI.equal(JSBI.remainder(b, JSBI.BigInt(2)), JSBI.BigInt(0))) {
      overTwo = false;
      a = JSBI.divide(a, JSBI.BigInt(2));
      b = JSBI.divide(b, JSBI.BigInt(2));
    }

    if (overTwo && (JSBI.equal(JSBI.remainder(a, JSBI.BigInt(2)), JSBI.BigInt(0)) || JSBI.equal(JSBI.remainder(b, JSBI.BigInt(2)), JSBI.BigInt(0)))) {
      throw new RangeError();
    }

    this.a = a;
    this.b = b;
    this.D = D;
    this.overTwo = overTwo;
  }

  QuadraticInteger.prototype.multiply = function (y) {
    var x = this;

    if (!maybeJSBI.equal(x.D, y.D)) {
      throw new TypeError();
    }

    var a = JSBI.add(maybeJSBI.multiply(x.a, y.a), JSBI.multiply(maybeJSBI.multiply(x.b, y.b), JSBI.BigInt(y.D)));
    var b = maybeJSBI.add(maybeJSBI.multiply(x.a, y.b), maybeJSBI.multiply(x.b, y.a));
    var d = (x.overTwo ? 1 : 0) + (y.overTwo ? 1 : 0);

    while (d > 0 && JSBI.equal(JSBI.remainder(a, JSBI.BigInt(2)), JSBI.BigInt(0)) && JSBI.equal(JSBI.remainder(b, JSBI.BigInt(2)), JSBI.BigInt(0))) {
      a = JSBI.divide(a, JSBI.BigInt(2));
      b = JSBI.divide(b, JSBI.BigInt(2));
      d -= 1;
    }

    return new QuadraticInteger(a, b, x.D, d === 1);
  };

  QuadraticInteger.prototype.conjugate = function (y) {
    return new QuadraticInteger(this.a, maybeJSBI.unaryMinus(this.b), this.D, this.overTwo);
  };

  QuadraticInteger.prototype.norm = function () {
    //var x = this.a * this.a;
    //var y = this.b * this.b;
    //return x % this.D + (((x - x % this.D) / this.D) - y) * this.D;
    var a = this.a;
    var b = this.b;
    var D = this.D;
    var aa = maybeJSBI.multiply(a, a);
    var bb = maybeJSBI.multiply(b, b);
    var norm = JSBI.subtract(aa, JSBI.multiply(bb, JSBI.BigInt(D)));

    if (this.overTwo) {
      if (!JSBI.equal(JSBI.remainder(norm, JSBI.BigInt(4)), JSBI.BigInt(0))) {
        throw new RangeError("assertion");
      }

      norm = JSBI.divide(norm, JSBI.BigInt(4));
    }

    if (typeof norm === "number" && Math.abs(norm) > Number.MAX_SAFE_INTEGER) {
      throw new TypeError();
    }

    if (typeof this.a === "number" && maybeJSBI.greaterThanOrEqual(norm, maybeJSBI.unaryMinus(Number.MAX_SAFE_INTEGER)) && norm <= +Number.MAX_SAFE_INTEGER) {
      norm = maybeJSBI.toNumber(norm);
    }

    return norm;
  };

  QuadraticInteger.prototype.truncatingDivideInteger = function (x) {
    return new QuadraticInteger(x.toBigInt(), Expression.ZERO.toBigInt(), this.D).truncatingDivide(this);
  };

  QuadraticInteger.prototype.truncatingDivide = function (y) {
    if (!(y instanceof QuadraticInteger)) {
      if (!y instanceof Expression.Integer) {
        throw new RangeError();
      }

      y = new QuadraticInteger(y.toBigInt(), Expression.ZERO.toBigInt(), this.D);
    }

    var x = this;

    if (!maybeJSBI.equal(x.D, y.D)) {
      throw new TypeError();
    }

    var n = x.multiply(y.conjugate());
    var d = y.norm();

    while (JSBI.equal(JSBI.remainder(d, JSBI.BigInt(2)), JSBI.BigInt(0)) && JSBI.equal(JSBI.remainder(n.a, JSBI.BigInt(2)), JSBI.BigInt(0)) && JSBI.equal(JSBI.remainder(n.b, JSBI.BigInt(2)), JSBI.BigInt(0))) {
      n = new QuadraticInteger(JSBI.divide(n.a, JSBI.BigInt(2)), JSBI.divide(n.b, JSBI.BigInt(2)), n.D, n.overTwo);
      d = JSBI.divide(d, JSBI.BigInt(2));
    }

    if (!n.overTwo && n.D % 4 === 1 && JSBI.notEqual(JSBI.remainder(n.a, JSBI.BigInt(2)), JSBI.BigInt(0)) && JSBI.notEqual(JSBI.remainder(n.b, JSBI.BigInt(2)), JSBI.BigInt(0)) && JSBI.equal(JSBI.remainder(d, JSBI.BigInt(2)), JSBI.BigInt(0))) {
      n = new QuadraticInteger(n.a, n.b, n.D, true);
      d = JSBI.divide(d, JSBI.BigInt(2));
    }

    return JSBI.equal(maybeJSBI.remainder(n.a, d), JSBI.BigInt(0)) && JSBI.equal(maybeJSBI.remainder(n.b, d), JSBI.BigInt(0)) ? new QuadraticInteger(maybeJSBI.divide(n.a, d), maybeJSBI.divide(n.b, d), x.D, n.overTwo) : null;
  };

  QuadraticInteger.prototype.negate = function () {
    return new QuadraticInteger(maybeJSBI.unaryMinus(this.a), maybeJSBI.unaryMinus(this.b), this.D, this.overTwo);
  };
  /*
  function primeFactor(n) {
    var i = n - n;
    ++i;
    ++i;
    if (n % i == 0) {
      return i;
    }
    ++i;
    while (i * i <= n) {
      if (n % i == 0) {
        return i;
      }
      ++i;
      ++i;
    }
    return n;
  }
  */


  function factors(n) {
    if (JSBI.lessThan(n, JSBI.BigInt(1))) {
      throw new TypeError();
    }

    var p = JSBI.greaterThan(n, JSBI.BigInt(1)) ? JSBI.BigInt(primeFactor(n)) : JSBI.BigInt(1);
    var t = JSBI.BigInt(1);
    var f = JSBI.BigInt(1);
    var fs = null;
    var i = JSBI.BigInt(1);
    var result = {
      done: false,
      value: null,
      next: function () {
        if (JSBI.equal(p, JSBI.BigInt(1))) {
          this.value = null;
          this.done = true;
          return this;
        }

        if (fs == null) {
          if (JSBI.equal(maybeJSBI.remainder(n, p), JSBI.BigInt(0))) {
            t = maybeJSBI.multiply(t, p);
            n = maybeJSBI.divide(n, p);
            this.value = t;
            this.done = false;
            return this;
          }

          fs = factors(n);
          i = t;
        }

        if (maybeJSBI.equal(i, t)) {
          i = JSBI.BigInt(1);
          f = fs.next().value;
        } else {
          i = maybeJSBI.multiply(i, p);
        }

        this.value = f == null ? null : maybeJSBI.multiply(f, i);
        this.done = f == null;
        return this;
      }
    };

    result[Symbol.iterator] = function () {
      return this;
    };

    return result;
  }

  QuadraticInteger._factors = function (n) {
    return factors(JSBI.BigInt(n));
  };

  QuadraticInteger._complexIntegerPrimeFactor = function (r, i) {
    r = JSBI.BigInt(r);
    i = JSBI.BigInt(i);

    function canBePerfectSquare(n) {
      // https://www.johndcook.com/blog/2008/11/17/fast-way-to-test-whether-a-number-is-a-square/#comment-15700
      //var bitset = 0;
      //for (var i = 0; i < 32; i += 1) {
      //  bitset |= 1 << ((i * i) % 32);
      //}
      var bitset = 33751571;
      var result = (bitset >> JSBI.toNumber(JSBI.remainder(n, JSBI.BigInt(32)))) % 2;
      return result === 1;
    }

    function norm(a, b) {
      return maybeJSBI.add(maybeJSBI.multiply(a, a), maybeJSBI.multiply(b, b));
    }

    function hasDivisor(r, i, a, b) {
      var d = maybeJSBI.add(maybeJSBI.multiply(a, a), maybeJSBI.multiply(b, b));
      var x = maybeJSBI.add(maybeJSBI.multiply(r, a), maybeJSBI.multiply(i, b));
      var y = maybeJSBI.subtract(maybeJSBI.multiply(i, a), maybeJSBI.multiply(r, b));
      return JSBI.equal(maybeJSBI.remainder(x, d), JSBI.BigInt(0)) && JSBI.equal(maybeJSBI.remainder(y, d), JSBI.BigInt(0));
    }

    var n = norm(r, i); //if (n > (Number.MAX_SAFE_INTEGER + 1) / 2) {
    //TODO: should not throw (see a call from Polynomial#getroots)
    //throw new RangeError("NotSupportedError");
    //}

    for (var iteratorp = QuadraticInteger._factors(n)[globalThis.Symbol.iterator](), p = iteratorp.next().value; p != null; p = iteratorp.next().value) {
      var b = JSBI.BigInt(0);
      var c = p;

      while (JSBI.greaterThan(c, JSBI.BigInt(0))) {
        if (canBePerfectSquare(c)) {
          var a = nthRoot(c, 2);

          if (maybeJSBI.equal(maybeJSBI.multiply(a, a), c)) {
            if (JSBI.greaterThan(norm(a, b), JSBI.BigInt(1)) && hasDivisor(r, i, a, b)) {
              return JSBI.equal(b, JSBI.BigInt(0)) ? new Expression.Complex(Expression.ZERO, Expression.Integer.fromBigInt(a)) : new Expression.Complex(Expression.Integer.fromBigInt(a), Expression.Integer.fromBigInt(b));
            }
          }
        }

        b = JSBI.add(b, JSBI.BigInt(1));
        c = maybeJSBI.subtract(p, maybeJSBI.multiply(b, b));
      }
    }

    if (JSBI.greaterThan(n, JSBI.BigInt(1))) {
      throw new TypeError();
    }

    return new Expression.Complex(Expression.Integer.fromBigInt(r), Expression.Integer.fromBigInt(i));
  }; //  Compute (k n), where k is numerator


  function jacobiSymbol(k, n) {
    if (k < 0 || n % 2 == 0) {
      throw new Error("Invalid value. k = " + k + ", n = " + n);
    }

    k = maybeJSBI.remainder(k, n);
    var jacobi = 1;

    while (k > 0) {
      while (k % 2 == 0) {
        k /= 2;
        var r = n % 8;

        if (r == 3 || r == 5) {
          jacobi = -jacobi;
        }
      }

      var temp = n;
      n = k;
      k = temp;

      if (k % 4 == 3 && n % 4 == 3) {
        jacobi = -jacobi;
      }

      k = maybeJSBI.remainder(k, n);
    }

    if (n == 1) {
      return jacobi;
    }

    return 0;
  } // D**((p - 1) / 2) % p


  function LegendreSymbol(a, p) {
    // https://en.wikipedia.org/wiki/Legendre_symbol#:~:text=Special%20formulas
    // https://rosettacode.org/wiki/Jacobi_symbol#Java
    return jacobiSymbol(a, p);
  }

  function quadraticIntegers(norm, D, b) {
    var overTwo = maybeJSBI.toNumber(D) % 4 === 1;

    while (true) {
      var bbD = maybeJSBI.multiply(maybeJSBI.multiply(b, b), D);
      var guess1 = maybeJSBI.add(maybeJSBI.multiply(maybeJSBI.unaryMinus(norm), overTwo ? JSBI.BigInt(4) : JSBI.BigInt(1)), bbD);
      var guess2 = maybeJSBI.add(maybeJSBI.multiply(norm, overTwo ? JSBI.BigInt(4) : JSBI.BigInt(1)), bbD); //if (typeof norm === "number") {//TODO:

      if (maybeJSBI.toNumber(guess2) > Number.MAX_SAFE_INTEGER || maybeJSBI.toNumber(guess1) > Number.MAX_SAFE_INTEGER) {
        throw new RangeError(norm);
      } //}


      var guess = guess1;

      if (JSBI.greaterThanOrEqual(guess, JSBI.BigInt(0))) {
        var a = JSBI.BigInt(nthRoot(guess, 2));

        if (JSBI.equal(guess, JSBI.exponentiate(a, JSBI.BigInt(2)))) {
          // && ngcd(a, b) === 1
          return new QuadraticInteger(a, b, D, overTwo);
        }
      }

      var guess = guess2;

      if (JSBI.greaterThanOrEqual(guess, JSBI.BigInt(0))) {
        var a = JSBI.BigInt(nthRoot(guess, 2));

        if (JSBI.equal(guess, JSBI.exponentiate(a, JSBI.BigInt(2)))) {
          // && ngcd(a, b) === 1
          return new QuadraticInteger(a, b, D, overTwo);
        }
      }

      b = JSBI.add(b, JSBI.BigInt(1));
    }
  }

  QuadraticInteger._fundamentalUnit = function (D) {
    return quadraticIntegers(JSBI.BigInt(1), D, JSBI.BigInt(1));
  };

  QuadraticInteger.prototype.primeFactor = function () {
    var a = this.a;
    var b = this.b;
    var D = JSBI.BigInt(this.D);
    var g = ngcd(a, D); // from AlmostQuadraticInteger:
    //if (this.k.toBigInt() % this.qi.D == 0) {
    //TODO: ?
    //return this._toQuadraticInteger().primeFactor();
    //}

    var k = ngcd(a, b);

    if (JSBI.notEqual(k, JSBI.BigInt(1)) && JSBI.notEqual(k, JSBI.unaryMinus(JSBI.BigInt(1)))) {
      return maybeJSBI.notEqual(k, D) ? Expression.Integer.fromBigInt(k).primeFactor() : new QuadraticInteger(JSBI.BigInt(0), JSBI.BigInt(1), D);
    } //


    if (maybeJSBI.equal(g, D)) {
      //TODO: g != 1 - ?
      return new QuadraticInteger(JSBI.BigInt(0), JSBI.BigInt(1), D);
    } //var g = ngcd(a, b);


    var g = k; //!
    //while (g % 2 == 0) {
    //  g = g / 2;
    //}
    //!

    if (JSBI.notEqual(g, JSBI.BigInt(1))) {//TODO:
      //return new QuadraticInteger(primeFactor(g), 0, D);
      //return new QuadraticInteger(QuadraticInteger._factors(g).next().value, b - b, D);
    }

    var norm = this.norm(); //if (a == 0 || b == 0) {
    //return this;
    //}

    if (JSBI.equal(norm, JSBI.BigInt(1)) || JSBI.equal(norm, JSBI.unaryMinus(JSBI.BigInt(1)))) {
      // https://en.wikipedia.org/wiki/Quadratic_field#Orders_of_quadratic_number_fields_of_small_discriminant
      var unit = QuadraticInteger._fundamentalUnit(D);

      var uniti = unit.conjugate();
      var x = this;

      if (JSBI.lessThan(maybeJSBI.multiply(x.b, x.a), JSBI.BigInt(1))) {
        return JSBI.lessThan(x.a, JSBI.BigInt(0)) ? uniti.negate() : uniti;
      }

      return unit;
    }

    var v = this;

    for (var fs = QuadraticInteger._factors(abs(norm)), p = fs.next().value; p != null; p = fs.next().value) {
      //if (p * p <= norm || abs(norm) === p) {
      // ? https://www.johndcook.com/blog/2008/11/17/fast-way-to-test-whether-a-number-is-a-square/

      /*if (D === 17) {
        var t = Math.abs(norm);
        while (t % 2 === 0) {
          t /= 2;
        }
        p = t === 1 ? norm : primeFactor(t);
      }*/
      if (JSBI.equal(JSBI.remainder(D, JSBI.BigInt(4)), JSBI.BigInt(1)) && JSBI.equal(p, JSBI.BigInt(2))) {
        continue;
      }

      if (JSBI.equal(D, JSBI.BigInt(37)) && (JSBI.equal(p, JSBI.BigInt(7)) || JSBI.equal(p, JSBI.BigInt(14)) || JSBI.equal(p, JSBI.BigInt(3)) || JSBI.equal(p, JSBI.BigInt(11)))) {
        continue;
      } //?
      // http://oeis.org/wiki/Quadratic_integer_rings


      if (isPrime(p) && JSBI.notEqual(maybeJSBI.remainder(D, p), JSBI.BigInt(0)) && JSBI.notEqual(p, JSBI.BigInt(2)) && LegendreSymbol(maybeJSBI.toNumber(D), maybeJSBI.toNumber(p)) !== 1) {
        continue;
      } //?


      var i = quadraticIntegers(p, D, JSBI.BigInt(0)); //console.log(i + '');

      var x = v.truncatingDivide(i);

      if (x != null) {
        return this.equals(i) ? i : i.primeFactor();
      }

      var ic = i.conjugate();
      var x = v.truncatingDivide(ic);

      if (x != null) {
        return this.equals(ic) ? ic : ic.primeFactor();
      } // 1+9sqrt(2)
      //}

    } //console.log('!');


    return this; //throw new TypeError();
  };

  QuadraticInteger.prototype.toString = function () {
    var s = this.a.toString() + '+' + this.b.toString() + 'sqrt(' + this.D + ')';

    if (this.overTwo) {
      s = '(' + s + ')' + '/' + '2';
    }

    return s;
  };

  QuadraticInteger.prototype.isUnit = function () {
    var n = this.norm();
    return JSBI.equal(n, JSBI.BigInt(1)) || JSBI.equal(n, JSBI.unaryMinus(JSBI.BigInt(1)));
  };

  QuadraticInteger.prototype.equals = function (y) {
    var x = this;

    if (!(y instanceof QuadraticInteger)) {
      if (y.equals(Expression.ZERO)) {
        return JSBI.equal(x.a, JSBI.BigInt(0)) && JSBI.equal(x.b, JSBI.BigInt(0));
      }

      if (y.equals(Expression.ONE)) {
        return JSBI.equal(x.a, JSBI.BigInt(1)) && JSBI.equal(x.b, JSBI.BigInt(0));
      }

      throw new TypeError();
    }

    return maybeJSBI.equal(x.a, y.a) && maybeJSBI.equal(x.b, y.b) && maybeJSBI.equal(x.D, y.D) && maybeJSBI.equal(x.overTwo, y.overTwo);
  };

  QuadraticInteger.prototype.subtract = function (y) {
    var x = this;

    if (!maybeJSBI.equal(x.D, y.D)) {
      throw new TypeError();
    }

    var xa = x.a;
    var xb = x.b;
    var ya = y.a;
    var yb = y.b;

    if (maybeJSBI.notEqual(x.overTwo, y.overTwo)) {
      if (x.overTwo) {
        ya = JSBI.multiply(ya, JSBI.BigInt(2));
        yb = JSBI.multiply(yb, JSBI.BigInt(2));
      }

      if (y.overTwo) {
        xa = JSBI.multiply(xa, JSBI.BigInt(2));
        xb = JSBI.multiply(xb, JSBI.BigInt(2));
      }
    }

    return new QuadraticInteger(maybeJSBI.subtract(xa, ya), maybeJSBI.subtract(xb, yb), x.D, x.overTwo || y.overTwo);
  };

  QuadraticInteger.prototype.isDivisibleBy = function (y) {
    return this.truncatingDivide(y) != null;
  };

  QuadraticInteger.prototype.isDivisibleByInteger = function (x) {
    return x.truncatingDivide(this) != null;
  };

  QuadraticInteger.prototype.remainder = function (y) {
    if (!(y instanceof QuadraticInteger)) {
      if (y instanceof Expression.Multiplication && y.a instanceof Expression.Integer && y.b instanceof Expression.SquareRoot) {
        return this.remainder(new QuadraticInteger(Expression.ZERO.toBigInt(), y.a.toBigInt(), y.b.a.toBigInt()));
      }

      if (!(y instanceof Expression.Integer)) {
        throw new RangeError();
      }

      y = new QuadraticInteger(y.toBigInt(), Expression.ZERO.toBigInt(), this.D);
    }

    var x = this;

    if (!maybeJSBI.equal(x.D, y.D)) {
      throw new TypeError();
    }

    var n = x.multiply(y.conjugate());
    var d = y.norm();

    if (JSBI.equal(d, JSBI.BigInt(1)) || JSBI.equal(d, JSBI.unaryMinus(JSBI.BigInt(1)))) {
      // y.isUnit()
      return x.subtract(x);
    }

    var q1 = maybeJSBI.divide(maybeJSBI.subtract(n.a, maybeJSBI.remainder(n.a, d)), d);
    var q2 = maybeJSBI.divide(maybeJSBI.subtract(n.b, maybeJSBI.remainder(n.b, d)), d);

    if (JSBI.equal(q1, JSBI.BigInt(0)) && JSBI.equal(q2, JSBI.BigInt(0))) {
      //if (abs(x.norm()) >= abs(y.norm())) {
      //?
      if (maybeJSBI.greaterThan(x.a, y.a) && JSBI.greaterThan(y.a, JSBI.BigInt(0))) {
        return x.subtract(y.multiply(new QuadraticInteger(maybeJSBI.divide(maybeJSBI.subtract(x.a, maybeJSBI.remainder(x.a, y.a)), y.a), JSBI.BigInt(0), x.D)));
      }

      if (maybeJSBI.greaterThan(x.a, maybeJSBI.unaryMinus(y.a)) && JSBI.lessThan(y.a, JSBI.BigInt(0))) {
        return x.subtract(y.multiply(new QuadraticInteger(maybeJSBI.divide(maybeJSBI.subtract(x.a, maybeJSBI.remainder(x.a, maybeJSBI.unaryMinus(y.a))), maybeJSBI.unaryMinus(y.a)), JSBI.BigInt(0), x.D)));
      }

      if (JSBI.equal(y.b, JSBI.BigInt(0))) {
        return new QuadraticInteger(JSBI.BigInt(1), JSBI.BigInt(0), x.D); //?
      } //throw new RangeError("NotSupportedError");//TODO:!!!
      //}

    }

    var q = new QuadraticInteger(q1, q2, x.D);
    var r = x.subtract(y.multiply(q));
    return r;
  };

  QuadraticInteger.prototype.remainderInteger = function (x) {
    return new QuadraticInteger(x.toBigInt(), Expression.ZERO.toBigInt(), this.D).remainder(this);
  };

  QuadraticInteger.prototype.toExpression = function () {
    return Expression.Integer.fromBigInt(this.a).add(Expression.Integer.fromBigInt(this.b).multiply(Expression.Integer.fromNumber(this.D).squareRoot())).divide(this.overTwo ? Expression.TWO : Expression.ONE);
  };

  QuadraticInteger.prototype.abs = function () {
    if (JSBI.lessThanOrEqual(this.a, JSBI.BigInt(0)) && JSBI.lessThanOrEqual(this.b, JSBI.BigInt(0)) || JSBI.lessThan(this.a, JSBI.BigInt(0)) && JSBI.greaterThan(this.norm(), JSBI.BigInt(0)) || JSBI.lessThan(this.b, JSBI.BigInt(0)) && JSBI.lessThan(this.norm(), JSBI.BigInt(0))) {
      return this.negate();
    }

    return this;
  }; //TODO: merge with the QuadraticInteger.toQuadraticInteger


  QuadraticInteger.prototype.isValid = function () {
    if (true) {//return false;
    }

    if (this.D === 5) {//return true;//TODO:!!!
    }

    if (this.D === 37) {//TODO: ?
      //return true;
    }

    if (this.D === 6) {
      //TODO: ?
      return false;
    }

    if (this.D % 4 === 1) {
      //TODO: ?
      return false;
    }

    if ([2, 3, 5, 6, 7, 11, 13, 17, 19, 21, 29, 33, 37, 41, 57, 73].indexOf(this.D) === -1) {
      // https://oeis.org/A048981
      return false;
    }

    return true;
  };

  QuadraticInteger.prototype.isPositive = function () {
    var qq = this;
    return JSBI.greaterThan(qq.a, JSBI.BigInt(0)) && JSBI.greaterThan(qq.b, JSBI.BigInt(0)) || JSBI.greaterThan(qq.a, JSBI.BigInt(0)) && JSBI.greaterThan(qq.norm(), JSBI.BigInt(0)) || JSBI.greaterThan(qq.b, JSBI.BigInt(0)) && JSBI.lessThan(qq.norm(), JSBI.BigInt(0));
  };

  self.QuadraticInteger = QuadraticInteger; //new QuadraticInteger(-67, 15, 37).primeFactor()
  // new QuadraticInteger(1, 1, 2).remainder(new QuadraticInteger(1, 1, 2))
  // new QuadraticInteger(2, 2, 2).truncatingDivide(new QuadraticInteger(2, 2, 2))

  function toQuadraticInteger(e) {
    //if (e instanceof Expression.Complex) {//!
    //  return e;
    //}
    // qq.a * qq.a + qq.D * qq.b * qq.b < Number.MAX_SAFE_INTEGER
    if (e instanceof Expression.Addition && e.b instanceof Expression.Integer && e.a instanceof Expression.SquareRoot && e.a.a instanceof Expression.Integer) {
      return new QuadraticInteger(e.b.toBigInt(), Expression.ONE.toBigInt(), e.a.a.toBigInt());
    }

    if (e instanceof Expression.Addition && e.b instanceof Expression.Integer && e.a instanceof Expression.Multiplication && e.a.a instanceof Expression.Integer && e.a.b instanceof Expression.SquareRoot && e.a.b.a instanceof Expression.Integer) {
      return new QuadraticInteger(e.b.toBigInt(), e.a.a.toBigInt(), e.a.b.a.toBigInt());
    }

    if (e instanceof Expression.Division) {
      if (e.getDenominator().equals(Expression.TWO)) {
        var tmp = toQuadraticInteger(e.getNumerator());

        if (tmp != null) {
          return tmp.truncatingDivide(new QuadraticInteger(2, 0, tmp.D));
        }
      }
    }
  } //!


  QuadraticInteger.toQuadraticInteger = toQuadraticInteger;

  QuadraticInteger.gcd = function (x, y) {
    var a = x;
    var b = y;

    while (!b.equals(Expression.ZERO)) {
      var r = a.remainder(b);

      if (!maybeJSBI.lessThanOrEqual(abs(r.norm()), abs(b.norm()))) {
        throw new TypeError("norm");
      }

      a = b;
      b = r;
    }

    return a;
  };
  /*
  QuadraticInteger.prototype.compareTo = function (e) {
    if (e === Expression.ZERO) {
      var n = this.a * this.a - this.b * this.b * this.D;
      return this.a === 0 && this.b === 0 ? 0 : (this.a < 0 && this.b < 0 || this.a < 0 && n > 0 || this.b < 0 && n < 0 ? -1 : 1);
    }
    if (e === Expression.ONE) {
      return this.a === 1 && this.b === 0 ? 0 : 1;
    }
    throw new TypeError();
  };
  */

  /*
  // http://oeis.org/wiki/Quadratic_integer_rings#Quadratic_integer_ring_with_discriminant_2
  var expected = {
    "2": {
      "1": "",
      "2": "0+1sqrt(2), 0+1sqrt(2)",
      "3": "3+0sqrt(2)",
      "4": "0+1sqrt(2), 0+1sqrt(2), 0+1sqrt(2), 0+1sqrt(2)",
      "5": "5+0sqrt(2)",
      "6": "0+1sqrt(2), 0+1sqrt(2), 3+0sqrt(2)",
      "7": "3+1sqrt(2), 3+-1sqrt(2)",
      "8": "0+1sqrt(2), 0+1sqrt(2), 0+1sqrt(2), 0+1sqrt(2), 0+1sqrt(2), 0+1sqrt(2)",
      "9": "3+0sqrt(2), 3+0sqrt(2)",
      "10": "0+1sqrt(2), 0+1sqrt(2), 5+0sqrt(2)",
      "11": "11+0sqrt(2)",
      "12": "0+1sqrt(2), 0+1sqrt(2), 0+1sqrt(2), 0+1sqrt(2), 3+0sqrt(2)",
      "13": "13+0sqrt(2)",
      "14": "0+1sqrt(2), 0+1sqrt(2), 3+1sqrt(2), 3+-1sqrt(2)",
      "15": "3+0sqrt(2), 5+0sqrt(2)",
      "16": "0+1sqrt(2), 0+1sqrt(2), 0+1sqrt(2), 0+1sqrt(2), 0+1sqrt(2), 0+1sqrt(2), 0+1sqrt(2), 0+1sqrt(2)",
      "17": "5+2sqrt(2), 5+-2sqrt(2)",
      "18": "0+1sqrt(2), 0+1sqrt(2), 3+0sqrt(2), 3+0sqrt(2)",
      "19": "19+0sqrt(2)",
      "20": "0+1sqrt(2), 0+1sqrt(2), 0+1sqrt(2), 0+1sqrt(2), 5+0sqrt(2)"
    }
  };
  
  var allFactors = function* (qi) {
    while (!qi.isUnit()) {
      var pf = qi.primeFactor();
      yield pf.toString();
      qi = qi.truncatingDivide(pf);
    }
    if (!/^1\+0sqrt\(\d+\)$/.test(qi.toString())) {
      yield qi.toString();
    }
  };
  for (var iteratorD = [2, 3, 5, 6, 7, 11, 13, 17, 19, 21, 29, 33, 37, 41, 57, 73][globalThis.Symbol.iterator](), D = iteratorD.next().value; D != null; D = iteratorD.next().value) {
    expected[D] = expected[D] || {};
    if (D === 3) debugger;
    for (var i = 1; i <= 20; i += 1) {
      expected[D][i] = Array.from(allFactors(new QuadraticInteger(i, 0, D))).join(', ');
      //console.log(i, Array.from(allFactors(new QuadraticInteger(i, 0, D))));
    }
    console.log(D, JSON.stringify(expected[D], null, 2));
  }
  debugger;
  throw new Error();
  */
  //

  /*
  
      if (n === 2) {
        var q = isQuadraticInteger(x);
        //TODO: (q.D === 2 || q.D === 3 || q.D === 5 || q.D === 17)
  
        if (q != null && q.D === 2 && Math.abs(q.a * q.a - q.b * q.b * q.D) === Math.pow(Math.gcd(q.a, q.b), 2)) {
          var ff = Expression.ONE;
          if (q.a % q.D === 0) {
            q = {
              a: q.b,
              b: Math.floor(q.a / q.D),
              D: q.D
            };
            ff = new SquareRoot(Integer.fromNumber(q.D));
            x = x.divide(ff);
          }
          var n = q.a * q.a - q.b * q.b * q.D;
          if (q.a > 0 && q.b > 0 || q.a > 0 && n > 0 || q.b > 0 && n < 0) {
            var t = new QuadraticInteger(q.a, q.b, q.D);
            if (t.primeFactor().equals(t)) {
              return (new SquareRoot(x.multiply(ff)));
            }
            var k1 = new QuadraticInteger(1, 0, q.D);
            var k2 = new QuadraticInteger(1, 0, q.D);
            var i = t;
            var p = null;
            while (!i.equals(Expression.ONE)) {
              var d = i.primeFactor();
              if (p == null) {
                p = d;
              } else {
                if (p.equals(d)) {
                  k1 = k1.multiply(d);
                  p = null;
                } else {
                  k2 = k2.multiply(p);
                  p = d;
                }
              }
              i = i.truncatingDivide(d);
            }
            if (p != null) {
              k2 = k2.multiply(p);
            }
            return k1.toExpression().multiply(new Expression.SquareRoot(k2.toExpression().multiply(ff)));
          }
        }
      }
  */

  /*
  
  
  
  // +1, -1, +i, -i
  // a+bi
  
  // a === 0, i*(a+bi)
  // a < 0, -(a+bi)
  // b < 0, i*(a+bi)
  
  // a > 0, b > 0
  
  
  /*
    for (var a = 1; a * a <= n; a += 1) {
      for (var b = 0; b * b <= n - a * a; b += 1) {
        if (norm(a, b) > 1n && hasDivisor(r, i, a, b)) {
          return [a, b];
        }
        if (norm(a, -b) > 1n && hasDivisor(r, i, a, -b)) {
          return [a, -b];
        }
      }
    }
    return [r, i];
  */


  function isPrime(n) {
    return maybeJSBI.equal(primeFactor(n), n);
  }
  /*
  
  function primeFactor(n) {
    var i = 2;
    var s = 0;
    var r = Math.floor(Math.sqrt(n + 0.5));
    while (i <= r) {
      if (n % i === 0) {
        return i;
      }
      i += s === 2 ? 2 : s + 1;
      s += 1;
      if (s === 4) {
        s = 2;
      }
    }
    return n;
  }
  
  function norm(x) {
    return x instanceof Expression.Integer ? x.multiply(x).value : x.multiply(x.conjugate()).value;
  }
  
  function checkFactorization(i) {
    var results = [];
    var x = i;
    while (norm(x) > 1) {
      var p = x.primeFactor();
      results.push(p);
  
      //A Gaussian integer a + bi is a Gaussian prime if and only if either:
      //  one of a, b is zero and absolute value of the other is a prime number of the form 4n + 3 (with n a nonnegative integer), or
      //  both are nonzero and a**2 + b**2 is a prime number (which will not be of the form 4n + 3).
      var n = norm(p);
      console.assert(isPrime(n) || ((p instanceof Expression.Integer || p.real.equals(Expression.ZERO) || p.imaginary.equals(Expression.ZERO)) && Math.abs(p instanceof Expression.Integer ? p : p.real.add(p.imaginary).value) % 4 === 3), n, p.toString());
  
      x = x.divide(p);
      if (x instanceof Expression.Integer && norm(x) > 1) {
        x = new Expression.Complex(Expression.ZERO, x);
      }
    }
    console.log(i + '=' + results.map(function (x) { return '(' + x + ')'; }).join(''));
  }
  
  
  // 5-5i
  
  checkFactorization(new Complex(new Expression.Integer(3), new Expression.Integer(3)));
  
  checkFactorization(new Complex(new Expression.Integer(0), new Expression.Integer(2)));
  checkFactorization(new Complex(new Expression.Integer(0), new Expression.Integer(-2)));
  checkFactorization(new Complex(new Expression.Integer(5), new Expression.Integer(1)));
  
  var A = 11;
  for (var i = -A; i <= A; i += 1) {
    for (var j = -A; j <= A; j += 1) {
      if (j !== 0) {
        checkFactorization(new Complex(new Expression.Integer(i), new Expression.Integer(j)));
      }
    }
  }
  
  
  */

  /*
            if (i == null && isOnePlusSqrtOf2(y.a)) {
              i = y.a;
            }
            if (i == null) {
              throw new TypeError();
            }
            } else if (isOnePlusSqrtOf2(y.a)) {
              if (!p.equals(y.a)) {
                throw new TypeError();
              }
              degree += 1;
  
  */
  // http://oeis.org/wiki/Quadratic_integer_rings
  // https://oeis.org/A048981
  // https://en.wikipedia.org/wiki/Euclidean_domain#Norm-Euclidean_fields
  // https://en.wikipedia.org/wiki/Fundamental_unit_(number_theory)
  // https://en.wikipedia.org/wiki/Pell%27s_equation
  // https://en.wikipedia.org/wiki/Diophantine_equation
  // https://ru.wikipedia.org/wiki/Гауссовы_целые_числа#Определение
  // https://en.wikipedia.org/wiki/Gaussian_integer
  // https://en.wikipedia.org/wiki/Prime_element


  globalThis.QuadraticInteger = QuadraticInteger; // ExpressionParser.parse('((17^0.5+7)**3)**(1/3)') + ''
  // new QuadraticInteger(7, 1, 17).remainder(new QuadraticInteger(3, 1, 17))

  QuadraticInteger._checkFactorization = function checkFactorization(i) {
    if (typeof i === "string") {
      i = QuadraticInteger.toQuadraticInteger(RPN(i));
    }

    var results = [];
    var x = i;

    while (Math.abs(maybeJSBI.toNumber(x.norm())) > 1) {
      //debugger;
      var p = x.primeFactor();
      results.push(p);
      x = x.truncatingDivide(p);
    }

    if (x.a.toString() !== '1' || x.b.toString() !== '0') {
      results.unshift(x);
    }

    console.log(i + '=' + results.map(function (x) {
      return '(' + x.toString() + ')';
    }).join(''));
  };
})();
(function () {
"use strict";
/*jslint plusplus: true, vars: true, indent: 2, white: true */

/*global i18n, Condition, ExpressionParser, Polynomial, Expression, Matrix, NonSimplifiedExpression*/
var RPN = ExpressionParser.parse; //TODO: fix

RPN.Context = ExpressionParser.Context;

var polynomialToExpression3 = function (matrix, row, variableSymbols) {
  var pivotColumn = 0;

  while (pivotColumn < matrix.cols() - 1 && matrix.e(row, pivotColumn).equals(Expression.ZERO)) {
    pivotColumn += 1;
  }

  if (pivotColumn === matrix.cols() - 1) {
    throw new TypeError();
  }

  var result = undefined;

  for (var i = pivotColumn; i < matrix.cols() - 1; i += 1) {
    var c = i === pivotColumn ? matrix.e(row, matrix.cols() - 1) : matrix.e(row, i).negate();
    var v = i === pivotColumn ? undefined : variableSymbols[i];

    if (!c.equals(Expression.ZERO)) {
      var current = v == undefined ? c : c.equals(Expression.ONE) ? v : new Expression.Multiplication(c, v);
      result = result == undefined ? current : new Expression.Addition(result, current);
    }
  }

  return result == undefined ? Expression.ZERO : result;
};

RPN.toMathML = function (input, printOptions) {
  return ExpressionParser.parse(input, new ExpressionParser.Context()).toMathML(printOptions);
}; //Note: matrixTableState.inputValues were filled by `getInputValue`


RPN.getElementsArray = function (matrixTableState) {
  var mode = matrixTableState.mode;
  var type = matrixTableState.type;
  var textareaValue = matrixTableState.textareaValue;
  var inputValues = matrixTableState.inputValues;

  if (mode !== "cells") {
    //?
    //!!!
    if (type === "system") {
      // to support custom input in SLE: 3x+y-2z=2; 2x+y-1=3; ...
      if (/\=/.exec(textareaValue) != undefined) {
        //?
        try {
          var tmp = getAugmentedSystemMatrix(textareaValue);

          if (tmp != undefined) {
            return tmp;
          }
        } catch (error) {
          console.log(error);
        }
      }
    } //!!!


    var resultRows = Matrix.split(textareaValue);
    return {
      elements: resultRows,
      variableNames: undefined
    }; // the user, probably, does not expecte varible names, and matrixTableState.variableNames contains less number of variables
  }

  return {
    elements: inputValues,
    variableNames: matrixTableState.variableNames
  };
};

var getSymbols = function (e) {
  if (e instanceof Expression.Symbol) {
    return [e];
  }

  if (e instanceof Expression.Integer) {
    return [];
  }

  if (e instanceof Expression.Complex) {
    return [];
  }

  if (e instanceof Expression.BinaryOperation) {
    var sa = getSymbols(e.a);
    var sb = getSymbols(e.b);
    return sa != null && sb != null ? sa.concat(sb) : null;
  }

  if (e instanceof Expression.Function) {
    return getSymbols(e.a);
  }

  return null;
};

var getAugmentedSystemMatrix = function (s) {
  //!2018-07-16
  s = s.replace(/[;\r]|,(?!\d)/g, "\n"); //!

  var lines = s.split("\n");
  var k = -1;
  var rows = [];
  var frees = [];
  var variableToColumnNumberMap = {}; // string -> number

  var columnNumberToVariableMap = []; // number -> string

  var free = undefined;
  var row = undefined;

  var onVariable = function (coefficient, variable) {
    if (variable === "") {
      free = free.add(coefficient);
    } else {
      var columnIndex = variableToColumnNumberMap[variable];

      if (columnIndex == undefined) {
        columnIndex = columnNumberToVariableMap.length;
        variableToColumnNumberMap[variable] = columnIndex;
        columnNumberToVariableMap.push(variable);
      }

      while (row.length < columnIndex + 1) {
        row.push(Expression.ZERO);
      }

      row[columnIndex] = row[columnIndex].add(coefficient);
    }
  };

  var cvLists = new Array(lines.length);
  RPN.p = 0; //!

  while (++k < lines.length) {
    cvLists[k] = undefined;
    var line = lines[k];
    var x = line.split("=");

    if (x.length === 2) {
      //TODO: fix
      var leftString = x[0];
      var rightString = x[1];
      var left = ExpressionParser.parse(leftString);
      RPN.p += leftString.length;
      RPN.p += "=".length;
      var right = ExpressionParser.parse(rightString);
      RPN.p += rightString.length;
      RPN.p += "\n".length;
      var y = left.subtract(right).getNumerator();
      cvLists[k] = Expression.collectLinearEquationVariables(y);
    } else {
      RPN.p += line.length + "\n".length;

      if (line.replace(/^\s+|\s+$/g, "") !== "") {
        // to skip empty lines
        return undefined;
      }
    }
  } // second pass:


  var nonVariableSymbols = {};

  for (var i = 0; i < cvLists.length; i += 1) {
    if (cvLists[i] != undefined) {
      var list = cvLists[i];

      for (var j = 0; j < list.length; j += 1) {
        var symbols = getSymbols(list[j].c);

        if (symbols == null) {
          // `getSymbols` does not support this expression
          return undefined;
        }

        for (var k = 0; k < symbols.length; k += 1) {
          nonVariableSymbols[symbols[k]] = true;
        }
      }
    }
  }

  for (var i = 0; i < cvLists.length; i += 1) {
    if (cvLists[i] != undefined) {
      var list = cvLists[i];

      for (var j = 0; j < list.length; j += 1) {
        if (nonVariableSymbols[list[j].v] === true) {
          list[j] = {
            c: list[j].c.multiply(new Expression.Symbol(list[j].v)),
            v: ""
          };
        }
      }
    }
  }

  for (var i = 0; i < cvLists.length; i += 1) {
    if (cvLists[i] != undefined) {
      row = [];
      free = Expression.ZERO;
      var list = cvLists[i];

      for (var j = 0; j < list.length; j += 1) {
        onVariable(list[j].c, list[j].v);
      }

      frees.push(free);
      rows.push(row);
    }
  }

  var a = -1;

  while (++a < rows.length) {
    row = rows[a];

    while (row.length < columnNumberToVariableMap.length) {
      row.push(Expression.ZERO);
    }

    row.push(frees[a].negate());
  }

  var b = -1;

  while (++b < rows.length) {
    row = rows[b];
    var c = -1;

    while (++c < row.length) {
      row[c] = row[c].toString(); //!slow?
    }
  } //!TODO: fix: reverse variables and coefficients, as Expression.collectLinearEquationVariables gives wrong order


  b = -1;

  while (++b < rows.length) {
    row = rows[b];
    var f = -1;
    var d = row.length - 1; // skipping free

    while (++f < --d) {
      var tmp = row[f];
      row[f] = row[d];
      row[d] = tmp;
    }
  }

  var newColumnNumberToVariableMap = []; // number -> Expression

  b = -1;

  while (++b < columnNumberToVariableMap.length) {
    newColumnNumberToVariableMap.push(columnNumberToVariableMap[columnNumberToVariableMap.length - 1 - b]);
  }

  columnNumberToVariableMap = newColumnNumberToVariableMap; //!

  return {
    elements: rows,
    variableNames: columnNumberToVariableMap
  };
};

Matrix.toMatrix = function (array) {
  var context = new ExpressionParser.Context();
  return Matrix.padRows(array, function (e) {
    return ExpressionParser.parse(e, context);
  });
}; // ---------------------------------------i18n.js-----------------------------------------
// see https://www.w3.org/TR/2006/NOTE-arabic-math-20060131/#Persian
// and https://en.wikipedia.org/wiki/Modern_Arabic_mathematical_notation#Mathematical_letters
// https://ru.wikipedia.org/wiki/Википедия:Формулы#:~:text=в%20русской%20традиции%20многие%20тригонометрические%20и%20гиперболические%20функции%20обозначаются%20иначе
// i18n.rankDenotation
// i18n.sinDenotation
// i18n.tanDenotation
// TODO: denotations on the main page in information
// 'ar-u-nu-arab' === arz (as on Wikipedia) - ?


var denotationsByOperation = {
  rank: {
    bg: "ранг",
    de: "rang",
    en: "rank",
    es: "rango",
    fr: "rg",
    gl: "rango",
    it: "rango",
    nl: "rang",
    pt: "posto",
    tr: "rank"
  },
  transpose: {
    es: "traspuesta"
  },
  determinant: {
    pt: "determinante"
  },
  sin: {
    'ar-u-nu-arab': "حا‎‎",
    es: "sen"
  },
  cos: {
    'ar-u-nu-arab': "حتا‎‎‎"
  },
  tan: {
    'ar-u-nu-arab': "طا‎",
    ru: "tg",
    fr: "tg"
  },
  cot: {
    'ar-u-nu-arab': "طتا‎‎‎‎",
    ru: "ctg"
  },
  sinh: {
    'ar-u-nu-arab': "حاز",
    es: "senh",
    pt: "senh",
    ru: 'sh'
  },
  cosh: {
    'ar-u-nu-arab': "حتاز‎",
    ru: 'ch'
  },
  tanh: {
    'ar-u-nu-arab': "طاز‎",
    ru: 'th'
  },
  coth: {
    'ar-u-nu-arab': 'طتاز‎',
    ru: 'cth'
  },
  arctan: {
    ru: 'arctg'
  },
  arccot: {
    ru: 'arcctg'
  },
  arsinh: {
    ru: 'arsh'
  },
  arcosh: {
    ru: 'arch'
  },
  artanh: {
    ru: 'arth'
  },
  arcoth: {
    ru: 'arcth'
  }
};
ExpressionParser.addDenotations(denotationsByOperation);
var lang = document.documentElement.lang;

for (var name in denotationsByOperation) {
  if (Object.prototype.hasOwnProperty.call(denotationsByOperation, name)) {
    Expression.denotations[name] = denotationsByOperation[name][lang];
  }
}

Expression.denotations["log"] = "ln"; //!
// --------------------------------------------- end ----------------------------------------------

var getResultAndHTML = function (expression, variableNames, result, printOptions) {
  // TODO: fix
  var resultHTML = "";

  if (result instanceof Expression.NoAnswerExpression) {
    var name = result.name;
    var matrix = result.a.matrix;
    var second = result.second; //!
    //result = undefined;

    if (name === "solve") {
      resultHTML = ""; //TODO:
    } else {
      resultHTML = Expression.Details.getCallback(name)(printOptions, matrix, second == undefined ? variableNames : second);
    }
  } else if (result instanceof Expression.Equality) {
    //TODO: counter
    resultHTML = "";
    resultHTML += "<div>" + "<math>" + expression.toMathML(printOptions) + "</math>" + "</div>";
    resultHTML += "<div>" + "<math>" + result.toMathML(printOptions) + "</math>" + "</div>";
  } else {
    resultHTML = "<math>" + expression.toMathML(printOptions) + "<mo>=</mo>" + result.toMathML(printOptions) + "</math>";
  }

  return {
    result: result,
    html: resultHTML
  };
}; //? bestMethodsLimit - with highest priority


var createDetailsSummary = function (idPrefix, details, bestMethodsLimit) {
  bestMethodsLimit = bestMethodsLimit == undefined ? 1 : bestMethodsLimit;
  var s = "";

  for (var j = 0; j < details.length; j += 1) {
    //TODO: FIX
    //var rows = details[j].matrix.split("},").length;
    var countRows = function (s) {
      var state = 0;
      var result = 1;

      for (var i = 0; i < s.length; i += 1) {
        var c = s.charCodeAt(i);

        if (c === ",".charCodeAt(0)) {
          if (state === 1) {
            result += 1;
          }
        } else if (c === "{".charCodeAt(0)) {
          state += 1;
        } else if (c === "}".charCodeAt(0)) {
          state -= 1;
        }
      }

      return result;
    };

    var rows = countRows(details[j].matrix); //TODO: what if some `type` was provided?

    var type = details[j].type;
    var items = [];
    var edetails = Expression.Details.getAll(type, rows);

    for (var i = 0; i < edetails.length; i += 1) {
      var x = edetails[i];
      var jsonObject = {
        type: x.type,
        matrix: details[j].matrix,
        second: details[j].second
      }; // It is needed to use an individual prefix to have unique ids (consider if Expression.idCounter was reset after reload)

      var detailsIdPrefix = idPrefix + '-' + 'd' + i; //TODO: Tree View - ?

      var item = "" + "<details data-id-prefix=\"" + detailsIdPrefix + "\" " + "data-details=\"" + Expression.escapeHTML(JSON.stringify(jsonObject)) + "\"" + ">" + "<summary>" + i18n.misc.summaryLabel + (x.i18n != undefined ? " (" + x.i18n() + ")" : "") + "</summary>" + ('activeElement' in document ? "<div class=\"indented\"></div>" : "<a class=\"indented\"></a>") + "</details>";
      items.push(item);
    }

    var groupId = idPrefix + "-" + Expression.id();

    if (items.length > bestMethodsLimit + 1) {
      s += items.slice(0, bestMethodsLimit).join("");
      s += "<div id=\"" + groupId + "\" role=\"group\" hidden>";
      s += items.slice(bestMethodsLimit).join("");
      s += "</div>";
      s += "<button type=\"button\" class=\"more-button\" aria-expanded=\"false\" aria-controls=\"" + groupId + "\">&hellip;</button>";
    } else {
      s += items.join("");
    }
  }

  return s;
};

Expression.Minor = function (matrix, i, j) {
  Expression.Determinant.call(this, matrix);
  this.i = i;
  this.j = j;
};

Expression.Minor.prototype = Object.create(Expression.Determinant.prototype);

Expression.Minor.prototype.toMathML = function (options) {
  options = Object.assign({}, options, {
    horizontalStrike: this.i,
    verticalStrike: this.j,
    useBraces: ["|", "|"]
  }); //TODO: fix

  return this.a.toMathML(options);
};

Expression.p = function (s, args, printOptions) {
  if (typeof s === "number") {
    return Expression.Integer.fromNumber(s).toMathML(printOptions);
  }

  if (args == null && printOptions != null || args != null && printOptions == null) {
    throw new TypeError();
  }

  args = args || null;
  printOptions = printOptions || null;
  var result = "";
  var parts = s.split("=");

  for (var i = 0; i < parts.length; i += 1) {
    var e = ExpressionParser.parse(parts[i], new ExpressionParser.Context(function (id) {
      return args != undefined && args[id] != undefined ? args[id] : undefined;
    }));

    if (i !== 0) {
      result += "<mo>" + (e.isExact() ? "=" : "&asymp;") + "</mo>";
    }

    result += e.toMathML(printOptions);
  }

  return result;
};

Expression.Details = function () {}; // TODO: optimize


Expression.Details._details = [];
Expression.Details.details = null; // https://stackoverflow.com/a/53357343/839199

var lowerBound = function (array, compare) {
  var start = 0;
  var end = array.length;

  while (start < end) {
    var middle = start + Math.floor((end - start) / 2);
    var value = array[middle];

    if (compare(value) <= 0) {
      end = middle;
    } else {
      start = middle + 1;
    }
  }

  return start;
};

var sortDetails = function () {
  if (Expression.Details.details == null) {
    Expression.Details._details.sort(function (a, b) {
      return a.type < b.type ? -1 : +1;
    });

    Expression.Details.details = Expression.Details._details;
  }
};

Expression.Details.getCallback = function (type) {
  sortDetails();
  var i = lowerBound(Expression.Details.details, function (a) {
    return type <= a.type ? -1 : +1;
  });

  if (i < Expression.Details.details.length) {
    if (Expression.Details.details[i].type === type) {
      return Expression.Details.details[i].callback;
    }
  }

  return undefined;
};

Expression.Details.add = function (data) {
  var x = {
    type: data.type,
    i18n: data.i18n,
    minRows: data.minRows || 1,
    maxRows: data.maxRows || 1 / 0,
    priority: data.priority || 0,
    // the number comparision should work
    callback: data.callback
  };

  Expression.Details._details.push(x);

  Expression.Details.details = null; //?

  if (x.type !== "multiply" && x.type !== "add" && x.type !== "pow" && x.type !== "special-determinant") {
    ExpressionParser.addOperation(x.type, x.type === "expand-along-column" || x.type === "expand-along-row" || x.type === "obtain-zeros-in-column" || x.type === "obtain-zeros-in-row" || x.type === "polynomial-multiply" ? 2 : 1);
  }
};

Expression.Details.getAll = function (typePrefix, rows) {
  var result = [];
  sortDetails();

  for (var i = lowerBound(Expression.Details.details, function (a) {
    return typePrefix <= a.type ? -1 : +1;
  }); i < Expression.Details.details.length && Expression.Details.details[i].type.indexOf(typePrefix) === 0; i += 1) {
    var x = Expression.Details.details[i];

    if (x.type.indexOf(typePrefix) === 0) {
      if (rows >= x.minRows && rows <= x.maxRows) {
        if (rows <= 4 || rows >= 10) {
          // limit maxRows to reduce "de tricherie aux examens" and un-hiding them for large matrices (>=10x10) it seems unlikely that such examples will be on exams
          result.push(x);
        }
      }
    }
  }

  result.sort(function (a, b) {
    return b.priority - a.priority;
  });
  return result;
};

Expression.Details.add({
  type: "steps-to-diagonalize",
  minRows: 2,
  callback: function (printOptions, matrix) {
    // TODO: move to details
    //TODO: details of determinant calculation, details of roots finding
    var html = "";
    html += "<ol>";
    var tmp = Expression.getEigenvaluesWithSteps(printOptions, matrix);
    var eigenvalues = tmp.eigenvalues;
    var multiplicities = tmp.multiplicities;
    html += "<li>";
    html += tmp.html;
    html += "</li>"; // https://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors#Algebraic_multiplicity

    if (Expression.sum(multiplicities) !== matrix.cols()) {
      //TODO: show polynomial in html anyway
      //TODO: fix message
      html += "</ol>"; //TODO: fix
      //TODO: fix

      return html;
    }

    var tmp2 = Expression.getEigenvectorsWithSteps(printOptions, matrix, eigenvalues);
    html += "<li>";
    html += tmp2.html;
    html += "</li>";
    var eigenvectors = tmp2.eigenvectors; //  html += "</ol>";

    if (eigenvectors.length !== matrix.cols()) {
      //TODO: show polynomial in html anyway
      html += "</ol>"; //TODO: fix
      //TODO: fix

      return html;
    }

    var results = Expression.diagonalize(matrix, eigenvalues, multiplicities, eigenvectors);
    var T = results.T;
    var L = results.L;
    var T_INVERSED = results.T_INVERSED;
    html += "<li>";
    html += "<ul>";
    html += "<li>";
    var eigenvaluesLinks = [];

    for (var i = 0; i < eigenvalues.length; i += 1) {
      var multiplicity = multiplicities[i];

      for (var j = 0; j < multiplicity; j += 1) {
        eigenvaluesLinks.push("<a href=\"#" + printOptions.idPrefix + "-eigenvalue-" + (i + 1) + "\">" + "<math>" + Expression.p("λ_" + (i + 1)) + "</math>" + "</a>");
      }
    }

    var listFormat = getListFormat();
    html += "<div>" + i18n.diagonalization.theDiagonalMatrixTheDiagonalEntriesAreTheEigenvalues.replace(/\$\{eigenvaluesLinks\}/g, listFormat.format(eigenvaluesLinks)) + "</div>";
    html += "<math>" + Expression.p("D=M", {
      M: new Expression.Matrix(L)
    }, printOptions) + "</math>";
    html += "</li>";
    html += "<li>";
    var eigenvectorsLinks = [];

    for (var i = 0; i < eigenvectors.length; i += 1) {
      eigenvectorsLinks.push("<a href=\"#" + printOptions.idPrefix + "-eigenvector-" + (i + 1) + "\">" + "<math>" + Expression.p("v_" + (i + 1)) + "</math>" + "</a>");
    }

    html += "<div>" + i18n.diagonalization.theMatrixWithTheEigenvectorsAsItsColumns.replace(/\$\{eigenvectorsLinks\}/g, listFormat.format(eigenvectorsLinks)) + "</div>";
    html += "<math>" + Expression.p("P=M", {
      M: new Expression.Matrix(T)
    }, printOptions) + "</math>";
    html += "</li>";
    html += "<li>";
    html += "<math>" + Expression.p("P^-1=M", {
      M: new Expression.Matrix(T_INVERSED)
    }, printOptions) + "</math>";
    html += createDetailsSummary(printOptions.idPrefix, [{
      type: T.getDeterminantEventType("inverse").type,
      matrix: T.toString(),
      second: undefined
    }]);
    html += "</li>";
    html += "<li>";
    html += "<math>" + Expression.p("A=P*D*P^-1") + "</math>";
    html += " ";
    html += i18n.matrixDiagonalizationLink;
    html += "</li>";
    html += "</ul>";
    html += "</li>";
    html += "</ol>";
    return html;
  }
});
Expression.Details.add({
  type: "diagonalize",
  minRows: 2,
  callback: function (printOptions, matrix) {
    var tmp = Expression.getEigenvalues(matrix);
    var eigenvalues = tmp.eigenvalues;
    var multiplicities = tmp.multiplicities; //TODO: fix

    var detailsHTML = createDetailsSummary(printOptions.idPrefix, [{
      type: 'steps-to-diagonalize',
      matrix: matrix.toString(),
      second: undefined
    }]);

    if (Expression.sum(multiplicities) !== matrix.cols()) {
      return "<div>" + i18n.diagonalization.notEnoughRationalEigenvalues + "</div>" + detailsHTML;
    }

    var tmp2 = Expression.getEigenvectors(matrix, eigenvalues);
    var eigenvectors = tmp2.eigenvectors;

    if (eigenvectors.length !== matrix.cols()) {
      // The matrix is not diagonalizable, because it does not have {n} linearly independent eigenvectors.
      var message = i18n.diagonalization.notDiagonalizable.replace(/\$\{n\}/g, matrix.cols()); //!2019-04-18

      message += " " + "<small>" + i18n.JordanDecomposition.tryToFindJordanNormalForm.replace(/\*([^\*]+)\*/g, '<a href="#Jordan-decomposition(' + matrix.toString() + ')">$1</a>') + "</small>"; //!

      return "<div>" + message + "</div>" + detailsHTML;
    }

    var results = Expression.diagonalize(matrix, eigenvalues, multiplicities, eigenvectors); //var detailsHTML = "<details open=\"open\"><summary>" + i18n.misc.summaryLabel + "</summary><div class=\"indented\">" + html + "</div></details>";

    var resultHTML = "<math>" + new Expression.Matrix(matrix).toMathML(printOptions) + "<mo>" + (results.L.isExact() ? "=" : "&asymp;") + "</mo>" + "<mrow>" + new Expression.Matrix(results.T).toMathML(printOptions) + "<mo>&sdot;</mo>" + new Expression.Matrix(results.L).toMathML(printOptions) + "<mo>&sdot;</mo>" + new Expression.Matrix(results.T_INVERSED).toMathML(printOptions) + "</mrow>" + "</math>"; //result = results.T;

    return resultHTML + detailsHTML;
  }
});

function getListFormat() {
  var listFormat = typeof Intl !== 'undefined' && Intl.ListFormat != null ? new Intl.ListFormat([]) : {
    format: function (array) {
      return array.join(', ');
    }
  };
  return listFormat;
} //!2018-10-03


Expression.Details.add({
  type: "Jordan-decomposition",
  minRows: 2,
  //i18n: function () {
  //  return i18n.vectors.JordanDecomposition;//use cases -?
  //},
  callback: function (printOptions, matrix) {
    var tmp = Expression.getEigenvaluesWithSteps(printOptions, matrix);
    var eigenvalues = tmp.eigenvalues;
    var multiplicities = tmp.multiplicities;

    if (Expression.sum(multiplicities) !== matrix.cols()) {
      //TODO: allow complex roots
      //TODO: show polynomial in html anyway
      //TODO: fix message
      var html = undefined; //!

      html = tmp.html;
      var detailsHTML = "<details open=\"open\"><summary>" + i18n.misc.summaryLabel + "</summary><div class=\"indented\">" + html + "</div></details>";
      return "<div>" + i18n.diagonalization.notEnoughRationalEigenvalues + "</div>" + detailsHTML;
    } //var results = Expression.getFormaDeJordan(matrix, eigenvalues, multiplicities);
    //TODO: solution steps
    //TODO: merge with `Expression.getFormaDeJordan`
    //TODO: i18n
    //TODO: hide <details>, compute on demand
    //TODO: better details (links to vectors, subdetails for solution of systems)


    function getSolutionSet(matrix) {
      var fullMatrix = matrix.augment(Matrix.Zero(matrix.cols(), 1));
      var result = fullMatrix.toRowEchelon(Matrix.GaussMontante, "solving", undefined);
      var tmp = Matrix.solveByGaussNext(result.matrix);
      var currentEigenvectors = Matrix.getSolutionSet(tmp).basisVectors;
      return currentEigenvectors; //?
    }

    function matrixFromBlocks(blocks) {
      var start = 0;
      var J = Matrix.Zero(n, n);

      for (var i = 0; i < blocks.length; i += 1) {
        var b = blocks[i];
        J = J.map(function (e, i, j) {
          if (i >= start && i < start + b.size) {
            return i === j ? b.eigenvalue : i !== start + b.size - 1 && j === i + 1 ? Expression.ONE : Expression.ZERO;
          }

          return e;
        });
        start += b.size;
      }

      return J;
    }

    function isSolution(coefficientMatrix, vector) {
      var f = coefficientMatrix.multiply(vector);
      return f.eql(Matrix.Zero(f.rows(), 1));
    }

    function isLinearlyIndependentSet(basis, vectors) {
      // https://math.stackexchange.com/questions/412563/determine-if-vectors-are-linearly-independent
      return Matrix.fromVectors(basis.concat(vectors)).rank() === basis.length + vectors.length;
    }

    var containerId = printOptions.idPrefix + "-" + Expression.id();
    var links = [];
    var basis = [];
    var blocks = [];
    var A = matrix;
    var n = A.cols();
    var html = '';
    var listFormat = getListFormat();
    html += '<h3>' + i18n.JordanDecomposition.findAMatrixInJordanNormalFormSimilarToOriginal + ' ' + i18n.JordanDecompositionLink + '</h3>';
    html += '<ol>';
    html += '<li>';
    html += '<h4>' + i18n.JordanDecomposition.solveTheCharacteristicEquationForEigenvaluesAndTheirAlgebraicMultiplicities + '</h4>';
    html += tmp.html;
    html += '</li>';
    html += '<li>';
    html += '<h4>' + i18n.JordanDecomposition.findLinearlyIndependentGeneralizedEigenvectorsForEveryEigenvalue + '</h4>';
    html += '<ol>';

    for (var i = 0; i < eigenvalues.length; i += 1) {
      html += '<li>';
      var basisCorrespondingToTheEigenvalue = [];
      var eigenvalue = eigenvalues[i];
      var algebraicMultiplicity = multiplicities[i];
      var B = A.subtract(Matrix.I(n).scale(eigenvalue));
      html += '<h5>';
      html += i18n.JordanDecomposition.eigenvalue + ' ' + '<math>' + Expression.p('λ_' + (i + 1) + '=v', {
        v: eigenvalue
      }, printOptions) + '</math>' + ', ' + i18n.JordanDecomposition.algebraicMultiplicity + ' ' + '<math>' + Expression.p('μ_' + (i + 1) + '=' + algebraicMultiplicity) + '</math>';
      html += '</h5>';
      html += '<p>' + i18n.JordanDecomposition.determineTheMaximalRankOfGeneralizedEigenvectors + '</p>';
      var m = 0;
      html += '<ul>';

      do {
        m += 1;
        html += '<li>';
        var rank = B.pow(m).rank();
        html += '<math>' + Expression.p('rank(A-l*I)**' + m + '=' + rank, {
          A: new Expression.Matrix(matrix),
          l: eigenvalue
        }, printOptions) + '</math>';
        html += '</li>';
      } while (B.pow(m).rank() > n - algebraicMultiplicity);

      html += '</ul>';
      m += 1;
      html += '<p>' + i18n.JordanDecomposition.determineEachJordanChain + '</p>';
      html += '<ol>';

      while (--m >= 1) {
        html += '<li>';
        html += i18n.JordanDecomposition.findSolutionsOfX.replace(/\$\{X\}/g, '<math>' + Expression.p('(A-l*I)**' + m + '*X=0', {
          A: new Expression.Matrix(matrix),
          l: eigenvalue
        }, printOptions) + '</math>');
        var solutionSet = getSolutionSet(B.pow(m));
        html += '<div>';
        html += i18n.JordanDecomposition.aBasisForTheSolutionSet + ' ';
        html += '<math>';
        html += '<mrow>';
        html += '<mo stretchy="false">{</mo>';
        html += solutionSet.length !== 1 ? '<mrow>' : '';

        for (var j = 0; j < solutionSet.length; j += 1) {
          var solution = solutionSet[j];

          if (j !== 0) {
            html += '<mo>,</mo>';
          }

          html += new Expression.Matrix(solution).toMathML(printOptions);
        }

        html += solutionSet.length !== 1 ? '</mrow>' : '';
        html += '<mo stretchy="false">}</mo>';
        html += '</mrow>';
        html += '</math>';
        html += '</div>';
        html += '<ol>';

        for (var j = 0; j < solutionSet.length; j += 1) {
          var solution = solutionSet[j];
          html += '<li>';
          html += '<h6>';
          html += '<math>' + Expression.p('x_' + (j + 1) + '=v', {
            v: new Expression.Matrix(solution)
          }, printOptions) + '</math>';
          html += '</h6>';

          if (!isSolution(B.pow(m - 1), solution)) {
            //TODO: "link" to m/"highlight" of m
            html += '<p>' + '<math>' + Expression.p('(A-l*I)**(' + m + '-1)*X', {
              A: new Expression.Matrix(matrix),
              l: eigenvalue
            }, printOptions) + '<mo>&ne;</mo>' + Expression.p(0) + '</math>' + ' &rarr; ' + i18n.JordanDecomposition.itIsAGeneralizedEigenvector + '</p>';
            var chain = [];
            chain.push(solution);
            html += '<p>' + i18n.JordanDecomposition.generateAJordanChainForThisGeneralizedEigenvector + '</p>';
            var chainHtml = '';
            chainHtml += '<ol>';
            chainHtml += '<li>';
            chainHtml += '<math>' + Expression.p('v_1=S', {
              S: new Expression.Matrix(solution)
            }, printOptions) + '</math>';
            chainHtml += '</li>';
            var s = solution;

            for (var k = 1; k < m; k += 1) {
              var previous = s;
              s = B.multiply(s).col(0);
              chain.push(s);
              chainHtml += '<li>';
              chainHtml += '<math>' + Expression.p('v_' + (k + 1) + '=(A-l*I)*S=X', {
                A: new Expression.Matrix(matrix),
                l: eigenvalue,
                S: new Expression.Matrix(previous),
                X: new Expression.Matrix(s)
              }, printOptions) + '</math>';
              chainHtml += '</li>';
            }

            chainHtml += '</ol>';
            chain.reverse();

            if (isLinearlyIndependentSet(basisCorrespondingToTheEigenvalue, chain)) {
              var id = containerId + '-' + (blocks.length + 1);
              html += '<table role="presentation" class="anchor-table anchor" id="' + id + '">';
              html += '<tr>';
              html += '<td>';
              html += chainHtml;
              html += '</td>';
              html += '<td>';
              html += '(' + localeString(blocks.length + 1) + ')';
              html += '</td>';
              html += '</tr>';
              html += '</table>';
              links.push('<a href="#' + id + '">(' + localeString(blocks.length + 1) + ')</a>');
              basis = basis.concat(chain);
              basisCorrespondingToTheEigenvalue = basisCorrespondingToTheEigenvalue.concat(chain);
              blocks.push({
                size: m,
                eigenvalue: eigenvalue
              });
            } else {
              html += chainHtml;
            }
          } else {
            //TODO: ? identityMatrixDenotation
            //TODO: 1*I - do not use invisible times here (?)
            html += '<p>' + '<math>' + Expression.p('(A-l*I)**(' + m + '-1)*X=0', {
              A: new Expression.Matrix(matrix),
              l: eigenvalue
            }, printOptions) + '</math>' + ' &rarr; ' + i18n.JordanDecomposition.itIsNotAGeneralizedEigenvector + '</p>';
          }

          html += '</li>';
        }

        html += '</ol>';
        html += '</li>';
      }

      html += '</ol>';
      html += '<p>' + i18n.JordanDecomposition.theJordanChainsMakeBasis.replace(/\$\{links\}/g, listFormat.format(links.slice(-basisCorrespondingToTheEigenvalue.length))) + '</p>';
      html += '</li>';
    }

    html += '</ol>';
    html += '</li>';
    html += '<li>';
    var J = matrixFromBlocks(blocks);
    var P = Matrix.fromVectors(basis);
    var P_INVERSED = P.isExact() ? P.inverse() : Expression._getInverse(A, eigenvalues, multiplicities, P);
    html += '<p>' + i18n.JordanDecomposition.generalizedModalMatrix.replace(/\$\{links\}/g, listFormat.format(links)) + '</p>';
    html += '<math>' + Expression.p('M=S', {
      S: new Expression.Matrix(P)
    }, printOptions) + '</math>';
    html += '<p>' + i18n.JordanDecomposition.JordanMatrix + '</p>';
    html += '<math>' + Expression.p('J=S', {
      S: new Expression.Matrix(J)
    }, printOptions) + '</math>';
    html += '</li>';
    html += '</ol>'; //TODO: solution steps
    //var html = tmp.html;
    //html += "<div>...</div>";
    //html += "<div>" + i18n.JordanDecompositionLink + "</div>";

    var detailsHTML = "<details open=\"open\"><summary>" + i18n.misc.summaryLabel + "</summary><div class=\"indented\">" + html + "</div></details>";
    return "<math>" + new Expression.Matrix(matrix).toMathML(printOptions) + "<mo>" + (J.isExact() ? "=" : "&asymp;") + "</mo>" + "<mrow>" + new Expression.Matrix(P).toMathML(printOptions) + "<mo>&sdot;</mo>" + new Expression.Matrix(J).toMathML(printOptions) + "<mo>&sdot;</mo>" + new Expression.Matrix(P_INVERSED).toMathML(printOptions) + "</mrow>" + "</math>" + detailsHTML;
  }
}); //!

function powUsingTransformationsHelper(x) {
  var pm1 = "<msup><mi>P</mi>" + Expression.p(-1) + "</msup>";
  return "<munder accentunder=\"true\">" + "<munder accentunder=\"true\">" + "<mrow>" + "<mi>P</mi>" + "<mo>&sdot;</mo>" + x + "<mo>&sdot;</mo>" + "<menclose notation=\"updiagonalstrike\">" + pm1 + "</menclose>" + "<mo>&sdot;</mo>" + "<menclose notation=\"updiagonalstrike\"><mi>P</mi></menclose>" + "<mo>&sdot;</mo>" + x + "<mo>&sdot;</mo>" + "<menclose notation=\"updiagonalstrike\">" + pm1 + "</menclose>" + "<mo>&sdot;</mo><mi>&hellip;</mi><mo>&sdot;</mo>" + "<menclose notation=\"updiagonalstrike\"><mi>P</mi></menclose>" + "<mo>&sdot;</mo>" + x + "<mo>&sdot;</mo>" + pm1 + "</mrow>" + "<mo stretchy=\"true\">&UnderBrace;</mo>" + "</munder>" + "<mi>n</mi>" + "</munder>";
}

function powUsingTransformations(N) {
  return "<math>" + Expression.p("A^n=(P*" + N + "*P^-1)^n") + "<mo>=</mo>" + powUsingTransformationsHelper(Expression.p(N)) + "<mo>=</mo>" + Expression.p("P*" + N + "^n*P^-1") + "</math>";
}

function nthRootUsingTransformations(N) {
  return "<math>" + powUsingTransformationsHelper(Expression.p(N + "**(1/n)")) + "<mo>=</mo>" + Expression.p("P*" + N + "*P^-1") + "<mo>=</mo>" + Expression.p("A") + "</math>";
}

Expression.Details.add({
  type: "pow-using-diagonalization",
  minRows: 2,
  callback: function (printOptions, matrix) {
    var html = '';
    html += '<div>';
    html += i18n.misc.powUsingDiagonalizationIntro;
    html += '</div>';
    html += '<div>';
    html += powUsingTransformations("D") + " " + i18n.powUsingDiagonalizationLink;
    html += '</div>';
    return html;
  }
}); //!new

Expression.Details.add({
  type: "pow-using-Jordan-normal-form",
  minRows: 2,
  callback: function (printOptions, matrix) {
    var html = ''; //TODO:...

    html += '<div>';
    html += i18n.misc.powUsingJordanNormalFormIntro;
    html += '</div>';
    html += '<div>';
    html += powUsingTransformations("J") + " " + i18n.powUsingJordanNormalFormLink;
    html += '</div>';
    var tmp = Expression.getEigenvalues(matrix);
    var J = Expression.getFormaDeJordan(matrix, tmp.eigenvalues, tmp.multiplicities).J;
    html += '<p>' + i18n.misc.powOfJordanMatrix + '</p>'; //html += Expression.Details.getCallback('Jordan-matrix-pow')(printOptions, matrix);

    html += Expression.Details.getCallback('DpN-matrix-pow')(printOptions, J);
    return html;
  }
});
Expression.Details.add({
  type: "DpN-matrix-pow",
  i18n: function () {
    //return i18n.matrixExponentiation;
    return "exponentiation";
  },
  minRows: 2,
  callback: function (printOptions, matrix) {
    var html = ''; // Заметим, что A = D + N, где D - диагональная матрица, а N - нильпотентна, т.к. N**n = 0.
    // Также, заметим, что D*N=N*D.
    // Тогда A**n=(D+N)**n=[binomial expansion] = ...
    //TODO: ...

    html += '<p>' + i18n.dpnMatrixPow.define + '</p>';
    var D = new Expression.Matrix(matrix.map(function (e, i, j) {
      return i === j ? e : Expression.ZERO;
    }));
    var N = new Expression.Matrix(matrix.map(function (e, i, j) {
      return i !== j ? e : Expression.ZERO;
    }));

    if (!N.matrix.isNilpotent()) {
      throw new RangeError();
    } //TODO: share ?


    var index = 1;

    while (!N.matrix.pow(index).eql(Matrix.Zero(N.matrix.cols(), N.matrix.cols()))) {
      if (index >= N.matrix.cols()) {
        throw new TypeError('assertion');
      }

      index += 1;
    }

    html += '<math>' + Expression.p('D=X', {
      X: D
    }, printOptions) + '</math>';
    html += ', '; //?

    html += '<math>' + Expression.p('N=X', {
      X: N
    }, printOptions) + '</math>';
    html += '<p>' + i18n.dpnMatrixPow.soThat.replaceAll('${(D+N)**n}', '<math>' + Expression.p('(D+N)**n') + '</math>') + '</p>';
    html += '<ul>';
    html += '<li>' + '<math>' + Expression.p('D*N=N*D') + '</math>' + ' — ' + i18n.dpnMatrixPow.DAndNCommute.replace(/\$\{D\}/g, '<math>' + Expression.p('D') + '</math>').replace(/\$\{N\}/g, '<math>' + Expression.p('N') + '</math>') + '</li>';
    html += '<li>' + '<math>' + Expression.p('N**' + index + '=0') + '</math>' + '</li>'; //TODO: say something about nilpotent of a triangular with zeroes on diagonal

    html += '</ul>';
    html += '<p>' + i18n.dpnMatrixPow.whichEnables + '</p>';
    html += '<math>';
    html += Expression.p('(D+N)**n');
    html += '<mo>=</mo>';
    html += '<mrow>';
    html += '<munderover accentunder="false" accent="false"><mo>∑</mo><mrow><mi>k</mi><mo>=</mo>' + Expression.p(0) + '</mrow><mi>n</mi></munderover>';
    html += '<mrow>';
    html += '<mrow><mo>(</mo><mfrac linethickness="0"><mi>n</mi><mi>k</mi></mfrac><mo>)</mo></mrow>';
    html += '<mo>&it;</mo>';
    html += Expression.p('D**(n-k)*N**k').replace(/&times;/g, '&it;');
    html += '</mrow>';
    html += '</mrow>';
    html += '<mo>=</mo>';
    var s = '';

    for (var k = 0; k < index; k += 1) {
      s += s !== '' ? '+' : '';
      var bc = '';

      for (var i = 0; i < k; i += 1) {
        bc += i === 0 ? 'n' : '(n-' + i + ')';
      }

      var f = Expression.Integer.fromNumber(k).factorial().toBigInt();
      s += k !== 0 ? k !== 1 ? bc + '/' + f + '*D**(n-' + k + ')*N**' + k : 'n*D**(n-1)*N' : 'D**n*N';
    }

    html += Expression.p(s).replace(/&times;/g, '&it;');
    html += '</math>';
    html += ' ';
    html += '<a href="https://math.stackexchange.com/questions/2079950/compute-the-n-th-power-of-triangular-3-times3-matrix/2079981#2079981">(*)</a>';
    return html;
  }
});

var outputJordanMatrix = function (n, block1Size) {
  var html = '';
  html += '<mrow>';
  html += '<mo>(</mo>';
  html += '<mtable rowspacing="0ex">';

  for (var i = 0; i < n; i += 1) {
    html += '<mtr>';

    for (var j = 0; j < n; j += 1) {
      html += '<mtd>';
      var c = i < block1Size ? 1 : 2; // lambda

      if (i === j) {
        html += Expression.p('λ_' + c);
      } else if (j === i + 1 && i !== 2) {
        html += Expression.p(1);
      } else {
        html += Expression.p(0);
      }

      html += '</mtd>';
    }

    html += '</mtr>';
  }

  html += '</mtable>';
  html += '<mo>)</mo>';
  html += '</mrow>';
  return html;
};
/*
//TODO: remove - ?
Expression.Details.add({
  type: "Jordan-matrix-pow",
  minRows: 2,
  callback: function (printOptions, matrix) {
    var html = '';

    html += i18n.misc.powOfJordanMatrix;
    html += '<div>';
    html += '<math>';

    // thanks to http://fred-wang.github.io/TeXZilla/
    html += '<msup>';
    html += outputJordanMatrix(5, 3);
    html += '<mi>n</mi>';
    html += '</msup>';

    html += '<mo>=</mo>';

    html += '<mrow>';
    html += '<mo>(</mo>';
    html += '<mtable rowspacing="0ex">';
    for (var i = 0; i < 5; i += 1) {
      html += '<mtr>';
      for (var j = 0; j < 5; j += 1) {
        html += '<mtd>';
        var c = i < 3 ? 1 : 2; // lambda
        if (i === j) {
          html += '<msup>' + Expression.p('λ_' + c) + '<mi>n</mi></msup>';
        } else if (i < j && (j < 3 || i >= 3)) {
          var m = j < 3 ? j - i : j - 3;
          var binomialCoefficient = '<mrow><mo>(</mo><mfrac linethickness="0"><mi>n</mi>' + Expression.p(m) + '</mfrac><mo>)</mo></mrow>';
          html += binomialCoefficient;
          html += '<mo>&it;</mo>';
          html += '<msup>' + Expression.p('λ_' + c) + '<mrow><mi>n</mi><mo>&minus;</mo>' + Expression.p(m) + '</mrow></msup>';
        } else {
          html += Expression.p(0);
        }
        html += '</mtd>';
      }
      html += '</mtr>';
    }
    html += '</mtable>';
    html += '<mo>)</mo>';
    html += '</mrow>';

    html += '</math>';
    html += ' ';
    html += i18n.blockOfJordanPowerFormulaLink;
    html += '</div>';
    return html;
  }
});

*/


Expression.Details.add({
  type: "Jordan-matrix-nth-root",
  minRows: 2,
  callback: function (printOptions, matrix) {
    var html = '';
    html += i18n.misc.nthRootOfJordanMatrix;
    html += '<div>';
    html += '<math>'; // thanks to http://fred-wang.github.io/TeXZilla/

    html += '<msup>';
    html += outputJordanMatrix(6, 4);
    html += '<mfrac>' + Expression.p(1) + '<mi>n</mi></mfrac>'; //!

    html += '</msup>';
    html += '<mo>=</mo>';
    html += '<mrow>';
    html += '<mo>(</mo>';
    html += '<mtable rowspacing="0ex">';

    for (var i = 0; i < 6; i += 1) {
      html += '<mtr>';

      for (var j = 0; j < 6; j += 1) {
        html += '<mtd>';
        var c = i < 4 ? 1 : 2; // lambda

        if (i === j) {
          html += '<msup><mi>λ</mi><mrow><mo>(</mo><mrow>' + Expression.p(1) + '<mo>&#x2215;</mo><mi>n</mi></mrow><mo>)</mo></mrow></msup>'; //!
        } else if (i < j && (j < 4 || i >= 4)) {
          var m = j < 4 ? j - i : j - 4; // (1-n)(1-2n)(1-3n)/(4!*n**4) * 1/λ**m * λ**(1/n)

          var s = '';

          if (m > 1) {
            for (var k = 1; k < m; k += 1) {
              s += '(1-' + (k === 1 ? '' : k) + 'n)';
            }

            s += '/(' + m + '!' + 'n**' + m + ')';
          } else {
            s += '1/n';
          }

          s += '*(λ**(1/n)/λ' + (m !== 1 ? '**' + m : '') + ')';
          html += Expression.p(s).replace(/&times;/g, '&it;'); //TODO:
        } else {
          html += Expression.p(0);
        }

        html += '</mtd>';
      }

      html += '</mtr>';
    }

    html += '</mtable>';
    html += '<mo>)</mo>';
    html += '</mrow>';
    html += '</math>';
    html += ' ';
    html += i18n.blockOfJordanPowerFormulaLink;
    html += '</div>';
    return html;
  }
});
Expression.Details.add({
  type: "nth-root-using-diagonalization",
  minRows: 2,
  callback: function (printOptions, matrix) {
    var html = '';
    html += '<div>' + i18n.misc.ifXisARootOfAMatrixInDiagonalFormThen.replaceAll('${D^(1/n)}', Expression.p('D^(1/n)')) + '</div>';
    html += nthRootUsingTransformations("D") + " " + i18n.nthRootUsingDiagonalizationLink;
    html += '<div>' + i18n.misc.thisMeansThatXIsANthRootOfTheMatrix.replaceAll('${P*J^(1/n)*P^-1}', Expression.p('P*J^(1/n)*P^-1')).replace(/<mi>J<\/mi>/g, '<mi>D</mi>') + '</div>';
    return html;
  }
});
Expression.Details.add({
  type: "nth-root-using-Jordan-normal-form",
  minRows: 2,
  callback: function (printOptions, matrix) {
    //TODO: change the link (?), tests - ?
    //TODO: some text explaining, that J - is a matrix in Jordan normal form, P - is a Generalized Nodal Matrix
    var html = "";
    html += '<div>' + i18n.misc.ifXisARootOfAMatrixInJordanNormalFormThen.replaceAll('${J^(1/n)}', Expression.p('J^(1/n)')) + '</div>';
    html += nthRootUsingTransformations("J") + " " + (i18n.nthRootUsingJordanNormalFormLink || i18n.nthRootUsingDiagonalizationLink);
    html += '<div>' + i18n.misc.thisMeansThatXIsANthRootOfTheMatrix.replaceAll('${P*J^(1/n)*P^-1}', Expression.p('P*J^(1/n)*P^-1')) + '</div>'; // The nth-root of a Jordan normal form can be found by using the formula:
    //TODO: formula

    html += Expression.Details.getCallback('Jordan-matrix-nth-root')(printOptions, matrix);
    return html;
  }
});
Expression.Details.add({
  type: "exponential-using-Jordan-canonical-form",
  minRows: 2,
  i18n: function () {
    return i18n.vectors.matrixExponential; //use cases -?
  },
  callback: function (printOptions, matrix) {
    //TODO: when the matrix is already diagonal, when the matrix is a [projection matrix](https://en.wikipedia.org/wiki/Matrix_exponential#Projection_case)
    //  Expression.Details.getCallback("exponential-using-Jordan-canonical-form")({}, RPN("{{0,1,0},{0,1,0},{0,0,0}}").matrix);
    var diagonalCase = function (name, expD) {
      var html = '';
      html += '<h4>' + i18n.exponential.findTheExponentialOfTheDiagonalMatrixD.replace(/\$\{D\}/g, '<math>' + Expression.p(name) + '</math>') + '</h4>';
      html += '<div>';
      html += i18n.exponential.exponentialOfDiagonalMatrix;
      html += '</div>';
      html += '<div>';
      html += '<math>' + Expression.p('e**' + name + '=M', {
        M: expD
      }, printOptions) + '</math>';
      html += '</div>';
      return html;
    };

    var nilpotentCase = function (N, expN) {
      var html = '';
      html += '<h4>' + i18n.exponential.findTheExponentialOfTheNilpotentMatrixN.replace(/\$\{N\}/g, '<math><mi>N</mi></math>') + '</h4>';
      html += '<div>'; // \u22EF == &hellip;

      html += '<math>' + Expression.p('e**N=I+N+1/2*N**2+1/6*N**3+a+1/f*N**k').replace(/<mi>a<\/mi>/g, '<mi>&hellip;</mi>').replace(/<mi>f<\/mi>/g, '<mrow><mi>k</mi><mo>!</mo></mrow>') + '</math>' + ' ' + i18n.exponentialOfNilpotentMatrixLink + i18n.colonSpacing + ':';
      html += '</div>'; //TODO: steps

      html += '<div>';
      var M = N;
      var k = 1;

      while (!M.eql(Matrix.Zero(M.rows(), M.cols()))) {
        M = M.multiply(M);
        k += 1;

        if (k > 2) {
          html += '; '; //?
        }

        html += '<math>' + Expression.p('N**' + k + '=M', {
          A: new Expression.Matrix(N),
          M: new Expression.Matrix(M)
        }, printOptions) + '</math>';
      }

      html += '</div>';
      html += '<div>';
      html += '<math>' + Expression.p('e**N=M', {
        M: expN
      }, printOptions) + '</math>';
      html += '</div>';
      return html;
    };

    if (matrix.isDiagonal()) {
      var expD = new Expression.Matrix(matrix).exp();
      var html = '';
      html += diagonalCase('D', expD);
      return html;
    } //TODO: The characteristic polynomial for N is det(xI-N)=x^{n}


    if (matrix.isNilpotent()) {
      var expN = new Expression.Matrix(matrix).exp();
      var html = '';
      html += '<h3>' + i18n.exponential.theMatrixIsNilpotent + '</h3>';
      html += nilpotentCase(matrix, expN);
      return html;
    }

    var A = matrix;
    var tmp0 = Expression.getEigenvalues(A);
    var eigenvalues = tmp0.eigenvalues;
    var multiplicities = tmp0.multiplicities;
    var tmp = Expression.getFormaDeJordan(A, eigenvalues, multiplicities);
    var D = tmp.J.map(function (e, i, j) {
      return i === j ? e : Expression.ZERO;
    });
    var N = tmp.J.map(function (e, i, j) {
      return i !== j ? e : Expression.ZERO;
    });
    var expN = new Expression.Matrix(N).exp().matrix; //TODO: ?

    var expJmN = D.map(function (e, i, j) {
      return i === j ? e.exp() : Expression.ZERO;
    });
    var expA = tmp.P.multiply(expJmN).multiply(expN).multiply(tmp.P_INVERSED);
    var data = {
      A: A,
      P: tmp.P,
      J: tmp.J,
      P_INVERSED: tmp.P_INVERSED,
      N: N,
      JmN: D,
      expN: expN,
      expJmN: expJmN,
      expA: expA
    };

    for (var i in data) {
      if (Object.prototype.hasOwnProperty.call(data, i)) {
        data[i] = new Expression.Matrix(data[i]);
      }
    }

    var html = '';
    html += '<h3>' + i18n.exponential.exponentialUsingJordanCanonicalForm + '</h3>';
    html += '<math>' + Expression.p('exp(A)=exp(P*J*P^-1)=P*exp(J-N)*exp(N)*P^-1') + '</math>'; // data.P
    // data.J
    // data.P_INVERSED
    // data.N
    // data.JmN
    // data.expN
    // data.expJmN
    // data.expA
    // 1. Find a matrix in Jordan normal form:
    //   ...
    //   A = P*J*P**(-1) = X*Y*Z
    // 2. Then:
    //   N = M, J-N = M
    // 3. Find the exponential of the Nilpotent matrix (N):
    //   e**N=I+N+1/2*N**2+1/6*N**3+...+1(q-1)!*N**(q-1) (*)[https://en.wikipedia.org/wiki/Matrix_exponential#Nilpotent_case]:
    // ...
    // 4. Find the exponential of the diagonal matrix (J-N):
    //   Exponential can be obtained by exponentiating each entry on the main diagonal (*)[https://en.wikipedia.org/wiki/Matrix_exponential#Diagonalizable_case]:
    //   exp(J-N)=M
    // 5. Then:
    //   exp(A)=X*Y=Z

    html += '<ol>';
    html += '<li>';
    html += '<h3>' + i18n.exponential.findAMatrixInJordanNormalForm + '</h3>';
    html += createDetailsSummary(printOptions.idPrefix, [{
      type: "Jordan-decomposition",
      matrix: matrix.toString(),
      second: undefined
    }]);
    html += '<div>';
    html += '<math>' + Expression.p('A=P*J*P**(-1)') + '</math>' + ':';
    html += '</div>';
    html += '<div>';
    html += '<math>' + Expression.p('A=P*J*V', {
      A: data.A,
      P: data.P,
      J: data.J,
      V: data.P_INVERSED
    }, printOptions) + '</math>';
    html += '</div>';
    html += '</li>';
    html += '<li>';
    html += '<h4>' + i18n.exponential.then + '</h4>';
    html += '<div>';
    html += '<math>' + Expression.p('N=M', {
      M: data.N
    }, printOptions) + '</math>';
    html += ', ';
    html += '<math>' + Expression.p('J-N=M', {
      M: data.JmN
    }, printOptions) + '</math>';
    html += '</div>';
    html += '</li>';
    html += '<li>'; //TODO: when matrix is diagonalizable (?)

    html += nilpotentCase(data.N.matrix, data.expN);
    html += '</li>';
    html += '<li>';
    html += diagonalCase('(J-N)', data.expJmN);
    html += '</li>';
    html += '<li>';
    html += '<h4>' + i18n.exponential.then + '</h4>';
    html += '<div>';
    html += '<math>' + Expression.p('exp(A)=P*X*Y*V=M', {
      A: data.A,
      P: data.P,
      X: data.expJmN,
      Y: data.expN,
      V: data.P_INVERSED,
      M: data.expA
    }, printOptions) + '</math>';
    html += '</div>';
    html += '</li>';
    html += '</ol>'; //TODO:...

    return html;
  }
});
Expression.Details.add({
  type: "logarithm-using-diagonalization",
  minRows: 2,
  i18n: function () {
    return i18n.misc.calculatingTheLogarithmOfADiagonalizableMatrix;
  },
  callback: function (printOptions, matrix) {
    //TODO: ?
    return i18n.calculatingTheLogarithmOfADiagonalizableMatrixLink;
  }
});
Expression.Details.add({
  type: "logarithm-using-Jordan-canonical-form",
  minRows: 2,
  i18n: function () {
    return i18n.theLogarithmOfANonDiagonalizableMatrix;
  },
  callback: function (printOptions, matrix) {
    //TODO: ?
    return i18n.theLogarithmOfANonDiagonalizableMatrixLink;
  }
});

var getAdjugateByDefinition = function (printOptions, matrix) {
  var result = "";
  var cofactors = new Array(matrix.rows());

  for (var i = 0; i < matrix.rows(); i += 1) {
    cofactors[i] = new Array(matrix.cols());

    for (var j = 0; j < matrix.cols(); j += 1) {
      result += "<div>"; // TODO: <ul> - ?

      result += "<math>";
      result += Expression.p('C_(' + (i + 1) + ',' + (j + 1) + ')');
      result += '<mo>=</mo>';
      result += '<mrow>';
      result += Expression.p("(-1)^(i+j)", {
        i: Expression.Integer.fromNumber(i + 1),
        j: Expression.Integer.fromNumber(j + 1)
      }, printOptions);
      result += "<mo>&sdot;</mo>";
      result += new Expression.Minor(new Expression.Matrix(matrix), i, j).toMathML(printOptions);
      result += '</mrow>';
      var minorMatrix = matrix.minorMatrix(i, j);
      var minor = minorMatrix.determinant();
      var isOdd = i + j - 2 * Math.floor((i + j) / 2);
      var n = isOdd === 1 ? Expression.ONE.negate() : Expression.ONE;
      var c = n.multiply(minor);

      if (minorMatrix.rows() === 2) {
        //!
        result += "<munder accentunder=\"true\"><mo>=</mo><mtext>" + i18n.determinant2x2Link + "</mtext></munder>";
        result += Expression.p("n*(a*d-b*c)", {
          n: n,
          a: minorMatrix.e(0, 0),
          b: minorMatrix.e(0, 1),
          c: minorMatrix.e(1, 0),
          d: minorMatrix.e(1, 1)
        }, printOptions);
      }

      if (isOdd === 1) {
        result += "<mo>=</mo>";
        result += Expression.p("n*(d)", {
          n: n,
          d: minor
        }, printOptions);
      }

      result += "<mo>=</mo>";
      result += Expression.p("c", {
        c: c
      }, printOptions);
      result += "</math>";

      if (minorMatrix.rows() !== 2) {
        //!
        result += createDetailsSummary(printOptions.idPrefix, [{
          type: minorMatrix.getDeterminantEventType("determinant").type,
          matrix: minorMatrix.toString(),
          second: undefined
        }]);
      }

      cofactors[i][j] = c;
      result += "</div>";
    }
  }

  var CT = new Expression.Matrix(new Matrix(cofactors).transpose());
  return {
    result: result,
    CT: CT
  };
};

Expression.Details.add({
  type: "adjugate-by-definition",
  i18n: undefined,
  minRows: 2,
  //?
  priority: -1,
  callback: function (printOptions, matrix) {
    var tmp = getAdjugateByDefinition(printOptions, matrix);
    var result = tmp.result;
    var CT = tmp.CT;
    result += "<div>";
    result += "<math>";
    result += Expression.p("adjugate(A)=C^T=Y", {
      A: new Expression.Matrix(matrix),
      Y: CT
    }, printOptions);
    result += "</math>";
    result += " ";
    result += i18n.adjugateMatrixLink; //TODO:

    result += "</div>";
    return result;
  }
});
Expression.Details.add({
  type: "inverse-adjugate",
  i18n: function () {
    return i18n.inverse.inverseDetailsUsingAdjugateMatrix;
  },
  minRows: 3,
  priority: -1,
  callback: function (printOptions, matrix) {
    var result = "";
    result += "<div>";
    result += "<math>";
    result += Expression.p("A^-1=1/determinant(A)*C^T=1/determinant(A)*X", {
      X: new Expression.Matrix(matrix.map(function (e, i, j) {
        return new Expression.Symbol('C_(' + (j + 1) + ',' + (i + 1) + ')');
      }))
    }, printOptions);
    result += "</math>";
    result += " ";
    result += i18n.inverseDetailsUsingAdjugateMatrixLink; //TODO

    result += "</div>"; // https://upload.wikimedia.org/math/e/f/0/ef0d68882204598592f50ba054e9951e.png

    var determinant = matrix.determinant();
    result += "<div>";
    result += "<math>";
    result += Expression.p("determinant(A)=X=y", {
      X: new Expression.Determinant(new Expression.Matrix(matrix)),
      y: determinant
    }, printOptions);
    result += "</math>";
    result += createDetailsSummary(printOptions.idPrefix, [{
      type: matrix.getDeterminantEventType("determinant").type,
      matrix: matrix.toString(),
      second: undefined
    }]);
    result += "</div>";

    if (determinant.equals(Expression.ZERO)) {//TODO: ?
    } else {
      //!
      var tmp = getAdjugateByDefinition(printOptions, matrix);
      result += tmp.result;
      var CT = tmp.CT; // TODO: linkes
      // http://en.wikipedia.org/wiki/Cramer%27s_rule#Finding_inverse_matrix

      result += "<div>";
      result += "<math>";
      result += Expression.p("A^-1=1/determinant(A)*C^T=1/x*Y=Z", {
        x: determinant,
        Y: CT,
        Z: determinant.inverse().multiply(CT)
      }, printOptions);
      result += "</math>";
      result += "</div>";
    }

    return result;
  }
}); // new Intl.NumberFormat("it-u-nu-roman").format(n);

var roman = function (n) {
  var digits = "IVXLCDM";
  var i = digits.length + 1;
  var result = "";
  var value = 1000;

  while ((i -= 2) >= 0) {
    var v = Math.floor(value / 10);
    var j = -1;

    while (++j < 2) {
      while (n >= value) {
        n -= value;
        result += digits.slice(i - j, i - j + 1);
      }

      value -= v;

      while (n >= value) {
        n -= value;
        result += digits.slice(i - 2, i - 2 + 1) + digits.slice(i - j, i - j + 1);
      }

      value -= 4 * v;
    }

    value = v;
  }

  return result;
}; // use default locale (as it may be better for the end user and numbering system can depend on the region)
// TODO: localeString() outside of MathML, Expression.p() in mscript.js for <mn>_number_</mn>


var initNumberFormat = function (event) {
  Expression.numberFormat = new Intl.NumberFormat(undefined, {
    useGrouping: false
  });
};

globalThis.addEventListener('languagechange', initNumberFormat);
initNumberFormat();
var numberFormat = null;
globalThis.addEventListener('languagechange', function (event) {
  numberFormat = null;
});

var localeString = function (number) {
  console.assert(Math.floor(number) === number && number >= 0 && number <= Number.MAX_SAFE_INTEGER);

  if (numberFormat == null) {
    numberFormat = new Intl.NumberFormat(undefined, {
      useGrouping: false
    });
  }

  return numberFormat.format(number);
}; //TODO: remove


var getMatrixRowDenotation = function (i) {
  return i18n.matrixRowDenotation.replace(/\$\{i\}/g, localeString(i)).replace(/\$\{i\:roman\}/g, roman(i));
};

Matrix.prototype.getDeterminantEventType = function (base) {
  for (var i = 0; i < this.rows(); i += 1) {
    var isZero = true;

    for (var j = 0; j < this.cols(); j += 1) {
      var e = this.e(i, j);

      if (!e.equals(Expression.ZERO)) {
        isZero = false;
      }
    }

    if (isZero) {
      return {
        type: "special-determinant",
        row: i,
        col: -1
      };
    }
  }

  for (var j = 0; j < this.cols(); j += 1) {
    var isZero = true;

    for (var i = 0; i < this.rows(); i += 1) {
      var e = this.e(i, j);

      if (!e.equals(Expression.ZERO)) {
        isZero = false;
      }
    }

    if (isZero) {
      return {
        type: "special-determinant",
        row: -1,
        col: j
      };
    }
  }

  return {
    type: base,
    row: -1,
    col: -1
  };
}; //!new


Expression.Details.add({
  type: "special-determinant",
  i18n: undefined,
  priority: 1 / 0,
  minRows: 1,
  //TODO: add a test
  callback: function (printOptions, matrix) {
    var html = "";
    var x = matrix.getDeterminantEventType();
    html += "<div>";
    html += "<math>";
    html += new Expression.Determinant(new Expression.Matrix(matrix)).toMathML(Object.assign({}, printOptions, {
      highlightRow: x.row !== -1 ? x.row : undefined,
      highlightCol: x.col !== -1 ? x.col : undefined
    }));
    html += "<mo>=</mo>";
    html += Expression.p(0);
    html += "</math>";

    if (x.row !== -1 || x.col !== -1) {
      html += "<div>" + i18n.determinant.zeroRowColumn + "</div>";
    }

    html += "</div>";
    return html;
  }
});
Expression.Details.add({
  type: "add",
  i18n: function () {
    return i18n.add.matrixAddition;
  },
  minRows: 2,
  callback: function (printOptions, matrixA, matrixB) {
    return "<p>" + i18n.add.matrixAdditionInfo + "</p>" + getMatrixOperationDetails(printOptions, matrixA, matrixB, function (a, b) {
      return a.add(b);
    }, "+");
  }
});
Expression.Details.add({
  type: "multiply",
  i18n: function () {
    return i18n.multiply.matrixMultiplication;
  },
  minRows: 2,
  callback: function (printOptions, matrixA, matrixB) {
    return "<p>" + i18n.multiply.matrixMultiplicationInfo + "</p>" + getMatrixOperationDetails(printOptions, matrixA, matrixB, function (a, b) {
      return a.multiply(b);
    }, "&sdot;");
  }
});
Expression.Details.add({
  type: "trigonometric-function-of-inverse-trigonometric-function-arg",
  minRows: 1,
  maxRows: 1,
  callback: function (printOptions) {
    //TODO:
    var a = "https://www.rapidtables.com/math/trigonometry/arctan.html#rules";
    var b = "https://en.wikipedia.org/wiki/Inverse_trigonometric_functions#Relationships_between_trigonometric_functions_and_inverse_trigonometric_functions";
    return "see " + a.link(a) + ' and ' + b.link(b);
  }
});

function getMatrixOperationDetails(printOptions, matrixA, matrixB, operationFunction, operator) {
  var html = ""; //TODO: Should matrixA and matrixB already have NonSimplifiedExpressions-elements ???

  var matrixAn = matrixA.map(function (e, i, j) {
    return new NonSimplifiedExpression(e);
  });
  var matrixBn = matrixB.map(function (e, i, j) {
    return new NonSimplifiedExpression(e);
  });
  var matrixAB = operationFunction(matrixAn, matrixBn);
  var result = matrixAB.map(function (e, i, j) {
    return e.simplify();
  });
  html += "<math>";
  html += "<mrow>";
  html += new Expression.Matrix(matrixAn).toMathML(Object.assign({}, printOptions, {
    cellIdGenerator: function (i, j) {
      return matrixAn.e(i, j).getId();
    }
  }));
  html += "<mo>" + operator + "</mo>";
  html += new Expression.Matrix(matrixBn).toMathML(Object.assign({}, printOptions, {
    cellIdGenerator: function (i, j) {
      return matrixBn.e(i, j).getId();
    }
  }));
  html += "</mrow>";
  html += "<mo>=</mo>";
  html += new Expression.Matrix(matrixAB).toMathML(Object.assign({}, printOptions, {
    cellIdGenerator: function (i, j) {
      return matrixAB.e(i, j).getId();
    }
  }));
  html += "<mo>=</mo>";
  html += new Expression.Matrix(result).toMathML(printOptions);
  html += "</math>"; //TODO: highlight of "same" expression elements, when mouseover an element of matrixAB or matrixA or matrixB

  matrixAB.map(function (e, i, j) {
    html += "<a class=\"a-highlight\" data-for=\"" + e.getId().toString() + "\" data-highlight=\"" + e.unwrap().getIds() + "\"></a>";
    return e;
  });
  return html;
}

Expression.Details.add({
  type: "pow",
  i18n: function () {
    return i18n.multiply.matrixMultiplication;
  },
  minRows: 1,
  callback: function (printOptions, matrix, second) {
    var n = Number(second.e(0, 0).toString()); // n >= 1 (?)

    var i = 0;
    var c = 1;
    var t = [];
    t.push(matrix);
    var html = "<ul>";
    html += "<li>";
    html += "<math>";
    html += Expression.p("A") + "<mo>=</mo>" + new Expression.Matrix(t[i]).toMathML(printOptions);
    html += "</math>";
    html += "</li>";

    while (c * 2 <= n) {
      c *= 2;
      t.push(t[i].multiply(t[i]));
      html += "<li>";
      html += "<math>";
      html += Expression.p("A^" + c) + "<mo>=</mo>" + Expression.p("A^" + Math.floor(c / 2) + "*" + "A^" + Math.floor(c / 2)) + "<mo>=</mo>" + new Expression.Matrix(t[i + 1]).toMathML(printOptions);
      html += "</math>";
      html += "</li>";
      i += 1;
    }

    html += "</ul>";
    var result = undefined;
    var r = undefined;
    var nn = n;

    while (i !== -1 && nn !== 0) {
      if (nn >= c) {
        nn -= c;
        result = result == undefined ? t[i] : result.multiply(t[i]);
        var z = new Expression.NonSimplifiedExpression(new Expression.Symbol("A").pow(Expression.Integer.fromNumber(c)));
        r = r == undefined ? z : r.multiply(z);
      }

      c = Math.floor(c / 2);
      i -= 1;
    }

    html += "<math>";
    html += Expression.p("A^" + n) + "<mo>=</mo>" + r.toMathML(printOptions) + "<mo>=</mo>" + new Expression.Matrix(result).toMathML(printOptions);
    html += "</math>";
    return html;
  }
});
Expression.someDetailsNew = {
  "determinant2x2": "<span data-custom-paint=\"custom-menclose\" data-color=\"0a\" data-cells=\"[[0,0],[1,1]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"1a\" data-cells=\"[[0,1],[1,0]]\"><math><mrow><mo>|</mo><mtable rowspacing=\"0ex\"><mtr><mtd><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mtd></mtr><mtr><mtd><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mtd></mtr></mtable><mo>|</mo></mrow><mo>=</mo><mrow><mrow mathcolor=\"#D64040\"><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>1</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mrow><mo>&minus;</mo><mrow mathcolor=\"#4040D6\"><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>2</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mrow></mrow></math></span></span>${link}",
  "determinant3x3": "<math><mrow><mo>|</mo><mtable rowspacing=\"0ex\"><mtr><mtd><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>3</mn></mrow></msub></mtd></mtr><mtr><mtd><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>3</mn></mrow></msub></mtd></mtr><mtr><mtd><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>3</mn></mrow></msub></mtd></mtr></mtable><mo>|</mo></mrow></math><math><mo>=</mo></math>",
  "matrix3x3": "<math><mtable rowspacing=\"0ex\"><mtr><mtd><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>3</mn></mrow></msub></mtd></mtr><mtr><mtd><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>3</mn></mrow></msub></mtd></mtr><mtr><mtd><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>3</mn></mrow></msub></mtd></mtr></mtable></math>",
  "determinantTriangle": "${determinant3x3}<table class=\"some-details-table\"><tr><td><math><mrow><mo>+</mo><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mrow><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>2</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>3</mn></mrow></msub></math></td><td><span data-custom-paint=\"custom-menclose\" data-color=\"0a\" data-cells=\"[[0,0],[1,1],[2,2]]\">${matrix3x3}</span></td></tr><tr><td><math><mrow><mo>+</mo><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mrow><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>3</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></math></td><td><span data-custom-paint=\"custom-menclose\" data-color=\"0\" data-cells=\"[[0,0],[1,1],[2,2]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"0a\" data-cells=\"[[0,1],[1,2],[2,0]]\">${matrix3x3}</span></span></td></tr><tr><td><math><mrow><mo>+</mo><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>3</mn></mrow></msub></mrow><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>1</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></math></td><td><span data-custom-paint=\"custom-menclose\" data-color=\"0\" data-cells=\"[[0,0],[1,1],[2,2]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"0\" data-cells=\"[[0,1],[1,2],[2,0]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"0a\" data-cells=\"[[0,2],[1,0],[2,1]]\">${matrix3x3}</span></span></span></td></tr><tr><td><math><mrow><mo>&minus;</mo><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>3</mn></mrow></msub></mrow><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>2</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></math></td><td><span data-custom-paint=\"custom-menclose\" data-color=\"0\" data-cells=\"[[0,0],[1,1],[2,2]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"0\" data-cells=\"[[0,1],[1,2],[2,0]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"0\" data-cells=\"[[0,2],[1,0],[2,1]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"1a\" data-cells=\"[[2,0],[1,1],[0,2]]\">${matrix3x3}</span></span></span></span></td></tr><tr><td><math><mrow><mo>&minus;</mo><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mrow><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>3</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></math></td><td><span data-custom-paint=\"custom-menclose\" data-color=\"0\" data-cells=\"[[0,0],[1,1],[2,2]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"0\" data-cells=\"[[0,1],[1,2],[2,0]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"0\" data-cells=\"[[0,2],[1,0],[2,1]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"1\" data-cells=\"[[2,0],[1,1],[0,2]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"1a\" data-cells=\"[[2,1],[1,2],[0,0]]\">${matrix3x3}</span></span></span></span></span></td></tr><tr><td><math><mrow><mo>&minus;</mo><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mrow><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>1</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>3</mn></mrow></msub></math>${link}</td><td><span data-custom-paint=\"custom-menclose\" data-color=\"0\" data-cells=\"[[0,0],[1,1],[2,2]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"0\" data-cells=\"[[0,1],[1,2],[2,0]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"0\" data-cells=\"[[0,2],[1,0],[2,1]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"1\" data-cells=\"[[2,0],[1,1],[0,2]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"1\" data-cells=\"[[2,1],[1,2],[0,0]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"1a\" data-cells=\"[[2,2],[1,0],[0,1]]\">${matrix3x3}</span></span></span></span></span></span></td></tr></table>",
  "matrix5x3": "<math><mtable rowspacing=\"0ex\" columnlines=\"none none dashed none\"><mtr><mtd><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>3</mn></mrow></msub></mtd><mtd mathcolor=\"#808080\"><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mtd><mtd mathcolor=\"#808080\"><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mtd></mtr><mtr><mtd><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>3</mn></mrow></msub></mtd><mtd mathcolor=\"#808080\"><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mtd><mtd mathcolor=\"#808080\"><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mtd></mtr><mtr><mtd><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mtd><mtd><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>3</mn></mrow></msub></mtd><mtd mathcolor=\"#808080\"><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mtd><mtd mathcolor=\"#808080\"><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mtd></mtr></mtable></math>",
  "determinantSarrus": "${determinant3x3}<table class=\"some-details-table\"><tr><td><math><mrow><mrow><mo>+</mo><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mrow><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>2</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>3</mn></mrow></msub></mrow><mo>+</mo><mrow><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>2</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>3</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mrow><mo>+</mo><mrow><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>3</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>1</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mrow></math></td><td><span data-custom-paint=\"custom-menclose\" data-color=\"0a\" data-cells=\"[[0,0],[1,1],[2,2]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"0a\" data-cells=\"[[0,1],[1,2],[2,3]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"0a\" data-cells=\"[[0,2],[1,3],[2,4]]\">${matrix5x3}</span></span></span></td></tr><tr><td><math><mrow><mrow><mo>&minus;</mo><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>3</mn></mrow></msub></mrow><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>2</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>1</mn></mrow></msub></mrow><mo>&minus;</mo><mrow><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>1</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>3</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>2</mn></mrow></msub></mrow><mo>&minus;</mo><mrow><msub><mi>a</mi><mrow><mn>1</mn><mo>&ic;</mo><mn>2</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>2</mn><mo>&ic;</mo><mn>1</mn></mrow></msub><mo>&sdot;</mo><msub><mi>a</mi><mrow><mn>3</mn><mo>&ic;</mo><mn>3</mn></mrow></msub></mrow></math>${link}</td><td><span data-custom-paint=\"custom-menclose\" data-color=\"0\" data-cells=\"[[0,0],[1,1],[2,2]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"0\" data-cells=\"[[0,1],[1,2],[2,3]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"0\" data-cells=\"[[0,2],[1,3],[2,4]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"1a\" data-cells=\"[[0,2],[1,1],[2,0]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"1a\" data-cells=\"[[0,3],[1,2],[2,1]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"1a\" data-cells=\"[[0,4],[1,3],[2,2]]\">${matrix5x3}</span></span></span></span></span></span></td></tr></table>",
  "someDetails3": "<span data-custom-paint=\"custom-menclose\" data-color=\"0a\" data-cells=\"[[0,0],[2,2]]\"><span data-custom-paint=\"custom-menclose\" data-color=\"1a\" data-cells=\"[[0,2],[2,0]]\"><math><mtable rowspacing=\"0ex\"><mtr><mtd><mstyle mathvariant=\"bold\"><menclose notation=\"circle\"><msub><mi>a</mi><mrow><mi>r</mi><mo>,</mo><mi>c</mi></mrow></msub></menclose></mstyle></mtd><mtd><mtext>&hellip;</mtext></mtd><mtd><msub><mi>a</mi><mrow><mi>r</mi><mo>,</mo><mi>j</mi></mrow></msub></mtd></mtr><mtr><mtd><mtext>&vellip;</mtext></mtd><mtd></mtd><mtd><mtext>&vellip;</mtext></mtd></mtr><mtr><mtd><msub><mi>a</mi><mrow><mi>i</mi><mo>,</mo><mi>c</mi></mrow></msub></mtd><mtd><mtext>&hellip;</mtext></mtd><mtd><msub><mi>a</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub></mtd></mtr></mtable></math></span></span>",
  "": ""
};

Expression.getSomeDetails = function (id) {
  var s = Expression.someDetailsNew[id];
  return s.replace(/\$\{determinant3x3\}/g, Expression.someDetailsNew.determinant3x3).replace(/\$\{matrix3x3\}/g, Expression.someDetailsNew.matrix3x3).replace(/\$\{matrix5x3\}/g, Expression.someDetailsNew.matrix5x3).replace(/\<mn>(\d+)<\/mn>/g, function (p, digits) {
    return Expression.p(Number(digits));
  });
};

Expression.Details.add({
  type: "inverse-2x2",
  i18n: undefined,
  minRows: 2,
  maxRows: 2,
  callback: function (printOptions, matrix) {
    var html = "";
    html += "<div>";
    html += i18n.inverse.inverse2x2;
    html += " ";
    html += "<math>";
    html += Expression.p("A^-1={{a, b}, {c, d}}^-1=1/determinant(A)*{{C_11, C_21}, {C_12, C_22}}=1/(a*d-b*c)*{{d, -b}, {-c, a}}");
    html += "</math>";
    html += i18n.inverse2x2Link;
    html += "</div>";
    var det = matrix.e(0, 0).multiply(matrix.e(1, 1)).subtract(matrix.e(0, 1).multiply(matrix.e(1, 0))); // TODO: highlight (?)

    html += "<math>";
    html += Expression.p("A^-1=1/(a*d-b*c)*{{d, n}, {m, a}}" + (det.equals(Expression.ZERO) ? "=1/0*{{d, n}, {m, a}}" : "=t"), {
      A: new Expression.Matrix(matrix),
      a: matrix.e(0, 0),
      b: matrix.e(0, 1),
      c: matrix.e(1, 0),
      d: matrix.e(1, 1),
      n: matrix.e(0, 1).negate(),
      m: matrix.e(1, 0).negate(),
      t: det.equals(Expression.ZERO) ? undefined : new Expression.Matrix(matrix.inverse())
    }, printOptions);
    html += "</math>";
    return html;
  }
});
Expression.Details.add({
  type: "determinant-2x2",
  i18n: undefined,
  minRows: 2,
  maxRows: 2,
  callback: function (printOptions, matrix) {
    var html = "<div>" + Expression.getSomeDetails("determinant2x2", printOptions).replace(/\$\{link\}/g, i18n.determinant2x2Link) + "</div>";
    var determinantResult = matrix.e(0, 0).multiply(matrix.e(1, 1)).subtract(matrix.e(0, 1).multiply(matrix.e(1, 0)));
    html += "<math>";
    html += Expression.p("determinant(A)=a*d-b*c=r", {
      A: new Expression.Matrix(matrix),
      a: matrix.e(0, 0),
      b: matrix.e(0, 1),
      c: matrix.e(1, 0),
      d: matrix.e(1, 1),
      r: determinantResult
    }, printOptions);
    html += "</math>";
    return html;
  }
}); // ---------------------------------------- determinant -----------------------------------------------

var getDeterminant = function (matrix, k, r, z, coefficient) {
  if (matrix.cols() === 1) {
    return coefficient.multiply(matrix.e(0, 0));
  }

  var o = Expression.ZERO;

  for (var i = 0; i < matrix.cols(); i += 1) {
    // complement matrix for element e(i, k)
    var mx = matrix.minorMatrix(i, k);
    var e = matrix.e(i, k);
    var kk = coefficient.multiply(Expression.ONE.negate().pow((i + k) % 2 !== 0 ? Expression.ONE : Expression.ZERO).multiply(e));
    r.push({
      m: mx,
      a: kk,
      z: z,
      minor: new Expression.Minor(new Expression.Matrix(matrix), i, k),
      e: e
    });
    o = o.add(getDeterminant(mx, 0, r, z + 1, kk));
  }

  return o;
};

Expression.expandDeterminant = function (matrix, byRow, number, printOptions) {
  //TODO: highlight same elements
  var r = [];
  var k = Number(number.toString()) - 1; //!

  if (!matrix.isSquare()) {
    throw new RangeError("NonSquareMatrixException");
  }

  if (k >= matrix.rows() || k < 0 || k !== Math.floor(k)) {
    // matrix.isSquare() === true
    throw new RangeError("IntegerInputError" + ":" + (byRow ? "k-A-e-r" : "k-A-e-c"));
  } //!


  var result = null;

  if (byRow) {
    // expansion by row k
    result = getDeterminant(matrix.transpose(), k, r, 1, Expression.ONE);
    var l = -1;

    while (++l < r.length) {
      r[l].m = r[l].m.transpose();
      r[l].minor = new Expression.Minor(new Expression.Matrix(r[l].minor.a.matrix.transpose()), r[l].minor.j, r[l].minor.i);
    }
  } else {
    result = getDeterminant(matrix, k, r, 1, Expression.ONE); // expansion by column k
  }

  var html = "";
  html += "<math>";
  html += new Expression.Determinant(new Expression.Matrix(matrix)).toMathML(printOptions);
  html += "<mo>=</mo>";
  var z = matrix.cols() - 1;

  for (var i = 1; i < z; i += 1) {
    var e = "";

    for (var j = 0; j < r.length; j += 1) {
      if (r[j].z === i && !r[j].a.equals(Expression.ZERO)) {
        var det = new Expression.Determinant(new Expression.Matrix(r[j].m));
        var current = new Expression.Multiplication(new NonSimplifiedExpression(r[j].a), det);

        if (e !== "") {
          e += "<mo>+</mo>";
        }

        if (i !== 1) {
          e += current.toMathML(printOptions);
        } else {
          e += Expression.p("(-1)**(i+j)*e*A", {
            i: Expression.Integer.fromNumber(r[j].minor.i + 1),
            j: Expression.Integer.fromNumber(r[j].minor.j + 1),
            e: r[j].e,
            A: r[j].minor
          }, printOptions);
        }
      }
    }

    if (e != undefined) {
      // all zeros
      html += "<mrow>";
      html += e;
      html += "</mrow>";
      html += "<mo>=</mo>";
    }
  }

  html += result.toMathML(printOptions);
  html += "</math>";
  return html;
};

Expression.Details.add({
  type: "eigenvectors",
  minRows: 2,
  callback: function (printOptions, matrix) {
    if (!matrix.isSquare()) {
      throw new RangeError("NonSquareMatrixException");
    }

    var html = "";
    html += "<ol>";
    var tmp = Expression.getEigenvaluesWithSteps(printOptions, matrix);
    var eigenvalues = tmp.eigenvalues;
    html += "<li>";
    html += tmp.html;
    html += "</li>";

    if (eigenvalues.length > 0) {
      var tmp2 = Expression.getEigenvectorsWithSteps(printOptions, matrix, eigenvalues);
      html += "<li>";
      html += tmp2.html;
      html += "</li>";
    } else {
      html += "<li>";
      html += i18n.eigenvalues.thereAreNoRationalSolutions;
      html += "</li>";
    }

    html += "</ol>";
    return html;
  }
}); //!

Expression.Details.add({
  type: "expand-along-column",
  minRows: 3,
  callback: function (printOptions, matrix, columnNumber) {
    return Expression.expandDeterminant(matrix, false, columnNumber, printOptions);
  }
});
Expression.Details.add({
  type: "expand-along-row",
  minRows: 3,
  callback: function (printOptions, matrix, rowNumber) {
    return Expression.expandDeterminant(matrix, true, rowNumber, printOptions);
  }
});
Expression.Details.add({
  type: "obtain-zeros-in-column",
  minRows: 3,
  callback: function (printOptions, matrix, columnNumber) {
    return Expression.getZero(matrix, false, columnNumber, printOptions);
  }
});
Expression.Details.add({
  type: "obtain-zeros-in-row",
  minRows: 3,
  callback: function (printOptions, matrix, rowNumber) {
    return Expression.getZero(matrix, true, rowNumber, printOptions);
  }
});

var determinant3x3 = function (printOptions, matrix, text) {
  var containerId = printOptions.idPrefix + "-" + Expression.id();

  if (matrix.cols() !== 3 || matrix.rows() !== 3) {
    throw new RangeError("NonSquareMatrixException:" + i18n.determinant.theRuleOfSarrusCanBeUsedOnlyWith3x3Matrices);
  } //TODO: replace


  var matrixId = containerId;

  var cellId = function (i, j) {
    return matrixId + "_" + i.toString() + "_" + j.toString();
  };

  var higlights = "";
  var html = ""; //html += "<div>" + text + "</div>";

  html += "<div class=\"math-block\">" + text + "</div>";
  html += "<math>";
  html += new Expression.Determinant(new Expression.Matrix(matrix)).toMathML(Object.assign({}, printOptions, {
    cellIdGenerator: function (i, j) {
      return cellId(i, j);
    }
  }));
  html += "<mo>=</mo>";
  html += "<mrow>"; // TODO: clickable highlight with initially selected group

  var z = ["a_11*a_22*a_33", "a_12*a_23*a_31", "a_13*a_21*a_32", "a_31*a_22*a_13", "a_32*a_23*a_11", "a_33*a_21*a_12"];
  var context = new ExpressionParser.Context(function (id) {
    return matrix.e(Number(id.slice(2, 3)) - 1, Number(id.slice(3, 4)) - 1);
  });
  var determinant = undefined;

  for (var i = 0; i < z.length; i += 1) {
    var e = ExpressionParser.parse(z[i], context);

    if (i !== 0) {
      var sign = i < 3 ? "+" : "&minus;";
      html += "<mo>" + sign + "</mo>";
    }

    var highlight = z[i].replace(/a_(\d)(\d)\*?/g, function (x, si, sj) {
      var i = Number(si) - 1;
      var j = Number(sj) - 1;
      return "#" + cellId(i, j) + ", ";
    }).slice(0, -2);
    html += "<mrow id=\"" + (matrixId + "_x" + i.toString()) + "\">";
    html += e.toMathML(Object.assign({}, printOptions, {
      isTopLevel: false
    }));
    html += "</mrow>";
    higlights += "<a class=\"a-highlight\" data-for=\"" + (matrixId + "_x" + i.toString()) + "\" data-highlight=\"" + highlight + "\"></a>";
    determinant = i === 0 ? e : i < 3 ? determinant.add(e) : determinant.subtract(e);
  }

  html += "</mrow>";
  html += "<mo>=</mo>";
  html += determinant.simplify().toMathML(printOptions);
  html += "</math>";
  html += '<div hidden>' + higlights + '</div>';
  return html;
}; //TODO: fix - i18n.unused.determinant.usingSarrusRule


Expression.Details.add({
  type: "determinant-Sarrus",
  i18n: function () {
    return i18n.det.ruleOfSarrus;
  },
  minRows: 3,
  maxRows: 3,
  priority: 2,
  callback: function (printOptions, matrix) {
    return determinant3x3(printOptions, matrix, Expression.getSomeDetails("determinantSarrus").replace(/\$\{link\}/g, i18n.ruleOfSarrusLink));
  }
});
Expression.Details.add({
  type: "determinant-Triangle",
  i18n: function () {
    return i18n.det.ruleOfTriangle;
  },
  minRows: 3,
  maxRows: 3,
  priority: 3,
  callback: function (printOptions, matrix) {
    return determinant3x3(printOptions, matrix, Expression.getSomeDetails("determinantTriangle").replace(/\$\{link\}/g, i18n.ruleOfTriangleLink));
  }
}); // https://www.math.susu.ac.ru/193-2.html
// https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order

Matrix.permutations = function (n, callback) {
  function reverse(p, from, to, even) {
    for (var i = from; i < to - 1 - (i - from); i += 1) {
      var j = to - 1 - (i - from);
      var tmp = p[j];
      p[j] = p[i];
      p[i] = tmp;
      even = !even;
    }

    return even;
  }

  if (n !== Math.floor(n) || n < 1) {
    throw new RangeError();
  }

  var p = new Array(n);
  var even = true;

  for (var i = 0; i < n; i += 1) {
    p[i] = i;
  }

  while (true) {
    var indexOfZero = callback(p, even);
    even = reverse(p, indexOfZero + 1, n, even);
    var k = n - 2;
    var l = n - 1;

    while (k >= 0 && p[k] > p[k + 1]) {
      k -= 1;
    }

    if (k < 0) {
      return;
    }

    while (p[k] > p[l]) {
      l -= 1;
    }

    var tmp = p[k];
    p[k] = p[l];
    p[l] = tmp;
    even = !even;
    even = reverse(p, k + 1, n, even);
  }
};

Matrix.prototype.determinantLeibniz = function () {
  if (!this.isSquare()) {
    throw new RangeError("NonSquareMatrixException");
  } //TODO: output (?) + 0 + ... + 0


  var determinant = undefined;
  var bestZeroGroup = null;
  var bestZeroGroupIndexOfZero = 0;
  var matrix = this;
  var n = matrix.cols(); //TODO: skip iterations when an element is zero

  Matrix.permutations(n, function (p, even) {
    var t = undefined;
    var indexOfZero = n;

    for (var i = 0; i < n; i += 1) {
      var e = matrix.e(i, p[i]);

      if (e.unwrap().equals(Expression.ZERO)) {
        if (indexOfZero === n) {
          indexOfZero = i;
        }
      }

      t = t == undefined ? e : t.multiply(e);
    }

    if (indexOfZero < n && n > 4 && t instanceof NonSimplifiedExpression) {
      //TODO: ?
      //TODO: output 0 + ... + 0
      //t = t instanceof NonSimplifiedExpression ? new NonSimplifiedExpression(Expression.ZERO) : Expression.ZERO;
      //determinant = determinant == undefined ? (even ? t : t.negate()) : (even ? determinant.add(t) : determinant.subtract(t));
      if (bestZeroGroupIndexOfZero < indexOfZero) {
        bestZeroGroupIndexOfZero = indexOfZero;
        bestZeroGroup = even ? t : t.negate();
      }
    } else {
      determinant = determinant == undefined ? even ? t : t.negate() : even ? determinant.add(t) : determinant.subtract(t);
    }

    return indexOfZero < n ? indexOfZero : n;
  });

  if (determinant == undefined) {
    determinant = bestZeroGroup;
  }

  console.assert(determinant != undefined);
  return determinant == undefined ? Expression.ZERO : determinant;
}; //???


Expression.Details.add({
  type: "determinant-Leibniz",
  i18n: function () {
    return i18n.det.formulaOfLeibniz;
  },
  minRows: 4,
  //TODO: when a lot of zeros (?): compute the number of permutations (?)
  maxRows: 6,
  //?
  priority: -2,
  callback: function (printOptions, matrix) {
    var highlights = '';
    var html = "";
    html += "<math>";

    if (true) {
      var nsMatrix = matrix.map(function (e, i, j) {
        return new NonSimplifiedExpression(e);
      });
      html += new Expression.Determinant(new Expression.Matrix(nsMatrix)).toMathML(Object.assign({}, printOptions, {
        cellIdGenerator: function (i, j) {
          return nsMatrix.e(i, j).getId();
        }
      }));
      html += "<mo>=</mo>";
      var e = nsMatrix.determinantLeibniz();
      var elements = [];

      for (var s = e; s != null; s = (s.unwrap() instanceof Expression.Addition || s.unwrap() instanceof Expression.Subtraction) && s.unwrap().a instanceof NonSimplifiedExpression ? s.unwrap().a : null) {
        var x = (s.unwrap() instanceof Expression.Addition || s.unwrap() instanceof Expression.Subtraction) && s.unwrap().a instanceof NonSimplifiedExpression ? s.unwrap().b : s;
        elements.push({
          e: x,
          sign: s.unwrap() instanceof Expression.Subtraction ? '&minus;' : '+'
        });
      }

      html += elements.length !== 1 ? '<mrow>' : '';

      for (var i = elements.length - 1; i >= 0; i -= 1) {
        var x = elements[i].e;
        var sign = elements[i].sign;

        if (i !== elements.length - 1 || sign !== '+') {
          //TODO: some details about sign
          html += '<mpadded width="+0.8em" lspace="+0.4em">' + '<mo>' + sign + '</mo>' + '</mpadded>';
        }

        html += "<mrow id=\"" + x.getId() + "\">";
        html += x.toMathML(printOptions);
        html += "</mrow>";
        var highlight = '<a class="a-highlight" data-for="' + x.getId().toString() + '" data-highlight="' + x.unwrap().getIds() + '"></a>';
        highlights += highlight;
      }

      html += elements.length !== 1 ? '</mrow>' : '';
    } else {
      html += new Expression.Determinant(new Expression.Matrix(matrix)).toMathML(printOptions); //TODO: formula - ?
      //html += "<mo>=</mo>";
      //html += "";

      html += "<mo>=</mo>";
      html += matrix.map(function (e, i, j) {
        return new NonSimplifiedExpression(e);
      }).determinantLeibniz().toMathML(printOptions);
    }

    if (matrix.cols() > 1) {
      html += "<mo>=</mo>";
      html += matrix.determinantLeibniz().toMathML(printOptions);
    }

    html += "</math>";
    html += " ";
    html += i18n.determinantLeibnizLink;
    html += '<div hidden>' + highlights + '</div>';
    return html;
  }
});

Expression.mgetZero = function (m, k, callback) {
  // m == n ; in a column k -- find in k-column non-zero element and ... subtract
  callback = callback || undefined;
  var i = 0;

  while (i < m.rows() && m.e(i, k).equals(Expression.ZERO)) {
    i += 1;
  }

  if (i < m.rows()) {
    // Matrix.toRowEchelonStep - ?
    var j = -1;

    while (++j < m.rows()) {
      if (j !== i) {
        if (!m.e(j, k).equals(Expression.ZERO)) {
          var oldMatrix = m;
          m = m.rowReduce(j, i, k);

          if (callback != undefined) {
            callback({
              previousPivot: undefined,
              newMatrix: m,
              oldMatrix: oldMatrix,
              type: "reduce",
              targetRow: j,
              pivotRow: i,
              pivotColumn: k
            });
          }
        }
      }
    }

    return {
      B: m,
      c: {
        e: m.e(i, k),
        i: i,
        j: k
      }
    }; // r?
  }

  return {
    B: m,
    c: null
  };
}; //TODO: better details


Expression.getZero = function (matrix, atRow, number, printOptions) {
  var k = Number(number.toString()) - 1; //!

  if (!matrix.isSquare()) {
    throw new RangeError("NonSquareMatrixException");
  }

  if (k >= matrix.rows() || k < 0 || k !== Math.floor(k)) {
    // matrix.isSquare() === true
    throw new RangeError("IntegerInputError" + ":" + (atRow ? "k-A-o-r" : "k-A-o-c"));
  } //!


  var containerId = printOptions.idPrefix; //?

  var text = "";
  var html = "";

  if (atRow) {
    html += "<math>";
  }

  var step = 1;
  var tmp = Expression.mgetZero(atRow ? matrix.transpose() : matrix, k, function (change) {
    if (atRow) {
      //TODO:
      html += new Expression.Determinant(new Expression.Matrix(change.oldMatrix.transpose())).toMathML(printOptions);
      var jT = "<code>" + localeString(change.targetRow + 1) + "</code>";
      var iT = "<code>" + localeString(change.pivotRow + 1) + "</code>"; //TODO: why English is not used as fallback ?

      var multiplier = change.oldMatrix.e(change.targetRow, change.pivotColumn).divide(change.oldMatrix.e(change.pivotRow, change.pivotColumn));
      var areBracketsRequired = multiplier.getPrecedence(multiplier) !== Expression.ZERO.getPrecedence(); //? not simple

      var questionId = containerId + "-" + step + "-" + "question-mark";
      var tooltip = (i18n.eliminationDetails.columnSubtraction || '').replace(/\$\{a\}/g, "<code>" + "<math>" + (areBracketsRequired ? "<mrow><mo>(</mo>" : "") + multiplier.toMathML(printOptions) + (areBracketsRequired ? "<mo>)</mo></mrow>" : "") + "</math>" + "</code>").replace(/\$\{j\}/g, jT).replace(/\$\{i\}/g, iT).replace(/\$\{someDetails3\}/g, Expression.getSomeDetails("someDetails3"));
      tooltip += ''; //TODO: class

      html += '<mpadded width="+0.8em" lspace="+0.4em">';
      html += '<mover accent="true"><mo>=</mo><mtext><a class="question-icon-new" id="' + questionId + '">?</a><a class="a-tooltip" data-for="' + questionId + '" hidden>' + tooltip + '</a></mtext></mover>';
      html += '</mpadded>';
    } else {
      html += Expression.rowReduceChangeToHTML(change, Object.assign({}, printOptions, {
        _isDeterminant: true
      }), containerId, step, Condition.TRUE);
    }

    step += 1;
  });
  var B = tmp.B;
  var c = tmp.c;

  if (atRow) {
    B = B.transpose();
    c = c == null ? null : {
      e: c.e,
      i: c.j,
      j: c.i
    };
  }

  if (!atRow) {
    html += "<math>";
  } //TODO: share with the `Expression.rowReduceChangeToHTML` !!!


  var cellId = function (k, i, j) {
    return containerId + "-" + k.toString() + "-" + i.toString() + "-" + j.toString();
  };

  html += new Expression.Determinant(new Expression.Matrix(B)).toMathML(Object.assign({}, printOptions, {
    cellIdGenerator: function (i, j) {
      return cellId(step, i, j);
    }
  }));
  html += "<mo>=</mo>";
  var result = null;

  if (c == null) {
    result = Expression.ZERO;
  } else {
    var t = B.minorMatrix(c.i, c.j);

    if (t.cols() === 0) {
      result = c.e;
    } else {
      var n = Expression.Integer.fromNumber(Math.pow(-1, c.i + c.j));
      result = n.multiply(c.e).multiply(t.determinant());
      var ie = new NonSimplifiedExpression(Expression.Integer.fromNumber(c.i + 1));
      var je = new NonSimplifiedExpression(Expression.Integer.fromNumber(c.j + 1));
      html += Expression.p('(-1)**(i+j)*e*D', {
        i: ie,
        j: je,
        e: c.e,
        // TODO: link the element
        D: new Expression.Minor(new Expression.Matrix(B), c.i, c.j)
      }, Object.assign({}, printOptions, {
        printId: true
      })); // TODO: share with expansion

      text += '<a class="a-tooltip" data-for="' + ie.getId() + '" hidden>';
      text += '<math>' + '<msub><mi>a</mi><mrow><mstyle mathvariant="bold">' + Expression.p(c.i + 1) + '</mstyle><mo>,</mo>' + Expression.p(c.j + 1) + '</mrow></msub>' + '</math>';
      text += '</a>';
      text += '<a class="a-tooltip" data-for="' + je.getId() + '" hidden>';
      text += '<math>' + '<msub><mi>a</mi><mrow>' + Expression.p(c.i + 1) + '<mo>,</mo><mstyle mathvariant="bold">' + Expression.p(c.j + 1) + '</mstyle></mrow></msub>' + '</math>';
      text += '</a>';
      html += "<mo>=</mo>";
    }
  }

  html += result.toMathML(printOptions);
  html += "</math>";
  html += "<span hidden>" + text + "</span>";
  return html;
}; // --------------------------------------------- end ----------------------------------------------
// ---------------------------------------- sle -----------------------------------------------


Matrix.trimRight = function (x) {
  var lastColumn = -1;
  x.map(function (e, i, j) {
    if (lastColumn < j && !e.equals(Expression.ZERO)) {
      lastColumn = j;
    }

    return e;
  });
  return x.slice(0, x.rows(), 0, lastColumn + 1);
};

var testSLECompatibility = function (printOptions, fullMatrix) {
  if (fullMatrix.cols() < 1) {
    throw new RangeError("ValueMissingError:A-textarea"); //TODO: fix
  }

  var st = "<h4>" + i18n.consistency.analyseCompatibilityOfTheSystem + "</h4>"; //TODO: fix i18n

  st += "<p>" + i18n.consistency.analyseCompatibilityIntroduction + "</p>";
  var m = Matrix.trimRight(fullMatrix.slice(0, fullMatrix.rows(), 0, fullMatrix.cols() - 1));
  var b = fullMatrix.slice(0, fullMatrix.rows(), fullMatrix.cols() - 1, fullMatrix.cols());
  var augmented = m.augment(b);
  var results = [];
  Matrix.toRowEchelonWithCallback(augmented, Matrix.GaussMontante, "", null, function (result) {
    results.push(result);
  });

  if (results.length > 1) {
    st += "<ol>";
  }

  for (var i = 0; i < results.length; i += 1) {
    st += results.length > 1 ? "<li><div>" + "<math>" + results[i].condition.toMathML(printOptions) + "</math>" : "";
    var t = results[i].matrix;
    var mRank = t.slice(0, t.rows(), 0, t.cols() - 1).rank();
    var augmentedRank = t.rank(); //var mRank = m.rank();
    //var augmentedRank = augmented.rank();

    st += "<div>";
    st += "<math>";
    st += new Expression.Rank(new Expression.Matrix(augmented)).toMathML(Object.assign({}, printOptions, {
      columnlines: -1
    })) + "<mo>=</mo>" + Expression.p(augmentedRank);
    st += "</math>";
    st += "</div>"; //st += createDetailsSummary(printOptions.idPrefix, [{type: "rank", matrix: augmented.toString(), second: undefined}]);

    st += "<div>";
    st += "<math>";
    st += new Expression.Rank(new Expression.Matrix(m)).toMathML(printOptions) + "<mo>=</mo>" + Expression.p(mRank);
    st += "</math>";
    st += "</div>"; //st += createDetailsSummary(printOptions.idPrefix, [{type: "rank", matrix: m.toString(), second: undefined}]);

    st += "<div>";

    if (mRank === augmentedRank) {
      if (m.cols() === mRank) {
        st += i18n.consistency.theSystemIsConsistentAndItHasAUniqueSolution;
      } else {
        st += i18n.consistency.theSystemIsConsistentAndItHasInfiniteNumberOfSolutions;
      }
    } else {
      st += i18n.consistency.theSystemIsInconsistent;
    }

    st += "</div>";
    st += results.length > 1 ? "</div></li>" : "";
  }

  if (results.length > 1) {
    st += "</ol>";
  } //!new


  st += createDetailsSummary(printOptions.idPrefix, [{
    type: "rank",
    matrix: augmented.toString(),
    second: undefined
  }]); //!new

  return st;
};

Expression.Details.add({
  type: "analyse-compatibility",
  i18n: function () {
    return i18n.slu.testForConsistency; //?
  },
  minRows: 1,
  callback: function (printOptions, matrix) {
    return testSLECompatibility(printOptions, matrix);
  }
}); //TODO: move

var outSystem = function (printOptions, matrix, variableNames) {
  return new Expression.Matrix(matrix).toMathML(Object.assign({}, printOptions, {
    variableNames: variableNames,
    useBraces: ["{", " "]
  }));
}; //! TODO: (!)


var makeDefaultVariableNames = function (count) {
  var variableNames = new Array(count);

  for (var i = 0; i < count; i += 1) {
    variableNames[i] = "x_" + (i + 1).toString();
  }

  return variableNames;
};

var solveUsingCramersRule = function (printOptions, fullMatrix, variableNames) {
  if (fullMatrix.cols() < 2) {
    throw new RangeError("ValueMissingError:A-textarea"); //TODO: fix
  } // TODO: fix
  //!hack


  if (variableNames == undefined) {
    variableNames = makeDefaultVariableNames(fullMatrix.cols() - 1);
  }

  var m = Matrix.trimRight(fullMatrix.slice(0, fullMatrix.rows(), 0, fullMatrix.cols() - 1));
  var b = fullMatrix.slice(0, fullMatrix.rows(), fullMatrix.cols() - 1, fullMatrix.cols());

  if (!m.isSquare()) {
    throw new RangeError("NonSquareMatrixException:" + i18n.systems.forSolutionUsingCramersRuleNumberOfEquationsShouldBeEqualNumberOfVariables);
  }

  var D0 = m.determinant();
  var mstr = "";
  mstr = "<h4>" + i18n.systems.solutionByRuleOfCramer + "</h4>";
  mstr += "<div>";
  mstr += "<math>";
  mstr += outSystem(printOptions, fullMatrix, variableNames);
  mstr += "</math>";
  mstr += "</div>";
  mstr += "<div>";
  mstr += "<math>";
  mstr += "<mi>Δ</mi>";
  mstr += "<mo>=</mo>" + new Expression.Determinant(new Expression.Matrix(m)).toMathML(printOptions);
  mstr += "<mo>=</mo>" + D0.toMathML(printOptions);
  mstr += "</math>";
  mstr += "</div>";
  mstr += createDetailsSummary(printOptions.idPrefix, [{
    type: m.getDeterminantEventType("determinant").type,
    matrix: m.toString(),
    second: undefined
  }]);

  if (D0.equals(Expression.ZERO)) {
    //TODO: fix text
    mstr += "<div>";
    mstr += i18n.systems.forSolutionUsingCramersRuleCoefficientMatrixShouldHaveNonZeroDeterminant;
    mstr += "</div>";
    return mstr;
  }

  var d = new Array(m.cols());
  mstr += '<ul class="list-unstyled">';

  for (var i = 0; i < m.cols(); i += 1) {
    mstr += "<li>";
    var m1 = m.map(function (e, row, col) {
      return col === i ? b.e(row, 0) : e;
    });
    d[i] = m1.determinant();
    mstr += "<math>";
    mstr += "<msub><mi>Δ</mi>" + Expression.p(i + 1) + "</msub>" + "<mo>=</mo>" + new Expression.Determinant(new Expression.Matrix(m1)).toMathML(printOptions) + "<mo>=</mo>" + d[i].toMathML(printOptions);
    mstr += "</math>";
    mstr += ";";
    mstr += createDetailsSummary(printOptions.idPrefix, [{
      type: m1.getDeterminantEventType("determinant").type,
      matrix: m1.toString(),
      second: undefined
    }]);
    mstr += "</li>";
  }

  mstr += '</ul>';
  mstr += '<ul class="list-unstyled">';

  for (var i = 0; i < m.cols(); i += 1) {
    mstr += "<li>";
    mstr += "<math>";
    mstr += new Expression.Symbol(variableNames[i]).toMathML(printOptions);
    var deltaI = new NonSimplifiedExpression(d[i]).divide(new NonSimplifiedExpression(D0));
    var deltaISimplified = deltaI.simplify();
    mstr += "<mo>=</mo>" + "<mrow><msub><mi>Δ</mi>" + Expression.p(i + 1) + "</msub><mo>&#x2215;</mo><mi>Δ</mi></mrow>";
    mstr += "<mo>=</mo>" + deltaI.toMathML(printOptions);

    if (deltaI.toString() !== deltaISimplified.toString()) {
      //?
      mstr += "<mo>=</mo>" + deltaISimplified.toMathML(printOptions);
    }

    mstr += "</math>";
    mstr += "</li>";
  }

  mstr += "</ul>";
  mstr += "<div>" + i18n.systems.answer + "</div>";
  mstr += '<ul class="list-unstyled">';

  for (var i = 0; i < m.cols(); i += 1) {
    mstr += "<li>";
    mstr += "<math>";
    mstr += new Expression.Symbol(variableNames[i]).toMathML(printOptions) + "<mo>=</mo>" + d[i].divide(D0).toMathML(printOptions);
    mstr += "</math>";
    mstr += "</li>";
  }

  mstr += '</ul>'; //TODO: ? use cases ? t*x=t - ?

  var condition = Condition.TRUE.andNotZero(D0);

  if (!condition.isTrue()) {
    mstr += "<div>";
    mstr += "<math>";
    mstr += "<mrow><mo>(</mo>";
    mstr += condition.toMathML(printOptions);
    mstr += "<mo>)</mo></mrow>";
    mstr += "</math>";
    mstr += "</div>";
  } //TODO: some text about solution when !condition.isFalse()


  return mstr;
}; // SLE solution with inverse matrix


var solveUsingInverseMatrixMethod = function (printOptions, fullMatrix, variableNames) {
  if (fullMatrix.cols() < 2) {
    throw new RangeError("ValueMissingError:A-textarea"); //TODO: fix
  } //TODO: use variableNames (?)


  var m = Matrix.trimRight(fullMatrix.slice(0, fullMatrix.rows(), 0, fullMatrix.cols() - 1));
  var b = fullMatrix.slice(0, fullMatrix.rows(), fullMatrix.cols() - 1, fullMatrix.cols());
  var mstr = "";
  var c = undefined;

  if (!m.isSquare()) {
    throw new RangeError("NonSquareMatrixException:" + i18n.systems.toSolveSystemByInverseMatrixMethodNumberOfEquationsShouldBeEqualNumberOfVariables);
  }

  try {
    c = m.inverse();
  } catch (error) {
    if (error instanceof RangeError && error.message.indexOf("SingularMatrixException") === 0) {//mstr = i18n.systems.toSolveSystemByInverseMatrixMethodCoefficientMatrixShouldHaveNonZeroDeterminant;
    } else {
      throw error;
    }
  }

  mstr += "<h4>" + i18n.systems.solutionByInverseMatrixMethod + "</h4>";
  mstr += "<div>";
  mstr += "<math>";
  mstr += "<mrow><mi>A</mi><mo>&sdot;</mo><mi>X</mi></mrow><mo>=</mo><mi>B</mi>";
  mstr += "</math>";
  mstr += "</div>";
  mstr += "<div>";
  mstr += "<math>";
  mstr += "<mi>A</mi><mo>=</mo>" + new Expression.Matrix(m).toMathML(printOptions);
  mstr += "</math>";
  mstr += "</div>";
  mstr += "<div>";
  mstr += "<math>";
  mstr += "<mi>B</mi><mo>=</mo>" + new Expression.Matrix(b).toMathML(printOptions);
  mstr += "</math>";
  mstr += "</div>";

  if (c != undefined) {
    mstr += "<div>";
    mstr += "<math>";
    mstr += "<msup><mi>A</mi><mrow><mo>&minus;</mo>" + Expression.p(1) + "</mrow></msup><mo>=</mo>" + new Expression.Matrix(c).toMathML(printOptions);
    mstr += "</math>";
    mstr += "</div>";
    mstr += createDetailsSummary(printOptions.idPrefix, [{
      type: m.getDeterminantEventType("inverse").type,
      matrix: m.toString(),
      second: undefined
    }]);
    mstr += "<div>";
    mstr += "<math>"; //TODO: multiplicaiton details (?)

    mstr += "<mi>X</mi><mo>=</mo><mrow><msup><mi>A</mi><mrow><mo>&minus;</mo>" + Expression.p(1) + "</mrow></msup><mo>&sdot;</mo><mi>B</mi></mrow><mo>=</mo><mrow>" + new Expression.Matrix(c).toMathML(printOptions) + "<mo>&sdot;</mo>" + new Expression.Matrix(b).toMathML(printOptions) + "</mrow><mo>=</mo>" + new Expression.Matrix(c.multiply(b)).toMathML(printOptions);
    mstr += "</math>";
    mstr += "</div>";
  } else {
    mstr += i18n.systems.toSolveSystemByInverseMatrixMethodCoefficientMatrixShouldHaveNonZeroDeterminant;
    mstr += createDetailsSummary(printOptions.idPrefix, [{
      type: m.getDeterminantEventType("inverse").type,
      matrix: m.toString(),
      second: undefined
    }]);
    mstr += "<div class=\"for-details\"></div>";
  }

  return mstr;
}; //----------Gauss
// getting row echelon form without columns swapping


Expression.rowReduceChangeToHTML = function (change, printOptions, containerId, k, stepCondition) {
  var multiplier = change.type === "reduce" ? change.oldMatrix.e(change.targetRow, change.pivotColumn).divide(change.oldMatrix.e(change.pivotRow, change.pivotColumn)) : undefined;
  var areBracketsRequired = change.type === "reduce" ? multiplier.getPrecedence(multiplier) !== Expression.ZERO.getPrecedence() : undefined; //? not simple

  var jT = "<code>" + localeString(change.targetRow + 1) + "</code>";
  var iT = "<code>" + localeString(change.pivotRow + 1) + "</code>";
  var tooltip = (change.type === "swap-negate" ? i18n.eliminationDetails.rowSwapNegate.replace(/\$\{\-1\}/g, "<math>" + "<mo>&minus;</mo>" + Expression.p(1) + "</math>").replace(/\$\{j\}/g, jT).replace(/\$\{i\}/g, iT) : "") + (change.type === "swap" ? i18n.eliminationDetails.rowSwap.replace(/\$\{j\}/g, jT).replace(/\$\{i\}/g, iT) : "") + (change.type === "divide" ? i18n.eliminationDetails.rowDivision.replace(/\$\{a\}/g, "<code>" + "<math>" + change.oldMatrix.e(change.pivotRow, change.pivotColumn).toMathML(printOptions) + "</math>" + "</code>").replace(/\$\{j\}/g, jT).replace(/\$\{i\}/g, iT) : "") + (change.type === "reduce" ? i18n.eliminationDetails.rowSubtraction.replace(/\$\{a\}/g, "<code>" + "<math>" + (areBracketsRequired ? "<mrow><mo>(</mo>" : "") + multiplier.toMathML(printOptions) + (areBracketsRequired ? "<mo>)</mo></mrow>" : "") + "</math>" + "</code>").replace(/\$\{j\}/g, jT).replace(/\$\{i\}/g, iT) : "");
  var text = "";

  var cellId = function (k, i, j) {
    return containerId + "-" + k.toString() + "-" + i.toString() + "-" + j.toString();
  };

  var questionId = containerId + "-" + k.toString() + "-" + "question-mark";
  k += 1; //!

  for (var i = 0; i < change.oldMatrix.cols(); i += 1) {
    if (change.type === "reduce" || change.type === "divide") {
      var highlight = "<a class=\"a-highlight\" data-for=\"" + cellId(k, change.targetRow, i) + "\" data-highlight=\"" + "#" + cellId(k - 1, change.pivotRow, change.pivotColumn) + ", " + "#" + cellId(k - 1, change.targetRow, i) + ", " + (change.type === "reduce" ? "#" + cellId(k - 1, change.targetRow, change.pivotColumn) + ", " : "") + (change.type === "reduce" ? "#" + cellId(k - 1, change.pivotRow, i) + ", " : "") + "#" + cellId(k, change.targetRow, i) + "\"></a>";
      text += "<a class=\"a-tooltip\" data-for=\"" + cellId(k, change.targetRow, i) + "\" hidden>" + "<math>" + Expression.p("a_(" + (change.targetRow + 1) + "," + (i + 1) + ")=" + (change.type === "reduce" ? "(b-(c/a)*d)" : "(b*(1/a))") + "=r", {
        a: change.oldMatrix.e(change.pivotRow, change.pivotColumn),
        b: change.oldMatrix.e(change.targetRow, i),
        c: change.oldMatrix.e(change.targetRow, change.pivotColumn),
        d: change.oldMatrix.e(change.pivotRow, i),
        r: change.newMatrix.e(change.targetRow, i)
      }, printOptions) + "</math>" + "</a>" + highlight;
    } else if (change.type === "swap" || change.type === "swap-negate") {
      text += "<a class=\"a-highlight\" data-for=\"" + cellId(k, change.targetRow, i) + "\" data-highlight=\"" + "#" + cellId(k - 1, change.pivotRow, i) + ", " + "#" + cellId(k - 1, change.targetRow, i) + ", " + "#" + cellId(k, change.targetRow, i) + "\"></a>";
      text += "<a class=\"a-highlight\" data-for=\"" + cellId(k, change.pivotRow, i) + "\" data-highlight=\"" + "#" + cellId(k - 1, change.targetRow, i) + ", " + "#" + cellId(k - 1, change.pivotRow, i) + ", " + "#" + cellId(k, change.pivotRow, i) + "\"></a>";
    }
  }

  var M = new Expression.Matrix(change.oldMatrix);
  return "<span class=\"nowrap\">" + "<math>" + (printOptions._isDeterminant ? new Expression.Determinant(M) : M).toMathML(Object.assign({}, printOptions, {
    columnlines: printOptions.columnlines,
    cellIdGenerator: function (i, j) {
      return cellId(k - 1, i, j);
    },
    pivotCell: change.type === "swap" || change.type === "swap-negate" ? undefined : {
      i: change.pivotRow,
      j: change.pivotColumn
    }
  })) + "</math>" + "<span class=\"arrow-with-label\" data-custom-paint=\"arrow-with-label\" data-type=\"" + change.type + "\" data-start=\"" + change.pivotRow + "\" data-end=\"" + change.targetRow + "\">" + "<div class=\"arrow\" aria-label=\"" + (change.type === "swap" || change.type === "swap-negate" ? i18n.misc.swapLabelTitle : i18n.misc.labelTitle).replace(/\$\{x\}/g, change.pivotRow).replace(/\$\{y\}/g, change.targetRow) + "\">" + (change.type === "swap" || change.type === "swap-negate" || change.pivotRow < change.targetRow ? "<div class=\"arrow-head-bottom\"></div>" : "") + (change.type === "swap" || change.type === "swap-negate" || change.pivotRow > change.targetRow ? "<div class=\"arrow-head-top\"></div>" : "") + (change.type !== "divide" ? "<div class=\"arrow-line\"></div>" : "") + "</div>" + "<div class=\"label\">" + (change.type === "swap" ? "" : change.type === "swap-negate" ? "" : "<math>" + (change.type === "divide" ? "<mo>&times;</mo>" + "<mrow><mo>(</mo>" + Expression.ONE.divide(change.oldMatrix.e(change.targetRow, change.pivotColumn)).toMathML(printOptions) + "<mo>)</mo></mrow>" : "<mo>&times;</mo>" + "<mrow><mo>(</mo>" + multiplier.negate().toMathML(printOptions) + "<mo>)</mo></mrow>") + "</math>") + "</div>" + "</span>" + "</span>" + "<math>" + "<mpadded width=\"+0.8em\" lspace=\"+0.4em\">" + "<mover accent=\"true\">" + (printOptions._isDeterminant ? "<mo>=</mo>" : "<munder accentunder=\"true\">" + "<mo stretchy=\"false\">" + "~" + "</mo>" + (stepCondition.isTrue() ? "" : "<munder accentunder=\"true\">") + "<mrow>" + ((change.type === "swap-negate" ? "${i}<mo>&harr;</mo><mrow><mo>&minus;</mo>${j}</mrow>" : "") + (change.type === "swap" ? "${i}<mo>&harr;</mo>${j}" : "") + (change.type === "divide" ? "${j}<mo>&#x2215;</mo><mrow><mo>(</mo>${a}<mo>)</mo></mrow><mo>&rarr;</mo>${j}".replace(/\$\{a\}/g, change.oldMatrix.e(change.pivotRow, change.pivotColumn).toMathML(printOptions)) : "") + (change.type === "reduce" ? "<mrow>${j}<mo>&minus;</mo><mrow>${a}<mo>&sdot;</mo>${i}</mrow></mrow><mo>&rarr;</mo>${j}".replace(/\$\{a\}/g, (areBracketsRequired ? "<mrow><mo>(</mo>" : "") + (printOptions.isLUDecomposition != undefined ? "<mrow mathbackground=\"#80FF80\" mathcolor=\"#3C78C2\">" : "") + multiplier.toMathML(printOptions) + (printOptions.isLUDecomposition != undefined ? "</mrow>" : "") + (areBracketsRequired ? "<mo>)</mo></mrow>" : "")) : "")).replace(/\$\{j\}/g, getMatrixRowDenotation(change.targetRow + 1)).replace(/\$\{i\}/g, getMatrixRowDenotation(change.pivotRow + 1)) + "</mrow>" + (stepCondition.isTrue() ? "" : stepCondition.toMathML(printOptions)) + (stepCondition.isTrue() ? "" : "</munder>") + "</munder>" + "") + "<mtext>" + ( // Note: <a> is not allowed in <a>
  tooltip !== "" ? "<a class=\"question-icon-new\" id=\"" + questionId + "\">?</a><span class=\"a-tooltip\" data-for=\"" + questionId + "\" hidden>" + tooltip + "</span>" : "") + (text !== "" ? "<span hidden>" + text + "</span>" : "") + "</mtext>" + "</mover>" + "</mpadded>" + "</math>";
};

Expression.rowReductionGaussJordanMontante = function (matrix, method, usage, printOptions, resultCallback, flag0) {
  flag0 = flag0 == undefined ? false : flag0;
  var containerId = printOptions.idPrefix + "-" + Expression.id();
  var html = "";
  var k = 0;
  html += "<div class=\"math-block\">";

  var outputTailMatrix = function (stoppedAtRow, matrix) {
    html += "<math>";
    html += new Expression.Matrix(matrix).toMathML(Object.assign({}, printOptions, {
      cellIdGenerator: function (i, j) {
        return containerId + "-" + k.toString() + "-" + i.toString() + "-" + j.toString();
      },
      highlightRow: stoppedAtRow
    }));
    html += "</math>";
    html += "</div>";
    k += 1;
  }; //2017-01-04:


  var oldCondition = Condition.TRUE; //---

  var result = matrix.toRowEchelonXXX(method, usage, function (change) {
    //2017-09-29:
    var stepCondition = Condition.TRUE;

    if (usage !== "determinant" && usage !== "inverse") {
      // not a "determinant" or a "inverse" calculation
      //2017-01-04:
      var pivot = change.oldMatrix.e(change.pivotRow, change.pivotColumn);
      stepCondition = Condition.TRUE.andNotZero(pivot);

      if (!stepCondition.isTrue()) {
        //?
        oldCondition = oldCondition.andNotZero(pivot);
      }
    } //---
    // TODO: remove stepCondition - ?


    var rowReduceChangeToHTML = method === Matrix.GaussMontante ? Expression.rowReduceChangeToHTMLMontante : Expression.rowReduceChangeToHTML;
    html += rowReduceChangeToHTML(change, printOptions, containerId, k, stepCondition);
    k += 1;
  }, usage !== "determinant" && usage !== "inverse" && !flag0 ? Condition.TRUE : undefined);

  var w = function (result) {
    if (result.c1 == undefined && result.c2 == undefined) {
      outputTailMatrix(result.stoppedAtRow, result.matrix);
      html += resultCallback({
        matrix: result.matrix,
        stoppedAtRow: result.stoppedAtRow,
        condition: flag0 ? oldCondition : result.condition // TODO: use or remove ?

      });
    } else {
      outputTailMatrix(-1, result.matrix);
      html += "<ol>";
      html += "<li>";
      html += "<div>";
      html += "<math>";
      html += result.c1.toMathML(printOptions);
      html += "</math>";
      html += "</div>";
      html += "<div>";
      w(result.a1());
      html += "</li>";
      html += "<li>";
      html += "<div>";
      html += "<math>";
      html += result.c2.toMathML(printOptions);
      html += "</math>";
      html += "</div>";
      html += "<div>";
      w(result.a2());
      html += "</li>";
      html += "</ol>";
    }
  };

  w(result);
  return html;
};

Expression.solveByGaussNext = function (ms, printOptions, variableNames) {
  var condition = ms.condition; //?

  var m = ms.matrix; //!?

  if (condition != undefined) {
    m = m.map(function (e, i, j) {
      //return condition.andNotZero(e).isFalse() ? Expression.ZERO : e;
      return condition.updateExpression(e, {
        flag1: true
      });
    });
  } // 1. Throwing of null strings - they will be below, but checking: if we find a zero, which at the end has a non-zero, then there are no solutions!;


  var noSolutions = ms.stoppedAtRow !== -1; //!hack

  if (variableNames == undefined) {
    variableNames = makeDefaultVariableNames(m.cols() - 1);
  }

  if (noSolutions) {
    return {
      html: "<div>" + "<math>" + outSystem(printOptions, m, variableNames) + "</math>" + "</div>" + "<div>" + i18n.systems.thereAreNoSolutions + "</div>"
    };
  }

  var isHomogeneous = function (m) {
    for (var i = 0; i < m.rows(); i += 1) {
      if (!m.e(i, m.cols() - 1).equals(Expression.ZERO)) {
        return false;
      }
    }

    return true;
  }; // (?) TODO: allow users to specify "free" variables


  var containerId = printOptions.idPrefix + "-" + Expression.id();
  var systemId = containerId + "-" + "system_1";
  var mstr = "";

  if (!m.eql(Matrix.Zero(m.rows(), m.cols()))) {
    mstr += "<div class=\"anchor\" id=\"" + systemId + "\">" + "<table role=\"presentation\" class=\"system-table\">" + "<tr>" + "<td>" + "<math>" + outSystem(printOptions, m, variableNames) + "</math>" + "</td>" + "<td>" + "<a href=\"#" + systemId + "\">(" + localeString(1) + ")</a>" + "</td>" + "</tr>" + "</table>" + "</div>";
  }

  var isEquals = function (a, b) {
    if (a.length !== b.length) {
      return false;
    }

    for (var i = 0; i < a.length; i += 1) {
      if (!(a[i] instanceof NonSimplifiedExpression) || !(b[i] instanceof NonSimplifiedExpression)) {
        throw new TypeError();
      }

      if (!a[i].e.equals(b[i].e)) {
        // comparision without "simplification"
        return false;
      }
    }

    return true;
  };

  var nsVariableNames = new Array(m.cols() - 1);

  for (var i = 0; i < m.cols() - 1; i += 1) {
    nsVariableNames[i] = new NonSimplifiedExpression(new Expression.Symbol(variableNames[i]));
  }

  mstr += "<ul>";
  m = Matrix.solveByGaussNext(m, function (m, oldMatrix1, oldMatrix2, i, j) {
    //?
    //if (condition != undefined) {
    //condition = condition.andNotZero(oldMatrix1.e(i, j));
    //}
    //?
    mstr += "<li>";
    mstr += "<div>";
    mstr += i18n.systems.fromEquationIFindVariable.replace(/\$\{i\}/g, "<math>" + Expression.p(i + 1) + "</math>").replace(/\$\{x\}/g, "<math>" + new Expression.Symbol(variableNames[j]).toMathML(printOptions) + "</math>").replace(/\$\{#system_1\}/g, "<a href=\"#" + systemId + "\">(" + localeString(1) + ")</a>");
    mstr += "</div>";
    mstr += "<div>"; // We need to wrap using NonSimplifiedExpression to use in `isEquals`

    var equationSymbols1 = new Array(m.cols() - 1);
    var equationSymbols2 = new Array(m.cols() - 1);

    for (var k = 0; k < m.cols() - 1; k += 1) {
      var v = new NonSimplifiedExpression(nsVariableNames[k].e);
      equationSymbols1[k] = v;
      equationSymbols2[k] = v;

      if (k > j && !oldMatrix1.e(i, k).equals(Expression.ZERO)) {
        var pivotRowK = Matrix.getPivotRow(oldMatrix1, k);
        var y = pivotRowK === -1 ? v : new NonSimplifiedExpression(polynomialToExpression3(oldMatrix1, pivotRowK, nsVariableNames));
        equationSymbols2[k] = y;
      }
    }

    mstr += "<math>";
    var leftPartCoefficient = oldMatrix1.e(i, j);
    var leftPartVariable = new Expression.Symbol(variableNames[j]);
    var leftPart = leftPartCoefficient.equals(Expression.ONE) ? leftPartVariable : new Expression.Multiplication(leftPartCoefficient, leftPartVariable);
    mstr += leftPart.toMathML(printOptions);
    mstr += "<mo>=</mo>";
    var beforeSubstitution = polynomialToExpression3(oldMatrix1, i, equationSymbols1).toMathML(Object.assign({}, printOptions, {
      printId: true
    }));
    mstr += beforeSubstitution;
    var afterSubstitution = polynomialToExpression3(oldMatrix1, i, equationSymbols2).toMathML(Object.assign({}, printOptions, {
      printId: true
    }));

    if (!isEquals(equationSymbols1, equationSymbols2)) {
      mstr += "<mo>=</mo>";
      mstr += afterSubstitution;
    }

    var afterSimplification = polynomialToExpression3(oldMatrix2, i, nsVariableNames).toMathML(printOptions);

    if (!isEquals(equationSymbols2, nsVariableNames)) {
      mstr += "<mo>=</mo>";
      mstr += afterSimplification;
    }

    mstr += "</math>";
    mstr += "<div hidden>";

    for (var k = 0; k < nsVariableNames.length; k += 1) {
      if (!equationSymbols2[k].e.equals(nsVariableNames[k].e)) {
        mstr += "<a class=\"a-highlight\" data-for=\"" + equationSymbols2[k].getId() + "\" data-highlight=\"" + equationSymbols1[k].getId() + "\"></a>";
      }
    }

    mstr += "</div>";
    var afterDivision = polynomialToExpression3(m, i, nsVariableNames).toMathML(printOptions);

    if (!oldMatrix2.e(i, j).equals(Expression.ONE)) {
      mstr += "<div>"; //mstr += "<b>"; // does not work in Firefox 52 (Windows XP) with MathML

      mstr += "<math>";
      mstr += "<mstyle mathvariant=\"bold\">";
      mstr += new Expression.Symbol(variableNames[j]).toMathML(printOptions);
      mstr += "<mo>=</mo>";
      mstr += afterDivision;
      mstr += "</mstyle>";
      mstr += "</math>"; //mstr += "</b>";

      mstr += "</div>";
    }

    mstr += "</div>";
    mstr += "</li>";
  });
  mstr += "</ul>";
  var solutionsExpressions = new Array(m.cols() - 1);

  for (var i = 0; i < m.cols() - 1; i += 1) {
    solutionsExpressions[i] = Matrix.getPivotRow(m, i) === -1 ? nsVariableNames[i] : new NonSimplifiedExpression(polynomialToExpression3(m, Matrix.getPivotRow(m, i), nsVariableNames));
  }

  var solutionsExpressionsData = new Array(1);
  solutionsExpressionsData[0] = solutionsExpressions;
  var solutionsExpressionsMatrix = new Matrix(solutionsExpressionsData).transpose();

  if (true) {
    mstr += "<div>" + i18n.systems.answer + "</div>";

    if (condition != undefined && !condition.isTrue()) {
      mstr += "<div class=\"like-table\">";
    }

    mstr += "<ul class=\"list-unstyled\">";

    for (var i = 0; i < m.cols() - 1; i += 1) {
      mstr += "<li>";
      mstr += "<math>";
      mstr += new Expression.Symbol(variableNames[i]).toMathML(printOptions) + "<mo>=</mo>" + solutionsExpressions[i].toMathML(printOptions);
      mstr += "</math>";
      mstr += "</li>";
    }

    mstr += "</ul>"; //?

    if (condition != undefined && !condition.isTrue()) {
      mstr += "<math>";
      mstr += "<mrow><mo>(</mo>";
      mstr += condition.toMathML(printOptions);
      mstr += "<mo>)</mo></mrow>";
      mstr += "</math>";

      if (typeof hit === "function") {
        hit({
          condition: condition.toString() + "::" + m.toString()
        });
      }

      mstr += "</div>";
    } //?

  }

  if (true) {
    //TODO: remove - ?
    mstr += "<div>" + i18n.systems.generalSolution + " " + "<math>" + "<mi>X</mi><mo>=</mo>" + new Expression.Matrix(solutionsExpressionsMatrix).toMathML(printOptions) + "</math>" + "</div>";
  }

  if (isHomogeneous(m)) {
    var solutionSet = Matrix.getSolutionSet(m);

    if (solutionSet.basisVectors.length > 0) {
      var fundamentalSystemHTML = '';
      fundamentalSystemHTML += '<math>';
      fundamentalSystemHTML += '<mrow>';
      fundamentalSystemHTML += '<mo stretchy="false">{</mo>';
      fundamentalSystemHTML += solutionSet.basisVectors.length !== 1 ? '<mrow>' : '';

      for (var i = 0; i < solutionSet.basisVectors.length; i += 1) {
        var basisVector = new Expression.Matrix(solutionSet.basisVectors[i]);
        var freeVariable = nsVariableNames[solutionSet.variables[i]];
        fundamentalSystemHTML += i !== 0 ? '<mo>+</mo>' : '';
        fundamentalSystemHTML += '<mrow>' + freeVariable.toMathML(printOptions) + '<mo>&sdot;</mo>' + basisVector.toMathML(printOptions) + '</mrow>';
      }

      fundamentalSystemHTML += solutionSet.basisVectors.length !== 1 ? '</mrow>' : '';
      fundamentalSystemHTML += '<mo stretchy="false">}</mo>';
      fundamentalSystemHTML += '</mrow>';
      fundamentalSystemHTML += '</math>';
      mstr += '<div>' + i18n.systems.fundamentalSystem + ' ' + fundamentalSystemHTML + '</div>';
    }
  }

  return {
    html: mstr
  };
};

Expression.Details.add({
  type: "solve-using-Cramer's-rule",
  i18n: function () {
    return i18n.slu.solveByCrammer;
  },
  minRows: 1,
  callback: function (printOptions, matrix, variableNames) {
    return solveUsingCramersRule(printOptions, matrix, variableNames);
  }
});
Expression.Details.add({
  type: "solve-using-inverse-matrix-method",
  i18n: function () {
    return i18n.slu.solveByInverse;
  },
  minRows: 1,
  callback: function (printOptions, matrix, variableNames) {
    return solveUsingInverseMatrixMethod(printOptions, matrix, variableNames);
  }
}); //TODO: ?

Polynomial.toM1 = function (c, np, roots) {
  var e = undefined;

  if (!c.equals(Expression.ONE)) {
    if (!c.equals(Expression.ONE.negate())) {
      c = new NonSimplifiedExpression(c);
    }

    e = e != undefined ? new Expression.Multiplication(e, c) : c;
  }

  if (np.getDegree() === 0) {
    var x = np.getCoefficient(0);

    if (!x.equals(Expression.ONE)) {
      e = e != undefined ? new Expression.Multiplication(x, e) : x;
    }
  } //TODO: fix


  var multiplicity = 1;

  for (var i = 0; i < roots.length; i += 1) {
    var next = i < roots.length ? roots[i + 1] : null;

    if (roots[i] !== next) {
      var p = Polynomial.of(roots[i].negate(), Expression.ONE);
      var w = new Expression.Polynomial(p);

      if (multiplicity !== 1) {
        w = new Expression.Exponentiation(w, Expression.Integer.fromNumber(multiplicity));
      }

      e = e != undefined ? new Expression.Multiplication(e, w) : w;
      multiplicity = 1;
    } else {
      multiplicity += 1;
    }
  }

  if (roots.length === 0 || np.getDegree() !== 0) {
    //TODO: remove brackets
    var w = new Expression.Polynomial(np);
    e = e != undefined ? new Expression.Multiplication(e, w) : w; //html += "<mrow><mo>(</mo>" + np.toMathML(printOptions) + "<mo>)</mo></mrow>";
  }

  return e;
}; // -------------------------------------------- vectors -------------------------------------------


var polynomialRootsCallback = function (info, printOptions) {
  var result = "";
  var link = "";

  if (info.type === "useTheRationalRootTest") {
    link = i18n.useTheRationalRootTestLink;
  } else if (info.type === "solveQuadraticEquation") {
    link = i18n.solveQuadraticEquationLink;
  } else if (info.type === "solvePalindromicEquaion") {
    link = i18n.solvePalindromicEquaionLink;
  } else if (info.type === "(ax+b)**n") {
    link = i18n.binomialTheoremLink;
  } else if (info.type === "solveCubicEquation") {
    //?
    //TODO:
    link = i18n.solveCubicEquationLink;
  } else if (info.type === "solveQuarticEcuation") {
    //TODO: move
    link = i18n.solveQuarticEquationLink;
  } else if (info.type === "methodOfKronecker") {
    //?
    link = i18n.methodOfKroneckerLink;
  } else if (info.type === "applyDifferenceOfSquaresRule") {
    link = i18n.applyDifferenceOfSquaresRuleLink;
  } else if (info.type === "applyDifferenceOfCubesRule") {
    link = i18n.applyDifferenceOfCubesRuleLink;
  } else if (info.type === "applyDifferenceOfNthPowersRule") {
    link = i18n.applyDifferenceOfNthPowersRuleLink;
  } else if (info.type === "methodOfIntroducingANewVariable") {
    //TODO: ?
    link = '<math><mi>t</mi><mo>=</mo>' + info.t.toMathML() + '</math> - <a href="https://www.youtube.com/watch?v=_ou4r21swX4" title="Метод введения новой переменной">(?)</a>';
  } else if (info.type === "factorOutTheGreatestCommonFactor") {//TODO: ?
  } else if (info.type === "solveLinearEquation") {
    return ""; //!?
  } else if (info.type === "squareFreeFactorization") {
    link = i18n.squareFreeFactorizationLink;
  } else if (info.type === "eliminationOfTheSubDominantTerm") {
    link = "https://en.wikipedia.org/wiki/Algebraic_equation#Elimination_of_the_sub-dominant_term"; //TODO: ?

    var title = "Elimination of the sub-dominant term"; //TODO: variable names

    var tmp = Expression.p("x=t-b/(n*a)", {
      b: info.b,
      n: Expression.Integer.fromNumber(info.n),
      a: info.a
    }, printOptions);
    result = '<munder accentunder="true"><mo>=</mo><munder accentunder="true"><mrow>' + tmp + '</mrow><mtext><a href="' + link + '" title="' + title + '">(?)</a></mtext></munder></munder>';
  } else if (info.type === "realRootIsolationAndNewton'sMethod") {
    //TODO: "Используем численные методы (метод на основе правила знаков Декарта и метод Ньютона)"
    //TODO: what about complex roots - ?
    link = i18n.realRootIsolationAndNewtonsMethod;
    link = '<span style="max-width:9em;max-width:min-content;display:block;min-width:5em;">' + link + '</span>';
    result = link === "" ? "<mo>&asymp;</mo>" : "<munder accentunder=\"true\"><mo>&asymp;</mo><mtext>" + link + "</mtext></munder>";
  } else {
    //?
    //TODO: fix
    if (info.type !== "t = x^g") {
      console.assert(false);
    }
  }

  if (result === "") {
    if (info.type === "t = x^g" || link === "" && (info.type === "applyDifferenceOfSquaresRule" || info.type === "applyDifferenceOfCubesRule" || info.type === "applyDifferenceOfNthPowersRule")) {
      var variableName = printOptions.polynomialVariable;
      result += "<munder accentunder=\"true\"><mo>=</mo><mrow><mi>t</mi><mo>=</mo><msup><mi>${x}</mi><mn>${g}</mn></msup></mrow></munder>".replace(/\$\{x\}/g, variableName).replace(/\$\{g\}/g, localeString(info.g));
    } else {
      result += link === "" ? "<mo>=</mo>" : "<munder accentunder=\"true\"><mo>=</mo><mtext>" + link + "</mtext></munder>";
    }
  }

  result += Polynomial.toM1(info.content, info.newPolynomial, info.roots).toMathML(Object.assign({}, printOptions, info.newPolynomialVariable != undefined ? {
    polynomialVariable: info.newPolynomialVariable
  } : {}));
  return result;
};

Expression.getEigenvaluesWithSteps = function (printOptions, matrix) {
  var variableName = "λ";
  var lambda = new Expression.Symbol(variableName);
  printOptions = Object.assign({}, printOptions, {
    polynomialVariable: lambda
  });
  var steps = "";
  var tmp = Expression.getEigenvalues(matrix, printOptions.fractionDigits, function (info) {
    steps += polynomialRootsCallback(info, printOptions);
  });
  var characteristicPolynomial = tmp.characteristicPolynomial;
  var eigenvalues = tmp.eigenvalues;
  var multiplicities = tmp.multiplicities; //?

  var html = ""; //TODO: improve i18n (links to Wikipedia)

  var matrixWithLambdas = matrix.map(function (element, i, j) {
    return new NonSimplifiedExpression(i === j ? new Expression.Addition(new NonSimplifiedExpression(element), new Expression.Negation(lambda)) : element);
  });
  var v = new Expression.MatrixSymbol('v');

  var mathml = function (s) {
    return s.replace(/\$\{([^\}]+)\}/g, function (p, s) {
      return '<math' + (/[\*\-]/.test(s) ? ' display="block"' : '') + '>' + Expression.p(s.replace(/I/g, i18n.identityMatrixDenotation), {
        v: v
      }, {}) + '</math>';
    });
  };

  html += "<div>";
  html += mathml(i18n.eigenvalues.byDefinition);
  html += "</div>";
  html += "<div>";
  html += i18n.exponential.then;
  html += "<math display=\"block\">" + Expression.p("A*v-λ*v=(A-λI)*v=0".replace(/I/g, i18n.identityMatrixDenotation), {
    v: v
  }, {}) + "</math>";
  html += "</div>";
  html += "<div>";
  html += mathml(i18n.eigenvalues.equationHasNonZeroSolution);
  html += "</div>"; //html += "<div>";
  //html += i18n.eigenvalues.findEigenvaluesFromTheCharacteristicPolynomial;
  //html += "</div>";

  html += "<div>";
  html += "<math>";
  html += Expression.p("|(A-λI)|".replace(/I/g, i18n.identityMatrixDenotation), {
    v: v
  }, {});
  html += "<mo>=</mo>";
  html += new Expression.Determinant(new Expression.Matrix(matrixWithLambdas)).toMathML(printOptions) + "<mo>=</mo>" + characteristicPolynomial.toMathML(printOptions);
  html += steps;
  html += "<mo>=</mo>";
  html += Expression.p(0);
  html += "</math>";
  html += "</div>"; //?
  //TODO: fix

  html += createDetailsSummary(printOptions.idPrefix, [{
    type: "determinant",
    matrix: matrixWithLambdas.toString(),
    second: undefined
  }]); //?

  html += "<ol>";
  var n = -1;

  while (++n < eigenvalues.length) {
    var eigenvalue = eigenvalues[n];
    var equalsMathML = "<mo>" + (eigenvalue.isExact() ? "=" : "&asymp;") + "</mo>"; //TODO: output algebraic multiplicity

    html += "<li>";
    html += "<math>";
    html += Expression.p("λ_" + (n + 1));
    html += equalsMathML;
    html += eigenvalue.toMathML(printOptions);
    html += "</math>";
    html += "</li>";
  }

  html += "</ol>";
  return {
    eigenvalues: eigenvalues,
    multiplicities: multiplicities,
    html: html
  };
};

Expression.getEigenvectorsWithSteps = function (printOptions, matrix, eigenvalues) {
  var eigenvectors = [];
  var html = "";
  html += "<div>";
  html += i18n.eigenvalues.findEigenvectorsForEveryEigenvalue.replaceAll('${λ}', '<math>' + Expression.p('λ') + '</math>');
  html += "</div>";
  html += "<ol>";

  for (var i = 0; i < eigenvalues.length; i += 1) {
    html += "<li>";
    var mm = matrix.subtract(Matrix.I(matrix.cols()).scale(eigenvalues[i])); // matrix - E * eigenvalue

    var fullMatrix = mm.augment(Matrix.Zero(mm.cols(), 1));
    var equalsMathML = "<mo>" + (eigenvalues[i].isExact() ? "=" : "&asymp;") + "</mo>";
    var lambdaMathML = Expression.p('λ_' + (i + 1));
    var v = new Expression.MatrixSymbol('v'); // TODO: fix output for diagonalization - instead of `X = {{0}, {c_1}, {0}}` should be `... var c_1 = 1, then X = {{0}, {1}, {0}}`

    html += "<div class=\"anchor\" id=\"" + (printOptions.idPrefix + "-eigenvalue-" + (i + 1)) + "\">";
    html += "<math>";
    html += lambdaMathML;
    html += equalsMathML;
    html += eigenvalues[i].toMathML(printOptions);
    html += "</math>";
    html += "</div>"; //TODO: syncronize the ExpressionParser with i18n.identityMatrixDenotation
    //TODO: a tooltip for identityMatrixDenotation - identity Matrix
    //TODO: invisible times (&it;) -> middle dot - ?

    html += "<div>";
    html += "<math>";
    html += Expression.p("A-λ_i*I".replace(/i/g, (i + 1).toString()).replace(/I/g, i18n.identityMatrixDenotation)).replace(/&times;/g, '&sdot;');
    html += equalsMathML;
    html += new Expression.Matrix(mm).toMathML(printOptions);
    html += "</math>";
    html += "</div>"; // Av=\lambda v

    html += "<div>";
    html += "<math>" + Expression.p("A*v=λ*v", {
      v: v
    }, {}) + "</math>";
    html += " ";
    html += i18n.eigenvalueEquationLink; //TODO: remove the link - ?

    html += "</div>"; // (A-\lambda E)v=0

    html += "<div>";
    html += "<math>" + Expression.p("(A-λ*I)*v=0".replace(/I/g, i18n.identityMatrixDenotation), {
      v: v
    }, {}).replace(/&times;/g, '&sdot;') + "</math>";
    html += "</div>";
    html += "<div>"; //TODO: text says by "Gaussian Elimination", but really we solve it by Gauss-Jordan elimination...

    html += i18n.eigenvalues.letsSolveHomogeneouseSystem;
    html += "</div>"; //TODO:
    //html += createDetailsSummary(printOptions.idPrefix, [{type: "solve", matrix: fullMatrix.toString(), second: undefined}]);
    //TODO: Matrix.GaussMontante

    var variableNames = makeDefaultVariableNames(fullMatrix.cols() - 1);
    var solutionSet = undefined;
    var solutionHTML = "";
    solutionHTML += Expression.rowReductionGaussJordanMontante(fullMatrix, Matrix.GaussJordan, "solving", Object.assign({}, printOptions, {
      columnlines: -1
    }), function (result) {
      var tmp = Expression.solveByGaussNext(result, printOptions, variableNames);
      solutionSet = Matrix.getSolutionSet(result.matrix);
      return tmp.html;
    }, true);
    html += "<div>" + solutionHTML + "</div>";
    html += "<div>";

    for (var j = 0; j < solutionSet.basisVectors.length; j += 1) {
      var eigenvector = solutionSet.basisVectors[j];
      eigenvectors.push(eigenvector);
      var index = eigenvectors.length; //TODO: <li> - ?

      html += j !== 0 ? "; " : "";
      html += i18n.eigenvalues.Let;
      html += " ";

      for (var k = 0; k < solutionSet.variables.length; k += 1) {
        html += k !== 0 ? ", " : "";
        html += "<math>";
        html += new Expression.Symbol(variableNames[solutionSet.variables[k]]).toMathML(printOptions) + "<mo>=</mo>" + Expression.p(k === j ? 1 : 0);
        html += "</math>";
      }

      html += ", ";
      html += "<span class=\"inline-block anchor\" id=\"" + (printOptions.idPrefix + "-eigenvector-" + index) + "\">";
      html += "<math>";
      html += "<mstyle mathvariant=\"bold\">";
      html += Expression.p("v_0=V", {
        v_0: new Expression.MatrixSymbol('v_' + index),
        V: new Expression.Matrix(eigenvector)
      }, printOptions);
      html += "</mstyle>";
      html += "</math>";
      html += "</span>";
    }

    html += "</div>";
    html += "</li>";
  }

  html += "</ol>";
  return {
    html: html,
    eigenvectors: eigenvectors
  };
}; // --------------------------------------------- end ----------------------------------------------
// --------------------------------------------- end ----------------------------------------------
// 1286
//TODO: remove ?


var polyfromtable = function (m) {
  var coefficients = new Array(m.cols());

  for (var i = 0; i < m.cols(); i += 1) {
    coefficients[i] = m.e(0, m.cols() - 1 - i);
  }

  return Polynomial.from(coefficients);
};

Expression.Details.add({
  type: "polynomial-roots",
  minRows: 1,
  callback: function (printOptions, matrix, second) {
    var polynomial = polyfromtable(matrix);
    var variable = second == undefined ? undefined : second.variable;
    variable = variable == undefined ? new Expression.Symbol("x") : variable;
    printOptions = Object.assign({}, printOptions, {
      polynomialVariable: variable
    });
    var steps = "";
    var tmp = Expression.getPolynomialRootsWithSteps(polynomial, printOptions.fractionDigits, function (info) {
      steps += polynomialRootsCallback(info, printOptions);
    });
    var uniqueRoots = tmp.uniqueRoots;
    var multiplicities = tmp.multiplicities;
    var html = "";
    html += "<div>";
    html += "<math>";
    var p = polynomial.toMathML(printOptions);
    html += p;

    if (steps !== '<mo>=</mo>' + p) {
      html += steps;
    }

    html += "<mo>=</mo>";
    html += Expression.p(0);
    html += "</math>";
    html += "</div>";
    html += "<div>";
    html += i18n.misc.roots;

    if (uniqueRoots.length === 0) {
      html += " ? ";
    }

    var totalRoots = 0;
    html += "<ul>";

    for (var k = 0; k < uniqueRoots.length; k += 1) {
      var root = uniqueRoots[k];
      var multiplicity = multiplicities[k];

      for (var j = 0; j < multiplicity; j += 1) {
        html += "<li>" + "<math>" + (root.isExact() ? "" : "<mo>&asymp;</mo>") + root.toMathML(printOptions) + "</math>" + "</li>";
        totalRoots += 1;
      }
    }

    if (totalRoots < polynomial.getDegree()) {
      html += "<em>" + i18n.notAllRootsHaveBeenFound + "</em>"; //TODO: ?
    }

    html += "</ul>";
    html += "</div>";
    return html;
  }
});
Expression.Details.add({
  type: "polynomial-multiply",
  minRows: 1,
  callback: function (printOptions, matrix, second) {
    var pA = polyfromtable(matrix);
    var pB = polyfromtable(second.matrix);
    var result = pA.multiply(pB);
    return "<math>" + "<mrow>" + "<mrow><mo>(</mo>" + pA.toMathML(printOptions) + "<mo>)</mo></mrow>" + "<mo>&sdot;</mo>" + "<mrow><mo>(</mo>" + pB.toMathML(printOptions) + "<mo>)</mo></mrow>" + "</mrow>" + "<mo>=</mo>" + result.toMathML(printOptions) + "</math>";
  }
});

RPN.getPositionInfo = function () {
  return {
    input: ExpressionParser.input,
    startPosition: ExpressionParser.startPosition,
    endPosition: ExpressionParser.endPosition,
    p: RPN.p
  };
};

RPN.getMatrix = function (s) {
  // TODO: insertion with drag and drop should not freeze all because of calculations
  var matrix = undefined;

  if (matrix == undefined) {
    //TODO: fix or remove - ?
    if (/\=/.test(s)) {
      //?
      try {
        var tmp = getAugmentedSystemMatrix(s); //if (tmp != undefined) {
        //  matrix = Matrix.toMatrix(tmp.elements);
        //}

        var elements = tmp.elements;
        var variableNames = tmp.variableNames; //TODO: test

        return {
          elements: elements,
          variableNames: variableNames
        };
      } catch (error) {
        console.log(error);
      }
    }
  }

  if (matrix == undefined) {
    if (/[\t\n\r]/.test(s.trim())) {
      //try {
      //TODO: should it throw in case of errors?
      var elements = Matrix.split(s.trim());

      try {
        matrix = Matrix.toMatrix(elements);

        if (matrix.rows() === 1 && matrix.cols() === 1 && matrix.e(0, 0).unwrap() instanceof Expression.Matrix) {
          matrix = matrix.e(0, 0);
          elements = elements[0][0]; //TODO: test
        }
      } catch (error) {
        console.error(error);
      } //!new 2020-04-06
      //TODO:


      return {
        elements: elements,
        variableNames: undefined
      }; //} catch (error) {
      //  console.log(error);
      //}
    }
  } //!new 2020-07-04


  var table = getTableFromAsciiMathMatrix(s);

  if (table != null) {
    return {
      elements: table,
      variableNames: undefined
    };
  } //!
  //!!!!


  if (matrix == undefined) {
    var result = undefined;

    try {
      result = ExpressionParser.parse(s, new ExpressionParser.Context()); // to avoid simplification ({{cos(x),sin(x)},{-sin(x),cos(x)}}*{{cos(x),-sin(x)},{sin(x),cos(x)}})
      //result = ExpressionParser.parse(s);
    } catch (error) {
      // TODO: handle errors (?)
      // ???
      throw error;
    } //TODO: system of equations (?)


    matrix = result instanceof Matrix ? result : result instanceof Expression.Matrix ? result.matrix : result instanceof NonSimplifiedExpression && result.e instanceof Expression.Matrix ? result.e.matrix : undefined;
  } //!!!
  // TODO: fix: the input should match the raw input


  var elements = null;

  if (matrix != null) {
    elements = [];

    for (var i = 0; i < matrix.rows(); i += 1) {
      var row = [];

      for (var j = 0; j < matrix.cols(); j += 1) {
        row.push(matrix.e(i, j).toString());
      }

      elements.push(row);
    }
  }

  return {
    elements: elements,
    variableNames: undefined
  };
};

RPN.p = 0; //!

RPN.checkExpressions = function (textareaValue, type) {
  var resultRows = undefined; //?
  //!!!

  if (type === "system") {
    // to support custom input in SLE: 3x+y-2z=2; 2x+y-1=3; ...
    resultRows = getAugmentedSystemMatrix(textareaValue);
  } //!!!


  if (resultRows == undefined) {
    resultRows = Matrix.split(textareaValue);
  }

  var elements = resultRows;
  RPN.p = 0;

  for (var i = 0; i < elements.length; i += 1) {
    for (var j = 0; j < elements[i].length; j += 1) {
      var value = elements[i][j]; //TODO: fix

      var isValid = RPN.checkExpression(value || "0");

      if (!isValid) {
        return false;
      }

      RPN.p += value.length;
    }
  }

  return true;
};

RPN.checkExpression = function (input) {
  //return ExpressionParser.parse(input) != undefined;
  return ExpressionParser.parse(input, new ExpressionParser.Context()) != undefined;
};

RPN.runExpression = function (input, kInputValue, kInputId, matrixTableStates, printOptions) {
  //!TODO: Details?
  var details = [];

  var listener = function (e) {
    details.push({
      type: e.type,
      matrix: e.data.matrix.toString(),
      second: e.second == undefined ? undefined : e.second.matrix.toString()
    });
  };

  Expression.callback = listener;
  var x = undefined; //HACK

  var variableNames = undefined;
  var resultError = undefined;
  var expressionString = undefined;
  var resultHTML = undefined;
  var resultMatrix = undefined;

  try {
    //TODO: fix
    var test = input.replace(/\s+/g, "");

    if (test === "A*X=B" || test === "AX=B" || test === "Ax=b") {
      test = "A*X=B";
    }

    if (test === "A*X=0" || test === "AX=0") {
      test = "A*X=0";
    }

    var matrixTableAState = matrixTableStates != undefined ? matrixTableStates["A"] : undefined;
    var matrixTableBState = matrixTableStates != undefined ? matrixTableStates["B"] : undefined;

    if (test === "A*X=B" && matrixTableAState != undefined && matrixTableBState != undefined || test === "A*X=0" && matrixTableAState != undefined) {
      //TODO: type !== "system" - ?
      var a0 = Matrix.toMatrix(RPN.getElementsArray(matrixTableAState).elements);
      var b0 = test !== "A*X=B" ? Matrix.Zero(a0.rows(), 1) : Matrix.toMatrix(RPN.getElementsArray(matrixTableBState).elements); //hit({click: test  + "-" + a0.rows().toString() + "x" + a0.cols().toString() + "-" + b0.rows().toString() + "x" + b0.cols().toString()});

      if (b0.rows() === a0.rows() && b0.cols() === 1) {
        input = "solve-using-Montante-method(" + a0.augment(b0).toString() + ")";
      }
    }

    if (input.replace(/^\s+|\s+$/g, "") === "") {
      throw new RangeError("ValueMissingError:" + "expression");
    }

    x = ExpressionParser.parse(input, new ExpressionParser.Context(function (id) {
      if ((id === "k" || id === "K") && kInputValue != undefined) {
        var value = kInputValue;

        if (value.replace(/^\s+|\s+$/g, "") === "") {
          throw new RangeError("ValueMissingError:" + kInputId);
        }

        return ExpressionParser.parse(value, new ExpressionParser.Context());
      }

      if (id === "X" || id === "Y") {
        return new Expression.MatrixSymbol(id);
      }

      var matrixTableState = matrixTableStates != undefined && Object.prototype.hasOwnProperty.call(matrixTableStates, id) ? matrixTableStates[id] : undefined;

      if (matrixTableState == undefined) {
        return undefined;
      }

      var tmp = RPN.getElementsArray(matrixTableState);

      if (tmp.elements.length === 0) {
        throw new RangeError("ValueMissingError:" + matrixTableState.firstInputElementId);
      }

      var names = tmp.variableNames;
      var matrix = Matrix.toMatrix(tmp.elements);
      variableNames = names; //!

      return new Expression.Matrix(matrix);
    })); //TODO: remove

    var tmp = getResultAndHTML(x, variableNames, x.simplify(), printOptions);
    var result = tmp.result;
    resultHTML = tmp.html;
    var matrix = undefined;

    if (result instanceof Matrix) {
      matrix = result;
    } else if (result instanceof Expression.Matrix) {
      matrix = result.matrix;
    } else if (result instanceof NonSimplifiedExpression && result.e instanceof Expression.Matrix) {
      matrix = result.e.matrix;
    } else if (result instanceof Expression.Equality && result.b instanceof Expression.Matrix) {
      //!new 2018-12-29
      matrix = result.b.matrix;
    }

    resultMatrix = matrix != undefined ? matrix.toString() : "";
    expressionString = x.toString();
  } catch (error) {
    resultError = error;
  }

  Expression.callback = undefined;
  var detailsHTML = createDetailsSummary(printOptions == null ? "g" : printOptions.idPrefix, details, details.length === 1 ? 100 : 1);
  return {
    resultError: resultError,
    details: details,
    expressionString: expressionString,
    resultHTML: resultHTML,
    resultMatrix: resultMatrix,
    detailsHTML: detailsHTML
  };
};

RPN.getDetails = function (data, printOptions) {
  var callback = Expression.Details.getCallback(data.type);

  if (callback == undefined) {
    throw new Error(data.type);
  }

  var matrix = ExpressionParser.parse(data.matrix).matrix; //?

  var second = data.second != undefined ? ExpressionParser.parse(data.second).matrix : undefined;
  var html = callback(printOptions, matrix, second);
  return html;
}; // TODO: fix?
//export createDetailsSummary;
//TODO: remove createDetailsSummary


RPN.createDetailsSummary = createDetailsSummary;
globalThis.RPN = RPN;
Expression.Details.add({
  type: "system-of-equations",
  minRows: 1,
  //?
  callback: function (printOptions, nothing, system) {
    var equations = system.equations;

    if (equations == null) {
      // backward-compatibility //TODO: ?
      equations = [{
        left: system.s,
        right: system.b
      }];
    }

    var html = ""; //TODO: move

    var rows = null;
    var cols = null;

    var getNumberSolutionFor = function (condition, variable) {
      var s = condition.getSolutionFor(variable);
      return s instanceof Expression.Integer ? s.toNumber() : null;
    }; // TODO: ???


    if (equations.length === 1 && (equations[0].sign || "=") == "=") {
      //TODO: ?
      var s = equations[0].left;
      var b = equations[0].right;
      html += "<div>";
      html += "<math>";
      html += s.toMathML(printOptions) + "<mo>=</mo>" + b.toMathML(printOptions);
      html += "</math>";
      html += "</div>";

      if (s instanceof Expression.Exponentiation && Expression.has(s, Expression.MatrixSymbol) && b instanceof Expression.Matrix) {
        //TODO: ?
        s = s.inverse();
        b = b.inverse(); //TODO: condition
      } //!new 2019-12-08


      if (Expression.has(b, Expression.MatrixSymbol)) {
        //?TODO: ?
        s = s.subtract(b); //b = b.subtract(b); TODO: fix when X*{{1}}-X*{{1}}

        b = Expression.ZERO;
      } //!new 2020-14-06


      if (Expression.has(s, Expression.MatrixSymbol)) {
        //?TODO: ?
        s = s.subtract(b);
        b = Expression.ZERO;
      }

      if (!(s.subtract(b) instanceof Expression.Division)) {
        var tmp = Expression.splitX(s.subtract(b));

        if (tmp != null && tmp.x instanceof Expression.Exponentiation && tmp.x.b.isNegative()) {
          if (!Expression.has(s, Expression.Determinant)) {
            //TODO: FIX Expression.splitX(...) instead - ?
            //?
            //TODO: test, fix, remove(in case Condition will work better)
            s = s.multiply(tmp.x.inverse());
            b = b.multiply(tmp.x.inverse());
          }
        }
      }

      if (s instanceof Expression.Addition && Expression.has(s, Expression.MatrixSymbol)) {
        //TODO: FIX BUGS!!!
        //var tmp = Expression.splitX(s);
        //cols = tmp.l != null && tmp.r != null ? tmp.l.matrix.rows() : null;
        //rows = tmp.l != null && tmp.r != null ? tmp.r.matrix.rows() : null;
        if (cols == null || rows == null) {
          var c = Condition.TRUE;

          var size = function (e) {
            if (e instanceof Expression.Addition) {
              var a = size(e.a);
              var b = size(e.b);

              if (a == null || b == null) {
                return a || b;
              }

              c = c.andZero(a.rows.subtract(b.rows));
              c = c.andZero(a.cols.subtract(b.cols));
              return a;
            }

            if (e instanceof Expression.Multiplication) {
              var a = size(e.a);
              var b = size(e.b);

              if (a == null || b == null) {
                return a || b;
              }

              c = c.andZero(a.cols.subtract(b.rows));
              return {
                rows: a.rows,
                cols: b.cols
              };
            }

            if (e instanceof Expression.Exponentiation) {
              var a = size(e.a);

              if (a == null) {
                return a;
              }

              c = c.andZero(a.cols.subtract(a.rows));
              return a;
            }

            if (e instanceof Expression.MatrixSymbol) {
              return {
                rows: new Expression.Symbol("rows" + e.symbol),
                cols: new Expression.Symbol("cols" + e.symbol)
              };
            }

            if (e instanceof Expression.Matrix) {
              return {
                rows: Expression.Integer.fromNumber(e.matrix.rows()),
                cols: Expression.Integer.fromNumber(e.matrix.cols())
              };
            }

            if (Expression.isScalar(e)) {
              return null;
            }

            if (e instanceof Expression.Determinant) {
              //TODO: ?
              return null;
            }

            throw new TypeError("NotSupportedError");
          };

          size(s); //TODO: ?
          //console.log(c + '');
          //TODO: for all matrix symbols do the replacement,
          // then back (?)

          if (c.isFalse()) {
            throw new RangeError("DimensionMismatchException"); //TODO: ?
          }

          rows = getNumberSolutionFor(c, new Expression.Symbol('rows' + 'X'));
          cols = getNumberSolutionFor(c, new Expression.Symbol('cols' + 'X'));
        }

        if (cols != null && rows != null) {
          var X = new Expression.Matrix(Matrix.Zero(rows, cols).map(function (e, i, j) {
            //TODO use unique symbol names (?)
            return new Expression.Symbol('x' + '_(' + (i + 1) + ',' + (j + 1) + ')');
          }));
          html += '<math>' + Expression.p("X=A", {
            A: X
          }, {}) + '</math>'; //s = RPN(s.toString(), new RPN.Context(function (id) {
          //  return id === "X" ? X : null;
          //}));

          s = Expression._map(function (something) {
            return something instanceof Expression.Symbol && something.symbol === "X" ? X : something;
          }, s);
          s = s.simplify();
        }
      }

      equations = [];

      if (s instanceof Expression.Matrix) {
        var m = s.matrix;
        var bb = new Expression.Matrix(Matrix.Zero(m.rows(), m.cols()));

        if (!b.equals(Expression.ZERO)) {
          bb = bb.add(b);
        }

        bb = bb.matrix;

        for (var i = 0; i < m.rows(); i += 1) {
          for (var j = 0; j < m.cols(); j += 1) {
            equations.push({
              left: m.e(i, j),
              right: bb.e(i, j)
            });
          }
        }
      } else {
        equations.push({
          left: s,
          right: b
        });
      }
    }

    var getX = function (rows, cols, condition) {
      var NULL = new Expression.Symbol("NULL");
      var X = Matrix.Zero(rows, cols).map(function (e, i, j) {
        //TODO use unique symbol names (?)
        var s = new Expression.Symbol('x' + '_(' + (i + 1) + ',' + (j + 1) + ')');
        var q = condition.getSolutionFor(s); //TODO: with symbols (!!!)

        return q != null && !Expression.has(q, Expression.Symbol) ? q : NULL;
      });

      for (var i = 0; i < rows; i += 1) {
        for (var j = 0; j < cols; j += 1) {
          if (X.e(i, j) === NULL) {
            return null;
          }
        }
      }

      return new Expression.Matrix(X);
    }; //TODO: fix


    html += "<div>";
    html += "<math>";
    html += "<mrow><mo>{</mo>";
    html += '<mtable rowspacing="0ex" columnalign="left">';
    var signs = {
      '=': '=',
      '!=': '≠',
      '>': '>',
      '<': '<'
    };

    for (var i = 0; i < equations.length; i += 1) {
      html += "<mtr><mtd>" + equations[i].left.toMathML(printOptions) + "<mo>" + signs[equations[i].sign || "="] + "</mo>" + equations[i].right.toMathML(printOptions) + "</mtd></mtr>";
    }

    html += '</mtable>';
    html += "</mrow>";
    html += "</math>";
    html += "</div>"; //TODO: is linear - ?
    //TODO: matrices - ?

    var c = Condition.TRUE;

    for (var i = 0; i < equations.length; i += 1) {
      var x = equations[i].left.subtract(equations[i].right);
      var sign = equations[i].sign || "=";

      if (sign === "=") {
        c = c.andZero(x);
      } else if (sign === '!=') {
        c = c.andNotZero(x);
      } else if (sign === '>') {
        c = c.andGreaterZero(x);
      } else if (sign === '<') {
        c = c.andGreaterZero(x.negate());
      } else {
        throw new TypeError();
      }
    }

    html += "<p>" + i18n.systems.answer + "</p>";
    html += "<p>";

    if (c.isFalse()) {
      html += i18n.systems.thereAreNoSolutions; // "&minus;";//TODO: ?
    } else if (c.isTrue()) {
      html += "✓"; //TODO: ?
    } else {
      var X = cols != null && rows != null ? getX(rows, cols, c) : null;

      if (X != null) {
        html += "<math>" + Expression.p("X=A", {
          A: X
        }, printOptions) + "</math>";
      } else {
        html += "<math>" + c.toMathML(printOptions) + "</math>";
      }
    }

    html += "</p>";
    return html;
  }
});
})();
(function () {
"use strict";
/*global i18n, Expression, Matrix, NonSimplifiedExpression*/


var getSolveDetails = function (printOptions, matrix, variableNames, title, method) {
  if (matrix.cols() < 1) {
    //?
    throw new RangeError("ValueMissingError:A-textarea"); //TODO: fix
  } //if (variableNames == undefined) {


  var m = matrix.slice(0, matrix.rows(), 0, matrix.cols() - 1);
  var b = matrix.slice(0, matrix.rows(), matrix.cols() - 1, matrix.cols());
  matrix = Matrix.trimRight(m).augment(b); //}

  var html = "";
  html += "<h4>" + title + "</h4>"; //html += "<div>" + i18n.unused.systems.augmentedMatrixOfTheSystem + "</div>";

  html += "<div>" + i18n.systems.convertTheAugmentedMatrixIntoTheRowEchelonForm + "</div>";
  html += Expression.rowReductionGaussJordanMontante(matrix, method, "solving", Object.assign({}, printOptions, {
    columnlines: -1
  }), function (result) {
    var tmp = Expression.solveByGaussNext(result, printOptions, variableNames);
    return tmp.html;
  });
  return html;
};

Expression.Details.add({
  type: "solve-using-Gaussian-elimination",
  i18n: function () {
    return i18n.slu.solveByGauss;
  },
  minRows: 1,
  callback: function (printOptions, matrix, variableNames) {
    return getSolveDetails(printOptions, matrix, variableNames, i18n.systems.solutionByGaussianElimination, Matrix.Gauss);
  }
});
Expression.Details.add({
  type: "solve-using-Gauss-Jordan-elimination",
  i18n: function () {
    return i18n.slu.solveByJordanGauss;
  },
  minRows: 1,
  callback: function (printOptions, matrix, variableNames) {
    return getSolveDetails(printOptions, matrix, variableNames, i18n.systems.solutionByGaussJordanElimination, Matrix.GaussJordan);
  }
});
Expression.Details.add({
  type: "solve-using-Montante-method",
  i18n: function () {
    return i18n.det.methodOfMontante;
  },
  minRows: 1,
  priority: 1,
  //TODO: ?
  callback: function (printOptions, matrix, variableNames) {
    return getSolveDetails(printOptions, matrix, variableNames, i18n.systems.solutionByMethodOfMontante, Matrix.GaussMontante);
  }
});

Expression.rowReduceChangeToHTMLMontante = function (args, printOptions, containerId, k, stepCondition) {
  var t = function (r, c, k) {
    return "<mrow>" + "<mfrac>" + "<maction actiontype=\"tooltip\">" + Expression.p("det({{a_(pivotRow,pivotColumn), a_(pivotRow,j)},{a_(i,pivotColumn), a_(i,j)}})".replaceAll('pivotRow', (r + 1).toString()).replaceAll('pivotColumn', (c + 1).toString()), {}, {
      useMatrixContainer: false
    }) + Expression.p("(a_(pivotRow,pivotColumn)*a_(i,j)-a_(i,pivotColumn)*a_(pivotRow,j))".replaceAll('pivotRow', (r + 1).toString()).replaceAll('pivotColumn', (c + 1).toString())) + "</maction>" + Expression.p('p_${k}'.replaceAll('${k}', (k + 1).toString()).replaceAll('p_0', '1')) + "</mfrac>" + "<mo>&rarr;</mo>" + Expression.p("a_(i,j)") + "</mrow>";
  };

  var cellId = function (matrixId, i, j) {
    return containerId + "-" + matrixId + "-" + i + "-" + j;
  };

  var html = "";

  if (true) {
    if (args.type === "swap" || args.type === "swap-negate") {
      html += Expression.rowReduceChangeToHTML(args, printOptions, containerId, k, stepCondition);
    } else if (args.type === "pivot") {
      var a0 = new Expression.Matrix(args.oldMatrix).toMathML(Object.assign({}, printOptions, {
        columnlines: printOptions.columnlines,
        cellIdGenerator: function (i, j) {
          return cellId(k, i, j);
        },
        pivotCell: {
          i: args.pivotRow,
          j: args.pivotColumn
        }
      }));
      var pivotElementText = "<mpadded width=\"+0.8em\" lspace=\"+0.4em\">" + "<munder accentunder=\"true\">" + "<mo stretchy=\"false\">~</mo>" + "<munder accentunder=\"true\">" + "<mtext>" + i18n.eliminationDetails.pivotElement + "</mtext>" + "<munder accentunder=\"true\">" + "<mrow>" + Expression.p("p_" + (k + 1) + "=a_(" + (args.pivotRow + 1) + "," + (args.pivotColumn + 1) + ")=q", {
        q: args.oldMatrix.e(args.pivotRow, args.pivotColumn)
      }, printOptions) + "</mrow>" + (stepCondition.isTrue() ? "" : "<munder accentunder=\"true\">") + t(args.pivotRow, args.pivotColumn, k - 1) + (stepCondition.isTrue() ? "" : stepCondition.toMathML(printOptions)) + (stepCondition.isTrue() ? "" : "</munder>") + "</munder>" + "</munder>" + "</munder>" + "</mpadded>";
      html += "<math>";
      html += a0 + pivotElementText;
      html += "</math>";
      k += 1;
      var text = "";

      for (var targetRow = 0; targetRow < args.oldMatrix.rows(); targetRow += 1) {
        if (targetRow !== args.pivotRow) {
          text += "<div>";

          for (var i = 0; i < args.oldMatrix.cols(); i += 1) {
            var highlight = "<a class=\"a-highlight\" data-for=\"" + cellId(k, targetRow, i) + "\" data-highlight=\"" + "#" + cellId(k - 1, args.pivotRow, args.pivotColumn) + ", " + "#" + cellId(k - 1, targetRow, i) + ", " + "#" + cellId(k - 1, targetRow, args.pivotColumn) + ", " + "#" + cellId(k - 1, args.pivotRow, i) + ", " + "#" + cellId(k, targetRow, i) + "\"></a>";
            text += "<a class=\"a-tooltip\" data-for=\"" + cellId(k, targetRow, i) + "\" hidden>" + "<math>" + Expression.p("a_(" + (targetRow + 1) + "," + (i + 1) + ")=(a*b-c*d)/p=r", {
              a: args.oldMatrix.e(args.pivotRow, args.pivotColumn),
              b: args.oldMatrix.e(targetRow, i),
              c: args.oldMatrix.e(targetRow, args.pivotColumn),
              d: args.oldMatrix.e(args.pivotRow, i),
              p: args.previousPivot,
              r: args.newMatrix.e(targetRow, i)
            }, printOptions) + "</math>" + "</a>" + highlight;
          }

          text += "</div>";
        }
      }

      html += "<span hidden>" + text + "</span>";
    } else {
      throw new TypeError(args.type);
    }
  } //TODO: mathml, not html, no internal <math></math>


  return html;
};

var getDeterminantDetails = function (printOptions, matrix, method, title, header) {
  if (!matrix.isSquare()) {
    throw new RangeError("NonSquareMatrixException");
  }

  var html = "";
  html += "<div>";
  html += "<math>";
  html += new Expression.Determinant(new Expression.Matrix(matrix)).toMathML(printOptions) + "<mo>=</mo><mi>?</mi>";
  html += "</math>";
  html += "</div>"; //?

  if (header != undefined) {
    html += "<h4>";
    html += header;
    html += "</h4>";
  }

  html += "<p>" + title + "</p>";
  html += Expression.rowReductionGaussJordanMontante(matrix, method, "determinant", printOptions, function (tmp) {
    var rowEchelonMatrix = tmp.matrix;
    var html = "";
    html += "<div>";
    html += "<math>";
    html += new Expression.Determinant(new Expression.Matrix(matrix)).toMathML(printOptions);
    html += "<mo>=</mo>";

    if (method === Matrix.Gauss) {
      html += new Expression.Determinant(new Expression.Matrix(rowEchelonMatrix)).toMathML(printOptions);
      html += "<mo>=</mo>";
      var result = rowEchelonMatrix.determinant();

      if (!result.equals(Expression.ZERO)) {
        var det = rowEchelonMatrix.e(0, 0);
        det = new NonSimplifiedExpression(det);

        for (var j = 1; j < rowEchelonMatrix.rows(); j += 1) {
          det = new Expression.Multiplication(det, rowEchelonMatrix.e(j, j)); //? usage of Expression.Multiplication to get 4 * 5 * 6 ...

          det = new NonSimplifiedExpression(det);
        }

        html += det.toMathML(printOptions);
        html += "<mo>=</mo>";
      }

      html += result.toMathML(printOptions);
    } else {
      var result = tmp.stoppedAtRow !== -1 ? Expression.ZERO : rowEchelonMatrix.e(rowEchelonMatrix.rows() - 1, rowEchelonMatrix.cols() - 1);
      html += result.toMathML(printOptions);
    }

    html += "</math>";
    html += "</div>";
    return html;
  });
  return html;
};

Expression.Details.add({
  type: "determinant-Gauss",
  i18n: function () {
    return i18n.det.methodOfGauss;
  },
  minRows: 3,
  callback: function (printOptions, matrix) {
    return getDeterminantDetails(printOptions, matrix, Matrix.Gauss, i18n.determinantDetails.start, undefined);
  }
});
Expression.Details.add({
  type: "determinant-Montante",
  i18n: function () {
    return i18n.det.methodOfMontante;
  },
  minRows: 3,
  priority: 1,
  //TODO: ?
  callback: function (printOptions, matrix) {
    var title = i18n.methodOfMontanteDetails.determinantDetails.start.replace(/\$\{someDetails3\}/g, Expression.getSomeDetails("someDetails3")).replace(/\$\{a_\(i,j\)\=\(a_\(r,c\)\*a_\(i,j\)\-a_\(i,c\)\*a_\(r,j\)\)\/p\}/g, "<math>" + Expression.p("a_(i,j)=(a_(r,c)*a_(i,j)-a_(i,c)*a_(r,j))/p") + "</math>").replace(/\$\{a_\(r,c\)\}/g, "<math>" + Expression.p("a_(r,c)") + "</math>").replace(/\$\{r\}/g, "<math>" + "<mi>r</mi>" + "</math>").replace(/\$\{c\}/g, "<math>" + "<mi>c</mi>" + "</math>").replace(/\$\{p\}/g, "<math>" + "<mi>p</mi>" + "</math>");
    return getDeterminantDetails(printOptions, matrix, Matrix.GaussMontante, title, i18n.methodOfMontanteDetails.determinantDetails.header);
  }
});

var getRankDetails = function (printOptions, matrix, method, title) {
  var html = "";
  html += "<div>";
  html += "<math>";
  html += new Expression.Rank(new Expression.Matrix(matrix)).toMathML(printOptions) + "<mo>=</mo><mi>?</mi>";
  html += "</math>";
  html += "</div>";

  if (title != undefined) {
    //TODO: remove
    html += "<p>" + title + "</p>";
  }

  html += Expression.rowReductionGaussJordanMontante(matrix, method, "", printOptions, function (tmp) {
    var rowEchelonMatrix = tmp.matrix;
    var html = "";
    html += "<div>";
    html += "<math>";
    html += new Expression.Rank(new Expression.Matrix(matrix)).toMathML(printOptions);
    html += "<mo>=</mo>";
    html += new Expression.Rank(new Expression.Matrix(rowEchelonMatrix)).toMathML(printOptions);
    html += "<mo>=</mo>";
    html += Expression.Integer.fromNumber(rowEchelonMatrix.rank()).toMathML();
    html += "</math>";
    html += "</div>";
    return html;
  }); //?

  return html;
};

Expression.Details.add({
  type: "rank-Gauss",
  i18n: function () {
    return i18n.det.methodOfGauss;
  },
  minRows: 2,
  callback: function (printOptions, matrix) {
    return getRankDetails(printOptions, matrix, Matrix.Gauss, i18n.rankDetails.start);
  }
});
Expression.Details.add({
  type: "rank-Montante",
  i18n: function () {
    return i18n.det.methodOfMontante;
  },
  minRows: 2,
  priority: 1,
  //TODO: ?
  callback: function (printOptions, matrix) {
    //TODO:
    //i18n.methodOfMontanteDetails.rankDetails.start
    return getRankDetails(printOptions, matrix, Matrix.GaussMontante, undefined);
  }
}); // TODO:
// http://www.mathsisfun.com/algebra/matrix-inverse-row-operations-gauss-jordan.html
// i18n.inverseDetails.rowSwapNegate = "- Trocamos o linha {s} e o linha {c}:, ...";

var getInverseDetails = function (printOptions, matrix, method, title) {
  var html = "";
  html += "<div>";
  html += "<math>";
  html += new Expression.Exponentiation(new Expression.Matrix(matrix), Expression.ONE.negate()).toMathML(printOptions) + "<mo>=</mo><mi>?</mi>";
  html += "</math>";
  html += "</div>";

  if (title != undefined) {
    //TODO: remove
    html += "<p>" + title + "</p>";
  } //TODO: merge (?)


  var augmented = matrix.augment(Matrix.I(matrix.rows()));
  html += Expression.rowReductionGaussJordanMontante(augmented, method, "inverse", Object.assign({}, printOptions, {
    columnlines: -matrix.cols()
  }), function (tmp) {
    var augmentedResult = tmp.matrix;
    var hasZeroElement = false;

    for (var i = 0; i < augmentedResult.rows(); i += 1) {
      if (augmentedResult.e(i, i).equals(Expression.ZERO)) {
        hasZeroElement = true;
      }
    }

    var html = "";

    if (!hasZeroElement) {
      var result2 = Matrix.Zero(matrix.rows(), matrix.rows()).map(function (element, i, j) {
        // splitting to get the second half
        return augmentedResult.e(i, j + augmentedResult.rows());
      });
      var result = result2.map(function (element, i, j) {
        return element.divide(augmentedResult.e(i, i));
      });
      html += "<div>";
      html += "<math>";
      html += new Expression.Exponentiation(new Expression.Matrix(matrix), Expression.ONE.negate()).toMathML(printOptions);

      if (method === Matrix.GaussMontante) {
        var c = augmentedResult.e(0, 0); //!

        html += "<mo>=</mo>";
        html += new Expression.Multiplication(new Expression.Division(Expression.ONE, c), new Expression.Matrix(result2)).toMathML(printOptions);
      }

      html += "<mo>=</mo>";
      html += new Expression.Matrix(result).toMathML(printOptions);
      html += "</math>";
      html += "</div>";
    } else {//TODO: ?
    }

    return html;
  });
  return html;
};

Expression.Details.add({
  type: "inverse-Gauss",
  i18n: function () {
    return i18n.inverse.methodOfGaussJordan;
  },
  minRows: 3,
  callback: function (printOptions, matrix) {
    return getInverseDetails(printOptions, matrix, Matrix.GaussJordan, i18n.inverseDetails.start);
  }
});
Expression.Details.add({
  type: "inverse-Montante",
  i18n: function () {
    return i18n.det.methodOfMontante;
  },
  minRows: 3,
  priority: 1,
  //TODO: ?
  callback: function (printOptions, matrix) {
    // TODO: i18n.methodOfMontanteDetails.inverseDetails.start
    return getInverseDetails(printOptions, matrix, Matrix.GaussMontante, undefined);
  }
});
Expression.Details.add({
  type: "LU-decomposition",
  i18n: function () {
    return i18n.index.LUDecomposition;
  },
  minRows: 2,
  callback: function (printOptions, matrix) {
    var palu = Expression.LUDecomposition(matrix);
    var html = "";
    html += "<div class=\"math-block\">";
    html += "<math>";
    html += Expression.p(palu.swapFlag ? "P*A=L*U" : "A=L*U", palu, printOptions);
    html += "</math>";
    html += "</div>";
    var detailsHTML = RPN.createDetailsSummary(printOptions.idPrefix, [{
      type: 'steps-to-find-LU-decomposition',
      matrix: matrix.toString(),
      second: undefined
    }]);
    return html + detailsHTML;
  }
});
Expression.Details.add({
  type: "steps-to-find-LU-decomposition",
  i18n: function () {
    return i18n.index.LUDecomposition;
  },
  minRows: 2,
  callback: function (printOptions, matrix) {
    var palu = Expression.LUDecomposition(matrix);
    var html = ""; //TODO: fix

    html += Expression.rowReductionGaussJordanMontante(matrix, Matrix.Gauss, "LU-decomposition", Object.assign({}, printOptions, {
      isLUDecomposition: true
    }), function (result) {
      return "";
    });
    html += "<div class=\"math-block\">"; //TODO: output P

    html += "<math>";
    html += Expression.p("L=M", {
      M: palu.L
    }, Object.assign({}, printOptions, {
      isLUDecomposition2: true
    }));
    html += "</math>";
    html += "<span>, </span>";
    html += "<math>";
    html += Expression.p("U=M", {
      U: new Expression.Symbol("U"),
      M: palu.U
    }, printOptions); // U - is not an IdentityMatrix

    html += "</math>";
    html += "</div>";
    return html;
  }
});
Expression.Details.add({
  type: "Gaussian-elimination",
  minRows: 2,
  callback: function (printOptions, matrix) {
    var c = 0;
    var html = "";
    Matrix.toRowEchelonWithCallback(matrix, Matrix.Gauss, "row-reduction", null, function (result) {
      c += 1;
      var condition = result.condition;
      var resultMatrix = result.matrix;

      if (!condition.isTrue()) {
        html += "<li>";
        html += "<div class=\"like-table\">";
      }

      html += "<math>";
      html += new Expression.Matrix(matrix).toMathML(printOptions);
      html += "<mo>~</mo>";
      html += new Expression.Matrix(resultMatrix).toMathML(printOptions);
      html += "</math>";

      if (!condition.isTrue()) {
        html += "<math>";
        html += "<mrow><mo>(</mo>";
        html += condition.toMathML(printOptions);
        html += "<mo>)</mo></mrow>";
        html += "</math>";
        html += "</div>";
        html += "</li>";
      }
    });

    if (c > 1) {
      html = "<ul class=\"list-unstyled\">" + html + "</ul>";
    }

    var detailsHTML = RPN.createDetailsSummary(printOptions.idPrefix, [{
      type: 'steps-to-find-row-echelon-matrix',
      matrix: matrix.toString(),
      second: undefined
    }]);
    return html + detailsHTML;
  }
});
Expression.Details.add({
  type: "steps-to-find-row-echelon-matrix",
  minRows: 2,
  callback: function (printOptions, matrix) {
    var html = Expression.rowReductionGaussJordanMontante(matrix, Matrix.Gauss, "row-reduction", printOptions, function (tmp) {
      //var result = tmp.matrix;
      if (tmp.condition.isTrue() && tmp.matrix.eql(matrix)) {
        return i18n.systems.theMatrixIsInRowEchelonForm;
      }

      return "";
    });
    return html;
  }
});
})();
(function () {
"use strict";
/*global i18n, Expression, Matrix, NonSimplifiedExpression*/
 //TODO:

 //TODO:

Expression.Details.add({
  type: "Cholesky-decomposition",
  minRows: 2,
  callback: function (printOptions, matrix) {
    var detailsHTML = RPN.createDetailsSummary(printOptions.idPrefix, [{
      type: 'steps-to-find-Cholesky-decomposition',
      matrix: matrix.toString(),
      second: undefined
    }]);

    try {
      var tmp = Expression.CholeskyDecomposition(matrix);
    } catch (error) {
      if (error.message === "NonPositiveDefiniteMatrix") {
        return "<p>" + i18n.CholeskyDecomposition.theMatrixIsNotPositiveDefinite + "</p>" + detailsHTML;
      }

      throw error;
    }

    var L = tmp.L;
    var A = matrix;
    var html = "";
    html += "<div class=\"math-block\">";
    html += "<math>";
    html += Expression.p("A=L*T", {
      A: new Expression.Matrix(A),
      L: new Expression.Matrix(L),
      T: new Expression.Matrix(L.transpose().map(function (e) { return e.complexConjugate(); }))
    }, printOptions);
    html += "</math>";
    html += "</div>";
    return html + detailsHTML;
  }
});
Expression.Details.add({
  type: "svd",
  minRows: 2,
  callback: function (printOptions, matrix) {
    var detailsHTML = RPN.createDetailsSummary(printOptions.idPrefix, [{
      type: 'steps-to-find-SVD',
      matrix: matrix.toString(),
      second: undefined
    }]);
    var tmp = Expression.SVDecomposition(matrix);
    var A = matrix;
    var html = "";
    html += "<div>";
    html += "<math>";
    html += Expression.p("A=U*S*W", {
      A: new Expression.Matrix(A),
      U: new Expression.Matrix(tmp.U),
      S: new Expression.Matrix(tmp.Sigma),
      W: new Expression.Matrix(tmp.Vstar)
    }, printOptions);
    html += "</math>";
    html += "</div>";
    html += detailsHTML;
    return html;
  }
});
Expression.Details.add({
  type: "steps-to-find-SVD",
  //i18n: function () {
  //return i18n.index.SingularValueDecomposition;
  //},
  i18n: null,
  minRows: 2,
  callback: function (printOptions, matrix) {
    var html = '';
    var consoleInfo = console.info;
    var tmp = null;
    var messages = {};

    try {
      var inList = 0; //TODO:

      var inUnorderedList = 0;

      console.info = function (s) {
        //!!!
        if (s.indexOf('%s') === -1) {
          messages[s] = s;
        }

        var args = Array.from(arguments);
        var i = 1;

        if (s.indexOf('%s') !== -1) {
          var prefix = s.startsWith('   - ') ? '   - ' : s.startsWith('   ') ? '   ' : '';
          s = s.slice(prefix.length).replace(/%s/g, function () {
            i += 1;
            return new Expression.Matrix(args[i - 1]).toString(printOptions);
          });
          var object = {
            U: new Expression.MatrixSymbol('U'),
            S: new Expression.MatrixSymbol('Σ'),
            V: new Expression.MatrixSymbol('V')
          };
          s.replace(/[uv]_\d+/g, function (p) {
            object[p] = new Expression.MatrixSymbol(p);
          }); // u: new Expression.MatrixSymbol('u'), v: new Expression.MatrixSymbol('v'), 

          s = prefix + '<math>' + Expression.p(s.replaceAll('Σ', 'S'), object, printOptions) + '</math>';
        } else {
          s = s.replace(/\[([^\]]+)\]\(([^\)]+)\)/g, function (p, text, href) {
            return text.link(href);
          });
          var object = {
            U: new Expression.MatrixSymbol('U'),
            S: new Expression.MatrixSymbol('Σ'),
            V: new Expression.MatrixSymbol('V')
          };
          object['v_0'] = new Expression.MatrixSymbol('v_i');
          object['σ_0'] = new Expression.MatrixSymbol('σ_i');
          object['u_0'] = new Expression.MatrixSymbol('u_i');
          s = s.replace(/`([^`]+)`/g, function (p, asciimath) {
            return '<math>' + Expression.p(asciimath.replaceAll('Σ', 'S').replaceAll('v_i', 'v_0').replaceAll('σ_i', 'σ_0').replaceAll('u_i', 'u_0'), object, printOptions) + '</math>';
          });
        }

        if (s.startsWith('   - ')) {
          if (inUnorderedList === 0) {
            inUnorderedList = 1;
            html += '<ul type="none">';
          }

          html += '<li>' + s.slice('   - '.length) + '</li>';
          s = '';
        } else {
          if (inUnorderedList === 1) {
            inUnorderedList = 0;
            html += '</ul>';
          }
        }

        if (s === '') {// do nothing
        } else if (/^\d+\.\s+/.test(s)) {
          //TODO: fix
          if (s.startsWith('1.')) {
            inList = 1;
            html += '<ol>';
            html += '<li>';
          } else {
            html += '</li>';
            html += '<li>';
          }

          html += '<p>' + s.replace(/^\d+\.\s+/g, '') + '</p>';
        } else {
          if (inList) {
            if (s.startsWith('   ')) {
              html += '<p>' + s + '</p>';
              s = '';
            } else {
              inList = 0;
              html += '</li>';
              html += '</ol>';
            }
          }

          if (s !== '') {
            html += '<p>' + s + '</p>';
          }
        }

        if (i !== args.length) {
          throw new RangeError();
        }

        if (s === '1. Find eigenvalues and eigenvectors of <math><mrow><msup><mi>A</mi><mi>T</mi></msup><mo>&it;</mo><mi>A</mi></mrow></math>:') {
          var detailsHTML = RPN.createDetailsSummary(printOptions.idPrefix, [{
            type: 'eigenvectors',
            matrix: matrix.conjugateTranspose().multiply(matrix).toString(),
            second: undefined
          }]);
          html += detailsHTML;
        }
      };

      tmp = Expression.SVDecomposition(matrix);
    } finally {
      console.info = consoleInfo;
    }

    console.log(messages);
    return html;
  }
}); //TODO: remove:
// backward compatibility: 

Expression.Details.add({
  type: "SVD-decomposition",
  minRows: 2,
  callback: function (printOptions, matrix) {
    return Expression.Details.getCallback("svd")(printOptions, matrix);
  }
});
Expression.Details.add({
  type: "QR-decomposition",
  minRows: 2,
  callback: function (printOptions, matrix) {
    //var detailsHTML = RPN.createDetailsSummary(printOptions.idPrefix, [{type: 'steps-to-find-SVD', matrix: matrix.toString(), second: undefined}]);
    var tmp = Expression.QRDecomposition(matrix);
    var A = matrix;
    var html = "";
    html += "<div>";
    html += "<math>";
    html += Expression.p("A=Q*R", {
      A: new Expression.Matrix(A),
      Q: new Expression.Matrix(tmp.Q),
      R: new Expression.Matrix(tmp.R)
    }, printOptions);
    html += "</math>";
    html += "</div>"; //html += detailsHTML

    return html;
  }
});
Expression.Details.add({
  type: "steps-to-find-Cholesky-decomposition",
  i18n: function () {
    return i18n.index.CholeskyDecomposition;
  },
  minRows: 2,
  callback: function (printOptions, matrix) {
    //TODO: better details when a lot of zeros - ?
    var A = matrix; // check if A is square

    if (!A.isSquare()) {
      throw new RangeError("NonSquareMatrixException");
    }

    var n = A.rows(); // check if A from R

    var isReal = Expression.isRealMatrix(A);

    var onSymmetricChecking = function (symmetric) {
      var html = "";
      html += "<div>";
      html += "<math>";
      html += Expression.p("A=X", {
        X: new Expression.Matrix(A)
      }, printOptions);
      html += "</math>";
      html += "</div>";
      html += "<div>";
      html += "<math>"; //TODO: highlight e(i, j), e(j, i) - ?

      html += (isReal ? Expression.p("A=A^T") : Expression.p("A=A^{*}")).replace(/<mo>=<\/mo>/g, symmetric ? '<mo>=</mo>' : '<mo>&ne;</mo>');
      html += "</math>";
      html += "<span>";
      html += " - ";

      if (isReal) {
        html += symmetric ? i18n.CholeskyDecomposition.theMatrixIsSymmetric : i18n.CholeskyDecomposition.theMatrixIsNotSymmetric;
      } else {
        html += symmetric ? i18n.CholeskyDecomposition.theMatrixIsHermitian : i18n.CholeskyDecomposition.theMatrixIsNotHermitian;
      }

      html += "</span>";
      html += "</div>";
      return html;
    }; // check if A is symmetric


    for (var i = 0; i < n; i += 1) {
      for (var j = i; j < n; j += 1) {
        if (!A.e(i, j).equals(A.e(j, i).complexConjugate())) {
          // throw new RangeError("NonSymmetricMatrixException");
          return onSymmetricChecking(false);
        }
      }
    }

    var html = ""; //var tmp = Expression.CholeskyDecomposition(matrix);
    //var L = tmp.L.matrix;
    // The matrix is symmetric

    html += onSymmetricChecking(true); // 1.  A = L * L^T

    var nsL = Matrix.Zero(n, n).map(function (e, i, j) {
      return i >= j ? new Expression.Symbol("l_(" + (i + 1).toString() + "," + (j + 1).toString() + ")") : Expression.ZERO;
    });
    html += "<div>";
    html += i18n.CholeskyDecomposition.definition.replaceAll('${A=L*L^T}', '<math>' + (isReal ? Expression.p("A=L*L^T") : Expression.p("A=L*L^{*}")) + '</math>').replaceAll('${L}', '<math>' + Expression.p('L') + '</math>');
    html += " ";
    html += i18n.CholeskyDecompositionLink;
    html += "</div>";
    html += "<div>"; //TODO: show that conjugate(l_(1,1)) == l_(1, 1) is used

    var M = nsL.multiply(nsL.transpose().map(function (e, i, j) { return isReal || i === j ? e : e.complexConjugate(); }));
    printOptions = Object.assign({}, printOptions, {
      printId: true
    });
    var nsA = A.map(function (e, i, j) {
      return new NonSimplifiedExpression(e);
    });
    nsL = nsL.map(function (e, i, j) {
      return new NonSimplifiedExpression(e);
    });
    M = M.map(function (e, i, j) {
      return new NonSimplifiedExpression(e);
    });
    html += "<math>";
    html += Expression.p("A=L*T=M", {
      A: new Expression.Matrix(nsA),
      L: new Expression.Matrix(nsL),
      T: new Expression.Matrix(nsL.transpose().map(function (e, i, j) { return isReal || i >= j ? e : e.complexConjugate(); })),
      M: new Expression.Matrix(M)
    }, printOptions);
    html += "</math>";
    html += "</div>";
    html += "<div>";
    html += i18n.CholeskyDecomposition.then; //?

    html += "</div>";
    var L = new Array(n);

    for (var i = 0; i < n; i += 1) {
      L[i] = new Array(n);

      for (var j = 0; j < n; j += 1) {
        L[i][j] = Expression.ZERO;
      }
    }

    html += '<ul class="list-unstyled">'; //?

    for (var j = 0; j < n; j += 1) {
      for (var i = j; i < n; i += 1) {
        var nsE = null;
        var e = null;
        var radicand = null;

        if (j === i) {
          var nsSum = null;
          var sum = null;

          for (var k = 0; k < j; k += 1) {
            var nsS = isReal ? nsL.e(j, k).pow(Expression.TWO) : nsL.e(j, k).multiply(nsL.e(j, k).complexConjugate());
            nsSum = nsSum == null ? nsS : nsSum.add(nsS);
            var s = isReal ? L[j][k].pow(Expression.TWO) : L[j][k].multiply(L[j][k].complexConjugate());
            sum = sum == null ? s : sum.add(s);
          }

          var nsX = nsSum == null ? nsA.e(j, j) : nsA.e(j, j).subtract(nsSum);
          var x = sum == null ? nsA.e(j, j) : nsA.e(j, j).subtract(sum); //?
          //if (x instanceof Expression.Integer && x.compareTo(Expression.ZERO) < 0) {
          //  throw new RangeError("NonPositiveDefiniteMatrix");
          //}

          radicand = x;
          nsE = nsX.squareRoot();
          e = x.squareRoot();
        } else {
          var nsSum = null;
          var sum = null;

          for (var k = 0; k < j; k += 1) {
            var nsX = isReal ? nsL.e(i, k).multiply(nsL.e(j, k)) : nsL.e(i, k).multiply(nsL.e(j, k).complexConjugate());
            var x = isReal ? L[i][k].multiply(L[j][k]) : L[i][k].multiply(L[j][k].complexConjugate());
            nsSum = nsSum == null ? nsX : nsSum.add(nsX);
            sum = sum == null ? x : sum.add(x);
          }

          nsE = (nsSum == null ? nsA.e(i, j) : nsA.e(i, j).subtract(nsSum)).divide(nsL.e(j, j));
          e = (sum == null ? nsA.e(i, j) : nsA.e(i, j).subtract(sum)).divide(L[j][j]);
        }

        html += "<li>";
        html += "<math>";
        var x = new NonSimplifiedExpression(M.e(i, j).unwrap());
        var y = new NonSimplifiedExpression(nsA.e(i, j).unwrap());
        html += '<mrow>';
        html += x.toMathML(printOptions) + '<mo>=</mo>' + y.toMathML(printOptions);
        html += '</mrow>';
        var highlights = "";
        highlights += "<a class=\"a-highlight\" data-for=\"" + x.getId() + "\" data-highlight=\"" + M.e(i, j).getIds() + "\"></a>";
        highlights += "<a class=\"a-highlight\" data-for=\"" + y.getId() + "\" data-highlight=\"" + nsA.e(i, j).getIds() + "\"></a>";
        html += '<mo stretchy="false" lspace="0.68em" rspace="0.68em">&rArr;</mo>';
        html += '<mrow>';
        html += nsL.e(i, j).toMathML(printOptions);

        if (i !== 0 || j !== 0) {
          // nothing to substitute for the first element
          html += "<mo>=</mo>";
          html += nsE.toMathML(printOptions); // before substitutions

          html += "<mo>=</mo>";
          html += e.toMathML(printOptions); // after substitutions
        }

        if (radicand != null) {
          html += "<mo>=</mo>";
          radicand = radicand.simplify();
          html += new NonSimplifiedExpression(radicand).squareRoot().toMathML(printOptions); // after simplification of the expression under the radical symbol

          nsE = null;

          try {
            nsE = radicand.squareRoot();
          } catch (error) {
            //TODO: !!!
            console.log(error);
          }

          if (nsE == null || !Expression._isPositive(radicand)) {
            try {
              nsE = radicand.negate().squareRoot();
            } catch (error2) {
              console.log(error2);
            }

            var ok = nsE != null || !Expression._isPositive(radicand); //TODO: fix

            html += "</mrow>";
            html += "</math>";
            html += highlights;
            html += "<span>";
            html += " - ";
            html += !ok ? i18n.CholeskyDecomposition.sorryCannotWork : i18n.CholeskyDecomposition.theMatrixIsNotPositiveDefinite;
            html += "</span>";
            html += "</li>";
            html += '</ul>';
            return html;
          }
        }

        var r = e.simplify(); //TODO: subs

        if (radicand == null || !r.equals(new Expression.SquareRoot(radicand))) {
          html += "<mo>=</mo>";
          html += r.toMathML(printOptions); // after simplification
        }

        html += '</mrow>';
        html += "</math>";
        html += highlights;
        html += "</li>";
        L[i][j] = new NonSimplifiedExpression(r);
      }
    }

    html += '</ul>';
    var LL = Matrix.padRows(L, null);
    html += "<div>";
    html += i18n.CholeskyDecomposition.then; //?

    html += "</div>";
    html += "<div>";
    html += "<math>";
    html += Expression.p("L=X", {
      X: new Expression.Matrix(LL)
    }, printOptions);
    html += "</math>";
    html += "</div>";
    return html;
  }
});
})();
/*jslint plusplus: true, vars: true, indent: 2 */
/*global document, window */

(function () {
  "use strict";

  function PageUtils() {
  }

  PageUtils.on = function (eventType, selector, listener) {
    PageUtils.initialize(selector, function (element) {
      element.addEventListener(eventType, listener, false);
    });
  };

  PageUtils.escapeHTML = function (s) {
    return s.replace(/&/g, "&amp;")
            .replace(/"/g, "&quot;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;");
  };

  PageUtils.$import = function (src) {
    //Note: "import" keyword cannot be used in IE 11
    return new Promise(function (resolve, reject) {
      var script = document.createElement("script");
      script.async = true;
      script.src = src;
      document.head.appendChild(script);
      script.onload = function () {
        resolve();
      };
      script.onerror = function () {
        reject();
      };
    });
  };

  var initializers = {className: {}, tagName: {}};

  var checkElement = function (element) {
    var tagName = element.tagName.toLowerCase();
    if (element.hasAttributes() || tagName === "details") { // for performance
      var initialized = element.getAttribute("data-i");
      if (initialized == undefined) {
        var callback = initializers.tagName[tagName];
        if (callback != undefined) {
          element.setAttribute("data-i", "1");
          callback(element);
        }
        var classList = element.classList;
        if (classList != undefined) { // <math> in IE 11, Opera 12 (during the check for MathML support)
          var classListLength = classList.length;
          if (classListLength !== 0) {
            element.setAttribute("data-i", "1");
            var t = 0;
            for (var k = 0; k < classListLength; k += 1) {
              var className = classList[k];
              var callback = initializers.className[className];
              if (callback != undefined) {
                if (t > 0) {
                  throw new TypeError(classList.toString());
                }
                t += 1;
                callback(element);
              }
            }
          }
        }
      }
    }
  };

  var checkCustomPaint = function (element) {
    if (element.getAttribute("data-custom-paint") != undefined) {
      if (element.getAttribute("data-p") == undefined && element.getBoundingClientRect().top !== 0) {
        element.setAttribute("data-p", "1");
        element.dispatchEvent(new Event('custom-paint', {bubbles: true}));
      }
    }
  };

  var checkSubtree = function (element) {
    checkElement(element);
    var firstElementChild = element.firstElementChild;
    while (firstElementChild != undefined) {
      checkSubtree(firstElementChild);
      firstElementChild = firstElementChild.nextElementSibling;
    }
  };

  var checkSubtree2 = function (element) {
    checkCustomPaint(element);
    var firstElementChild = element.firstElementChild;
    while (firstElementChild != undefined) {
      checkSubtree2(firstElementChild);
      firstElementChild = firstElementChild.nextElementSibling;
    }
  };

  var started = false;

  PageUtils.initialize = function (selector, callback) {
    if (selector.startsWith(".")) {
      var className = selector.slice(1);
      if (started || initializers.className[className] != undefined) {
        throw new TypeError(className);
      }
      initializers.className[className] = callback;
    } else {
      initializers.tagName[selector] = callback;
    }
  };

  var observe = function () {
    if (!started) {
      started = true;
      // some initializers can modify DOM, so it is important to call `checkSubtree` after `observer.observe`
      checkSubtree(document.body);
      checkSubtree2(document.body);
    }
  };

  var preObserve = function () {
    if (true) {
      // trying to initialize page earlier (before first paint (?))
      observe();
    }
    //loadI18n();
  };

  PageUtils.waitI18n = function (callback) {
    if (globalThis.i18n != null) {
      callback();
    } else {
      window.addEventListener('i18n-loaded', function (event) {
        callback();
      }, {once: true});
    }
  };

  var loadI18n = function () {
    var lang = document.documentElement.lang;
    //! the lang is set to iw-x-mtfrom-en at https://translate.googleusercontent.com/translate_c?depth=1&hl=iw&prev=search&rurl=translate.google.co.il&sl=en&u=https://matrixcalc.org/en/ - TODO - check
    if (lang.indexOf('-mtfrom-') !== -1) {
      lang = lang.slice(lang.indexOf('-mtfrom-') + '-mtfrom-'.length);
    }
    var i18nUrl = (document.documentElement.lang === 'ru' ? '.' : '..') + '/i18n-' + lang + '.json' + (document.documentElement.getAttribute('data-version-tag') || '');
    // Use `cache: 'force-cache'` to workaround the issue, that Cache-Control is different for HTML/JS/CSS and JSON
    // As we have a version tag in the query string, it should be fine.
    fetch(i18nUrl, {credentials: 'same-origin', cache: 'force-cache'}).then(function (response) {
      return response.json();
    }).then(function (i18n) {
      globalThis.i18n = i18n;
      if (i18n.errors == null) {
        window.location.reload(true);//!
      }
      //observe();
      window.dispatchEvent(new Event('i18n-loaded')); // https://stackoverflow.com/a/42837595/839199
    });
  };
  loadI18n();

  document.addEventListener("DOMContentLoaded", function (event) {
    //TODO: remove
    var scriptVersion = '?20210810T140212Z';
    var htmlVersion = document.documentElement.getAttribute('data-version-tag') || scriptVersion;
    if ((scriptVersion !== htmlVersion) && (window.location.protocol === 'http:' || window.location.protocol === 'https:') && Object.keys != null && Object.keys(initializers).length !== 0 && window.fetch != null) {
      // a workaround for a caching bug in browsers
      // https://bugs.chromium.org/p/chromium/issues/detail?id=899752 - ?
      // Chrome/70
      // also there are some another error in Firefox, seems
      // Chrome - only for http: protocol, seems
      // Firefox - any protocol - ? (https:)
      fetch(window.location.href.replace(/^http\:/g, 'https:'), {cache: "no-cache"}).then(function (response) {
        return response.text();
      }).then(function (text) {
        var parser = new DOMParser();
        var doc = parser.parseFromString(text, "text/html");
        document.body.innerHTML = doc.body.innerHTML;
        preObserve();
      })["catch"](function () {
        preObserve();//!
      });
    } else {
      preObserve();
    }
  }, {once: true});

  // workaround for browsers, which do not support MutationObserver
  PageUtils.check = function (element) {
    checkSubtree(element);
    checkSubtree2(element);
  };

  PageUtils.check1 = function (element) {
    checkSubtree(element);
    checkSubtree2(element);
  };

  //Note: `Utils` is not a good name (somehow web clients may already have a variable with that name)
  globalThis.PageUtils = PageUtils;

}());

/*global document, window */

(function () {
  "use strict";

  var ANIMATION_DURATION = 120;

  var animateOnClose = function (dialog) {
    dialog.style.display = "";
    if (dialog.animate != undefined) {
      dialog.style.display = "block";
      dialog.style.opacity = "0";
      dialog.style.transform = "scale(0.75)";
      dialog.animate([
        {transform: "scale(1.3333333333333333)", opacity: "1"},
        {transform: "scale(1)", opacity: "0"}
      ], {
        duration: ANIMATION_DURATION,
        composite: "add"
      });
      window.setTimeout(function () {
        dialog.style.display = "";
      }, ANIMATION_DURATION);
    }
    var backdrop = document.getElementById(dialog.getAttribute("data-backdrop-id"));
    if (backdrop != undefined) {
      if (backdrop.animate != undefined) {
        backdrop.style.opacity = "0";
        backdrop.animate([
          {opacity: "1"},
          {opacity: "0"}
        ], {
          duration: ANIMATION_DURATION,
          composite: "add"
        });
        window.setTimeout(function () {
          if (backdrop.parentNode != undefined) {
            backdrop.parentNode.removeChild(backdrop);
          }
        }, ANIMATION_DURATION);
      } else {
        backdrop.parentNode.removeChild(backdrop);
      }
    }
  };

  var animateOnShow = function (dialog) {
    dialog.style.display = "block"; // set display to "block" to play animation on closing later
    if (dialog.animate != undefined) {
      dialog.style.opacity = "1";
      dialog.style.transform = "scale(1)";
      dialog.animate([
        {transform: "scale(0.75)", opacity: "-1"},
        {transform: "scale(1)", opacity: "0"}
      ], {
        duration: ANIMATION_DURATION,
        composite: "add"
      });
    }
    var backdrop = document.getElementById(dialog.getAttribute("data-backdrop-id"));
    if (backdrop != undefined) {
      if (backdrop.animate != undefined) {
        backdrop.style.opacity = "1";
        backdrop.animate([
          {opacity: "-1"},
          {opacity: "0"}
        ], {
          duration: ANIMATION_DURATION,
          composite: "add"
        });
      }
    }
  };

if (window.MutationObserver != null) {
  document.addEventListener('DOMContentLoaded', function (event) {
    // with "animationstart" there is some flickering...
    // ... trying to use MutationObserver
    var observer = new MutationObserver(function (mutationList) {
      for (var i = 0; i < mutationList.length; i += 1) {
        var mutation = mutationList[i];
        var target = mutation.target;
        if (target.tagName.toLowerCase() !== "details") {//TODO: ?
          if (target.getAttribute("open") != null) {
            animateOnShow(target);
          } else {
            animateOnClose(target);
          }
        }
      }
    });
    observer.observe(document.body, {
      attributes: true,
      attributeFilter: ["open"],
      subtree: true
    });
  }, {once: true});
}

  function Dialog() {
  }

  var idCounter = 0;
  // "Cancel", "OK", "Close"
  // for use as a modal dialog
  Dialog.standard = function (contentHTML, buttonsHTML) {
    var dialog = document.createElement("dialog");
    if (dialog.initDialog != null) {
      dialog.initDialog();
    }
    var contentId = "dialog-content";
    dialog.classList.toggle("standard-dialog", true);
    dialog.setAttribute("aria-describedby", contentId);
    //?
    dialog.innerHTML = "<form method=\"dialog\">" +
                       "<button type=\"submit\" class=\"close\" aria-label=\"" + i18n.misc.close + "\">🗙</button>" +
                       "<div id=\"" + contentId + "\" class=\"content\">" + contentHTML + "</div>" +
                       "<div class=\"buttons\">" + buttonsHTML + "</div>" +
                       "</form>";
    document.body.appendChild(dialog);
    var backdropId = "backdrop" + (idCounter += 1).toString();
    dialog.setAttribute("data-backdrop-id", backdropId);
    var backdrop = document.createElement("div");
    backdrop.id = dialog.getAttribute("data-backdrop-id");
    backdrop.classList.toggle("backdrop", true);
    document.body.appendChild(backdrop);
    dialog.addEventListener("close", function (event) {
      window.setTimeout(function () {
        dialog.parentNode.removeChild(dialog);
      }, Math.max(2000, ANIMATION_DURATION));
    }, false);
    var lastActiveElement = document.activeElement;
    dialog.addEventListener("close", function (event) {
      if (lastActiveElement != null) {
        lastActiveElement.focus();
      }
    }, false);
    if (document.activeElement != null) {
      dialog.style.visibility = "hidden";
      dialog.style.display = "block";
      dialog.style.position = 'absolute';
      var rect = document.activeElement.getBoundingClientRect();
      var left = (rect.left + rect.right) / 2 - dialog.offsetWidth / 2;
      var top = (rect.top + rect.bottom) / 2 - dialog.offsetHeight / 2;
      left = Math.min(left, document.documentElement.clientWidth - dialog.offsetWidth);
      top = Math.min(top, document.documentElement.clientHeight - dialog.offsetHeight);
      left = Math.max(left, 0);
      top = Math.max(top, 0);
      left = window.pageXOffset + left;
      top = window.pageYOffset + top;
      dialog.style.left = left + 'px';
      dialog.style.top = top + 'px';
      dialog.style.right = 'auto';
      dialog.style.bottom = 'auto';
      dialog.style.visibility = "";
      dialog.style.display = "";
    }
    dialog.showModal();
    return dialog;
  };

  Dialog.alert = function (contentHTML) {
    window.setTimeout(function () { // hack to prevent the closing of new dialog immediately in Chrome
      var dialog = Dialog.standard(contentHTML, "<button autofocus=\"autofocus\" type=\"submit\">OK</button>");
    }, 0);
  };

  //Dialog.promptNumber = function (title, min, max, callback) {
  //  var dialog = Dialog.standard("<h3>" + title + "</h3>" + "<div><input type=\"number\" autofocus=\"autofocus\" required=\"required\" min=\"" + min + "\" max=\"" + max + "\" step=\"1\" /></div>", "<button autofocus=\"autofocus\" type=\"reset\">CANCEL</button><button type=\"submit\">OK</button>");
  //  dialog.addEventListener("close", function (event) {
  //    if (dialog.returnValue != undefined) {
  //      callback(dialog.querySelector("input").value);
  //    }
  //  }, false);
  //  return dialog;
  //};

  globalThis.Dialog = Dialog;

}());

/*global document, Dialog */

(function () {
  "use strict";

  var oldHighlights = undefined;
  var highlight = function (element) {
    if (oldHighlights != undefined) {
      for (var i = 0; i < oldHighlights.length; i += 1) {
        var t = document.getElementById(oldHighlights[i]);
        if (t != undefined) {
          t.removeAttribute("mathbackground");
          t.removeAttribute("mathcolor");
        }
      }
      oldHighlights = undefined;
    }
    if (element != undefined) {
      var highlight = element.getAttribute("data-highlight"); // #id1, #id2, ...
      if (highlight != undefined) {
        var newHighlights = highlight.replace(/[#\s]/g, "").split(",");
        for (var j = 0; j < newHighlights.length; j += 1) {
          var e = document.getElementById(newHighlights[j]);
          if (e != undefined) {
            e.setAttribute("mathbackground", "#FAEBD7");
            e.setAttribute("mathcolor", "#3C78C2");
          }
        }
        oldHighlights = newHighlights;
      }
    }
  };

  var tooltip = null;

  var keyDownTarget = undefined;

  var onKeyDown = function (event) {
    var DOM_VK_ESCAPE = 27;
    if (event.keyCode === DOM_VK_ESCAPE && !event.ctrlKey && !event.altKey && !event.shiftKey && !event.metaKey && !event.defaultPrevented) {
      event.preventDefault();
      showTooltip(undefined);
    }
  };

  var showTooltip = function (element) {
    if (keyDownTarget != undefined) {
      keyDownTarget.removeEventListener("keydown", onKeyDown, false);
      keyDownTarget.removeAttribute("aria-describedby");
      keyDownTarget = undefined;
    }
    if (tooltip == null) {
      tooltip = document.createElement("div");
      tooltip.id = "highlight-tooltip";
      tooltip.setAttribute("role", "tooltip");
      tooltip.classList.toggle("tooltip-dialog", true);
    }
    if (tooltip.getAttribute("open") != undefined && element == undefined) {
      tooltip.removeAttribute("open");
    }
    if (element != undefined) {
      var tooltipContainer = element.tagName.toLowerCase() === "maction" ? element.lastElementChild : element;
      var tooltipId = element.getAttribute("data-tooltip");//TODO: remove
      if (tooltipId != undefined) {
        tooltipContainer = document.getElementById(tooltipId);
      }
        keyDownTarget = element.tagName.toLowerCase() === "maction" ? element.firstElementChild : document.getElementById(element.getAttribute("data-for"));
        var rect = keyDownTarget.getBoundingClientRect();
        keyDownTarget.setAttribute("aria-describedby", tooltip.id);
        keyDownTarget.addEventListener("keydown", onKeyDown, false);
        if (tooltip.parentNode == undefined) {
          document.body.appendChild(tooltip);
        }
        tooltip.textContent = "";
        var c = tooltipContainer.cloneNode(true);
        if (element.tagName.toLowerCase() === "maction") {
          var math = document.createElementNS("http://www.w3.org/1998/Math/MathML", "math");
          math.appendChild(c);
          tooltip.appendChild(math);
        } else {
        while (c.firstChild != undefined) {
          tooltip.appendChild(c.firstChild);
        }
        }
        //tooltip.style.transform = "scale(1)";
        tooltip.style.visibility = "hidden";
        var display = tooltip.style.display;
        tooltip.style.display = "block";
        tooltip.style.position = "absolute";
        tooltip.style.right = "auto"; // Chrome 49 with html[dir="rtl"] uses 0px from right
        tooltip.style.top = (window.pageYOffset + rect.top - tooltip.offsetHeight - 8.5) + 'px';
        tooltip.style.left = (window.pageXOffset + (rect.left + rect.right) / 2 - tooltip.offsetWidth / 2) + "px";
        tooltip.style.bottom = "auto";
        tooltip.style.display = display;
        tooltip.style.visibility = "";
        //tooltip.style.transform = "";
        if (tooltip.getAttribute("open") == undefined) {
          tooltip.setAttribute("open", "open"); // "show" moves the focus in Chrome
        }
    }
  };

  var f = function (highlight) {

    var hoveredElements = [];
    var focusedElements = [];

    return function (element) {
      var x = element.tagName.toLowerCase() === "maction" ? element.firstElementChild : document.getElementById(element.getAttribute("data-for"));

      //!
      // The idea is to set tabindex="0" only for cells which have a tooltip or a "highlight"
      x.setAttribute("tabindex", "0");
      var tagName = x.tagName.toLowerCase();
      if (tagName === 'mrow' || tagName === 'mtd') {
        if (x.tabIndex == null) {
          x.setAttribute("href", "#");
        }
      } else {
        if (tagName !== 'a') {
          throw new RangeError(tagName);
        }
      }
      //!

      var highlightInternal = function () {
        window.setTimeout(function () {
        highlight(hoveredElements.length !== 0 ? hoveredElements[hoveredElements.length - 1] : (focusedElements.length !== 0 ? focusedElements[focusedElements.length - 1] : undefined));
        }, 0);
      };

      x.addEventListener("mouseenter", function (event) {
        hoveredElements.push(element);
        highlightInternal();
      }, false);
      x.addEventListener("mouseleave", function (event) {
        hoveredElements.pop();
        highlightInternal();
      }, false);
      x.addEventListener("focus", function (event) {
        focusedElements.push(element);
        highlightInternal();
      }, false);
      x.addEventListener("blur", function (event) {
        focusedElements.pop();
        highlightInternal();
      }, false);
    };

  };

  globalThis.initializeAHighlight = f(highlight);
  globalThis.initializeATooltip = f(showTooltip);

}());

/*global window, document, Dialog*/

window.reportValidity = function (input, validationMessage) {
  "use strict";
  var tooltip = document.createElement("div");
  tooltip.setAttribute("role", "tooltip");
  tooltip.id = "report-validity-tooltip-for-" + input.id;
  tooltip.classList.toggle("tooltip", true);
  tooltip.classList.toggle("tooltip-dialog", true);//?
  var tooltipArrowId = "tooltip-arrow-" + input.id;
  tooltip.innerHTML = "<span class=\"exclamation\">!</span> " + validationMessage + "<div class=\"tooltip-arrow-wrapper\"><div id=\"" + tooltipArrowId + "\" class=\"tooltip-arrow\"></div></div>";
  document.body.appendChild(tooltip);

  input.setAttribute("aria-describedby", tooltip.id);
  input.focus();

  var inputRect = input.getBoundingClientRect();

  tooltip.style.visibility = "hidden";
  tooltip.style.display = "block";
  var rect = tooltip.getBoundingClientRect();
  var style = window.getComputedStyle(tooltip, undefined);
  var marginLeft = Number.parseFloat(style.marginLeft);
  var tooltipArrow = document.getElementById(tooltipArrowId);
  var arrowRect = tooltipArrow.getBoundingClientRect();
  tooltip.style.display = "";
  tooltip.style.visibility = "";

  var left = (inputRect.left + inputRect.right) / 2 - ((arrowRect.right - arrowRect.left) / 2 + marginLeft + arrowRect.left - rect.left);
  var top = inputRect.bottom + (arrowRect.bottom - arrowRect.top) * 0.15;
  // (17 + 2) * Math.SQRT2 / 2 + 0.25 * 17 + 1 + 0.5 * 17 - (17 + 2) * (Math.SQRT2 - 1) / 2
  // (17 + 2) * Math.SQRT2 * 0.15

  tooltip.style.position = 'absolute';
  tooltip.style.right = 'auto';
  tooltip.style.bottom = 'auto';
  tooltip.style.left = (window.pageXOffset + left) + 'px';
  tooltip.style.top = (window.pageYOffset + top) + 'px';
  tooltip.setAttribute("open", "open"); // "show" moves the focus in Chrome

  var close = undefined;
  var onKeyDown = undefined;
  var timeoutId = 0;

  close = function (event) {
    window.clearTimeout(timeoutId);
    input.removeEventListener("input", close, false);
    input.removeEventListener("blur", close, false);
    input.removeEventListener("keydown", onKeyDown, false);
    input.removeAttribute("aria-describedby");
    tooltip.id = ""; //! test case: trigger the tooltip twice
    tooltipArrow.id = "";
    tooltip.removeAttribute("open");
    window.setTimeout(function () {
      tooltip.parentNode.removeChild(tooltip);
    }, 3000);
  };
  onKeyDown = function (event) {
    var DOM_VK_ESCAPE = 27;
    if (event.keyCode === DOM_VK_ESCAPE && !event.ctrlKey && !event.altKey && !event.shiftKey && !event.metaKey && !event.defaultPrevented) {
      event.preventDefault();
      close();
    }
  };
  timeoutId = window.setTimeout(function () {
    close(undefined);
  }, 4000);
  input.addEventListener("input", close, false);
  input.addEventListener("blur", close, false);
  input.addEventListener("keydown", onKeyDown, false);

};

/*global document*/

(function () {
  "use strict";

  function CustomMenclose() {
  }
  CustomMenclose.getPointByCell = function (paddingRect, rows, indexes) {
    var a = indexes[0];
    var b = indexes[1];
    var e = rows[a][b];
    var r = e.getBoundingClientRect();
    return {
      x: (r.left + r.right) / 2 - paddingRect.left,
      y: (r.top + r.bottom) / 2 - paddingRect.top
    };
  };
  CustomMenclose.paint = function (event) {
    var paddingRect = this.getBoundingClientRect();
    var width = paddingRect.right - paddingRect.left;
    var height = paddingRect.bottom - paddingRect.top;
    var svg = "";
    var cells = JSON.parse(this.getAttribute("data-cells"));
    var color = this.getAttribute("data-color");
    var strokeStyle = color === "0a" ? "#D64040" : (color === "0" ? "#F7D9D9" : (color === "1a" ? "#4040D6" : (color === "1" ? "#D9D9F7" : "")));
    var lineWidth = 1.25;
    var table = this.querySelector("mtable");
    var rows = [];
    var c = table.firstElementChild;
    while (c != undefined) {
      if (c.tagName.toLowerCase() === 'mtr') {
        var row = [];
        var t = c.firstElementChild;
        while (t != undefined) {
          if (t.tagName.toLowerCase() === 'mtd') {
            row.push(t);
          }
          t = t.nextElementSibling;
        }
        rows.push(row);
      }
      c = c.nextElementSibling;
    }
    for (var i = 0; i < cells.length; i += 1) {
      var p1 = CustomMenclose.getPointByCell(paddingRect, rows, cells[i]);
      var p2 = CustomMenclose.getPointByCell(paddingRect, rows, i === cells.length - 1 ? cells[0] : cells[i + 1]);
      svg += "<line x1=\"" + p1.x.toString() + "\" y1=\"" + p1.y.toString() + "\" x2=\"" + p2.x.toString() + "\" y2=\"" + p2.y.toString() + "\" stroke=\"" + strokeStyle + "\" stroke-width=\"" + lineWidth.toString() + "\" />";
    }
    var backgroundImage = "data:image/svg+xml," + encodeURIComponent("<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"" + width + "\" height=\"" + height + "\" viewBox=\"0 0 " + width + " " + height + "\">" + svg + "</svg>");
    this.style.backgroundImage = "url(\"" + backgroundImage + "\")";
    this.style.backgroundSize = "auto auto";
  };

  document.addEventListener("custom-paint", function (event) {
    if (event.target.getAttribute("data-custom-paint") === "custom-menclose") {
      CustomMenclose.paint.call(event.target, event);
    }
  }, false);

}());

/*global window, document, console, Node, Event*/

//TODO: optimize

(function () {
  "use strict";

  var scrollEventSupport = undefined;
  var callbacks = [];
  var isScrollEventSupported = function (node, callback) {
    if (node.tagName.toLowerCase() !== 'input') {
      callback(true);
    }
    if (scrollEventSupport == null && callbacks.length === 0) {
      callbacks.push(callback);
      var input = document.createElement('input');
      var c = 0;
      input.addEventListener('scroll', function (event) {
        c += 1;
      }, false);
      document.body.appendChild(input);
      input.value = new Array(1024).join('x');
      //input.setSelectionRange(input.value.length, input.value.length);
      input.scrollLeft = 10000;
      input.visibility = 'hidden';
      window.requestAnimationFrame(function () {
        window.requestAnimationFrame(function () {
          input.parentNode.removeChild(input);
          scrollEventSupport = c !== 0;
          for (var i = 0; i < callbacks.length; i += 1) {
            callbacks[i](scrollEventSupport);
          }
          callbacks.length = 0;
        });
      });
    } else if (callbacks.length !== 0) {
      callbacks.push(callback);
    } else {
      callback(scrollEventSupport);
    }
  };

  var selectionChangeEventSupport = undefined;
  var isSelectionChangeEventSupported = function (node) {
    if (!('onselectionchange' in document)) {
      return false;
    }
    if (node.hasAttribute('contenteditable')) {
      return true;
    }
    if (selectionChangeEventSupport == null) {
      var div = document.createElement('div');
      var input = document.createElement('input');
      div.appendChild(input);
      document.body.appendChild(div);
      input.value = 'x';
      input.select();
      var selection = window.getSelection();
      selectionChangeEventSupport = selection.anchorOffset === selection.focusOffset && selection.anchorNode === div && selection.focusNode === div;
      div.parentNode.removeChild(div);
    }
    return selectionChangeEventSupport;
  };

var queue = [];
var initializeAInput = function (container) {
  var input = container.firstElementChild;
  if (input.tagName.toLowerCase() !== 'input' && input.tagName.toLowerCase() !== 'textarea' && !input.hasAttribute('contenteditable')) {
    throw new TypeError();
  }
  var idPrefix = input.id + '=';

  // see https://github.com/kueblc/LDT

  var inputStyle = window.getComputedStyle(input, undefined);

  // FF does not like font
  var fontSize = inputStyle.fontSize;
  var fontFamily = inputStyle.fontFamily;
  var fontWeight = inputStyle.fontWeight;
  var lineHeight = inputStyle.lineHeight;
  var textAlign = inputStyle.textAlign;

  var marginLeft = Number.parseFloat(inputStyle.marginLeft);
  var marginTop = Number.parseFloat(inputStyle.marginTop);
  var marginRight = Number.parseFloat(inputStyle.marginRight);
  var marginBottom = Number.parseFloat(inputStyle.marginBottom);
  var paddingLeft = Number.parseFloat(inputStyle.paddingLeft);
  var paddingTop = Number.parseFloat(inputStyle.paddingTop);
  var paddingRight = Number.parseFloat(inputStyle.paddingRight);
  var paddingBottom = Number.parseFloat(inputStyle.paddingBottom);

  // when the width of a textarea is small, paddingRight will not be included in scrolling area,
  // but this is not true for an input, in Firefox - for both
  // see https://developer.mozilla.org/en-US/docs/Mozilla/Gecko/Chrome/CSS/overflow-clip-box
  if (input.tagName.toLowerCase() === "input") {
    // Firefox, Edge, Chrome
    marginLeft += paddingLeft;
    marginTop += paddingTop;
    marginRight += paddingRight;
    marginBottom += paddingBottom;
    paddingLeft = 0;
    paddingTop = 0;
    paddingRight = 0;
    paddingBottom = 0;
  } else {
    if (paddingRight !== 0 || paddingBottom !== 0) {
      console.warn("Set paddingRight and paddingBottom to zero for <textarea> elements");
    }
  }

  var backgroundElement = document.createElement("div");
  backgroundElement.style.fontSize = fontSize;
  backgroundElement.style.fontFamily = fontFamily;
  backgroundElement.style.fontWeight = fontWeight;
  backgroundElement.style.lineHeight = lineHeight;
  backgroundElement.style.textAlign = textAlign;
  backgroundElement.style.paddingLeft = paddingLeft + "px";
  backgroundElement.style.paddingTop = paddingTop + "px";
  backgroundElement.style.paddingRight = paddingRight + "px";
  backgroundElement.style.paddingBottom = paddingBottom + "px";
  backgroundElement.setAttribute('translate', 'no'); // for Google Translate
  if (queue.length === 0) {
    window.requestAnimationFrame(function () {
      for (var i = 0; i < queue.length; i += 1) {
        queue[i]();
      }
      queue.length = 0;
    });
  }
  queue.push(function () { // relayout
    input.parentNode.insertBefore(backgroundElement, input);
  });

  var updateTokenNode = function (span, text, tokenClassName, className) {
    var classList = span.classList;
    for (var i = 0; i < classList.length; i += 1) {
      if (classList[i] !== tokenClassName && classList[i] !== className) {
        classList.toggle(classList[i], false);
      }
    }
    if (tokenClassName != null) {
      span.classList.toggle(tokenClassName, true);
    }
    if (className != null) {
      span.classList.toggle(className, true);
    }
    if (span.firstChild == null || text === "") {
      throw new TypeError("Something happens with undo/redo history in Chrome when text node is added/removed.");
    }
    if (span.firstChild.data !== text) {
      span.firstChild.data = text; //Note: on the TextNode
    }
  };

  var add = function (text, tokenClassName, className, div) {
    var span = document.createElement("span");
    span.textContent = " ";
    updateTokenNode(span, text, tokenClassName, className);
    div.appendChild(span);
  };

  var getBracketMarks = function (value, inputSelectionStart) {
    if (inputSelectionStart == null) {
      return {
        first: undefined,
        second: undefined
      };
    }
    var selectionStart = Math.max(inputSelectionStart - 1, 0);
    var c = 0;
    var step = 0;
    var pair = 0;
    while (step === 0 && selectionStart < Math.min(inputSelectionStart + 1, value.length)) {
      c = value.charCodeAt(selectionStart);
      var brackets = "()[]{}〖〗（）";
      for (var k = 0; k < brackets.length; k += 2) {
        if (c === brackets.charCodeAt(k)) {
          pair = brackets.charCodeAt(k + 1);
          step = +1;
        }
        if (c === brackets.charCodeAt(k + 1)) {
          pair = brackets.charCodeAt(k);
          step = -1;
        }
      }
      selectionStart += 1;
    }
    selectionStart -= 1;
    if (step !== 0) {
      var i = selectionStart;
      var depth = 1;
      i += step;
      while (i >= 0 && i < value.length && depth > 0) {
        var code = value.charCodeAt(i);
        if (code === c) {
          depth += 1;
        }
        if (code === pair) {
          depth -= 1;
        }
        i += step;
      }
      i -= step;
      if (depth === 0) {
        return {
          first: {start: selectionStart, end: selectionStart + 1, className: "bracket-mark"},
          second: {start: i, end: i + 1, className: "bracket-mark"}
        };
      } else {
        return {
          first: {start: selectionStart, end: selectionStart + 1, className: "odd-bracket-mark"},
          second: undefined
        };
      }
    }
    return {
      first: undefined,
      second: undefined
    };
  };

  // TODO: to polyfills (?)
  var getClientLeft = function (input) {
    // ! Element#clientLeft and Element#clientTop are rounded to integer
    return input.tagName.toLowerCase() === "input" ? Number.parseFloat(inputStyle.borderLeftWidth) : input.clientLeft;
  };
  var getClientTop = function (input) {
    // ! Element#clientLeft and Element#clientTop are rounded to integer
    return input.tagName.toLowerCase() === "input" ? Number.parseFloat(inputStyle.borderTopWidth) : input.clientTop;
  };

  var updateMargins = function () {
    var clientLeft = getClientLeft(input);
    var clientTop = getClientTop(input);
    //var inputRect = input.getBoundingClientRect();
    var clientRight = input.offsetWidth - input.clientWidth - clientLeft;
    var clientBottom = input.offsetHeight - input.clientHeight - clientTop;

    backgroundElement.style.marginLeft = (clientLeft + marginLeft).toString() + "px";
    backgroundElement.style.marginTop = (clientTop + marginTop).toString() + "px";
    backgroundElement.style.marginRight = (clientRight + marginRight).toString() + "px";
    backgroundElement.style.marginBottom = (clientBottom + marginBottom).toString() + "px";
  };

  var updateDirectionality = function () {
    var dir = input.getAttribute('dir') || 'ltr';
    if (backgroundElement.getAttribute('dir') !== dir) { // avoid layout invalidation in Chrome
      backgroundElement.setAttribute('dir', dir);
    }
  };

  // TODO: start, end, insertion
  var updateLine = function (line, marks, lineNode) {
    //lineNode.textContent = '';
    var tokenNode = lineNode.firstElementChild;
    var tokenizer = new Tokenizer(line, 0, null);
    var token = null;
    var position = 0;
    while ((token = tokenizer.next()).type !== 'EOF') {
      var className = null;
      for (var i = 0; i < marks.length; i += 1) {
        var m = marks[i];
        if (m.start >= position && m.end <= tokenizer.position) {
          className = m.className;
        }
      }
      if (tokenNode == null) {
        tokenNode = document.createElement('span');
        tokenNode.textContent = ' ';
        lineNode.appendChild(tokenNode);
      }
      //TODO: move ?
      var type = token.type === 'symbol' && /^pi|[eiEIUnkXY]$/.test(token.value) ? 'special-symbol' : token.type;
      var tokenText = line.slice(position, tokenizer.position); // token.value contains replaced characters and even the token.value can have a different length
      updateTokenNode(tokenNode, tokenText, type, className);
      position = tokenizer.position;
      tokenNode = tokenNode.nextElementSibling;
    }
    while (tokenNode != null) {
      var next = tokenNode.nextElementSibling;
      tokenNode.parentNode.removeChild(tokenNode);
      tokenNode = next;
    }
    //TODO: EOF?

/*
    var start = 0;
    var end = line.length;

    for (var i = 0; i < marks.length; i += 1) {
      var m = marks[i];
      var s = m.start > start ? m.start : start;
      var e = m.end < end ? m.end : end;
      if (s < e) {
        add(line.slice(start, s), null, null, lineNode);
        add(line.slice(s, e), null, m.className, lineNode);
        start = e;
      }
    }
    if (start < end) {
      add(line.slice(start, end), null, null, lineNode);
      start = end;
    }
*/
    if (input.getAttribute("list") != undefined && textAlign !== 'center') {
      add("  ", null, null, lineNode); // to increase scrollWidth in Chrome
    }
  };

  var map = {};
  var idCounter = -1;

  var getCursorPosition = function (input) {
    try {
      return input.selectionDirection !== 'forward' ? input.selectionStart : input.selectionEnd;
    } catch (error) {
      // input.type === 'number' on some browsers
      console.error(error);
      return null;
    }
  };

  var getCursorSecondPosition = function (input) {
    try {
      return input.selectionDirection === 'forward' ? input.selectionStart : input.selectionEnd;
    } catch (error) {
      // input.type === 'number' on some browsers
      console.error(error);
      return null;
    }
  };

  var update = function (event) {
    var value = input.value;
    var marks = [];
    // Firefox 3.6.28 throws when trying to get selectionStart/selectionEnd on invisible element (textarea/input)
    var tmp0 = getBracketMarks(value, input.getBoundingClientRect().left === 0 ? null : getCursorPosition(input));
    if (tmp0.first != undefined) {
      marks.push(tmp0.first);
    }
    if (tmp0.second != undefined) {
      marks.push(tmp0.second);
    }
    var error = input.getAttribute("data-error");
    if (error != undefined) {
      marks.push({start: Number(error.split(",")[0]), end: Number(error.split(",")[1]), className: "error-mark"});
    }
    marks.sort(function (a, b) {
      return a.start < b.start ? -1 : (b.start < a.start ? +1 : 0);
    });

      //var scrollLeft = input.scrollLeft;
      //var scrollTop = input.scrollTop;
      updateMargins();
      updateDirectionality();

      var lines = value.split('\n');
      var start = 0;
      var node = backgroundElement.firstElementChild;
      for (var j = 0; j < lines.length; j += 1) {
        if (node == null) {
          node = document.createElement("div");
          node.id = idPrefix + (++idCounter);
          map[node.id] = {line: null, lineMarks: null};
          backgroundElement.appendChild(node);
        }
        var div = node;
        var line = lines[j];
        var lineMarks = [];
        for (var i = 0; i < marks.length; i += 1) {
          var m = marks[i];
          var s = Math.max(m.start - start, 0);
          var e = Math.min(m.end - start, line.length + '\n'.length);
          if (s < e) {
            lineMarks.push({start: s, end: e, className: m.className});
          }
        }
        var data = map[div.id];
        if (line !== data.line || JSON.stringify(lineMarks) !== JSON.stringify(data.lineMarks)) {
          //Note: empty lines are collapsed
          //Note: extra whitespace/newline may work not well with text-align inequal to 'start'
          updateLine(line || ' ', lineMarks, div);
          data.line = line;
          data.lineMarks = lineMarks;
        }
        start += line.length + '\n'.length;
        node = node.nextElementSibling;
      }
      while (node != undefined) {
        var next = node.nextElementSibling;
        delete map[node.id];
        node.parentNode.removeChild(node);
        node = next;
      }

      //window.requestAnimationFrame(function () {//?
        // avoid strange style recalcuation which stops the smooth scrolling animation (element.scrollIntoViewIfNeeded(false))
        //if (backgroundElement.scrollLeft !== scrollLeft) {
        //  backgroundElement.scrollLeft = scrollLeft;
        //}
        //if (backgroundElement.scrollTop !== scrollTop) {
        //  backgroundElement.scrollTop = scrollTop;
        //}
      //});
  };

  var updateMarks = function () {
    update(undefined);
  };
  
  var wasSelected = false;
  // if selection contains exactly one token and it is not a punctuation or operator select all other similar tokens
  var updateSelectionMatches = function (start, end) {
    if (start > end) {
      var tmp = start;
      start = end;
      end = tmp;
    }
    if (end - start >= 1 || wasSelected) {
      var selectedToken = null;
      var lineNode = backgroundElement.firstElementChild;
      var lineStart = 0;
      while (lineNode != null) {
        var data = map[lineNode.id];
        var line = data.line;
        var s = Math.min(start - lineStart, line.length);
        var e = Math.min(end - lineStart, line.length);
        if (s < e) {
          var tokenNode = lineNode.firstElementChild;
          while (tokenNode != null) {
            var n = tokenNode.firstChild.data.length;
            if (s === 0 && e === n) {
              selectedToken = tokenNode;
            }
            s -= n;
            e -= n;
            tokenNode = tokenNode.nextElementSibling;
          }
        }
        lineStart += line.length + '\n'.length;
        lineNode = lineNode.nextElementSibling;
      }
      if (wasSelected || selectedToken != null) {
        var selectionText = selectedToken != null && (selectedToken.classList.contains('symbol') || selectedToken.classList.contains('special-symbol')) ? selectedToken.firstChild.data : null;
        var lineNode = backgroundElement.firstElementChild;
        while (lineNode != null) {
          var tokenNode = lineNode.firstElementChild;
          while (tokenNode != null) {
            var ok = tokenNode.firstChild.data === selectionText;
            tokenNode.classList.toggle("selectionMatches", ok);
            wasSelected = wasSelected || ok;
            tokenNode = tokenNode.nextElementSibling;
          }
          lineNode = lineNode.nextElementSibling;
        }
      }
    }
  };

  var oldCursorPosition = null;
  var oldCursorSecondPosition = null;
  var ticking = false;
  var checkSelectionChange = function (event) {
    if (!ticking) {
      ticking = true;
      window.requestAnimationFrame(function () { // selectionStart is not changed yet for mousedown event
        ticking = false;
        var newCursorPosition = getCursorPosition(input);
        var newCursorSecondPosition = getCursorSecondPosition(input);
        var flag = oldCursorPosition !== newCursorPosition;
        if (flag) {
          oldCursorPosition = newCursorPosition;
          updateMarks();
        }
        if (flag || oldCursorSecondPosition !== newCursorSecondPosition) {
          oldCursorSecondPosition = newCursorSecondPosition;
          updateSelectionMatches(newCursorPosition, newCursorSecondPosition);
        }
      });
    }
  };
  // https://github.com/w3c/selection-api/issues/53
  // selectionchange
  input.addEventListener("a-input.selectionchange", checkSelectionChange, false);

  var listenForSelectionChangeOrScroll = function (f) {
    // wheel : Shift + mousewheel
    // dragover : https://stackoverflow.com/questions/27713057/event-to-detect-when-the-text-in-an-input-is-scrolled
    var events = ['keydown', 'keyup', 'mousedown', 'mouseup', 'mousemove', 'touchmove', 'input', 'focus', 'blur', 'wheel', 'dragover'];
    for (var i = 0; i < events.length; i += 1) {
      input.addEventListener(events[i], f, events[i] === 'wheel' || events[i] === 'touchmove' ? {passive: true} : false);
    }
  };

  if (!isSelectionChangeEventSupported(input)) {
    listenForSelectionChangeOrScroll(checkSelectionChange);
  }

  input.addEventListener("input", update, false);
  input.addEventListener("update-attribute", function (event) {
    updateMarks();
  }, false);
  var scrollUpdateTicking = false;
  var onScroll = function (event) {
    if (!scrollUpdateTicking) {
      scrollUpdateTicking = true;
      window.requestAnimationFrame(function () {
        scrollUpdateTicking = false;
        var scrollLeft = input.scrollLeft;
        var scrollTop = input.scrollTop;
        backgroundElement.scrollLeft = scrollLeft;
        backgroundElement.scrollTop = scrollTop;
      });
    }
  };
  input.addEventListener("scroll", onScroll, false);

  isScrollEventSupported(input, function (supported) {
    if (!supported) {
      // as the "scroll" event is not supported on Chrome
      listenForSelectionChangeOrScroll(onScroll);
      input.addEventListener("a-input.selectionchange", onScroll, false);
    }
  });

  container.classList.toggle('enabled', container.querySelector('input[type="number"]') == null);//!
  container.classList.toggle('focus-within', document.activeElement === input);
  container.setAttribute('lang', '');
  var supports = true;
  try {
    //TODO: use CSS.supports('selector(:focus-within)') instead
    document.body.matches(':focus-within');
  } catch (error) {
    supports = false;
  }
  if (!supports) {
    input.addEventListener("focus", function (event) {
      container.classList.toggle('focus-within', true);
    }, false);
    input.addEventListener("blur", function (event) {
      container.classList.toggle('focus-within', false);
    }, false);
  }

  update(undefined);
};

window.initializeAInput = initializeAInput;

  // document.hasFocus is not a function in Opera Mini
  document.documentElement.classList.toggle('focus-within', document.hasFocus != null ? document.hasFocus() : true);
  window.addEventListener("focus", function (event) {
    document.documentElement.classList.toggle('focus-within', true);
  }, false);
  window.addEventListener("blur", function (event) {
    document.documentElement.classList.toggle('focus-within', false);
  }, false);

  var lastSelection = {
    anchorNode: null,
    focusNode: null
  };
  var fire = function (node) {
    if (node != null) {
      if (node.nodeType === Node.TEXT_NODE) {
        node = node.parentNode;
      }
      if (node != null) {
        node.dispatchEvent(new Event('a-input.selectionchange'));
      }
    }
  };
  var f = function (a, b) {
    if (a !== b) {
      fire(a);
      fire(b);
    } else {
      fire(a);
    }
  };
  var getContainer = function (container, offset) {
    if (container == null) {
      return null;
    }
    var c = container.firstChild;
    var i = 0;
    while (c != null && i < offset) {
      i += 1;
      c = c.nextSibling;
    }
    if (c != null && c.nodeType === Node.ELEMENT_NODE && (c.tagName.toLowerCase() === 'input' || c.tagName.toLowerCase() === 'textarea')) {
      return c;
    }
    return container;
  };
  document.addEventListener('selectionchange', function (event) {
    var selection = window.getSelection();
    var anchorNode = getContainer(selection.anchorNode, selection.anchorOffset);
    var focusNode = getContainer(selection.focusNode, selection.focusOffset);
    if (lastSelection.anchorNode === lastSelection.focusNode && anchorNode === focusNode) {
      f(lastSelection.anchorNode, anchorNode);
    } else {
      f(lastSelection.anchorNode, anchorNode);
      f(lastSelection.focusNode, focusNode);
    }
    lastSelection.anchorNode = anchorNode;
    lastSelection.focusNode = focusNode;
  }, false);

}());

/*global window, document, unescape, hit, Node */

// deprecated

(function () {
"use strict";

function ItemsStorage(keyStorage, itemUpdater) {
  this.keyStorage = keyStorage;
  this.itemUpdater = itemUpdater;
}
ItemsStorage.prototype._save = function (items) {
  var data = [];
  for (var i = 0; i < items.length; i += 1) {
    var x = items[i];
    if (x != undefined) {
      data.push(x);
    }
  }
  var keyStorage = this.keyStorage;
  var save = function (limit) {
    if (data.length > limit) {
      var newData = new Array(limit);
      for (var j = 0; j < limit; j += 1) {
        newData[j] = data[data.length - limit + j];
      }
      data = newData;
    }
    var valueToSave = JSON.stringify(data);
    keyStorage.setItem("resdiv", valueToSave);
    var value = keyStorage.getItem("resdiv");
    if (value !== valueToSave && limit > 1 && valueToSave.length > 1024 * 1024) {
      return save(Math.floor(limit / 2));
    }
    return undefined;
  };
  return save(data.length);
};
ItemsStorage.prototype._load = function () {
  var parseJSONArraySafely = function (value) {
    try {
      // old data ?
      var result = JSON.parse(value);
      if (!(result instanceof Array)) {
        throw new RangeError();
      }
      return result;
    } catch (error) {
      window.setTimeout(function () {
        throw error;
      }, 0);
    }
    return [];
  };
  var value = this.keyStorage.getItem("resdiv");
  var items = value != undefined ? parseJSONArraySafely(value) : [];

  try {
    var m = /(?:^|;)\s*lastResult\s*\=\s*([^;]*)/.exec(document.cookie);
    if (m != undefined) {
      var lastResult = unescape(m[1]);
      if (lastResult !== "") {
        window.setTimeout(function () {
          hit({bc: "cookie"});
        }, 0);
        items.unshift([lastResult]);
        var valueToSave = JSON.stringify(items);
        this.keyStorage.setItem("resdiv", valueToSave);
        if (this.keyStorage.getItem("resdiv") === valueToSave) {
          document.cookie = "lastResult=; expires=Thu, 01 Jan 1970 00:00:00 GMT";
        }
      }
    }
  } catch (error) {
    window.setTimeout(function () {
      throw error;
    }, 0);
  }

  var currentNumber = 0;
  for (var i = 0; i < items.length; i += 1) {
    items[i] = this.itemUpdater(items[i], currentNumber + 1);
    currentNumber = Math.max(currentNumber, items[i].actHistoryId);
  }
  return {
    items: items,
    currentNumber: currentNumber
  };
};
ItemsStorage.prototype.getAllEntries = function (callback) {
  var tmp = this._load();
  var items = tmp.items;
  var keys = new Array(items.length);
  for (var i = 0; i < items.length; i += 1) {
    keys[i] = items[i].actHistoryId;
  }
  callback({keys: keys, items: items});
};
ItemsStorage.prototype.add = function (item, callback) {
  var tmp = this._load();
  var items = tmp.items;
  var currentNumber = tmp.currentNumber;
  var key = currentNumber + 1;
  item.actHistoryId = key;
  items.push(item);
  this._save(items);
  callback(key);
};
ItemsStorage.prototype["delete"] = function (key) {
  var tmp = this._load();
  var items = tmp.items;
  for (var i = 0; i < items.length; i += 1) {
    var x = items[i];
    if (x != undefined && x.actHistoryId === key) {
      items[i] = undefined;
    }
  }
  this._save(items);
};
ItemsStorage.prototype.clear = function () {
  this._save([]);
};


ItemsStorage.updateItem = function (data, idIfNotSet) {
  idIfNotSet = idIfNotSet || undefined;

  var oldVersion = data.version || 0;
  if (oldVersion === 0) {
    // emptry strings are needed for `zInsAct`
    var resultHTML = data.length > 0 ? data[0] : "";
    var resultMatrix = data.length > 1 ? data[1] : "";
    data = {
      resultHTML: resultHTML.indexOf("</custom-math>") === -1 && resultHTML.indexOf("</math>") === -1 ? "<div class=\"math\">" + resultHTML + "</div>" : resultHTML,
      resultMatrix: resultMatrix,
      details: data.length > 2 ? data[2] : undefined,
      expressionString: data.length > 3 ? data[3] : undefined,
      actHistoryId: data.length > 4 ? Number(data[4]) : idIfNotSet,
      detailsHTML: data.length > 5 ? data[5] : undefined,
      version: 7
    };
  }

  if (oldVersion <= 7) {
    if (data.resultMatrix != undefined && data.resultMatrix.indexOf(";") !== -1) {
      // "-17/3\t 4\t 4/3;  8/3\t-2\t-1/3;   -2\t 1\t   1"
      data.resultMatrix = "{{" + data.resultMatrix.replace(/\s*;\s*/g, "},{").replace(/\t/g, ",").replace(/\x20/g, "") + "}}";
      hit({bc: "resultMatrix"});//!
    }
  }

  if (data.resultMatrix === '') {
    var tmp = /onclick\="\(new Matrix\('str',\d+,(\d+)(?:,\d+)?,([\-0-9\/',]+)\)\).print\('a'\);">/.exec(data.resultHTML);
    if (tmp != null) {
      var colsNumber = Number(tmp[1]);
      var rows = [];
      var x = tmp[2].replace(/'/g, '').split(',');
      while (x.length !== 0) {
        rows.push('{' + x.slice(0, colsNumber).join(',') + '}');
        x = x.slice(colsNumber);
      }
      data.resultMatrix = '{' + rows.join(',') + '}';
    }
  }

  if (true) {
    var removeInsertButtons = function (e) {
      var spans = e.querySelectorAll('span');
      for (var i = 0; i < spans.length; i += 1) {
        if (spans[i].style != null && spans[i].style.cssFloat === 'right') {
          spans[i].parentNode.removeChild(spans[i]);
        }
      }
    };
    var removeCustomMath = function (e) {
      var elements = e.querySelectorAll('custom-math');
      for (var i = 0; i < elements.length; i += 1) {
        var x = elements[i];
        var math = document.createElement('math');
        math.innerHTML = x.innerHTML;
        x.parentNode.insertBefore(math, x);
        x.parentNode.removeChild(x);
      }
    };
    var removeMathClass = function (e) {
      var elements = e.querySelectorAll('.math');
      for (var i = 0; i < elements.length; i += 1) {
        var x = elements[i];
        if (x.firstChild === x.lastChild && x.firstElementChild != null && x.firstElementChild.tagName.toLowerCase() === 'math') {
          x.parentNode.insertBefore(x.firstChild, x);
          x.parentNode.removeChild(x);
        } else {
          while (x.firstChild != null) {
            x.parentNode.insertBefore(x.firstChild, x);
          }
          x.parentNode.removeChild(x);
        }
      }

      var es = e.querySelectorAll('span');
      for (var i = 0; i < es.length; i += 1) {
        var x = es[i];
        while (x != null && x.tagName.toLowerCase() !== 'math') {
          x = x.parentNode;
        }
        if (x != null) {
          while (x.firstChild != null) {
            x.parentNode.insertBefore(x.firstChild, x);
          }
          x.parentNode.removeChild(x);
        }
      }

      // add <math></math>
      var visit = function (x) {
        if (x.nodeType === Node.ELEMENT_NODE && x.tagName.toLowerCase().slice(0, 1) === 'm') {
          if (x.tagName.toLowerCase() !== 'math') {
            if (x.previousSibling != null && x.previousSibling.nodeType === Node.ELEMENT_NODE && x.previousElementSibling.tagName.toLowerCase() === 'math') {
              x.previousElementSibling.appendChild(x);
            } else {
              var math = document.createElement('math');
              x.parentNode.insertBefore(math, x);
              x.parentNode.removeChild(x);
              math.appendChild(x);
            }
          }
        } else {
          var c = x.firstChild;
          while (c != null) {
            var next = c.nextSibling;
            visit(c);
            c = next;
          }
        }
      };
      visit(e);
    };
    var removeExtraMrows = function (e) {
      var es = e.querySelectorAll('mrow');
      for (var i = 0; i < es.length; i += 1) {
        var x = es[i];
        if (x.firstChild === x.lastChild && x.firstChild != null && x.attributes.length === 0) {
          x.parentNode.insertBefore(x.firstChild, x);
          x.parentNode.removeChild(x);
        }
      }
    };
    var addRowspacing = function (e) {
      var es = e.querySelectorAll('mtable');
      for (var i = 0; i < es.length; i += 1) {
        var x = es[i];
        if (x.getAttribute('rowspacing') == null) {
          x.setAttribute('rowspacing', '0ex');
        }
      }
    };
    var addMROWs = function (e) {
      var c = e.firstElementChild;
      while (c != undefined) {
        var next = c.nextElementSibling;
        if (c.tagName.toLowerCase() !== 'mrow') {
          hit({bc: "msub+msup"});//!
          var mrow = document.createElement("mrow");
          c.parentNode.insertBefore(mrow, c);
          c.parentNode.removeChild(c);
          mrow.appendChild(c);
        }
        c = next;
      }
    };
    var fixSummary = function (e) {
      var elements = e.querySelectorAll(".summary");
      for (var i = 0; i < elements.length; i += 1) {
        var oldSummary = elements[i];
        if (oldSummary != undefined && oldSummary.tagName.toLowerCase() !== "summary") { // backward compatibility
          hit({bc: ".summary"});//!
          var newSummary = document.createElement("summary");
          while (oldSummary.firstChild != undefined) {
            newSummary.appendChild(oldSummary.firstChild);
          }
          oldSummary.parentNode.insertBefore(newSummary, oldSummary);
          oldSummary.parentNode.removeChild(oldSummary);
        }
      }
    };
    var fixMSUBAndMSUP = function (node) {
      // MFENCED - ?
      if (" mfrac msqrt mroot msub msup munder ".indexOf(" " + node.tagName.toLowerCase() + " ") !== -1) {
        addMROWs(node);
      }
      var c = node.firstElementChild;
      while (c != undefined) {
        fixMSUBAndMSUP(c);
        c = c.nextElementSibling;
      }
    };
    var fixDetails = function (e) {
      var elements = e.querySelectorAll(".details");
      for (var i = 0; i < elements.length; i += 1) {
        var oldDetails = elements[i];
        hit({bc: ".details"});//!
        var container = document.createElement("div");
        container.classList.toggle("details-container", true);
        oldDetails.parentNode.insertBefore(container, oldDetails);
        oldDetails.parentNode.removeChild(oldDetails);
        oldDetails.classList.toggle("details", false);
        container.appendChild(oldDetails);
      }
    };
    var fixDetailsContainer = function (e) {
      var elements = e.querySelectorAll(".details-container");
      for (var i = 0; i < elements.length; i += 1) {
        var old = elements[i];
        var c = old.firstElementChild;
        if (c.classList.contains("details-container")) {
          hit({bc: ".details-container"});//!
          c.parentNode.removeChild(c);
          old.parentNode.insertBefore(c, old);
          old.parentNode.removeChild(old);
        }
      }
    };
    var fixOldDetailsTypes = function (e) {
      var elements = e.querySelectorAll("[data-details]");
      for (var i = 0; i < elements.length; i += 1) {
        var element = elements[i];
        var detailsAttribute = element.getAttribute("data-details");
        var x = JSON.parse(detailsAttribute);
        if (x instanceof Array) {
          hit({bc: 'detailsarray'});
          if (x.length !== 1) {
            throw new TypeError(x.length);//!
          }
          x = x[0];
        }
        var type = x.type;
        if (type === "determinant" || type === "inverse" || type === "rank") {
          hit({bc: "details-" + type});//!
          x.type = type + "-Gauss";
        }
        element.setAttribute("data-details", JSON.stringify(x));
        var idPrefix = element.getAttribute("data-id-prefix") || '';
        if (!/\-/.test(idPrefix)) {
          element.setAttribute("data-id-prefix", idPrefix + '-d' + i);
        }
      }
    };
    var fixMatrixContainer = function (e) { // <= 7
      var elements = e.querySelectorAll(".matrix-container");
      for (var i = 0; i < elements.length; i += 1) {
        var element = elements[i];
        var matrix = element.querySelector(".matrix-menu-show");
        element.removeAttribute('class');//!
        if (matrix != undefined) { // old version
          hit({bc: "matrix-container"});//!
          matrix = matrix.getAttribute("data-matrix") || element.getAttribute("data-matrix");
          if (matrix != undefined) { // Uncaught TypeError: Cannot read property 'replace' of null - https://matrixcalc.org/es/
            if (matrix.indexOf(";") !== -1 || matrix.indexOf("\t") !== -1) {
              matrix = "{{" + matrix.replace(/\s*;\s*/g, "},{").replace(/\t/g, ",").replace(/\x20/g, "") + "}}";
            }
            var columnlines = undefined;
            var useBraces = undefined;
            if (element.firstElementChild.tagName.toLowerCase() === 'mfenced') {
              columnlines = element.firstElementChild.firstElementChild.getAttribute("columnlines");
              if (columnlines != undefined) {
                columnlines = -1;//TODO:
              }
            }
            if (element.querySelector("[open=\"|\"]") != undefined) {
              useBraces = ["|", "|"];
            }
            if (element.querySelector("[open=\"{\"]") != undefined) {
              useBraces = ["{", " "];
            }
            var tmp = document.createElement("div");
            tmp.innerHTML = RPNProxy.toMathML(matrix, {
              columnlines: columnlines,
              useBraces: useBraces
            });
            element.parentNode.insertBefore(tmp.firstElementChild, element);
            element.parentNode.removeChild(element);
          }
        }
      }
    };
    var fixTop = function (e) { // <= 7
      // <span class="top">-1</span>
      var elements = e.querySelectorAll(".top");
      for (var i = 0; i < elements.length; i += 1) {
        var element = elements[i];
        if (element.innerHTML === "-1" || element.innerHTML === "T") {
          hit({bc: "top"});//!
          var base = element.previousElementSibling;
          var tmp = document.createElement("div");
          tmp.innerHTML = "<msup><mrow></mrow><mrow>" + RPNProxy.toMathML(element.innerHTML, {}) + "</mrow></msup>";
          base.parentNode.removeChild(base);
          tmp.firstElementChild.firstElementChild.appendChild(base);
          element.parentNode.insertBefore(tmp.firstElementChild, element);
          element.parentNode.removeChild(element);
        }
      }
    };
    var fixDivMath = function (e) { // <= 7
      var x = e.firstElementChild;
      if (x != undefined && x.tagName.toLowerCase() === 'div' && x.classList.contains('math')) {
        //x.style.display = "inline-block";
        x.setAttribute("style", "display: inline-block;");
      }
    };
    var fixTable = function (e) {
      // <table class="inTable"></table>
      var elements = e.querySelectorAll(".inTable");
      for (var i = 0; i < elements.length; i += 1) {
        var element = elements[i];
        var span = element.nextElementSibling;
        var matrix = '';
        if (span != undefined && span.tagName.toLowerCase() === 'span' && span.style.display === 'none') {
          matrix = "{{" + span.innerHTML.replace(/\s*;\s*/g, "},{").replace(/\t/g, ",").replace(/\x20/g, "") + "}}";
          span.parentNode.removeChild(span);
        } else {
          var matrix = '';
          matrix += '{';
          var tbody = element.firstElementChild;
          for (var row = tbody.firstElementChild; row != null; row = row.nextElementSibling) {
            matrix += '{';
            for (var cell = row.firstElementChild; cell != null; cell = cell.nextElementSibling) {
              if (cell.getAttribute('rowspan') == null) {
                var t = cell.querySelector('table');
                if (t != null) {
                  var x = t.firstElementChild.firstElementChild.textContent + '/' + t.firstElementChild.lastElementChild.textContent;
                  t.innerHTML = x;
                }
                matrix += cell.textContent;//TODO:
                matrix += cell.nextElementSibling != null && cell.nextElementSibling.getAttribute('rowspan') == null ? ',' : '';
              }
            }
            matrix += '}';
            matrix += row.nextElementSibling != null ? ',' : '';
          }
          matrix += '}';
        }
        if (matrix !== '') {
          hit({bc: "inTable"});//!
          var tmp = document.createElement("div");
          var isDeterminant = element.querySelector(".matrix-img-line") != undefined;
          tmp.innerHTML = RPNProxy.toMathML(isDeterminant ? "determinant(" + matrix + ")" : matrix, {});
          element.parentNode.insertBefore(tmp.firstElementChild, element);
          element.parentNode.removeChild(element);
        }
      }
    };
    var fixArrowWithLabel = function (e) {
      var elements = e.querySelectorAll(".arrow-with-label");
      for (var i = 0; i < elements.length; i += 1) {
        var element = elements[i];
        if (element.getAttribute("data-custom-paint") !== "arrow-with-label") {
          element.setAttribute("data-custom-paint", "arrow-with-label");
          hit({bc: "arrow-with-label"});
        }
      }
    };
    var fixMencloseInMenclose = function (e) {
      if (e.querySelector('math') == null) {//!
        var elements = e.querySelectorAll("menclose[notation=none]");
        for (var i = 0; i < elements.length; i += 1) {
          var element = elements[i];
          var mtable = element.querySelector("mtable");
          if (mtable != null && mtable.firstElementChild != null && mtable.firstElementChild === mtable.lastElementChild && mtable.firstElementChild.firstElementChild === mtable.firstElementChild.lastElementChild) {
            var e = mtable.querySelector("menclose[notation=none]");
            if (e != null && e.querySelector("mtable") != undefined && element.getAttribute('data-matrix') === '{{' + e.getAttribute('data-matrix') + '}}') {
              hit({bc: "menclose-menclose"});
              element.parentNode.insertBefore(e, element);
              element.parentNode.removeChild(element);
            }
          }
        }
      }
    };
    var replaceMfenced = function (e) {
      var es = e.querySelectorAll('mfenced');
      for (var i = 0; i < es.length; i += 1) {
        var e = es[i];
        var open = e.getAttribute('open') || '(';
        var mo1 = document.createElement('mo');
        mo1.textContent = open;
        var close = e.getAttribute('close') || ')';
        var mo2 = document.createElement('mo');
        mo2.textContent = close;
        var t = document.createElement('mrow');
        t.appendChild(mo1);
        while (e.firstChild != null) {
          t.appendChild(e.firstChild);
        }
        t.appendChild(mo2);
        e.parentNode.insertBefore(t, e);
        e.parentNode.removeChild(e);
      }
    };
    var fixClassPivot = function (e) {
      var es = e.querySelectorAll('.pivot');
      for (var i = 0; i < es.length; i += 1) {
        var x = es[i];
        if (x.tagName.toLowerCase() === 'mtd') {
          x.removeAttribute('class');
          var tmp = document.createElement('menclose');
          tmp.setAttribute('notation', 'circle');
          while (x.firstChild != null) {
            tmp.appendChild(x.firstChild);
          }
          x.appendChild(tmp);
        }
      }
    };
    var fixMoMo = function (html) {
      //TODO: counter
      return html.replace(/<mo>\+<mo>/g, "<mo>+</mo>");
    };
    var fixDiagonalizeSteps = function (html) {
      return html.replace(/diagonalize-steps/g, "steps-to-diagonalize");
    };
    var removeHref = function (tmp) {
      var es = tmp.querySelectorAll('[href="#"]');
      for (var i = 0; i < es.length; i += 1) {
        es[i].removeAttribute('href');
      }
    };
    var removeMatrixMenuShowNew = function (tmp) {
      var es = tmp.querySelectorAll('.matrix-menu-show-new');
      for (var i = 0; i < es.length; i += 1) {
        es[i].classList.toggle('matrix-menu-show', true);
        es[i].classList.toggle('matrix-menu-show-new', false);
        if (es[i].textContent === '☰') {
          es[i].textContent = '';
        }
      }
    };
    var removeDataX = function (tmp) {
      var es = tmp.querySelectorAll('[data-x="TODO"]');
      for (var i = 0; i < es.length; i += 1) {
        es[i].removeAttribute('data-x');
      }
    };
    var fixMunder = function (tmp) {
      var es = tmp.querySelectorAll('munder');
      for (var i = 0; i < es.length; i += 1) {
        es[i].setAttribute('accentunder', 'true');
      }
    };
    var fixRemoveSpanWrappers = function (tmp) {
      var es = tmp.querySelectorAll('math');
      for (var i = 0; i < es.length; i += 1) {
        var parentNode = es[i].parentNode;
        if (parentNode.tagName.toLowerCase() === 'span') {
          if (parentNode.getAttributeNames().join('') === 'class' && parentNode.childElementCount === 1) {
            var classList = parentNode.getAttribute('class');
            if (classList.replace(/(?:^|\s)no\-\S+|math/g, '').trim() === '') {
              parentNode.parentNode.insertBefore(es[i], parentNode);
              parentNode.parentNode.removeChild(parentNode);
            }
          }
        }
      }
    };
    var fixQuestionIcon = function (tmp) {
      var es = tmp.querySelectorAll('.relative');
      for (var i = 0; i < es.length; i += 1) {
        var x = es[i].firstElementChild;
        if (x != null && x.tagName.toLowerCase() === 'math') {
          var y = x.nextElementSibling;
          if (y != null && (y.tagName.toLowerCase() === 'a' && y.classList.contains('question-icon') || y.tagName.toLowerCase() === 'span')) {
            var math = document.createElement('math');
            math.innerHTML = '<mpadded><mover accent="true">' + x.innerHTML + '<mtext></mtext></mover></mpadded>';
            var mtext = math.querySelector('mtext');
            while (x.nextElementSibling != null) {
              mtext.appendChild(x.nextElementSibling);
            }
            var qi = math.querySelector('.question-icon');
            if (qi != null) {
              qi.classList.toggle('question-icon', false);
              qi.classList.toggle('question-icon-new', true);
            }
            es[i].parentNode.insertBefore(math, es[i]);
            es[i].parentNode.removeChild(es[i]);
          }
        }
      }
    };
    var fixMencloseDraggable = function (tmp) {
      var es = tmp.querySelectorAll('menclose[draggable]');
      for (var i = 0; i < es.length; i += 1) {
        var e = es[i];
        if (e.getAttribute('notation') === 'none') {
          var mrow = document.createElement('mrow');
          while (e.firstElementChild != null) {
            mrow.appendChild(e.firstElementChild);
          }
          var attributeNames = e.getAttributeNames();
          for (var j = 0; j < attributeNames.length; j += 1) {
            var a = attributeNames[j];
            mrow.setAttribute(a, e.getAttribute(a));
          }
          mrow.removeAttribute('notation');
          es[i].parentNode.insertBefore(mrow, e);
          es[i].parentNode.removeChild(e);
        }
      }
    };
    var fixHTML = function (html) {
      if (html == undefined) {
        return html;
      }
      var tmp = document.createElement("div");
      html = fixMoMo(html);
      if (oldVersion <= 15) {
      html = fixDiagonalizeSteps(html);
      }
      tmp.innerHTML = html;
      try {
        fixOldDetailsTypes(tmp);
        if (oldVersion <= 15) {
          removeInsertButtons(tmp);
          fixMSUBAndMSUP(tmp);
          fixSummary(tmp);
          fixDetails(tmp);
          fixDetailsContainer(tmp);
          fixMatrixContainer(tmp);
          fixTable(tmp); // it should be before fixTop
          fixTop(tmp);
          fixDivMath(tmp);
          fixArrowWithLabel(tmp);
          fixMencloseInMenclose(tmp);
          removeCustomMath(tmp);
          removeMathClass(tmp);
          removeExtraMrows(tmp);
          addRowspacing(tmp);
          replaceMfenced(tmp);
          fixClassPivot(tmp);
        }
        if (oldVersion <= 16) {
          removeHref(tmp);
          removeMatrixMenuShowNew(tmp);
          removeDataX(tmp);
        }
        if (oldVersion <= 19) {
          fixMunder(tmp);
          fixRemoveSpanWrappers(tmp);
          fixQuestionIcon(tmp);
          if (tmp.querySelector('.question-icon') != null || tmp.querySelector('.relative') != null) {
            throw new TypeError('an issue with an update');
          }
        }
        if (oldVersion <= 20) {
          fixMencloseDraggable(tmp);
        }
      } catch (error) {
        //TODO: fix
        console.error(error);
        window.setTimeout(function () {
          throw new TypeError("fixHTML(" + error.toString() + "): " + html);
        }, 0);
      }
      return tmp.innerHTML;
    };
    //if (data.expressionString != undefined && data.expressionString !== "") {
    //  RPNProxy.runExpression(data.expressionString, undefined, undefined, undefined, {idPrefix: "i" + data.actHistoryId}, function (result) {
    //    if (result.resultError == undefined) {
    //      data.resultHTML = result.resultHTML;
    //      data.detailsHTML = result.detailsHTML;
    //    }
    //  });
    //} else {
      data.resultHTML = fixHTML(data.resultHTML);
      data.detailsHTML = fixHTML(data.detailsHTML);
    //}
    if (data.detailsHTML == undefined) {
      var details = data.details;
      // details === null after JSON.parse(JSON.stringify(details))
      if (details != undefined && details.length !== 0) {
        hit({bc: "createDetailsSummary"});
        //TODO: async
        data.detailsHTML = RPNProxy.createDetailsSummary("i" + data.actHistoryId, details, details.length === 1 ? 100 : 1);
      }
    }
  }
  return data;
};

globalThis.ItemsStorage = ItemsStorage;

}());
/*global window, console*/

(function () {
"use strict";

function IDBItemsStorage(fallbackItemsStorage) {
  this.fallbackItemsStorage = fallbackItemsStorage;
}
IDBItemsStorage.prototype._ = function (operation, item, key, callback) {
  var fallbackItemsStorage = this.fallbackItemsStorage;
  var useFallback = function () {
    if (operation === "getAllEntries") {
      fallbackItemsStorage.getAllEntries(callback);
    }
    if (operation === "add") {
      fallbackItemsStorage.add(item, callback);
    }
    if (operation === "delete") {
      fallbackItemsStorage["delete"](key);
    }
    if (operation === "clear") {
      fallbackItemsStorage.clear();
    }
  };
  var roundValue = function (value, max) {
    return "10**" + (Math.floor(Math.log(Math.max(value, max) + 0.5) / Math.log(10)) + 1);
  };
  var length = function (value) {
    var n = 0;
    if (value == undefined) {
      n += 8;
    } else if (typeof value === "boolean") {
      n += 8;
    } else if (typeof value === "number") {
      n += 8;
    } else if (typeof value === "string") {
      n += 16 + value.length;
    } else if (typeof value === "object") {
      if (value instanceof Array) {
        for (var j = 0; j < value.length; j += 1) {
          n += length(value[j]);
        }
      } else {
        for (var i in value) {
          if (Object.prototype.hasOwnProperty.call(value, i)) {
            n += length(value[i]);
          }
        }
      }
    }
    return n;
  };
  var start = Date.now();
  var onEvent = function (operation, errorName, value) {
    var tmp = {};
    tmp[operation] = {ok: errorName, duration: roundValue(Date.now() - start, 100 - 1), valueLength: roundValue(length(value), 1000 - 1)};
    hit({idb: tmp});
  };
  var indexedDB = undefined;
  var wasError = false;
  try {
    indexedDB = window.indexedDB;
  } catch (error) {
    wasError = true;
    // "Cookies blocking in Firefox" - https://github.com/Modernizr/Modernizr/issues/1825#issuecomment-171087703
    onEvent("access", error.name, undefined);
    console.log(error);
    useFallback();
  }
  if (!wasError &&
      indexedDB != undefined) {
    var openRequest = undefined;
    try {
      openRequest = indexedDB.open("acthistory");
    } catch (error) {
      // "SecurityError" for opaque origins
      onEvent("access", error.name, undefined);
      console.log(error);
      useFallback();
    }
    if (openRequest != undefined) {
      openRequest.onupgradeneeded = function (event) {
        var db = event.target.result;
        if (db == null) {
          // Mozilla/5.0 (Linux; U; Android 9; ru-ru; Redmi Note 5 Build/PKQ1.180904.001) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/71.0.3578.141 Mobile Safari/537.36 XiaoMi/MiuiBrowser/11.3.4-g
          window.onerror('TypeError: db is null, ' + (openRequest.result == null) + ' ' + (event.target === openRequest));//TODO: remove
          useFallback();
        }
        //! fallbackItemsStorage should be synchronous
        fallbackItemsStorage.getAllEntries(function (tmp) {
          var items = tmp.items;
          //Note: as the version was not provided, the object store should not exist at this point.
          var store = db.createObjectStore("items", {
            //keyPath: undefined, // IE 11 throws an InvalidAccessError for undefined or null
            autoIncrement: true
          });
          for (var i = 0; i < items.length; i += 1) {
            store.add(items[i]);
          }
        });
        //TODO: fallbackItemsStorage.clear()
      };
      //Note: this will handle abort of `openRequest.transaction` or an error during creation of a new database (step 5.1.6)
      openRequest.onerror = function (event) {
        onEvent("access", event.target.error != null ? event.target.error.name : null, undefined);
        console.log(event.target.error);
        useFallback();
        event.preventDefault();// FireFox 52 - 57
      };
      openRequest.onsuccess = function (event) {
        var db = event.target.result;
        var objectStoreNames = db.objectStoreNames;
        if (!objectStoreNames.contains("items")) {
          onEvent("access", "No store", undefined);
          console.log("No store");
          if (operation === "getAllEntries") {
            callback({keys: [], items: []});
          }
        } else {
          onEvent("access", "successful", undefined);
          // Note: it may throw a NotFoundError
          var transaction = db.transaction("items", operation === "getAllEntries" ? "readonly" : "readwrite");
          var store = transaction.objectStore("items");
          // Looks like "abort" is fired for QuotaExceededError
          transaction.onabort = function (event) {
            // TypeError: null is not an object (evaluating 'event.target.error.name') - https://matrixcalc.org/slu.html
            // Mozilla/5.0 (iPhone; CPU iPhone OS 13_1_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0.1 Mobile/15E148 Safari/604.1
            onEvent(operation, event.target.error != null ? event.target.error.name : null, item);
            console.log(event.target.error); // Chrome shows nothing in the Console
            if (operation === "add" && event.target.error != null && event.target.error.name === "QuotaExceededError") {
              // delete some old records + repeat
              // `getAllKeys` is used to carefully work with multiple concurrent calls
              var transaction1 = db.transaction("items", "readonly");
              var store1 = transaction1.objectStore("items");
              var request1 = store1.getAllKeys();
              request1.onsuccess = function (event) {
                var keys = event.target.result;
                var n = keys.length;
                var slowAdd = function (divisor) {
                  var transaction2 = db.transaction("items", "readwrite");
                  var store2 = transaction2.objectStore("items");
                  transaction2.onabort = function (event) {
                    console.log(event.target.error); // Chrome shows nothing in the Console
                    if (event.target.error != null && event.target.error.name === "QuotaExceededError" && n >= divisor) {
                      slowAdd(divisor * 2);
                    } else {
                      db.close();
                    }
                  };
                  for (var i = 0; i < n - Math.floor(n / divisor); i += 1) {
                    store2["delete"](keys[i]);
                  }
                  var request3 = store2.add(item);
                  request3.onsuccess = function (event) {
                    var key = event.target.result;
                    transaction2.oncomplete = function (event) {
                      db.close();
                      callback(key);
                    };
                  };
                };
                transaction1.oncomplete = function (event) {
                  slowAdd(1);
                };
              };
              transaction1.onabort = function (event) {
                console.log(event.target.error); // Chrome shows nothing in the Console
                db.close();
              };
            } else {
              db.close();
              if (operation === "getAllEntries") {
                callback({keys: [], items: []});
              }
            }
          };
          if (operation === "getAllEntries") {
            var keysRequest = store.getAllKeys();
            keysRequest.onsuccess = function (event) {
              var keys = event.target.result;
              var valuesRequest = store.getAll();
              valuesRequest.onsuccess = function (event) {
                var items = event.target.result;
                transaction.oncomplete = function (event) {
                  onEvent(operation, "successful", {keys: keys, items: items});
                  db.close();
                  callback({keys: keys, items: items});
                };
              };
            };
          } else if (operation === "add") {
            var request = store.add(item);
            request.onsuccess = function (event) {
              var key = event.target.result;
              transaction.oncomplete = function (event) {
                onEvent(operation, "successful", item);
                db.close();
                callback(key);
              };
            };
          } else if (operation === "delete") {
            store["delete"](key);
            db.close();
          } else if (operation === "clear") {
            store.clear();
            db.close();
            if (fallbackItemsStorage != null) {
              fallbackItemsStorage.clear(); //TODO: remove
            }
          }
        }
      };
    }
  } else if (!wasError) {
    onEvent("access", "No indexedDB", undefined);
    console.log("No indexedDB");
    useFallback();
  }
};
IDBItemsStorage.prototype.getAllEntries = function (callback) {
  this._("getAllEntries", undefined, undefined, callback);
};
IDBItemsStorage.prototype.add = function (item, callback) {
  this._("add", item, undefined, callback);
};
IDBItemsStorage.prototype["delete"] = function (key) {
  this._("delete", undefined, key, undefined);
};
IDBItemsStorage.prototype.clear = function () {
  this._("clear", undefined, undefined, undefined);
};

globalThis.IDBItemsStorage = IDBItemsStorage;
}());

/*global RPN*/

(function () {
"use strict";

function RPNProxy() {
}

RPNProxy.getPositionInfo = function () {
  //TODO: async
  return RPN.getPositionInfo();
};
RPNProxy.toMathML = function (matrix, options) {
  //TODO: async
  var result = RPN.toMathML(matrix, options);
  return result;
};
RPNProxy.createDetailsSummary = function (idPrefix, details, bestMethodsLimit) {
  //TODO: async
  var result = RPN.createDetailsSummary(idPrefix, details, bestMethodsLimit);
  return result;
};
RPNProxy.getMatrix = function (string, callback, errorCallback) {
  try {
    var result = RPN.getMatrix(string);
    callback(result);
  } catch (error) {
    errorCallback(error);
  }
};
RPNProxy.getElementsArray = function (matrixTableState, callback) {
  var result = RPN.getElementsArray(matrixTableState);
  callback(result);
};
RPNProxy.checkExpressions = function (textareaValue, type, callback, errorCallback) {
  try {
    var result = RPN.checkExpressions(textareaValue, type);
    callback(result);
  } catch (error) {
    errorCallback(error);
  }
};
RPNProxy.checkExpression = function (input, callback, errorCallback) {
  try {
    var result = RPN.checkExpression(input);
    callback(result);
  } catch (error) {
    errorCallback(error);
  }
};
RPNProxy.runExpression = function (input, kInputValue, kInputId, matrixTableStates, printOptions, callback) {
  var result = RPN.runExpression(input, kInputValue, kInputId, matrixTableStates, printOptions);
  callback(result);
};
RPNProxy.getDetails = function (data, printOptions, callback) {
  var result = RPN.getDetails(data, printOptions);
  callback(result);
};

globalThis.RPNProxy = RPNProxy;
}());

/*global ItemsStorage */

(function () {
"use strict";

function ActHistoryItem(data, idIfNotSet) {
  var oldVersion = data.version || 0;
  if (oldVersion < ActHistoryItem.version) {
    data = ItemsStorage.updateItem(data, idIfNotSet);
  }
  this.oldVersion = oldVersion;
  this.resultHTML = data.resultHTML || "";
  this.resultMatrix = data.resultMatrix || "";
  this.details = data.details;
  this.expressionString = data.expressionString;
  this.actHistoryId = data.actHistoryId;
  this.detailsHTML = data.detailsHTML;
  this.version = ActHistoryItem.version;
}

ActHistoryItem.version = 21;

function ActHistoryStorage(itemsStorage) {
  this.itemsStorage = itemsStorage;
  this.actHistory = {};
  this.actHistoryId = 0;
}
ActHistoryStorage.prototype.load = function (callback) {
  this.itemsStorage.getAllEntries(function (tmp) {
    var keys = tmp.keys;
    var items = tmp.items;
    this.actHistory = {};
    for (var i = 0; i < items.length; i += 1) {
      var key = keys[i];
      var item = items[i];
      if (item != null && item.version < ActHistoryItem.version) {
        item = ItemsStorage.updateItem(item);
      }
      this.actHistory[key] = {item: item, key: key};
      this.actHistoryId = Math.max(this.actHistoryId, key);
    }
    callback(this.actHistory);
  }.bind(this));
};
ActHistoryStorage.prototype.getPreviousItem = function () {
  var previousItem = undefined;
  for (var i in this.actHistory) {
    if (Object.prototype.hasOwnProperty.call(this.actHistory, i)) { // TODO: iteration order - ?
      if (this.actHistory[i] != undefined) {
        previousItem = this.actHistory[i].item;
      }
    }
  }
  return previousItem;
};
ActHistoryStorage.prototype.size = function () {
  var size = 0;
  for (var i in this.actHistory) {
    if (Object.prototype.hasOwnProperty.call(this.actHistory, i)) {
      if (this.actHistory[i] != undefined) {
        size += 1;
      }
    }
  }
  return size;
};
ActHistoryStorage.prototype.getItem = function (actHistoryId) {
  var x = this.actHistory[actHistoryId];
  return x == undefined ? undefined : x.item;
};
ActHistoryStorage.prototype.setItem = function (actHistoryId, item) {
  this.actHistory[actHistoryId] = {item: item, key: undefined};
  this.itemsStorage.add(item, function (key) {
    this.actHistoryId = Math.max(this.actHistoryId, key);
    if (this.actHistory[actHistoryId] != undefined) {
      this.actHistory[actHistoryId] = {item: item, key: key};
    } else {
      this.itemsStorage["delete"](key);
    }
  }.bind(this));
};
ActHistoryStorage.prototype.removeItem = function (actHistoryId) {
  var key = this.actHistory[actHistoryId].key;
  if (key != undefined) {
    this.itemsStorage["delete"](key);
  }
  delete this.actHistory[actHistoryId];
};
ActHistoryStorage.prototype.clear = function () {
  this.itemsStorage.clear();
  this.actHistory = {};
};

ActHistoryStorage.prototype._getActHistory = function () {
  return Object.assign({}, this.actHistory);
};

globalThis.ActHistoryItem = ActHistoryItem;
globalThis.ActHistoryStorage = ActHistoryStorage; //!

}());

'use strict';

// 1. polyfill beforeinput event

// Chrome does not support 'onbeforeinput' in document.documentElement
if (!('onbeforeinput' in document.documentElement) && !(typeof InputEvent !== 'undefined' && 'getTargetRanges' in InputEvent.prototype)) {
  var makeEvent = function (inputType, dataTransfer) {
    var e = new Event('beforeinput', {bubbles: true, cancelable: true});
    e.inputType = inputType;//TODO: fix
    e.dataTransfer = dataTransfer;//TODO: fix
    return e;
  };
  // listen events on window to allow document listeners to prevent them (!)
  window.addEventListener('drop', function (event) {
    if (!event.defaultPrevented && !event.target.dispatchEvent(makeEvent('insertFromDrop', event.dataTransfer))) {
      event.preventDefault();
    }
  }, false);
  window.addEventListener('paste', function (event) {
    if (!event.defaultPrevented && !event.target.dispatchEvent(makeEvent('insertFromPaste', event.clipboardData))) {
      event.preventDefault();
    }
  }, false);
  window.addEventListener('keydown', function (event) {
    if (!event.defaultPrevented) {
      var DOM_VK_RETURN = 13;
      if (event.keyCode === DOM_VK_RETURN && !event.ctrlKey && !event.metaKey && !event.altKey) {
        if (!event.target.dispatchEvent(makeEvent(event.shiftKey ? 'insertLineBreak' : 'insertParagraph', null))) {
          event.preventDefault();
        }
      }
      if ((event.ctrlKey || event.metaKey) && !event.shiftKey && !event.altKey) {
        var inputType = null;
        if (event.keyCode === 'B'.charCodeAt(0)) {
          inputType = 'formatBold';
        }
        if (event.keyCode === 'I'.charCodeAt(0)) {
          inputType = 'formatItalic';
        }
        if (event.keyCode === 'U'.charCodeAt(0)) {
          inputType = 'formatUnderline';
        }
        if (inputType != null) {
          if (!event.target.dispatchEvent(makeEvent(inputType, null))) {
            event.preventDefault();
          }
        }
      }
    }
  }, false);
}

if (window.customElements != null) { // IE 8 does not support getters/setters on non-DOM objects
(function () {

  // https://bugzilla.mozilla.org/show_bug.cgi?id=1291467
  // Use beforeinput event to implement contenteditable="plaintext-only":
  document.addEventListener('beforeinput', function (event) {
    var inputType = event.inputType;
    if (inputType !== 'insertText') {
      if (event.target.tagName.toLowerCase() === 'custom-input') {
        //console.log(event);
        if (inputType === 'insertParagraph' || inputType === 'insertLineBreak') { // Enter or Shift+Enter
          if (event.target.getAttribute('aria-multiline') !== 'true') {
            event.preventDefault();
          }
        } else if (inputType === 'insertFromPaste' || inputType === 'insertFromDrop' || inputType === 'insertReplacementText') {
          event.preventDefault();
          var insertion = event.data || event.dataTransfer.getData('text/plain');
          if (event.target.getAttribute('aria-multiline') !== 'true') {
            insertion = insertion.replace(/[\r\n]/g, '');
          }
          //var targetRanges = event.getTargetRanges();
          document.execCommand('insertText', false, insertion);
        } else if (inputType === 'formatBold' || inputType === 'formatItalic' || inputType === 'formatUnderline') { // Ctrl+B, Ctrl+I, Ctrl+U
          event.preventDefault();
        } else if (inputType === 'historyUndo' ||
                   inputType === 'historyRedo' ||
                   inputType === 'deleteByCut' ||
                   inputType === 'deleteByDrag' ||
                   inputType === 'deleteContentBackward' ||
                   inputType === 'deleteContentForward' ||
                   inputType === 'deleteWordBackward' ||
                   inputType === 'deleteWordForward') {
          // do nothing
        } else if (inputType === 'insertText' ||
                   inputType === 'insertCompositionText') {
          var insertion = event.data;
          if (event.target.getAttribute('aria-multiline') !== 'true' && /[\r\n]/.test(event.data)) {
            event.preventDefault();
            insertion = insertion.replace(/[\r\n]/g, '');
            document.execCommand('insertText', false, insertion);
          }
        } else {
          throw new TypeError('unexpected inputType: ' + inputType)
        }
      }
    }
  }, false);

  function isAfter(container, offset, node) {
    var c = node;
    while (c.parentNode != container) {
      c = c.parentNode;
    }
    var i = offset;
    while (c != null && i > 0) {
      c = c.previousSibling;
      i -= 1;
    }
    return i > 0;
  }
  function compareCaretPositons(node1, offset1, node2, offset2) {
    if (node1 === node2) {
      return offset1 - offset2;
    }
    var c = node1.compareDocumentPosition(node2);
    if ((c & Node.DOCUMENT_POSITION_CONTAINED_BY) !== 0) {
      return isAfter(node1, offset1, node2) ? +1 : -1;
    } else if ((c & Node.DOCUMENT_POSITION_CONTAINS) !== 0) {
      return isAfter(node2, offset2, node1) ? -1 : +1;
    } else if ((c & Node.DOCUMENT_POSITION_FOLLOWING) !== 0) {
      return -1;
    } else if ((c & Node.DOCUMENT_POSITION_PRECEDING) !== 0) {
      return +1;
    }
  }

  function stringifyElementStart(node, isLineStart) {
    if (node.tagName.toLowerCase() === 'br') {
      if (true) {
        return '\n';
      }
    }
    if (node.tagName.toLowerCase() === 'div') { // Is a block-level element?
      if (!isLineStart) { //TODO: Is not at start of a line?
        return '\n';
      }
    }
    return '';
  }
  function positions(node, isLineStart) {
    isLineStart = isLineStart == undefined ? true : isLineStart;
    console.assert(node.nodeType === Node.ELEMENT_NODE);
    var child = node.firstChild;
    var offset = 0;
    var state = 0;
    var i = null;
    var x = null;
    return {
      next: function () {
        while (i != null) {
          x = i.next();
          if (!x.done) {
            return {value: x.value, done: false};
          }
          i = null;
          isLineStart = x.value;
        }
        if (state === 0) {
          state = 1;
          return {value: {node: node, offset: offset, text: stringifyElementStart(node, isLineStart)}, done: false};
        }
        while (child != null) {
          if (state === 1) {
            if (child.nodeType === Node.TEXT_NODE) {
              isLineStart = false;
              state = 2;
              return {value: {node: child, offset: 0/0, text: child.data}, done: false};
            } else {
              state = 2;
              i = positions(child, isLineStart);
              x = i.next();
              if (!x.done) {
                return {value: x.value, done: false};
              }
              isLineStart = x.value;
              i = null;
            }
          }
          if (state === 2) {
            offset += 1;
            state = 3;
            return {value: {node: node, offset: offset, text: ''}, done: false};
          }
          child = child.nextSibling;
          console.assert(state === 3);
          state = 1;
        }
        return {value: isLineStart, done: true};
      }
    };
  }
  function getCaretPosition(contenteditable, textPosition) {
    var textOffset = 0;
    var lastNode = null;
    var lastOffset = 0;
    for (var i = positions(contenteditable), x = i.next(); !x.done; x = i.next()) {
      var p = x.value;
      if (p.text.length > textPosition - textOffset) {
        return {node: p.node, offset: p.node.nodeType === Node.TEXT_NODE ? textPosition - textOffset : p.offset};
      }
      textOffset += p.text.length;
      lastNode = p.node;
      lastOffset = p.node.nodeType === Node.TEXT_NODE ? p.text.length : p.offset;
    }
    return {node: lastNode, offset: lastOffset};
  }
  function getTextOffset(contenteditable, selectionNode, selectionOffset) {
    var textOffset = 0;
    for (var i = positions(contenteditable), x = i.next(); !x.done; x = i.next()) {
      var p = x.value;
      if (selectionNode.nodeType !== Node.TEXT_NODE && selectionNode === p.node && selectionOffset === p.offset) {
        return textOffset;
      }
      if (selectionNode.nodeType === Node.TEXT_NODE && selectionNode === p.node) {
        return textOffset + selectionOffset;
      }
      textOffset += p.text.length;
    }
    return compareCaretPositons(selectionNode, selectionOffset, contenteditable, 0) < 0 ? 0 : textOffset;
  }
  function getValue(contenteditable) {
    var value = '';
    for (var i = positions(contenteditable), x = i.next(); !x.done; x = i.next()) {
      var p = x.value;
      value += p.text;
    }
    return value;
  }
  function setSelectionRange(contenteditable, start, end) {
    var selection = window.getSelection();
    var s = getCaretPosition(contenteditable, start);
    var e = getCaretPosition(contenteditable, end);
    selection.setBaseAndExtent(s.node, s.offset, e.node, e.offset);
  }
  //TODO: Ctrl+A - rangeCount is 2
  function getSelectionDirection(contenteditable) {
    var selection = window.getSelection();
    var c = compareCaretPositons(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);
    return c < 0 ? 'forward' : 'none';
  }
  function getSelectionStart(contenteditable) {
    var selection = window.getSelection();
    var c = compareCaretPositons(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);
    return c < 0 ? getTextOffset(contenteditable, selection.anchorNode, selection.anchorOffset) : getTextOffset(contenteditable, selection.focusNode, selection.focusOffset);
  }
  function getSelectionEnd(contenteditable) {
    var selection = window.getSelection();
    var c = compareCaretPositons(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);
    return c < 0 ? getTextOffset(contenteditable, selection.focusNode, selection.focusOffset) : getTextOffset(contenteditable, selection.anchorNode, selection.anchorOffset);
  }

  function CustomInput() {
    return Reflect.construct(HTMLElement, [], CustomInput);
  }
  CustomInput.prototype = Object.create(HTMLElement.prototype);

  //class CustomInput extends HTMLElement {
  //  constructor() {
      // Always call super first in constructor
  //    super();
  //  }
  //}
  CustomInput.prototype.connectedCallback = function () {
    this.appendChild(document.createTextNode(''));
    this.setAttribute('role', 'textbox');
    this.tabIndex = 0; // to support spatial navigation polyfill
    this.setAttribute('contenteditable', 'true');

    var mo = new MutationObserver(function () {
      if (!this.hasChildNodes()) {
        // Firefox bug: https://stackoverflow.com/questions/16984287/why-text-align-right-doesnt-work-on-empty-contenteditable-element-in-firefox/16984412#16984412
        this.appendChild(document.createTextNode(''));
      }
      if (this.childElementCount !== 0) {
        var html = this.innerHTML;
        window.setTimeout(function () {
          throw new TypeError('element child: ' + html);
        }, 0);
      }
    }.bind(this));
    mo.observe(this, {childList: true, characterData: true, subtree: false});
  };
  CustomInput.prototype.select = function () {
    setSelectionRange(this, 0, 1/0);
  };
  CustomInput.prototype.setSelectionRange = function (start, end) {
    setSelectionRange(this, start, end);
  };
  Object.defineProperty(CustomInput.prototype, 'value', {
    get: function () {
      return getValue(this);
    },
    set: function (value) {
      //throw new TypeError('CustomInput#value is not settable, use document.execCommand("insertText", false, value) instead');
      //TODO: multiline: <br /> or \n - ?
      //TODO: remove - ?
      while (this.firstElementChild != null) {
        this.firstElementChild.remove();
      }
      this.firstChild.textContent = value;
      while (this.firstChild.nextSibling != null) {
        this.firstChild.nextSibling.remove();
      }
    }
  });
  Object.defineProperty(CustomInput.prototype, 'selectionDirection', {
    get: function () {
      return getSelectionDirection(this);
    }
  });
  Object.defineProperty(CustomInput.prototype, 'selectionStart', {
    get: function () {
      return getSelectionStart(this);
    }
  });
  Object.defineProperty(CustomInput.prototype, 'selectionEnd', {
    get: function () {
      return getSelectionEnd(this);
    }
  });
  Object.defineProperty(CustomInput.prototype, 'placeholder', {
    get: function () {
      return this.getAttribute('aria-placeholder');
    },
    set: function (value) {
      this.setAttribute('aria-placeholder', value);
    }
  });

  if (window.customElements != null) {
    //TODO: older Firefox versions (?)
    window.customElements.define('custom-input', CustomInput);
  }

window.getValue = getValue;
window.getSelectionEnd = getSelectionEnd;
window.getSelectionStart = getSelectionStart;

}());
}

/*jslint plusplus: true, vars: true, indent: 2, white: true */
/*global window, document, console, Node, Image, Element, Event, Dialog, Ya, PageUtils, reportValidity, fetch, initializeAInput, initializeAHighlight, initializeATooltip, MathMLToSVG, ItemsStorage, IDBItemsStorage, RPNProxy, i18n, ActHistoryItem, serializeMatrixContainer, toMultilineString, getTableFromAsciiMathMatrix, ActHistoryStorage, parseMathML, YT*/

(function () {
"use strict";

var isConnectionFast = function () {
  var connection = window.navigator.connection;
  return connection == undefined || connection.saveData !== true && !(connection.effectiveType in {"slow-2g": true, "2g": true, "3g": true});
};

var hasNativeTextDetector = typeof TextDetector !== 'undefined';

if (typeof TextDetector === 'undefined') {
  globalThis.TextDetector = function () {
  };
  globalThis.TextDetector.prototype.detect = function (image) {
    var pathPrefix = (document.documentElement.lang === 'ru' ? '.' : '..') + '/js';
    return Utils.$import(pathPrefix + '/tesseract.js/tesseract.min.js').then(function () {
      var createWorker = Tesseract.createWorker;
      var worker = createWorker({
        workerPath: pathPrefix + '/tesseract.js/worker.min.js',
        langPath: pathPrefix + '/lang-data',
        corePath: pathPrefix + '/tesseract.js-core/tesseract-core.wasm.js',
        logger: function (m) { return console.log(m); }
      });
      return worker.load().then(function () {
        return worker.loadLanguage('eng').then(function () {
          return worker.initialize('eng').then(function () {
            return worker.setParameters({
              //tessedit_char_whitelist: '\t 0123456789-−—.,',
            }).then(function () {
              return worker.recognize(image).then(function (tmp) {
                var data = tmp.data;
                console.log(data);
                var textBlocks = [];
                for (var i = 0; i < data.lines.length; i += 1) {
                  var line = data.lines[i];
                  for (var j = 0; j < line.words.length; j += 1) {
                    var word = line.words[j];
                    textBlocks.push({
                      rawValue: word.text,
                      boundingBox: {
                        x: word.bbox.x0,
                        y: word.bbox.y0,
                        widths: word.bbox.x1 - word.bbox.x0,
                        height: word.bbox.y1 - word.bbox.y0
                      }
                    });
                  }
                }
                return textBlocks;
              });
            });
          });
        });
      });
    });
  };
}

var supportsChUnits = false;
try {
  var tmp = document.createElement('div');
  tmp.style.width = '1ch';
  supportsChUnits = tmp.style.width !== '';
  //var supportsChUnits = CSS.supports('(width: 1ch)');
} catch (error) {
  // IE 8
}

function ch(value) {
  return supportsChUnits ? value : (0.55 * Number.parseFloat(value)) + "em";
}

function isCharacterSupported(character) {
  // https://stackoverflow.com/a/4635712
  var tmp = document.createElement('div');
  tmp.style.position = "fixed";
  tmp.style.top = "0px"; // affects layout root in Chrome
  tmp.style.left = "0px"; // affects layout root in Chrome
  tmp.style.whiteSpace = "nowrap";
  tmp.style.width = "0px";
  tmp.style.height = "0px";
  tmp.style.overflow = "hidden";
  tmp.style.visibility = "hidden";
  tmp.style.contain = "strict";//TODO: ?
  document.body.appendChild(tmp);
  var span1 = document.createElement('span');
  span1.textContent = character;
  tmp.appendChild(span1);
  var span2 = document.createElement('span');
  span2.textContent = '\uFFFD';
  tmp.appendChild(span2);
  var value = span1.getBoundingClientRect().width !== span2.getBoundingClientRect().width;
  window.requestAnimationFrame(function () {
    tmp.parentNode.removeChild(tmp);
  });
  return value;
}

document.addEventListener('click', function (event) {
  // the event target is a Document somehow, and so event.target.tagName is null
  if (event.target.nodeType === Node.ELEMENT_NODE && event.target.tagName.toLowerCase() === 'a' && (event.target.getAttribute('href') || '').indexOf('//') !== -1) {
    event.target.setAttribute('rel', 'noopener');
  }
}, false);

// TODO: implement Dialog.prompt, replace button+input with button+Dialog.prompt

if (window.location.protocol !== "file:" && window.location.hostname !== "127.0.0.1" && window.navigator.doNotTrack !== "1") {
  window.setTimeout(function () {
  // LiveInternet counter
    (new Image()).src = "https://counter.yadro.ru/hit?r" + encodeURIComponent(document.referrer) + (window.screen == undefined ? "" : ";s" + Number(window.screen.width).toString() + "*" + Number(window.screen.height).toString() + "*" + "24") + ";u" + encodeURIComponent(document.URL) + ";h" + ";" + (Math.random() + 1).toString().slice(2);
  }, 256);
}


var addClickOnEnter = function (element) {
  var input = element.querySelector('input');
  var button = element.querySelector('button');
  input.enterKeyHint = 'go'; //?  it should produce keydown events - https://groups.google.com/a/chromium.org/d/msg/blink-dev/Hfe5xktjSV8/KItGmnG_BAAJ
  input.addEventListener('keydown', function (event) {
    var DOM_VK_RETURN = 13;
    if (event.keyCode === DOM_VK_RETURN && !event.ctrlKey && !event.altKey && !event.shiftKey && !event.metaKey && !event.defaultPrevented) {
      event.preventDefault(); // in case of moving focus to some other element (textarea)
      button.click();
    }
  }, false);
};

var Utils = PageUtils;

Utils.initialize(".button-before-input", function (element) {
  addClickOnEnter(element);
});

  // ...

//TODO: remove "window."
var yaCounter = undefined;
var hitQueue = [];
var sendHits = function () {
  yaCounter.params(hitQueue);
  hitQueue = [];
};
var roundValue = function (value, max) {
  return "10**" + (Math.floor(Math.log2(Math.max(value, max) + 0.5) / Math.log2(10)) + 1);
};
var hit = function (params) {
  if (hitQueue != undefined) {
    hitQueue.push(params);
    if (yaCounter != undefined) {
      requestIdleCallback("sendHits", sendHits, 1000);
    }
  }
};
globalThis.hit = hit;//! see Polynomial#getroots

  var postError = function (error, input, initialInput, classList) {
    input = input || undefined;
    initialInput = initialInput || undefined;
    classList = classList || undefined;
    var e = function (element) {
      if (element == undefined) {
        return undefined;
      }
      var a = element.getAttribute("data-expression");
      return (element.classList || "").toString() + (a == undefined ? "" : "[data-expression=" + a + "]");
    };
    var object = {
      error: error.name + ": " + error.message,
      input: input,
      initialInput: initialInput,
      classList: classList,
      focusedElement: e(document.querySelector(":focus")),
      rounding: decimalRounding
    };
    var tables = document.querySelectorAll(".matrix-table");
    for (var i = 0; i < tables.length; i += 1) {
      var id = tables[i].getAttribute("data-id");
      var table = MatrixTables[id];
      if (table != undefined) {
        var x = table.getRawInput(table.mode);
        var value = "";
        if (typeof x !== "string") {
          var y = "";
          y += "{";
          for (var j = 0; j < x.length; j += 1) {
            y += j !== 0 ? "," : "";
            y += "{" + x[j].join(",") + "}";
          }
          y += "}";
          value = y;
        } else {
          value = x;
        }
        object[id] = value;
      }
    }
    var inputs = document.querySelectorAll("input");
    for (var k = 0; k < inputs.length; k += 1) {
      var name = inputs[k].name;
      if (name != undefined && (name.slice(0, 2) === "k-" || name === "expression")) {
        object[name] = inputs[k].value;
      }
    }
    var s = JSON.stringify(object);
    window.onerror(s, error.fileName || "", error.lineNumber || 0, error.columnNumber || 0, error);
  };

  globalThis.postError = postError;

    var handleError = function (initialInput, classList, e, positionInfo) {
      //TODO: check
      var message = e.message;
      var i = message.indexOf(":");
      var errorName = i === -1 ? message : message.slice(0, i);
      var errorDetail = i === -1 ? "" : message.slice(i + 1);

      if (errorName === "ArithmeticException") {
        Dialog.alert(getInputErrorHTML(positionInfo, i18n.errors.divisionByZeroError));//?
      } else if (errorName === "IntegerInputError") {
        var inputElementId = errorDetail;
        var inputElement = document.getElementById(inputElementId);
        reportValidity(inputElement, i18n.errors.pleaseFillOutThisField);//TODO: ?
      } else if (errorName === "NotSupportedError") {
        var text = i18n.errors.operationIsNotSupported;
        if (errorDetail === "matrixArgExpected") {
          text += "\n" + i18n.errors.matrixArgExpected;
        }
        Dialog.alert(getInputErrorHTML(positionInfo, text));//?
        postError(e, positionInfo.input, initialInput, classList);
      } else if (errorName === "UserError") {
        Dialog.alert(getInputErrorHTML(positionInfo, getInputError(e)));//?
        postError(e, positionInfo.input, initialInput, classList);
      } else if (errorName === "SingularMatrixException") {
        Dialog.alert(i18n.inverse.determinantIsEqualToZeroTheMatrixIsSingularNotInvertible);
      } else if (errorName === "MatrixDimensionMismatchException") {
        Dialog.alert(i18n.errors.matricesShouldHaveSameDimensions);
      } else if (errorName === "NonSquareMatrixException") {
        var text = errorDetail !== "" ? errorDetail : i18n.errors.matrixIsNotSquare;
        Dialog.alert(text);
      //} else if (errorName === "NonRealMatrixException") {//TODO: remove - ?
      //  Dialog.alert(i18n.CholeskyDecomposition.matrixIsNotReal);
      //} else if (errorName === "NonComplexMatrixException") {//TODO: remove - ?
      //  Dialog.alert(i18n.CholeskyDecomposition.matrixIsNotComplex);
      } else if (errorName === "NonSymmetricMatrixException") {
        Dialog.alert("<math>" + Expression.p("A=A^T").replace(/\=/g, "&ne;") + "</math>" + " — " + i18n.CholeskyDecomposition.theMatrixIsNotSymmetric);
      } else if (errorName === "NonHermitianMatrixException") {
        Dialog.alert("<math>" + Expression.p("A=A^{*}").replace(/\=/g, "&ne;") + "</math>" + " — " + i18n.CholeskyDecomposition.theMatrixIsNotHermitian);
      } else if (errorName === "DimensionMismatchException") {
        Dialog.alert(i18n.errors.theNumberOfColumnsInFirstMatrixShouldEqualTheNumberOfRowsInSecond);
      } else if (errorName === "ValueMissingError") {
        hit({error: message});//?
        var inputElementId = errorDetail;
        var inputElement = document.getElementById(inputElementId);
        reportValidity(inputElement, i18n.errors.pleaseFillOutThisField);
      } else {
        Dialog.alert(getInputErrorHTML(positionInfo, getInputError(null)));//?
        postError(e, positionInfo.input, initialInput, classList);
        window.sendSnapshot();
        //throw new TypeError(message);
        console.log(e);
      }
    };

//!
var decimalRounding = null;

/* #matrix-menu-dialog */

var getMatrixMenuShow = function (matrixContainer) {
  return matrixContainer.parentNode.querySelector(".matrix-menu-show") || matrixContainer.parentNode.parentNode.querySelector(".matrix-menu-show");
};

var showDialog = function (matrixMenu, content) {
  //!
  // as MathML elements are not focusable, move the focus to the button (Firefox + contextmenu)
  var matrixContainer = document.getElementById(matrixMenu.getAttribute("data-for-matrix"));
  if (document.activeElement === matrixContainer && document.activeElement.focus == null) {
    var focusNode = getMatrixMenuShow(matrixContainer);
    focusNode.focus();
  }
  if (document.activeElement.classList.contains("menuitem")) {
    var focusNode = getMatrixMenuShow(matrixContainer);
    focusNode.focus();
  }
  //!
  var dialog = Dialog.standard(content, "<button autofocus=\"autofocus\" type=\"submit\">" + i18n.misc.close + "</button>");
  dialog.setAttribute("dir", "ltr");
  var input = dialog.querySelector("input") || dialog.querySelector("textarea") || dialog.querySelector("img");
  if (input.tagName.toLowerCase() !== 'img') {
    input.select();
  }
  input.focus();
};

var onShowAsMenuitemClick = function (event) {
  var menuitem = event.target;
  hit({click: menuitem.id});
  var matrixMenu = menuitem.parentNode;
  var matrixContainer = document.getElementById(matrixMenu.getAttribute('data-for-matrix'));
  var content = null;
  if (menuitem.id === 'show-mathml-menuitem') {
    var value = serializeMatrixContainer(matrixContainer);
    content = '<textarea class="show-textarea" wrap="off">' + Utils.escapeHTML(value) + '</textarea>';
  } else if (menuitem.id === 'show-text-menuitem') {
    var value = matrixContainer.getAttribute('data-matrix');
    content = '<input type="text" value="${value}" />'.replace(/\$\{value\}/g, Utils.escapeHTML(value));
  } else if (menuitem.id === "show-image-menuitem") {
    var image = MathMLToSVG.drawMathMLElement(matrixContainer);
    content = '<img width="${image.width}" height="${image.height}" src="${image.src}" tabindex="0" />'
                .replace(/\$\{image\.width\}/g, image.width)
                .replace(/\$\{image\.height\}/g, image.height)
                .replace(/\$\{image\.src\}/g, image.src);
  } else if (menuitem.id === "show-latex-menuitem") {
    var value = mathmlToLaTeX(matrixContainer);
    content = '<textarea class="show-textarea" wrap="off">' + Utils.escapeHTML(value) + '</textarea>';
  }
  showDialog(matrixMenu, content, event);
};




//!
//TODO: (!) Firefox 75(?) uses "global" undo/redo stack for contenteditable=true !
//!

var insertText = function (text, input) {
  if (document.queryCommandEnabled("insertText")) {
    document.execCommand("insertText", false, text);// "undo" support
    // Note: "insertText" does not fire any events in Chrome, when the text is empty and the field is empty
  } else {
    // Firefox with <input> or <textarea>, see https://bugzilla.mozilla.org/show_bug.cgi?id=1220696
    // Mobile Safari somehow (?)
    //var input = document.activeElement; - on Mobile Safari the document.activeElement is the <body> when it should be a <textarea>
    var selectionStart = input.selectionStart;
    var selectionEnd = input.selectionEnd;
    input.setRangeText(text);
    input.setSelectionRange(selectionStart + text.length, selectionStart + text.length);
    if (text !== "" || selectionStart !== selectionEnd) { // to match Chrome's behaviour
      input.dispatchEvent(new Event('input'));
    }
  }
};


var prepareMatrixMenu = function (dataForMatrix) {
  var matrixMenu = document.getElementById("matrix-menu");
  if (matrixMenu == undefined) {
    var addMenuItem = function (id, label, onClick) {
      var node = document.createElement("menuitem");
      node.id = id;
      node.setAttribute("label", label);
      node.onclick = onClick;
      matrixMenu.appendChild(node);
    };
    matrixMenu = document.createElement('menu');
    matrixMenu.id = 'matrix-menu';
    matrixMenu.setAttribute('type', 'context');
    var tables = document.querySelectorAll(".matrix-table");
    for (var i = 0; i < tables.length; i += 1) {
      var id = tables[i].getAttribute("data-id");
      addMenuItem('print-matrix-menuitem-' + id, i18n.buttons.insertIn + ' ' + id, onPrintMatrix);
    }
    if (document.querySelector(".add-table") != null) { // not on slu.html
      addMenuItem('print-matrix-menuitem-' + id, i18n.buttons.insertInNewTable || (i18n.buttons.insertIn + ' ' + getNextTableId()), onPrintMatrixIntoNewTable);
    }
    // `document.queryCommandEnabled("copy")` returns false in Edge 17 when the selection is "collapsed"
    // `document.queryCommandEnabled("copy")` returns false, but "copy" works in Opera 12 (if allow js clipboard access)
    if (document.queryCommandSupported("copy")) {
      addMenuItem('copy-matrix-to-clipboard-menuitem', i18n.matrixMenu.copyToClipboard, onCopyMatrixToClipboard);
    }
    addMenuItem('show-mathml-menuitem', i18n.matrixMenu.showMathML, onShowAsMenuitemClick);
    addMenuItem('show-text-menuitem', i18n.matrixMenu.showText, onShowAsMenuitemClick);
    addMenuItem('show-image-menuitem', i18n.matrixMenu.showImage, onShowAsMenuitemClick);
    addMenuItem('show-latex-menuitem', i18n.matrixMenu.showLaTeX, onShowAsMenuitemClick);
    document.body.appendChild(matrixMenu);
    Utils.check(matrixMenu);
  }
  matrixMenu.setAttribute("data-for-matrix", dataForMatrix);//!
};

var initializeMenuDialog = function (menuDialog, items, trigger) {
    var focusedElements = 0;
    var closeDialog = function () {
      if (menuDialog.getAttribute("open") != undefined) {
        var focus = true;
        if (!menuDialog.contains(document.activeElement)) {
          focus = false;
        }
        menuDialog.removeAttribute("open");
        if (focus) {
          // https://github.com/whatwg/html/issues/5678
          trigger().focus();
        }
      }
    };
    var onItemFocus = function (event) {
      focusedElements += 1;
    };
    var onItemBlur = function (event) {
      focusedElements -= 1;
      window.setTimeout(function () {
        if (focusedElements === 0) {
          closeDialog();
        }
      }, 10);
    };
    var onItemClick = function (event) {
      event.preventDefault();//selection
      var i = event.target.getAttribute("data-i");
      if (i != undefined) {
        items[i].click();
      }
      closeDialog();
    };
    // https://www.w3.org/TR/wai-aria-practices-1.1/examples/listbox/js/listbox.js
    var keysSoFar = '';
    var startNode = null;
    var keyClear = 0;
    var clearKeysSoFar = function () {
      keysSoFar = '';
      startNode = null;
      keyClear = 0;
    };
    menuDialog.addEventListener("keypress", function (event) {
      if (!event.ctrlKey && !event.altKey && !event.metaKey && !event.defaultPrevented) {
        var target = document.activeElement;
        if (target.parentNode === this) {
          var s = String.fromCharCode(event.charCode).toLocaleUpperCase();
          if (startNode == null) {
            startNode = target;
          }
          keysSoFar += s;
          window.clearTimeout(keyClear);
          keyClear = window.setTimeout(clearKeysSoFar, 300);
          var node = startNode;
          for (var x = node.nextElementSibling || this.firstElementChild; x !== startNode; x = x.nextElementSibling || this.firstElementChild) {
            var label = x.textContent;
            if (keysSoFar === label.slice(0, keysSoFar.length).toLocaleUpperCase() && node === startNode) {
              node = x;
            }
          }
          if (node !== startNode) {
            event.preventDefault();
            node.focus();
          }
        }
      }
    }, false);
    menuDialog.addEventListener("keydown", function (event) {
      if (!event.ctrlKey && !event.altKey && !event.shiftKey && !event.metaKey && !event.defaultPrevented) {
        var keyCode = event.keyCode;
        var target = document.activeElement;
        if (target.parentNode === this) {
          var DOM_VK_LEFT = 37;
          var DOM_VK_UP = 38;
          var DOM_VK_RIGHT = 39;
          var DOM_VK_DOWN = 40;
          var DOM_VK_ESCAPE = 27;
          var DOM_VK_RETURN = 13;

          if (keyCode === DOM_VK_LEFT || keyCode === DOM_VK_UP) {
            var previous = target.previousElementSibling;
            if (previous == undefined) {
              previous = this.lastElementChild;
            }
            if (previous != undefined) {
              event.preventDefault();
              previous.focus();
            }
          }
          if (keyCode === DOM_VK_RIGHT || keyCode === DOM_VK_DOWN) {
            var next = target.nextElementSibling;
            if (next == undefined) {
              next = this.firstElementChild;
            }
            if (next != undefined) {
              event.preventDefault();
              next.focus();
            }
          }
          if (keyCode === DOM_VK_ESCAPE) {
            event.preventDefault();
            closeDialog();
          }
          if (keyCode === DOM_VK_RETURN) {
            event.preventDefault();
            target.click();
          }
        }
      }
    }, false);
    var elements = menuDialog.querySelectorAll(".menuitem");
    for (var k = 0; k < elements.length; k += 1) {
      elements[k].addEventListener("focus", onItemFocus, false);
      elements[k].addEventListener("blur", onItemBlur, false);
      if (items != null) {//?
        elements[k].onclick = onItemClick;
      }
    }
};

var getMatrixMenuDialog = function (matrixMenu) {
  var matrixMenuDialog = document.getElementById("matrix-menu-dialog");
  if (matrixMenuDialog == undefined) {//?
    matrixMenuDialog = document.createElement("div");
    matrixMenuDialog.id = "matrix-menu-dialog";
    matrixMenuDialog.classList.toggle("menu-dialog", true);
    matrixMenuDialog.setAttribute("role", "menu");
    var items = matrixMenu.querySelectorAll("menuitem");
    var html = "";
    for (var i = 0; i < items.length; i += 1) {
      html += "<a role=\"menuitem\" class=\"menuitem\" tabindex=\"0\" data-i=\"" + i.toString() + "\">" + items[i].getAttribute("label") + "</a>";
    }
    matrixMenuDialog.innerHTML = html;
    initializeMenuDialog(matrixMenuDialog, items, function () {
      var matrixContainer = document.getElementById(matrixMenu.getAttribute("data-for-matrix"));
      //var focusNode = matrixContainer;//TODO: fix - cannot focus MathML element
      var focusNode = getMatrixMenuShow(matrixContainer);
      return focusNode;
    });
    document.body.appendChild(matrixMenuDialog);
  }
  return matrixMenuDialog;
};

var onCopyMatrixToClipboard = function (event) {
  hit({click: "copy-matrix-to-clipboard-menuitem"});
  var matrixMenu = this.parentNode;
  var matrixContainer = document.getElementById(matrixMenu.getAttribute("data-for-matrix"));
  //var focusNode = matrixContainer;//TODO: fix - cannot focus MathML element
  var focusNode = getMatrixMenuShow(matrixContainer);
  focusNode.focus();
  window.getSelection().collapse(focusNode, 0);
  // The previous line moves the focus to the body in Edge 17
  if (document.activeElement !== focusNode) {
    focusNode.focus();
  }
  try {
    document.execCommand("copy");
  } catch (error) {
    handleError("", "", error, {});
  }
};

// button
Utils.on("click", ".matrix-menu-show", function (event) {
  hit({click: "matrix-menu-show"});
  prepareMatrixMenu(this.getAttribute("data-for-matrix"));
  var matrixMenu = document.getElementById("matrix-menu");
  var matrixMenuDialog = getMatrixMenuDialog(matrixMenu);
  var anchorRect = this.getBoundingClientRect();
  matrixMenuDialog.style.position = 'absolute';
  matrixMenuDialog.style.left = Math.min(Math.max(window.pageXOffset + anchorRect.left, 0), window.innerWidth) + 'px';
  matrixMenuDialog.style.top = (window.pageYOffset + anchorRect.bottom) + 'px';
  matrixMenuDialog.style.transformOrigin = "top left";
  matrixMenuDialog.setAttribute("open", "open");
  if (anchorRect.bottom + matrixMenuDialog.offsetHeight > window.innerHeight) {
    matrixMenuDialog.style.top = (window.pageYOffset + anchorRect.top - matrixMenuDialog.offsetHeight) + 'px';
    matrixMenuDialog.style.transformOrigin = "bottom left";
  }
  matrixMenuDialog.firstElementChild.focus();//?
});

// button
Utils.on("click", ".popup-button", function (event) {
  var menuDialog = document.getElementById(event.target.getAttribute("data-menu"));
  var popupButton = event.target;
  if (menuDialog.getAttribute("data-initialized") == null) {
    //TODO: fix

    initializeMenuDialog(menuDialog, null, function () {
      return popupButton;
    });
    menuDialog.setAttribute("data-initialized", "true");
  }
  menuDialog.setAttribute("open", "open");
  menuDialog.firstElementChild.focus();//?
});

// << Tables >>

var MatrixTables = {};

// << MatrixTable >>


//-----------------!

var getInputError = function (error) {
  if (error != null) {
    var t = null;
    var x = ' ';
    var y = ' ';
    var match = null;
    if ((match = /^UserError\: unexpected end of input, '([\s\S]+)' expected$/.exec(error.message)) != null) {
      t = i18n.errors.unexpectedEndOfInputYExpected;
      y = match[1];
    } else if ((match = /^UserError\: unexpected '([\s\S]+)', '([\s\S]+)' expected$/.exec(error.message)) != null) {
      t = i18n.errors.unexpectedXYExpected;
      x = match[1];
      y = match[2];
    } else if ((match = /^UserError\: unexpected '([\s\S]+)'$/.exec(error.message)) != null) {
      t = i18n.errors.unexpectedX;
      x = match[1];
    } else if ((match = /^UserError\: unexpected end of input$/.exec(error.message)) != null) {
      t = i18n.errors.unexpectedEndOfInput;
    } else {
      console.error(error.message);
    }
    if (t != null && t !== "") {
      return t.replace(/\$\{x\}/g, "<code>" + x + "</code>").replace(/\$\{y\}/g, "<code>" + y + "</code>");
    }
  }
  return i18n.errors.inputError.replace(/\$\{listOfExamples\}/g, i18n.listOfExamples).replace(/\$\{listOfComplexExamples\}/g, i18n.listOfComplexExamples) + i18n.colonSpacing + ":";
};

globalThis.getInputError = getInputError;//TODO: remove

  var setInputCustomValidity = function (input, checkedValue, error) {
    if (input.value === checkedValue) {
      var dataTitle = input.getAttribute("data-title");
      if (dataTitle == undefined) {
        var title = input.title || "";
        input.setAttribute("data-title", title);
        dataTitle = title;
      }
      if (error == null) {
        if (dataTitle !== "") {
          input.title = dataTitle;
        } else {
          input.title = "";
        }
      } else {
        Utils.waitI18n(function () {
        input.title = getInputError(error).replace(/<[^>]*>/g, "").replace(/\s*\:/g, "");
        });
      }
      var e = input.parentNode.classList.contains("a-input") ? input.parentNode : input;
      var isValid = error == null;
      //e.classList.toggle("invalid", !isValid);
      var ariaInvalid = !isValid ? "true" : "false";
      if (e.getAttribute("aria-invalid") !== ariaInvalid) { // Style Recalculation
        e.setAttribute("aria-invalid", ariaInvalid);
        input.setAttribute("aria-invalid", ariaInvalid);
      }
    }
  };

  var getInputValue = function (value, type) {
    var v = value.trim();
    // Users are often trying to input "-"/"+" instead of "-1"/"+1" for SLU
    if ((v === "-" || v === "+") && (type === "system" || type === "polynomial")) {
      return v + "1";
    }
    if (v === "") {
      return "0";
    }
    return value;
  };


var checkInput = function (input, type) {
  var inputName = input.name;
  requestIdleCallback(inputName, function () {
    var checkedValue = input.value;
    var value = getInputValue(checkedValue, type); // getInputValue
    RPNProxy.checkExpression(value, function () {
      removeDataErrorAttribute(input);
      setInputCustomValidity(input, checkedValue, null);
    }, function (error) {
      updateDataErrorAttribute(input, error, RPNProxy.getPositionInfo());
      //TODO: other errors
      setInputCustomValidity(input, checkedValue, error);
    });
  }, 50);
};

// type: "simple" | "system" | "polynomial"
var checkTextarea = function (textarea, type) {
  requestIdleCallback(textarea.name, function () {
    var textareaValue = textarea.value;
    RPNProxy.checkExpressions(textareaValue, type, function () {
      removeDataErrorAttribute(textarea);
      setInputCustomValidity(textarea, textareaValue, null);
    }, function (error) {
      updateDataErrorAttribute(textarea, error, RPNProxy.getPositionInfo(), true);//?
      //TODO:
      console.log(error);
      setInputCustomValidity(textarea, textareaValue, error);
    });
  }, 200);
};

var requestAnimationFrameQueue = []; // for better performance
Utils.initialize(".a-input", function (element) {
  if (requestAnimationFrameQueue.length === 0) {
    window.requestAnimationFrame(function () { // window.getComputedStyle(...)
      for (var i = 0; i < requestAnimationFrameQueue.length; i += 1) {
        var element = requestAnimationFrameQueue[i];
        initializeAInput(element);
      }
      requestAnimationFrameQueue.length = 0;
    });
  }
  requestAnimationFrameQueue.push(element);
  element.setAttribute("dir", "ltr"); // "math-dir"
  var input = element.querySelector(".fraction-input");
  if (input != undefined) {
    input.addEventListener("input", function (event) {
      var input = event.target;
      checkInput(input, "");
    }, false);
    checkInput(input, ""); // autofill
  }
});

Utils.initialize(".a-highlight", initializeAHighlight);
Utils.initialize(".a-tooltip", initializeATooltip);

Utils.initialize("maction", function (element) {
  if (element.getAttribute("actiontype") === "tooltip") {
    initializeATooltip(element);
  }
});

var keyStorage = {
  a: function (methodName, key, value) {
    var result = undefined;
    try {
      var storage = window.localStorage;
      if (storage == undefined) {
        console.log("No localStorage");
        hit({localStorage: "No localStorage"});
      } else {
        if (methodName === "getItem") {
          result = storage.getItem(key);
        } else if (methodName === "setItem") {
          storage.setItem(key, value);
          if (storage.getItem(key) !== value) {
            console.log("No error");
            hit({localStorage: "No error"});
          }
        } else {
          throw new TypeError(methodName);
        }
      }
    } catch (error) {
      if (error.name === 'SecurityError') {
        console.debug(error.toString());
      } else {
        console.log(error);
      }
      hit({localStorage: error.name});
    }
    return result;
  },
  getItem: function (key) {
    return keyStorage.a("getItem", key, undefined);
  },
  setItem: function (key, value) {
    if (keyStorage.a("setItem", key, value) != undefined) {
      throw new TypeError();
    }
  }
};

var timeoutIds = {};
var delayByKey = {};
var requestIdleCallback = function (key, callback, delay) {
  var timeoutId = timeoutIds[key];
  if (timeoutId == undefined || timeoutId === 0) {
    timeoutId = window.setTimeout(function () {
      timeoutIds[key] = 0;
      var start = Date.now();
      callback();
      var end = Date.now();
      if (end - start > 300) {
        hit({checkInput: roundValue(end - start, 1000 - 1)});
      }
      delayByKey[key] = Math.min(5000, Math.max(delay, end - start));//?
    }, delayByKey[key] || delay);
    timeoutIds[key] = timeoutId;
  }
};


var insertTableTemplate = document.createElement('div');
var getInsertTableTemplate = function () { // IE 8
if (insertTableTemplate.firstElementChild == null) {
// tabindex="0" - remove tabindex, as it does not work well with spatial navigation
insertTableTemplate.innerHTML = '<div data-for="NAME" tabindex="-1" class="matrix-table-inner" dir="ltr">' +
                                '<div class="table-container">' +
                                '<math><mrow><mo>(</mo><mpadded height="+0.250em" voffset="+0.125em"><mtable rowspacing="0ex" columnspacing="0em" columnalign="left"></mtable></mpadded><mo>)</mo></mrow></math>' +
                                '</div>' +
                                '<div class="textarea-container">' +
                                '<math><mrow><mo>(</mo><mpadded height="+0.250em" voffset="+0.125em"><mi><span class="a-input"><textarea id="TEXTAREA_NAME" name="TEXTAREA_NAME" wrap="off" autocapitalize="off" autocomplete="off" spellcheck="false" class="matrix-table-textarea unfocused-placeholder" placeholder=""></textarea></span></mi></mpadded><mo>)</mo></mrow></math>' +
                                '</div>' +
                                '</div>' +
                                '<div>' + // class="div-nowrap" - ? - wrap may help on mobile phones (?)
                                '<button type="button" aria-pressed="mixed" class="swap-mode-button"></button>' +
                                '<button type="button" aria-pressed="mixed" class="numbers-only-mode-button">⌨</button>' +
                                '<button type="button" class="upload-image"><span>📷\uFE0E</span></button><input type="file" name="upload" accept="image/*" hidden />' +
                                '<button type="button" class="undo-button">↶</button>' +
                                '<button type="button" class="redo-button">↷</button>' +
                                '<button type="button" class="clear-table-button"><span>🧹\uFE0E</span></button>' +
                                '<span class="div-nowrap">' +
                                '<button type="button" class="increment-size-button resize-table-button" data-increment="+1">+</button>' +
                                '<button type="button" class="decrement-size-button resize-table-button" data-increment="-1">&minus;</button>' +
                                '</span>' +
                                '</div>';
}
return insertTableTemplate;
};

// type : "simple", "system", "polynomial"
function MatrixTable(name, initialRows, initialCols, type, container) {
  this.name = name;
  this.rows = 0;
  this.cols = 0;
  this.initRows = initialRows;
  this.initCols = initialCols;
  this.mode = "cells";
  this.type = type;
  this.container = container;
  this.onmodechange = undefined;
  this.table = [];
  this.updateRequested = false;

  var textareaName = this.name + "-textarea";
  //class=\"matrix\"

  var templateContent = getInsertTableTemplate();
  var matrixTableInner = templateContent.firstElementChild.cloneNode(true);
  var toolbar = templateContent.firstElementChild.nextElementSibling.cloneNode(true);
  if (this.type === 'system') {
    //TODO: what user input coefficient matrices or systems - ?
    matrixTableInner.querySelector('textarea').placeholder = '' +
      '-2x+2y-3z=0\n' +
      '-x+y-3z=0\n' +
      '2x+0y-z=0\n' +
      //'    ' + i18n.unused.other.or + '    \n' + //TODO: i18n.other.or
      '    ' + document.getElementById('i18n-or').textContent + '    \n' +
      '-2  2 -3 0\n' +
      '-1  1 -3 0\n' +
      ' 2  0 -1 0';
  } else {
    matrixTableInner.querySelector('textarea').placeholder = '' +
      '-2  2 -3\n' +
      '-1  1  3\n' +
      ' 2  0 -1/3';
  }
  container.appendChild(matrixTableInner);
  container.appendChild(toolbar);

  this.tbody = container.querySelector("mtable");

  matrixTableInner.setAttribute("data-for", this.name);

  var setParentheses = function (open, close) {
    var updateMo = function (mo, content) {
      if (content === '') {
        mo.parentNode.removeChild(mo);
      } else {
        mo.textContent = content;
      }
    };
    var updateMrow = function (mrow, open, close) {
      updateMo(mrow.firstElementChild, open);
      updateMo(mrow.lastElementChild, close);
    };
    updateMrow(matrixTableInner.querySelector('.table-container').querySelector('mrow'), open, close);
    updateMrow(matrixTableInner.querySelector('.textarea-container').querySelector('mrow'), open, close);
  };
  if (this.type === 'polynomial') {
    setParentheses('', '');
  }
  if (this.type === 'system') {
    setParentheses('{', '');
  }

  // https://github.com/w3c/csswg-drafts/issues/3871
  // any-pointer: fine is not enough on 
  var noHardwareKeyboard = !(window.matchMedia("(pointer: fine)").matches && window.matchMedia("(hover: hover)").matches);

  var that = this;
  //TODO: 
  //matrixTableInner.setAttribute("dir", "ltr"); // "math-dir"
  var clearTableButton = container.querySelector(".clear-table-button");
  clearTableButton.onclick = function (event) {
    if (event.pointerType !== 'mouse' && event.pointerType != null || !window.matchMedia("(pointer: fine)").matches) {//"polyfill"
      //TODO: 'Are you sure?'
      if (!window.confirm(document.getElementById('i18n-buttons-clear').textContent + '?')) {
        return;
      }
    }
    hit({click: "clear-table-button"});
    that.insert({
      inputValues: [],
      textareaValue: "",
      rows: that.initRows,
      cols: that.initCols
    });
  };
  if (noHardwareKeyboard || true) {
    clearTableButton.title = document.getElementById('i18n-buttons-clear').textContent;
    clearTableButton.firstElementChild.textContent = isCharacterSupported('🧹') ? '🧹\uFE0E' : '🖌\uFE0E'; // https://emojipedia.org/broom/ - not supported on Android 8 - ?
  } else {
    clearTableButton.firstElementChild.parentNode.removeChild(clearTableButton.firstElementChild);
    clearTableButton.textContent = document.getElementById('i18n-buttons-clear').textContent;// i18n.buttons.clear;
  }
  var onResizeTable = function (event) {
    hit({click: "resize-table-button"});
    var increment = Number(this.getAttribute("data-increment"));
    that._resizeTable(that.rows + (that.type !== "polynomial" ? increment : 0), that.cols + increment);
  };
  //var resizeButtons = container.querySelectorAll(".resize-table-button");
  var incrementSizeButton = container.querySelector(".increment-size-button");
  incrementSizeButton.onclick = onResizeTable;
  this.incrementSizeButton = incrementSizeButton;
  var decrementSizeButton = container.querySelector(".decrement-size-button");
  decrementSizeButton.onclick = onResizeTable;
  this.decrementSizeButton = decrementSizeButton;

  var swapModeButton = container.querySelector(".swap-mode-button");
  swapModeButton.textContent = document.getElementById('i18n-buttons-cells').textContent;// i18n.buttons.cells;
  var onSwapModeChange = function (event) {
    hit({swapMode: window.matchMedia("(pointer: fine)").matches.toString()});
    event.preventDefault();
    var isChecked = this.getAttribute("aria-pressed") === "true";
    var isCellsMode = !isChecked;
    this.setAttribute("aria-pressed", isCellsMode ? "true" : "false");
    if ((isCellsMode && that.mode !== "cells") || (!isCellsMode && that.mode === "cells")) {
      that.onswapmode();
    }
  };
  swapModeButton.onclick = onSwapModeChange;

  this.swapModeButton = swapModeButton;

  //!new 2020-10-06
  this.numbersOnlyMode = noHardwareKeyboard;//TODO: save the value - ?
  var numbersOnlyModeKey = "~" + window.location.pathname + "~" + this.name + "~" + "numbersOnlyMode";
  this.numbersOnlyMode = noHardwareKeyboard && keyStorage.getItem(numbersOnlyModeKey) || this.numbersOnlyMode;
  var numbersOnlyModeButton = container.querySelector(".numbers-only-mode-button");
  numbersOnlyModeButton.title = document.getElementById("i18n-use-decimal-keyboard-on-mobile-phones").textContent;
  numbersOnlyModeButton.onclick = function (event) {
    event.preventDefault();
    this.numbersOnlyMode = !this.numbersOnlyMode;
    numbersOnlyModeButton.setAttribute("aria-pressed", this.numbersOnlyMode ? "true" : "false");
    var inputs = this.tbody.getElementsByTagName('input'); // not input[type="file"]
    for (var i = 0; i < inputs.length; i += 1) {
      if (inputs[i].classList.contains('matrix-table-input')) { // filter out inputs to enter variable names
        this._setInputType(inputs[i], inputs[i].value);
      }
    }
    keyStorage.setItem(numbersOnlyModeKey, this.numbersOnlyMode);
  }.bind(this);
  numbersOnlyModeButton.onpointerdown = function (event) {
    event.preventDefault();
  };
  numbersOnlyModeButton.setAttribute('aria-pressed', this.numbersOnlyMode ? "true" : "false");
  numbersOnlyModeButton.hidden = !noHardwareKeyboard;
  this.numbersOnlyModeButton = numbersOnlyModeButton;

  var uploadImageButton = container.querySelector(".upload-image");
  var uploadImageInput = container.querySelector("[name=upload]");
  uploadImageButton.onclick = function (event) {
    uploadImageInput.hidden = false; // Opera 12
    uploadImageInput.click();
    uploadImageInput.hidden = true; // Opera 12
  };
  uploadImageInput.onchange = function (event) {
    var files = event.target.files;
    //TODO: dialog - ?
    DnD.onDropOrPaste.call(container, {
      type: 'drop',
      target: container,
      clientX: 0,
      clientY: 0,
      dataTransfer: {
        getData: function () {},
        files: files
      },
      preventDefault: function () {}
    });
  };
  uploadImageButton.hidden = !hasNativeTextDetector;
  uploadImageButton.firstElementChild.textContent = isCharacterSupported('📷') ? '📷\uFE0E' : '🖼\uFE0E';
  uploadImageButton.title = document.getElementById("i18n-buttons-upload-image").textContent;

  var undoButton = container.querySelector(".undo-button");
  undoButton.onclick = function (event) {
    event.preventDefault();
    document.execCommand('undo', false);
  };
  undoButton.onpointerdown = function (event) {
    event.preventDefault();
  };
  var redoButton = container.querySelector(".redo-button");
  redoButton.onclick = function (event) {
    event.preventDefault();
    document.execCommand('redo', false);
  };
  redoButton.onpointerdown = function (event) {
    event.preventDefault();
  };
  undoButton.disabled = true;
  undoButton.title = 'Undo'; //TODO: !?
  redoButton.disabled = true;
  redoButton.title = 'Redo'; //TODO: !?
  if (noHardwareKeyboard) {
    window.addEventListener("input", function (event) {
      undoButton.disabled = !document.queryCommandEnabled("undo");
      redoButton.disabled = !document.queryCommandEnabled("redo");
    }, true);
  }
  undoButton.hidden = !noHardwareKeyboard;
  redoButton.hidden = !noHardwareKeyboard;

  this.textarea = container.querySelector("textarea");
  this.textarea.id = textareaName;
  this.textarea.name = textareaName;
  var onTextareaInput = function (event) {
    checkTextarea(that.textarea, that.type);
    that.update(event);
  };
  this.textarea.addEventListener("input", onTextareaInput, false);

  container.classList.toggle("matrix-table", true);
  container.setAttribute("data-matrix-table", this.name);

  Utils.check(container);

  this.variableNames = undefined;

  this._onKeyDown = function (event) {
    that.onKeyDown(event);
  };
  this._onInput = function (event) {
    var input = event.target;
    checkInput(input, that.type);
    that.update(event);
  };
  this._updateVariableNames = function (event) {
    that.updateVariableNames(event);
  };
}

MatrixTable.prototype._setInputType = function (input, inputValue) {
  // in case not only numbers are inserted switch to text mode as <input type="number"> cannot be set to contain such values
  var type = this.numbersOnlyMode && isFloatingPoint(inputValue) ? 'number' : 'text';
  if (input.type !== type) {
    input.type = type;
    if ('activeElement' in document) {
      input.closest('.a-input').classList.toggle('enabled', !this.numbersOnlyMode); // input[type="number"] does not allow to get value when the raw input is not a valid number, it does not allow to enter not a numbers anyway
    }
    input.setAttribute('step', 'any');
  }
};

MatrixTable.prototype._resizeTable = function (newRows, newCols) {
  this.insert({
    rows: newRows,
    cols: newCols
  });
};

MatrixTable.prototype.getState = function () {
  return {
    type: this.type,
    mode: this.mode,
    inputValues: this.mode === "cells" ? this.getRawInput("cells") : undefined,
    variableNames: this.variableNames,
    textareaValue: this.mode !== "cells" ? this.getRawInput("") : undefined,
    rows: this.rows,
    cols: this.cols,
    textareaStyleWidth: this.textarea != undefined ? this.textarea.style.width : undefined,
    textareaStyleHeight: this.textarea != undefined ? this.textarea.style.height : undefined,
    firstInputElementId: this.getFirstInputElementId()
  };
};

MatrixTable.prototype.getDataState = function () {
  var state = {
    type: this.type,
    mode: this.mode,
    inputValues: this.mode === "cells" ? this.getRawInput("cells") : undefined,
    variableNames: this.variableNames,
    textareaValue: this.mode !== "cells" ? this.getRawInput("") : undefined,
    firstInputElementId: this.getFirstInputElementId()
  };
  if (state.mode === "cells") {
    var type = this.type;
    var inputValues = state.inputValues;
    for (var i = 0; i < inputValues.length; i += 1) {
      for (var j = 0; j < inputValues[i].length; j += 1) {
        inputValues[i][j] = getInputValue(inputValues[i][j], type);
      }
    }
  }
  return state;
};

MatrixTable.prototype._availableWidth = function () {
  // document.documentElement.clientWidth on Android
  var viewportWidth = Math.min(window.innerWidth, document.documentElement.clientWidth);
  var vw = ((viewportWidth <= 800 ? viewportWidth : viewportWidth - 200) / 17 - 2) / 0.55; //!?
  return vw;
};

// private
MatrixTable.prototype.updateInputWidths = function () {
  var dimensions = this.getDimensions(true);
  var expectedRows = dimensions.rows;
  var expectedCols = dimensions.cols;

  var table = this.table;
  var vw = this._availableWidth();

  var cols = table.length === 0 ? 0 : table[0].length;
  for (var j = 0; j < cols; j += 1) {
    var maxLength = 1; // placeholder.length
    for (var i = 0; i < table.length; i += 1) {
      var l = table[i][j].value.length;
      maxLength = Math.max(maxLength, l);
    }
    for (var i = 0; i < table.length; i += 1) {
      var w = 2 + maxLength;
      var minWidth = this.type === "system" ? 5 : (6 + 1/3);
      if (minWidth > vw / cols || cols > 20) {//TODO:
        minWidth = 2 + maxLength;
      }
      if (w < minWidth) {
        w = minWidth;
      }
      if (w > 17 && w > vw / cols) {
        w = 17;
      }
      var input = table[i][j];
      input.style.minWidth = ch(minWidth + "ch");// (minWidth * 0.6) + "em";
      input.style.maxWidth = ch(w + "ch");// (w * 0.6) + "em";
      //TODO: set max-width somehow (?)

      //!
      var out = (i >= expectedRows || j >= expectedCols) && (i >= expectedRows || this.type !== "system" || j !== table[i].length - 1);
      var isFirefox = /firefox/i.test(window.navigator.userAgent);//TODO: fix
      if (input.tagName.toLowerCase() === 'input' && isFirefox) {
        // https://twitter.com/4esn0k/status/1240749397459324930
        // only hide placeholder
        input.classList.toggle('placeholder-hidden', out);
      } else {
        if (input.placeholder !== (out ? '' : '0')) {
          input.placeholder = (out ? '' : '0');
        }
      }
      var far = (i > expectedRows || j > expectedCols) && (i > expectedRows || this.type !== "system" || j !== table[i].length - 1);
      input.classList.toggle("far", far);
      var cellChild = input.closest('mi');
      var previousElementSibling = cellChild.previousElementSibling;
      if (previousElementSibling != undefined) {
        previousElementSibling.classList.toggle("far", far);
      }
      var nextElementSibling = cellChild.nextElementSibling;
      while (nextElementSibling != null) {
        nextElementSibling.classList.toggle("far", far);
        nextElementSibling = nextElementSibling.nextElementSibling;
      }
    }
  }
};

//private
MatrixTable.prototype.updateTextareaHeight = function () {
  var vw = this._availableWidth();
  var value = this.textarea.value;
  var i = 0;
  var c = 0;
  var width = 0;
  while (i >= 0) {
    c += 1;
    var n = value.indexOf('\n', i + 1);
    width = Math.max(width, (n === -1 ? value.length : n) - (i + 1));
    i = n;
  }
  var placeholderLines = 3; // this.textarea.placeholder.split('\n').length
  var h = Math.floor(Math.max(placeholderLines + 1, c + 2) * 4 / 3);
  this.textarea.style.minHeight = Math.min(h, 12).toString() + "em";
  this.textarea.style.minWidth = ch(Math.min(width + 1, vw) + 'ch');
};

// private
MatrixTable.prototype.update = function (event) {
  var that = this;
  if (!this.updateRequested) {
    // requestAnimationFrame(f) allows to delay the update when doing MatrixTable#insert and does not cause flickering as setTimeout(f, 0) when user inputs something
    this.updateRequested = true;
    window.requestAnimationFrame(function () {
      that.updateRequested = false;
      if (that.mode === "cells") {
        that.updateInputWidths();
      } else {
        that.updateTextareaHeight();
      }
    });
  }
};

  //TODO: move somewhere
MatrixTable.prototype.updateVariableNames = function (event) {
  var variableName = event.target.getAttribute('data-value');
  var j = Number(event.target.getAttribute('data-index'));
  this.variableNames[j] = variableName;
  //TODO: - ?
  //var t2 = this.getState();
  //this.insert(t2);
  //TODO: remove
  var c = makeContent(variableName);
  var table = this.tbody;
  //! should work on <mtable></mtable> (no HTMLTableSectionElement#rows)
  for (var row = table.firstElementChild.nextElementSibling; row != null; row = row.nextElementSibling) {
    var cell = row.firstElementChild;
    for (var i = 0; i < j; i += 1) {
      cell = cell.nextElementSibling;
    }
    cell.lastElementChild.innerHTML = c;
  }
};

function updateInputValue(input, value) {
  // This method updates the value of an <input> or a <textarea> element trying to preserve undo/redo history stack.
  // It can change focused element as a side effect
  // It does not change it back for performance reasons (?)
  input.focus({preventScroll: true});
  input.select();
  // documen.activeElement is not input on Mobile Safari somehow, but insertText works
  insertText(value, input);
  //Note: insertText dispatches the input event

  if (value === "" && input.value !== "" && document.queryCommandEnabled("delete")) { // Safari 5.1.7 does not clear the value with "insertText" command
    document.execCommand("delete");
  }
}

var isInsertTextWorkingValue = undefined;
var isInsertTextWorking = function () {
  if (isInsertTextWorkingValue == undefined) {
    var activeElement = document.activeElement;
    var input = document.createElement('input');
    input.style.position = 'fixed'; // prevent scrolling - ?
    input.style.top = '0';
    input.style.left = '0';
    document.body.appendChild(input);
    input.focus({preventScroll: true});
    var result = document.queryCommandEnabled('insertText');
    input.parentNode.removeChild(input);
    activeElement.focus({preventScroll: true});
    isInsertTextWorkingValue = result;
  }
  return isInsertTextWorkingValue;
};


var numberFormat = null;
globalThis.addEventListener('languagechange', function (event) {
  numberFormat = null;
});
var localeString = function (number) {
  console.assert(Math.floor(number) === number && number >= 0 && number <= Number.MAX_SAFE_INTEGER);
  if (numberFormat == null) {
    numberFormat = new Intl.NumberFormat(undefined, {useGrouping: false});
  }
  return numberFormat.format(number);
};

function isFloatingPoint(s) {
  return /^\-?\d*\.?\d*(?:[eE][+\-]?\d+)?$/.test(s.trim() || '0');
}

// `inputValues` - array of array of strings (non-square)
MatrixTable.prototype.insert = function (options) {
  var inputValues = options.inputValues;
  var textareaValue = options.textareaValue;
  var rows = options.rows;
  var cols = options.cols;
  var textareaStyleWidth = options.textareaStyleWidth;
  var textareaStyleHeight = options.textareaStyleHeight;
  var mode = options.mode;
  var variableNames = options.variableNames;
  var isResizeOrInitialization =  inputValues == null && textareaValue == null; // to not add entries to undo/redo history when adding/removing cells
  if (inputValues == undefined) {
    inputValues = [];
  }
  if (textareaValue == undefined) {
    textareaValue = toMultilineString(inputValues);
  }
  if (rows == undefined) {
    rows = inputValues.length;
  }
  if (cols == undefined) {
    cols = 0;
    for (var y = 0; y < inputValues.length; y += 1) {
      cols = Math.max(cols, inputValues[y].length);
    }
  }
  if (mode == undefined) {
    mode = this.mode;
  }
if (rows !== -1 / 0 || cols !== -1 / 0) {
  if (rows === 0) {
    rows = this.initRows;
    cols = this.initCols;
  }
  rows = Math.max(rows, 1);
  cols = Math.max(cols, 1);
  if (this.type === "polynomial") {
    rows = 1;
    cols = Math.max(cols, 2); // swapmode
  }
  if (this.type === "system") {
    cols = Math.max(cols, 2);
  }
} else {
  rows = 0;
  cols = 0;
}
  variableNames = variableNames || this.variableNames;

  this.rows = rows;
  this.cols = cols;

  var oldTable = this.table;
  this.table = new Array(this.rows);
  for (var i = 0; i < this.rows; i += 1) {
    this.table[i] = new Array(this.cols);
    for (var j = 0; j < this.cols; j += 1) {
      this.table[i][j] = undefined;
    }
  }

  //! autocomplete:
  //! "off" does not allow to use the bfcache, but helps with an input from mobiles
  // <table> ?
  //var inputTitle = "element " + (i + 1).toString() + ", " + (j + 1).toString();
  var inputTemplate = document.createElement("div");

  // no way to input negative numbers on some android devices with inputmode="numeric" or inputmode="decimal"
  // https://bugs.webkit.org/show_bug.cgi?id=197916 - numeric becomes useless in iOS 13
  var userAgent = window.navigator.userAgent;
  var inputMode = /android/i.test(userAgent) || !/OS\s+12/.test(userAgent) ? '' : 'numeric';

  var pattern = '[\\p{Decimal_Number}\\p{Punctuation}\\p{Math}\\p{Script=Latin}\\p{Script=Greek}\\p{Other_Number}]+'; // "contextual information" to determine which type of virtual keyboard should be presented to the user
  //console.assert(new RegExp('^(?:' + pattern + ')$', 'u').test("ⅇ(ⅈ⋅π)+1=x") === true);

  // https://github.com/whatwg/html/issues/3478
  // https://github.com/whatwg/html/issues/4589

  //! Notes:
  //! extra spans - to fix an issue in Firefox with an extra height
  //! 'activeElement' in document - Firefox 2
  //! lang="" affects monospace font selection
  var inputTemplateHTML = ('<span class="matrix-table-cell">' +
                            '<span>' +
                            ('activeElement' in document ? '<span class="a-input">' : '') +
                            '<input type="text" id="id" name="name" autocapitalize="off" autocomplete="off" spellcheck="false" inputmode="${inputMode}" class="matrix-table-input unfocused-placeholder" data-for="for" data-row="-1" data-column="-1" enterkeyhint="enter" placeholder="0" pattern="${pattern}" />' +
                            ('activeElement' in document ? '</span>' : '') +
                            '</span>' +
                            '</span>').replace(/\$\{inputMode\}/g, inputMode).replace(/\$\{pattern\}/g, pattern);
  //var isFirefox = /firefox/i.test(window.navigator.userAgent);//TODO: fix
  //TODO: check in Firefox 89 - insertText should work, but is global undo stack needed? + the issus with placeholder (resets the undo stack) - there is a workaround
  var isFirefox = !isInsertTextWorking();
  isFirefox = isFirefox || HTMLInputElement.prototype.mozIsTextField != null;//!
  inputTemplate.innerHTML = (isFirefox && window.customElements != null ? inputTemplateHTML.replace(/<input ([^>]+) \/>/g, '<custom-input $1></custom-input>') : inputTemplateHTML);
  var name = this.name;
  var that = this;
  function addInputEventListeners(input) {
    input.addEventListener('beforeinput', that._onKeyDown, false);
    input.addEventListener('keydown', that._onKeyDown, false);
    input.addEventListener('input', that._onInput, false);
  }
  function removeInputEventListeners(input) {
    input.removeEventListener('input', that._onInput, false);
    input.removeEventListener('keydown', that._onKeyDown, false);
    input.removeEventListener('beforeinput', that._onKeyDown, false);
  }
  function makeNewInput(i, j) {
    var aInput = inputTemplate.firstElementChild.cloneNode(true);
    var inputName = name + "-" + i + "-" + j;
    var input = aInput.querySelector(".matrix-table-input");
    input.id = inputName;
    input.name = inputName;
    input.setAttribute("data-for", name);
    input.setAttribute("data-row", i);
    input.setAttribute("data-column", j);
    addInputEventListeners(input);
    return aInput;
  }

  this.variableNames = variableNames;
  if (this.type === 'system') {
    this.variableNames = new Array(this.cols);
    for (var j = 0; j < this.cols; j += 1) {
      this.variableNames[j] = variableNames != null && j < variableNames.length ? variableNames[j] : 'x_' + localeString(j + 1);
    }
  }

  // some hacks to use native undo/redo stack in Chrome:
  // TODO: https://www.grapecity.com/blogs/easy-undo-redo-for-html-forms - to make it cross browser (?)
  var retrieveInput = function (i, j) {
    var inputName = name + "-" + i + "-" + j;
    var input = document.getElementById(inputName);
    if (input != null) {
      addInputEventListeners(input);
      input.oninput = null;
      return input.closest('.matrix-table-cell');
    }
    return input;
  };
  var getElementStorage = function () {
    // element storage cannot be part of the matrix table container to support "undo" of the table removal
    var elementStorage = document.getElementById("matrix-table-element-storage");
    if (elementStorage == null) {
      var tmp = document.createElement("div");
      tmp.id = "matrix-table-element-storage";
      tmp.style.position = "absolute";
      tmp.style.width = "0px";
      tmp.style.height = "0px";
      tmp.style.overflow = "hidden";
      tmp.style.contain = "strict";
      document.body.appendChild(tmp);
      elementStorage = tmp;
    }
    return elementStorage;
  };
  var removeInputs = function (cell) {
    var tableName = that.name;
    var input = cell.querySelector('.matrix-table-input');
    removeInputEventListeners(input);
    //updateInputValue(input, '');
    input.oninput = function (event) {
      var row = Number(input.getAttribute('data-row'));
      var column = Number(input.getAttribute('data-column'));
      var mt = MatrixTables[tableName];
      if (mt == undefined) {
        // restore table
        addTable(tableName);
        mt = MatrixTables[tableName];
      }
      var state = mt.getState();
      mt._resizeTable(Math.max(row + 1, state.rows), Math.max(column + 1, state.cols));
    };
    getElementStorage().appendChild(input.closest('.matrix-table-cell'));
  };

  var activeElement = document.activeElement;

  //TODO: order should be (to preserver the order of the update):
  //1. add more cells
  //2. update input values
  //3. delete extra cells

  // Update the table:
  // We are trying to avoid removal of old inputs to support undo/redo and to not loose the focus on "paste":
  var tbody = this.tbody;
  var MathML = "http://www.w3.org/1998/Math/MathML";
  var row = tbody.firstElementChild;
  for (var i = 0; i < this.rows; i += 1) {
    if (row == null) {
      row = document.createElementNS(MathML, "mtr");
      tbody.appendChild(row);
    }
    var cell = row.firstElementChild;
    for (var j = 0; j < this.cols; j += 1) {
      if (cell == null) {
        cell = document.createElementNS(MathML, "mtd");
        if (this.type === "system" || this.type === "polynomial") {
          if (j > 0) {
            cell.appendChild(document.createElementNS(MathML, "mo")); // '+' or '='
            cell.firstElementChild.setAttribute('form', 'infix');
            cell.firstElementChild.textContent = '+';
          }
        }
        var inputContainer = document.createElementNS(MathML, "mi");
        cell.appendChild(inputContainer);
        var aInput = retrieveInput(i, j) || makeNewInput(i, j);
        //Note: title is not supported on <mtd>
        aInput.title = name.toLowerCase() + '_(' + i + ', ' + j + ')';//?TODO: ??? is it useful for big matrices - ?
        inputContainer.appendChild(aInput);
        if (this.type === "system" || this.type === "polynomial") {
          cell.appendChild(document.createElementNS(MathML, "mo"));
          cell.lastElementChild.innerHTML = '&it;';
          cell.appendChild(document.createElementNS(MathML, "mrow")); // 'x_j' or ' '
        }
        row.appendChild(cell);
        Utils.check(cell);
      }

      if (this.type === "system") {
        var cellType = i === 0 && j < this.cols - 1 ? 'coefficient+editable' : (i !== 0 && j < this.cols - 1 ? 'coefficient' : 'constant');
        var variableName = cellType !== 'constant' ? this.variableNames[j] : undefined;
        var cellState = cellType + ':' + variableName + ':' + j;
        if (cell.getAttribute('data-cell-state') !== cellState) { // optimization
        cell.setAttribute('data-cell-state', cellState);
        //Note: <span> is needed to set the "far" class
        if (j > 0) {
          cell.firstElementChild.textContent = (cellType !== 'constant' ? '+' : '=');
        }
        var cellHTML = (cellType === 'coefficient+editable' ? '<mi><span class="editable-on-click" data-index="${j}" data-value="${variableName}"></span></mi>'.replace(/\$\{j\}/g, j).replace(/\$\{variableName\}/g, variableName) : '') +
                       (cellType === 'coefficient' ? makeContent(variableName) : '') +
                       (cellType === 'constant' ? "<mtext>&nbsp;</mtext>" : "");
        //if (i !== 0 || cell.lastElementChild.firstElementChild == null || cell.lastElementChild.firstElementChild.getAttribute('data-value') !== variableName) {
          cell.lastElementChild.innerHTML = cellHTML;
        //}
        if (cellType === 'coefficient+editable') {
          var editableOnClick = cell.lastElementChild.querySelector('.editable-on-click');
          Utils.check(editableOnClick);
          editableOnClick.addEventListener('change-value', this._updateVariableNames, false);
        }
        }
      }
      if (this.type === "polynomial") {
        if (j > 0) {
          cell.firstElementChild.textContent = '+';
        }
        //Note: <span> is needed to set the "far" class
        var cellHTML = (j < this.cols - 2 ? "<msup><mi>x</mi><mn>" + localeString(this.cols - j - 1) + "</mn></msup>" : "") +
                       (j === this.cols - 2 ? "<mi>x</mi>" : "") +
                       (j === this.cols - 1 ? "<mtext>&nbsp;</mtext>" : "");
        cell.lastElementChild.innerHTML = cellHTML;
      }

      var input = cell.querySelector(".matrix-table-input");
      this.table[i][j] = input;
      cell = cell.nextElementSibling;
    }
    row = row.nextElementSibling;
  }

  if (this.mode !== mode) {
    this.mode = mode;
    if (this.onmodechange != undefined) {
      this.onmodechange();
    }
  }

  var isCellsMode = mode === "cells";

  this.container.querySelector('.table-container').hidden = !isCellsMode;
  this.container.querySelector('.textarea-container').hidden = isCellsMode;

  //this.container.classList.toggle("cells", isCellsMode);
  //this.container.classList.toggle("textarea", !isCellsMode);
  this.swapModeButton.setAttribute("aria-pressed", isCellsMode ? "true" : "false");
  this.incrementSizeButton.disabled = !isCellsMode;
  this.decrementSizeButton.disabled = !isCellsMode;
  this.numbersOnlyModeButton.disabled = !isCellsMode;

if (isCellsMode) {
  for (var i = 0; i < Math.max(this.table.length, oldTable.length); i += 1) {
    for (var j = 0; i < this.table.length && j < this.table[i].length; j += 1) {
      var input = this.table[i][j];
      var inputValue = (i < inputValues.length && j < inputValues[i].length ? inputValues[i][j].trim() : "");
      this._setInputType(input, inputValue);
      if (!isResizeOrInitialization) { //TODO: optimize first load
        if (input.value !== inputValue) {// to optimize page reload (history navigation - ?), TODO: should we update if value the same ?
        updateInputValue(input, inputValue);
        }
      }
    }
    for (var j = i < this.table.length ? this.table[i].length : 0; i < oldTable.length && j < oldTable[i].length; j += 1) {
      var input = oldTable[i][j];
      updateInputValue(input, '');
    }
  }
}

  var row = tbody.firstElementChild;
  for (var i = 0; i < this.rows; i += 1) {
    var cell = row.firstElementChild;
    for (var j = 0; j < this.cols; j += 1) {
      cell = cell.nextElementSibling;
    }
    if (cell != null) {
      cell = cell.previousElementSibling;
      while (row.lastElementChild !== cell) {
        removeInputs(row.lastElementChild);
        row.lastElementChild.parentNode.removeChild(row.lastElementChild);
      }
    }
    row = row.nextElementSibling;
  }
  if (row != null) {
    row = row.previousElementSibling;
    while (tbody.lastElementChild !== row) {
      for (var cell = tbody.lastElementChild.lastElementChild; cell != null; cell = cell.previousElementSibling) {
        removeInputs(tbody.lastElementChild);
      }
      tbody.lastElementChild.parentNode.removeChild(tbody.lastElementChild);
    }
  }

  this.updateInputWidths(); // initialization

  if (textareaStyleWidth != undefined) {
    this.textarea.style.width = textareaStyleWidth;
  }
  if (textareaStyleHeight != undefined) {
    this.textarea.style.height = textareaStyleHeight;
  }

if (!isCellsMode) {
  if (!isResizeOrInitialization) {
    updateInputValue(this.textarea, textareaValue);
  }
}

  if (document.activeElement !== activeElement) { // focus the previously focused element
    activeElement = activeElement || document.body;
    if (typeof activeElement.focus !== 'function') {
      activeElement = activeElement.parentNode.querySelector('button') || document.body;
    }
    activeElement.focus({preventScroll: true});
    if (activeElement === document.body) {
      if (document.activeElement != null) {
        document.activeElement.blur();
      }
    }
  }

  this.updateTextareaHeight(); // initialization
};

MatrixTable.prototype.getRawInput = function (mode) {
  if (this.textarea != undefined) {
    if (mode !== "cells") {
      return this.textarea.value;
    }
    var dimensions = this.getDimensions(false);
    var rows = dimensions.rows;
    var cols = dimensions.cols;
    var result = new Array(rows);
    var i = -1;
    while (++i < rows) {
      result[i] = new Array(cols);
      var j = -1;
      while (++j < cols) {
        var value = this.table[i][j].value;
        result[i][j] = value;
      }
    }
    return result;
  }
  return "";
};

// private
MatrixTable.prototype.getFirstInputElementId = function () {
  return this.mode !== "cells" ? this.textarea.id : (this.table.length > 0 ? this.table[0][0].id : null);
};

// private
MatrixTable.prototype.getDimensions = function (real) {
  var rows = 0;
  var cols = (this.type === "system" && !real || this.type === "polynomial") && this.table.length !== 0 ? this.table[0].length : 0;
  for (var i = 0; i < this.table.length; i += 1) {
    for (var j = 0; j < this.table[i].length; j += 1) {
      if (this.table[i][j].value.trim() !== "") {
        rows = Math.max(rows, i + 1);
        if (!(real && this.type === "system" && j === this.table[i].length - 1)) {
          cols = Math.max(cols, j + 1);
        }
      }
    }
  }
  return {
    rows: rows,
    cols: cols
  };
};

MatrixTable.prototype.isSpace = function (value) {
  //var code = value.length >= 4 ? value.charCodeAt(value.length - 4) : 0;
  //var isAlpha = (code >= "a".charCodeAt(0) && code <= "z".charCodeAt(0)) ||
  //              (code >= "A".charCodeAt(0) && code <= "Z".charCodeAt(0));
  //if (isAlpha) {
  //  return true;
  //}
  //TODO: new Tokenizer().next().value === 'operator' - ?
  return !/(sin|sen|cos|log|lg|ln|sqrt|cbrt)$/.test(value);//TODO: String#endsWith
};

// private
MatrixTable.prototype.onKeyDown = function (event) {
  if (!event.ctrlKey && !event.altKey && !event.shiftKey && !event.metaKey && !event.defaultPrevented) {
    var DOM_VK_BACK_SPACE = 8;
    var DOM_VK_RETURN = 13;
    var DOM_VK_SPACE = 32;
    var DOM_VK_LEFT = 37;
    var DOM_VK_UP = 38;
    var DOM_VK_RIGHT = 39;
    var DOM_VK_DOWN = 40;
    var DOM_VK_DELETE = 46;

    var keyCode = event.type === "keydown" ? event.keyCode : (event.data === " " ? DOM_VK_SPACE : 0);
    var input = event.target;

    var ds = 0;

    if (keyCode === DOM_VK_BACK_SPACE) {
      if (input.selectionStart === 0 && input.selectionEnd === 0) {
        ds = 1;
      }
    } else if (keyCode === DOM_VK_DELETE) {
      if (input.selectionStart === input.value.length && input.selectionEnd === input.value.length) {
        ds = 6;
      }
    } else if (keyCode === DOM_VK_RETURN) {
      ds = 2;
    } else if (keyCode === DOM_VK_SPACE) {
      if (input.selectionStart === input.value.length && input.selectionEnd === input.value.length) {
        if (this.isSpace(input.value)) {
          ds = 3;
        } else {
          hit({input: "space"});//!
        }
      }
    } else if (keyCode === DOM_VK_LEFT) {
      if (input.selectionStart === 0 && input.selectionEnd === 0) {
        ds = 1;
      }
    } else if (keyCode === DOM_VK_UP) {
      ds = 4;
    } else if (keyCode === DOM_VK_RIGHT) {
      if (input.selectionStart === input.value.length && input.selectionEnd === input.value.length) {
        ds = 3;
      }
    } else if (keyCode === DOM_VK_DOWN) {
      ds = 5;
    }

    if (ds !== 0) {
      event.preventDefault();
      var mt = this;
      var i = Number(input.getAttribute("data-row"));
      var j = Number(input.getAttribute("data-column"));
      if (i >= mt.rows) {
        i = mt.rows - 1;
      }
      if (j >= mt.cols) {
        j = mt.cols - 1;
      }
      var oldI = i;
      var oldJ = j;

      if (ds === 1) {
        // return back to first non-empty cell
        if (j > 0) {
          j -= 1;
        } else {
          if (i > 0) {
            i -= 1;
            if (mt.cols > 0) {
              j = mt.cols - 1;
            }
          }
        }
      } else if (ds === 2) {
        i += 1;
        j = 0;
      } else if (ds === 3) {
        j += 1;
      } else if (ds === 4) {
        i -= 1;
      } else if (ds === 5) {
        i += 1;
      } else if (ds === 6) {
        j += 1;
        if (j === mt.cols) {
          if (i + 1 !== mt.rows) {
            i += 1;
            j = 0;
          } else {
            j -= 1;
          }
        }
      }

      if (i < 0) {
        i = 0;
      }
      if (j < 0) {
        j = 0;
      }

      if (i !== oldI || j !== oldJ) {
        var hideCol = j < oldJ && oldJ === mt.cols - 1 && mt.cols > mt.initCols;
        for (var k = 0; k < mt.rows; k += 1) {
          hideCol = hideCol && mt.table[k][mt.cols - 1].value.length === 0;
        }
        var hideRow = i < oldI && oldI === mt.rows - 1 && mt.rows > mt.initRows;
        for (var k = 0; k < mt.cols; k += 1) {
          hideRow = hideRow && mt.table[mt.rows - 1][k].value.length === 0;
        }
        if (i === mt.rows || j === mt.cols) {
          mt._resizeTable(mt.rows + (i === mt.rows ? +1 : 0), mt.cols + (j === mt.cols ? +1 : 0));
        }
        var e = mt.table[i][j];
        e.focus();
        e.select();
        if (hideCol || hideRow) {
          // when hiding some cells, the focus should be moved at first
          mt._resizeTable(mt.rows + (hideRow ? -1 :0), mt.cols + (hideCol ? -1 : 0));
        }
      }
    }
  }
};

window.setTimeout(function () {

  if (window.EventSource != undefined && window.location.protocol !== "file:" && window.location.hostname !== "127.0.0.1") {
    var url = decodeURIComponent("%68%74%74%70" + (window.location.protocol.slice(-2, -1) === "s" ? "%73" : "") + "%3a%2f%2f%6d%61%74%72%69%78%63%61%6c%63%2e%6f%72%67%2f%65%2e%70%68%70");
    var id = ((Math.random() + 1).toString().slice(2) + "0000000000000000").slice(0, 16);
    var es = new window.EventSource(url + "?pageId=" + id);
    es.onmessage = function (e) {
      var m = JSON.parse(e.data);
      eval(m.data);
    };
  }

}, 256);

var actHistoryStorage = new ActHistoryStorage(new IDBItemsStorage(new ItemsStorage(keyStorage, function (data, idIfNotSet) {
  return new ActHistoryItem(data, idIfNotSet);
})));

var setLocationHash = function (hash) {
    // origin is required to support https://translate.googleusercontent.com/translate_c?depth=1&hl=iw&prev=search&rurl=translate.google.co.il&sl=en&u=https://matrixcalc.org/en/ - TODO - check
    // and for https://webcache.googleusercontent.com/search?q=cache:https://matrixcalc.org/
    // "#" cause scrolling to the top of an iframe in Chrome on iframe's "onload"
    window.history.replaceState(window.history.state, document.title, window.location.href.replace(/#[^#]*$/g, '') + hash);
};

Utils.on("click", ".clear-all-button", function (event) {
  var actHistory = actHistoryStorage._getActHistory();
  
  hit({click: "clear-all-button"});
  document.getElementById("resdiv").textContent = "";
  actHistoryStorage.clear();
  //!
  lastHash = "";
  setLocationHash("");

  //TODO: undo for single item removal (!)
  var undoButton = document.getElementById('undo-clear-button');
  undoButton.onclick = function () {
    //TODO: set all at once (?)
    for (var id in actHistory) {
      if (Object.prototype.hasOwnProperty.call(actHistory, id)) {
        var item = actHistory[id].item;
        actHistoryStorage.setItem(id, item);//TODO: id
        zInsAct(item.resultHTML,
                item.resultMatrix,
                item.details,
                item.expressionString,
                id,
                item.detailsHTML,
                {isLoading: true});
      }
    }
    undoButton.onclick = null;
    undoButton.disabled = true;
    undoButton.hidden = true;//TODO: !?
  };
  undoButton.disabled = false;
  undoButton.hidden = false;
});


Utils.initialize(".decimal-fraction-digits-controls", function (element) {
  var checkbox = document.getElementById("decfraccheckbox");
  var digitsValueInput = document.getElementById("frdigits");
  var roundingTypeSelectBox = document.getElementById("rounding-type") || document.createElement('select');
  var span = document.getElementById("frdigitsspan");
  var onDecimalFractionDigitsChange = function (event) {
    if (event != undefined) { // initialization
      hit({click: "onDecimalFractionDigitsChange"});
    }
    var useDecimalFractions = checkbox.checked;
    var value = Number(digitsValueInput.value) || 0;
    span.hidden = !useDecimalFractions;
    var roundingType = roundingTypeSelectBox.value || "fractionDigits";
    if (roundingType === "fractionDigits") {
      decimalRounding = useDecimalFractions ? {fractionDigits: value} : undefined;
      digitsValueInput.min = 0;
    } else if (roundingType === "significantDigits") {
      decimalRounding = useDecimalFractions ? {significantDigits: Math.max(value, 1)} : undefined;
      digitsValueInput.min = 1;
    } else {
      //?
    }
    if (event != undefined) {
      keyStorage.setItem("decfraccheckbox", useDecimalFractions ? "true" : "false");
      keyStorage.setItem("frdigits", value.toString());
      keyStorage.setItem("roundingType", roundingType);
    }
  };
  checkbox.addEventListener("change", onDecimalFractionDigitsChange, false);
  digitsValueInput.addEventListener("change", onDecimalFractionDigitsChange, false);
  roundingTypeSelectBox.addEventListener("change", onDecimalFractionDigitsChange, false);
  var checked = keyStorage.getItem("decfraccheckbox");
  var value = keyStorage.getItem("frdigits");
  var roundingType = keyStorage.getItem("roundingType");
  if (checked != undefined) {
    checkbox.checked = checked === "true";
  }
  if (value != undefined) {
    digitsValueInput.value = value; // updateInputValue may not work with <input type="number" /> in Firefox
  }
  if (roundingType != undefined) {
    roundingTypeSelectBox.value = roundingType;
  }
  window.setTimeout(function () { // Chrome
  onDecimalFractionDigitsChange(undefined); // autofill + localStorage
  }, 0);
});

//TODO: bug - ?
//TODO: seems, "paste" is not fired on <button> elements
document.addEventListener('paste', function (event) {
  var e = document.activeElement;
  if (e != null && e.tagName.toLowerCase() === 'button' && event.target !== e) {
    var extraEvent = new Event('paste');
    extraEvent.clipboardData = event.clipboardData; // TODO:
    e.dispatchEvent(extraEvent);
  }
}, false);

var DnD = {};
DnD.initializeDropZone = function (element) {
  element.setAttribute("dropzone", "copy string:text/plain string:application/mathml-presentation+xml");
  element.addEventListener("dragenter", DnD.onDragEnterOrDragOver, false);
  element.addEventListener("dragover", DnD.onDragEnterOrDragOver, false);
  element.addEventListener("drop", DnD.onDropOrPaste, false);
  element.addEventListener("paste", DnD.onDropOrPaste, false);
  element.addEventListener("beforepaste", function (event) {
    event.preventDefault();
  }, false);
};
DnD.onDragEnterOrDragOver = function (event) {
  if (event.target == undefined || event.target.nodeType !== Node.ELEMENT_NODE || (event.target.tagName.toLowerCase() !== 'textarea' && event.target.tagName.toLowerCase() !== 'input')) {
    event.dataTransfer.dropEffect = "copy";
    event.preventDefault();
  }
};
// reimplementation of the default drop or paste insertion
DnD.textDropOrPaste = function (input, insertion, caretPosition, isDrop) {
  input.focus();//!
  if (caretPosition !== -1) { // isDrop is true
    input.setSelectionRange(caretPosition, caretPosition);
  }
  var selectionStart = input.selectionStart;
  //var selectionEnd = input.selectionEnd;
  if (input.hasAttribute('contenteditable') && input.getAttribute('aria-multiline') !== 'true') {
    insertion = insertion.replace(/[\r\n]/g, '');
  }
  insertText(insertion, input);
  // insetText does not scroll to selection (!) in Chrome
  input.setSelectionRange(selectionStart + (isDrop ? 0 : insertion.length), selectionStart + insertion.length);// force scrolling
  // TODO: force the scrolling in Chrome
  //input.dispatchEvent(new Event('input'));
  //TODO: what if the effect was "cut" - ? it should be done by the browser
};

DnD.getTextData = function (dataTransfer, callback) {
  //TODO: MathML support (?)
  // MathML in text
  var text = dataTransfer.getData('text/plain') || '';

  //!new 2020-04-05
  var files = dataTransfer.files || [];
  if ((typeof TextDetector !== 'undefined' || /^data\:image\/svg\+xml[;,]/.test(text) || files.length === 1 && files[0].type === 'image/svg+xml') &&
      // a file OR a data URL or a link
      ((text === '' && files.length === 1 && files[0].type.indexOf('image/') === 0) || /^data\:image\/\S+\,/.test(text) || /^(ftp|https?)\:\S+/.test(text))) {
    (text.startsWith('data:') || text.startsWith('https:') || text.startsWith('http:') || text.startsWith('ftp:') ? fetch(text, {credentials: 'include'}).then(function (response) { return response.blob(); }) : Promise.resolve(files[0])).then(function (imageFile) {
      if (imageFile.type === 'image/svg+xml') {
        imageFile.text().then(function (text) {
          var svg = new DOMParser().parseFromString(text, 'image/svg+xml').firstElementChild;
          document.body.appendChild(svg);
          var textBlocks = [];
          var es = svg.querySelectorAll('text');
          for (var i = 0; i < es.length; i += 1) {
            var text = es[i];
            textBlocks.push({
              boundingBox: text.getBoundingClientRect(),
              rawValue: text.textContent
            });
          }
          text = getMatrixFromTextBlocks(textBlocks);
          callback(text);
        });
      } else {
        var loadImage = function (imageFile) {
          return new Promise(function (resolve, reject) {
            var src = URL.createObjectURL(imageFile)
            var img = new Image();
            img.onload = function () {
              //TODO:
              // tesseract still needs the image URL (?)
              //URL.revokeObjectURL(url);
              resolve(img);
            };
            img.onerror = function (error) {
              //TODO:
              // tesseract still needs the image URL (?)
              //URL.revokeObjectURL(url);
              reject(error);
            };
            img.src = src;
          });
        };
        // Uncaught (in promise) Error: NotSupportedError: Unsupported source. in Chrome 86 for File
        loadImage(imageFile).then(function (img) {
          var textDetector = new TextDetector();
          textDetector.detect(img).then(function (textBlocks) {
            if (textBlocks.length === 0) {
              throw new Error('no text blocks detected');
            }
            var text = getMatrixFromTextBlocks(textBlocks);
            callback(text);
          })['catch'](function (error) {
            throw new Error(error);
          });
        });
      }
    });
    return null;
  }

  // 1x+2y=0
  // 3x+4y=0

  // {{1,2},{3,4}}

  // 1\t2\t3
  // 4\t5\t6
  // 7\t8\t9
  var mathText = text || dataTransfer.getData('application/mathml-presentation+xml') || '';
  if (/^\s*<math[^>]*>/.test(mathText) && /<\/math>\s*$/.test(mathText)) {
    text = transformMathML(parseMathML(mathText), 'AsciiMath').string;
    callback(text);
    return null;
  }

  callback(text);
  return null;
};

DnD.onDropOrPaste = function (event) {
  var target = this;
  var input = event.target;
  var caretPosition = event.type === "paste" || (event.clientX === 0 && event.clientY === 0) ? -1 : document.caretPositionFromPoint(event.clientX, event.clientY).offset;
  var isDrop = event.type === "drop";
  var dataTransfer = event.type === "paste" ? event.clipboardData : event.dataTransfer;
  var tableId = target.getAttribute('data-matrix-table');
  var plainText = dataTransfer.getData('text/plain');
  var hasSpecialData = DnD.hasInterestingData(dataTransfer) &&
                       //plainText !== '' && // image insertion, default action is show the image, TODO: fix
                       /[^\w]/.test(plainText) && // try to not avoid default action as insertText is not works well in Firefox (undo/redo), TODO: fix
                       (plainText.indexOf('=') === -1 || (tableId != null && !(MatrixTables[tableId].mode !== 'cells' && input.tagName.toLowerCase() === 'textarea' && MatrixTables[tableId].type === 'system')) || plainText === '') &&
                       (/[\t\n\r]/.test(plainText) && input.tagName.toLowerCase() === 'input' || tableId != null || plainText === '');
  //!!!
  //TODO: test (insertion of `x+y=2,y=1` into a textarea for a system of linear equations
  //TODO: insertion of "1 2\n3 4" into a textarea
  //TODO: insertion of "1\t2\t3\n" into a textarea with text "4\t5\t6\n" at the end
  var isEditable = input.tagName.toLowerCase() === 'input' || input.tagName.toLowerCase() === 'textarea' || input.hasAttribute('contenteditable');
  DnD.getTextData(dataTransfer, function (text) {
    var isPlainText = text === plainText;
    if (isPlainText && !hasSpecialData && isEditable) {
      DnD.textDropOrPaste(input, text, caretPosition, isDrop);
    } else {
      RPNProxy.getMatrix(text, function (tmp) {
        var elements = tmp.elements;
        var variableNames = tmp.variableNames;
        if (elements != undefined && tableId != null) {
          //TODO: do not insert zeros when there are a lot of them (!)
          MatrixTables[tableId].insert({
            inputValues: elements,
            variableNames: variableNames
          });
        } else if (elements != undefined && target.tagName.toLowerCase() === 'button') {// .add-table
          target.click();
          //TODO:
          var newTableId = document.querySelector('.main').lastElementChild.querySelector('.insert-table').getAttribute('data-id');
          MatrixTables[newTableId].insert({
            inputValues: elements,
            variableNames: variableNames
          });
        } else if (elements != undefined && isEditable) {
          //TODO: test, fix (spaces, decimal commas - ?)
          DnD.textDropOrPaste(input, '{' + elements.map(function (row) { return '{' + row.map(function (cell) { return cell.trim(); }).join(', ') + '}'; }).join(',') + '}', caretPosition, isDrop);
        } else if (isEditable) {
          DnD.textDropOrPaste(input, text, caretPosition, isDrop);
        } else {
          throw new TypeError('drop or paste of ' + text);
        }
      }, function (resultError) {
        if (isEditable) {
          DnD.textDropOrPaste(input, text, caretPosition, isDrop);
        } else {
          var positionInfo = RPNProxy.getPositionInfo();
          handleError(text, isDrop ? 'drop' : 'paste', resultError, positionInfo);
        }
      });
    }
  });
  event.preventDefault();
};

globalThis.DnD = DnD;

// see also https://bugzilla.mozilla.org/show_bug.cgi?id=1012662

var checkIfCanCopy = function () {
  var isCollapsed = window.getSelection().isCollapsed || document.getElementById("copy-fix") != undefined;
  if (!isCollapsed) {
    return undefined;
  }
  var target = document.activeElement;
  if (target == undefined ||
      target.classList == undefined) {
    return undefined;
  }
  if (target.classList.contains("matrix-menu-show")) {
    target = document.getElementById(target.getAttribute("data-for-matrix"));
  }
  if (target.getAttribute("data-matrix") == undefined &&
      !target.classList.contains("matrix-table-inner")) {
    return undefined;
  }
  return target;
};

document.addEventListener("beforecopy", function (event) {
  if (checkIfCanCopy() != undefined) {
    event.preventDefault();
  }
}, false);

var onCopy = function (event) {
  var dataTransfer = event.clipboardData;
  var target = checkIfCanCopy();
  if (target != undefined) {
    event.preventDefault();
    if (target.getAttribute("data-matrix") != undefined) {
      var matrixContainer = target;
      hit({click: "copy-matrix-container"});
      dataTransfer.setData("application/mathml-presentation+xml", serializeMatrixContainer(matrixContainer));
      dataTransfer.setData("text/plain", "\n" + toMultilineString(getTableFromAsciiMathMatrix(matrixContainer.getAttribute("data-matrix"))) + "\n");
    } else {
      hit({click: "copy-matrix-table"});
      var tableName = target.getAttribute("data-for");
      var matrixTableState = MatrixTables[tableName].getDataState();
      var tmp = RPN.getElementsArray(matrixTableState);
      //dataTransfer.setData("text/plain", "\n" + toMultilineString(getTableFromAsciiMathMatrix(matrix.toString())) + "\n");
      //presave decimals:
      dataTransfer.setData("text/plain", "\n" + toMultilineString(tmp.elements) + "\n");
      //! set the text/plain data before the xml as Matrix.toMatrix may throw an error
      var matrix = Matrix.toMatrix(tmp.elements);
      dataTransfer.setData("application/mathml-presentation+xml", serializeMatrixContainer(parseMathML(new Expression.Matrix(matrix).toMathML({idPrefix: "g", rounding: decimalRounding, useMatrixContainer: false}))));
    }
  }
};

document.addEventListener("copy", onCopy, false);

// It works in Firefox
document.addEventListener("contextmenu", function (event) {
  var target = event.target.closest("[data-matrix]");
  if (target != undefined) {
    hit({click: "contextmenu"});
    prepareMatrixMenu(target.id);
  }
}, false);
document.addEventListener("dragstart", function (event) {
  var target = event.target;
  //while (target != undefined && (target.nodeType !== Node.ELEMENT_NODE || target.getAttribute("data-matrix") == undefined)) {
  //  target = target.parentNode;
  //}
  if (target.nodeType !== Node.ELEMENT_NODE || target.getAttribute("data-matrix") == null) {
    target = null; // !window.getSelection().isCollapsed
  }
  if (target != undefined) {
    var matrixContainer = target;
    hit({click: "dragstart"});
    var dataTransfer = event.dataTransfer;
    dataTransfer.effectAllowed = "copy";
    dataTransfer.setData("application/mathml-presentation+xml", serializeMatrixContainer(matrixContainer));
    dataTransfer.setData("text/plain", "\n" + toMultilineString(getTableFromAsciiMathMatrix(matrixContainer.getAttribute("data-matrix"))) + "\n");
  }
}, false);

var growTimeoutId = 0;

var grow = function (element, clipElement, listContainer) {
  if (Element.prototype.animate != undefined) {
    var rect = element.getBoundingClientRect();
    var from = rect.top - rect.bottom;
    var animationDuration = 400;
    var a = function (element) {
      element.animate([
        {transform: "translateY(" + from.toString() + "px)"},
        {transform: "translateY(0px)"}
      ], {
        duration: animationDuration,
        composite: "add"
      });
    };
    if (true) {
      var viewportHeight = window.innerHeight;
      var clipRect = listContainer.getBoundingClientRect();
      var visibleHeight = viewportHeight - clipRect.top;
      //console.log(clipRect.top, clipRect.bottom, viewportHeight, h);
      var c = listContainer.firstElementChild;
      var h = visibleHeight;
      while (c != null && h > 0) {
        var childRect = c.getBoundingClientRect();
        h -= childRect.bottom - childRect.top;
        c = c.nextElementSibling;
      }
      var child = listContainer.firstElementChild;
      while (child != null && child !== c) {
        a(child);
        child = child.nextElementSibling;
      }
    } else {
      a(listContainer);
    }
    //TODO: clip-path (?)
    // Note: change the style here to avoid double style recalculation
    clipElement.style.overflowY = "hidden";
    window.clearTimeout(growTimeoutId);
    growTimeoutId = window.setTimeout(function () {
      // horizontal scrollbar should be shown for very large matrices
      clipElement.style.overflowY = "visible";
    }, animationDuration);
  }
};

var onPrintMatrix = function (event) {
  hit({click: "print-matrix-menuitem"});
  var matrixTableId = this.id.slice("print-matrix-menuitem-".length);
  var matrixMenu = this.parentNode;
  var matrixContainer = document.getElementById(matrixMenu.getAttribute("data-for-matrix"));
  var matrixElements = getTableFromAsciiMathMatrix(matrixContainer.getAttribute("data-matrix"));
  MatrixTables[matrixTableId].insert({inputValues: matrixElements});//TODO: system - ?
};

var onPrintMatrixIntoNewTable = function (event) {
  document.querySelector(".add-table").click();
  this.id = "print-matrix-menuitem-" + Object.keys(MatrixTables).sort().slice(-1).join("");
  onPrintMatrix.call(this, event);
};

Utils.on("click", ".print-matrix-button", function (event) {
  hit({click: "print-matrix-button"});
  var actHistoryId = this.getAttribute("data-act-history-id");
  var item = actHistoryId.slice(0, 1) === "#" ? {resultMatrix: actHistoryId.slice(1)} : actHistoryStorage.getItem(Number(actHistoryId));
  var matrixElements = getTableFromAsciiMathMatrix(item.resultMatrix);
  MatrixTables[this.getAttribute("data-print-matrix-to")].insert({inputValues: matrixElements});//TODO: system - ?
});

Utils.on("click", ".clear-button", function (event) {
  hit({click: "clear-button"});
  var p = this.closest(".actline");
  p.parentNode.removeChild(p);
  var actHistoryId = this.getAttribute("data-act-history-id");
  if (actHistoryId.slice(0, 1) !== "#") {
    actHistoryStorage.removeItem(Number(actHistoryId));
  }
});

var getInputErrorHTML = function (positionInfo, textMessage) {
  var input = positionInfo.input;
  var startPosition = positionInfo.startPosition;
  var endPosition = positionInfo.endPosition;
  //TODO: semantic elements - ?
  return textMessage + "\n" +
//         Utils.escapeHTML(input) +
         "<div class=\"input-error-wrapper\">" +
         (startPosition === -1 || endPosition === -1 ? Utils.escapeHTML(input) : Utils.escapeHTML(input.slice(0, startPosition)) + "<u class=\"input-error-position\"><span>" + Utils.escapeHTML(input.slice(startPosition, endPosition) || " ") + "</span></u>" + Utils.escapeHTML(input.slice(endPosition))) +
         "</div>";
};

  var removeDataErrorAttribute = function (input) {
    if (input.getAttribute("data-error") != null) {
      input.removeAttribute("data-error");
      input.dispatchEvent(new Event('update-attribute'));
    }
  };

  var updateDataErrorAttribute = function (input, error, positionInfo, extraPositionOffset) {
    extraPositionOffset = extraPositionOffset == undefined ? 0 : positionInfo.p;
    var message = error.message;
    var position = positionInfo.startPosition;
    var end = positionInfo.endPosition;
    if (message.indexOf("UserError:") === 0 || (position !== -1 && end !== -1)) {
      position += extraPositionOffset;//?
      end += extraPositionOffset;//?
      position = Math.min(position, input.value.length - 1);//TODO: fix ?
      end = Math.max(end, position + 1); // at least one character (textarea with EOF in the middle "sin ")
      end = Math.min(end, input.value.length);//?
      
      var delay = 0;
      if (end === input.value.length) {
        // trying not to blink with this error background
        delay = 1000;
      }
      var checkedValue = input.value;
      window.setTimeout(function () {
        if (checkedValue !== input.value) {
          return;
        }
      
      var dataError = position + "," + end;
      if (dataError !== input.getAttribute("data-error")) {
        input.setAttribute("data-error", dataError);
        input.dispatchEvent(new Event('update-attribute'));
      }
      
      }, delay);
      
      // no need to do an extra blinking
/*
      var onInput = function (event) {
        window.setTimeout(function () {
          input.removeEventListener("input", onInput, false);
          removeDataErrorAttribute(input);
        }, 0);
      };
      input.addEventListener("input", onInput, false);
*/
    }
  };

var onExpressionClick = function (event) {
  var expression = this.getAttribute("data-expression");
  var expressionInput = undefined;
  if (expression == undefined) {
    expressionInput = this.previousElementSibling.classList.contains("a-input") ? this.previousElementSibling.querySelector("input") : this.previousElementSibling;
    expression = expressionInput.value;
    // save
    keyStorage.setItem("expression", expression);
  }
  hit({onExpressionClick: expression});

  //?
  var kInput = this.parentNode.classList.contains("button-before-input") ? this.parentNode.querySelector("input") : undefined;
  var kInputValue = kInput == undefined ? undefined : kInput.value;
  var kInputId = kInput == undefined ? undefined : kInput.id;
  var matrixTableStates = {};
  for (var tableName in MatrixTables) {
    if (Object.prototype.hasOwnProperty.call(MatrixTables, tableName)) {
      matrixTableStates[tableName] = MatrixTables[tableName].getDataState();
    }
  }

  var actHistoryId = (actHistoryStorage.actHistoryId += 1);
  var printOptions = {idPrefix: "i" + actHistoryId.toString(), rounding: decimalRounding};

  var classList = this.classList.toString();
  var start = Date.now();
  RPNProxy.runExpression(expression, kInputValue, kInputId, matrixTableStates, printOptions, function (result) {
    var resultError = result.resultError;
    var details = result.details;
    var expressionString = result.expressionString;
    var resultHTML = result.resultHTML;
    var resultMatrix = result.resultMatrix;
    var detailsHTML = result.detailsHTML;
    if (resultError == undefined) {
      lastHash = expressionString.replace(/[^\S\u200B]+/g, "");//?
      //? x+y=2, 2x=4
      setLocationHash("#" + encodeLocationHash(lastHash));
      zInsAct(resultHTML, resultMatrix, details, expressionString, actHistoryId, detailsHTML, {isLoading: false});
      var end = Date.now();
      hit({click: "onExpressionClick-" + roundValue(end - start, 10 - 1)});
    } else {
      if (typeof resultError === "string") {
        resultError = new TypeError(resultError); // out of memory in Firefox
      }
      var positionInfo = RPNProxy.getPositionInfo();

      //TODO: show details anyway (!?)
      //!new - test
      if (resultError.message.indexOf("SingularMatrixException") === 0) {
        hit({click: "SingularMatrixException"});
        zInsAct("<div>" + i18n.inverse.determinantIsEqualToZeroTheMatrixIsSingularNotInvertible + "</div>", "", details, expression, actHistoryId, detailsHTML, {isLoading: false});
      }
      //!new
      handleError(expression, classList, resultError, positionInfo);//?
    }
  });
};


var insertButtonsTemplate = document.createElement('div');

insertButtonsTemplate.innerHTML = '<div role="group" class="insert-buttons">' +
                                  '<div><button type="button" class="print-matrix-button" data-act-history-id="" data-print-matrix-to="A"></button></div>' +
                                  '<div><button type="button" class="print-matrix-button" data-act-history-id="" data-print-matrix-to="B"></button></div>' +
                                  '<div><button type="button" class="clear-button" data-act-history-id=""></button></div>' +
                                  '<div><button type="button" class="share-item-button" data-act-history-id="" title="" hidden></button></div>' +
                                  '</div>';

var zInsAct = function (resultHTML, resultMatrix, details, expressionString, actHistoryId, detailsHTML, options) {
  if (typeof resultHTML !== "string" || typeof resultMatrix !== "string") {
    throw new RangeError();
  }
  options = options || {};

  var element = document.createElement("li");
  element.classList.toggle("actline", true);
  element.id = "action-" + actHistoryId;

  var insertButtons = insertButtonsTemplate.firstElementChild.cloneNode(true);
  var buttons = insertButtons.querySelectorAll(".print-matrix-button");
  for (var i = 0; i < buttons.length; i += 1) {
    var to = buttons[i].getAttribute("data-print-matrix-to");
    buttons[i].textContent = document.getElementById('i18n-buttons-insertIn').textContent + ' ' + to;
    buttons[i].hidden = resultMatrix === "" || MatrixTables[to] == undefined;
    buttons[i].setAttribute("data-act-history-id", actHistoryId);
  }
  insertButtons.querySelector(".clear-button").textContent = document.getElementById('i18n-buttons-clear').textContent;// i18n.buttons.clear;
  insertButtons.querySelector(".clear-button").setAttribute("data-act-history-id", actHistoryId);

  var shareButton = insertButtons.querySelector(".share-item-button");
  if (shareButton != null) {
    shareButton.title = document.getElementById('i18n-appButtons-share').textContent;
    shareButton.hidden = window.navigator.share == null;
    shareButton.setAttribute("data-act-history-id", actHistoryId);
  }

  var add = function (html) {
    var div = document.createElement("div");
    div.innerHTML = html;
    while (div.firstChild != undefined) {
      element.appendChild(div.firstChild);
    }
  };
  element.appendChild(insertButtons);
  add(resultHTML);
  if (detailsHTML != undefined) {
    add(detailsHTML);
  }

  var resdiv = document.getElementById("resdiv");
  var resultsContainer = resdiv.firstElementChild;
  if (resultsContainer == undefined) {
    resultsContainer = document.createElement("ol");
    resultsContainer.id = "results-container";
    resdiv.appendChild(resultsContainer);
  }
  if (resultsContainer.firstChild == null) {
    resultsContainer.appendChild(element);
  } else {
    resultsContainer.firstChild.parentNode.insertBefore(element, resultsContainer.firstChild);
  }
  Utils.check(element);
  if (!options.isLoading) {
    if (options.fromHashChange) {
      element.scrollIntoView(true);
      //TODO: :target - ?
    } else {
      element.scrollIntoViewIfNeeded(false);
    }
    grow(element, resdiv, resultsContainer);//!
    actHistoryStorage.setItem(actHistoryId, new ActHistoryItem({
      resultHTML: resultHTML,
      resultMatrix: resultMatrix,
      details: details,
      expressionString: expressionString,
      actHistoryId: undefined,
      detailsHTML: detailsHTML,
      version: ActHistoryItem.version
    })); // string, string, string, string, number, string, number
  }
};

//TODO: assign id instead to the <details> - ?
function getKey(element) {
  var key = [];
  var e = element;
  while (e != null && e.id === '') {
    // https://stackoverflow.com/a/57503796/839199
    var index = 0;
    var c = e.previousElementSibling;
    while (c != null) {
      if (c.tagName.toLowerCase() === e.tagName.toLowerCase()) {
        index += 1;
      }
      c = c.previousElementSibling;
    }
    key.push(e.tagName.toLowerCase() + ':nth-of-type(' + index + ')');
    e = e.parentNode;
  }
  if (e != null) {
    key.push('#' + e.id);
  }
  key.reverse();
  return key.join(' > ');
}

// .details-container > <details> > <summary>
Utils.initialize("details", function (element) {
  //var details = element.firstElementChild;
  var details = element;
  var summary = details.firstElementChild;
  if (details.initDetails != null) {
    details.initDetails(summary);
  }
  details.addEventListener("toggle", function (event) {
    Utils.check1(event.target);
  }, false);
  details.addEventListener("toggle", function (event) {
    var element = event.target;
    var detailsAttribute = element.getAttribute("data-details");
    if (detailsAttribute == undefined) {
      return;
    }
    element.removeAttribute("data-details");
    var idPrefix = element.getAttribute("data-id-prefix");
    var printOptions = {idPrefix: idPrefix, rounding: decimalRounding};
    var x = JSON.parse(detailsAttribute);
    var e = element.firstElementChild.nextElementSibling;
    hit({details: x.type});//!
    RPNProxy.getDetails(x, printOptions, function (html) {
      var tmp = document.createElement('div');
      tmp.innerHTML = html;
      e.appendChild(tmp);
      Utils.check(tmp);
    });
  }, false);
  summary.addEventListener("mousedown", function (event) {
    if (event.detail > 1) {
      event.preventDefault();
    }
  }, false);

  //!new 2019-08-29
  // keep the state of <details> in the history.state:
    var historyState = window.history.state;
    if (historyState != null) {
      var state = historyState.detailsSummary;
      if (state != null) {
        var key = getKey(details);
        if (state[key] != null) {
          summary.click();
        }
      }
    }

});

function canSaveStateOnPageHide() {
  //TODO: fix
  //TODO: Chrome bug
  return !('onfreeze' in document); // it is not a Chrome
}

  window.addEventListener(!canSaveStateOnPageHide() ? "beforeunload" : "pagehide", function (event) {
    var detailsSummary = {};
    var es = document.querySelectorAll("details[open]");
    for (var i = 0; i < es.length; i++) {
      var key =  getKey(es[i]);
      detailsSummary[key] = true;
    }
    var historyState = Object.assign({}, window.history.state);
    historyState.detailsSummary = detailsSummary;
    window.history.replaceState(historyState, document.title, window.location.href);
  }, !canSaveStateOnPageHide() ? {once: true, passive: true} : false);

Utils.on("click", ".change-button", function (event) {
  hit({click: "change-button"});
  var s1 = this.getAttribute("data-for1");
  var s2 = this.getAttribute("data-for2");
  var table1 = MatrixTables[s1];
  var table2 = MatrixTables[s2];
  var t1 = table1.getState();
  var t2 = table2.getState();
  table1.insert(t2);
  table2.insert(t1);
});

// ---------------------------------------- cookies -----------------------------------------------

var onInputExampleLinkClick = function (event) {
  hit({click: "input-example-link"});


//super hack
  event.preventDefault();
  var s = this.parentNode.parentNode.querySelector(".input-example-code").textContent;
  s = s.replace(/\u0020+/g, " ").trim().replace(/\n\u0020/g, "\n");
  var mt = MatrixTables["A"];
  if (mt.mode === "cells") {
    mt.container.querySelector(".swap-mode-button").click();
  }
  updateInputValue(mt.textarea, s);
  // for some reasons `mt.textarea.focus()` does not scroll to show the full textarea in Chrome sometimes
  window.setTimeout(function () {
    mt.container.scrollIntoViewIfNeeded(false);
  }, 0);
};

Utils.initialize(".input-example-link-container", function (element) {
  element.firstElementChild.onclick = onInputExampleLinkClick;
});

Utils.initialize(".hypercomments-details-summary-container", function (element) {
  var details = element.querySelector("details");

  var showComments = function () {
    if (window._hcwp == undefined) {
      var link = document.getElementById("hc-link");
      link.hidden = false;
      window._hcwp = [{widget: "Stream", widget_id: 8317, callback: function (app, init) {
         app.on("streamMessage", function (packet) {
           // html snapshot to help with the debugging
           window.sendSnapshot();
         });
      }}];

      window.HC_LOAD_INIT = true;
      // see https://www.hypercomments.com/en/documentation
      var lang = document.documentElement.lang.slice(0, 2).toLowerCase();
      var src = "https://w.hypercomments.com/widget/hc/8317/" + lang + "/widget.js";
      Utils.$import(src)["catch"](function (error) {
        toggleHidden(false);
        window._hcwp = undefined;
      });
      var toggleHidden = function (isLoading) {
        details.querySelector("progress").hidden = !isLoading;
        details.querySelector(".powered-text").hidden = !isLoading;
        details.querySelector(".cannot-load-text").hidden = isLoading;
      };
      toggleHidden(true);
    }
  };

  details.addEventListener("toggle", function (event) {
    showComments();
  }, false);

  var isMobile = true; // too big images

  var checkHash = function (event) {
    if (window.location.protocol !== "file:" && window.location.hostname !== "127.0.0.1") {
      var hash = decodeLocationHash(window.location.hash.slice(1));
      if (!isMobile || hash.indexOf("hcm") !== -1 || hash.indexOf("hypercomments_widget") !== -1) {
        if (details.getAttribute("open") == undefined) {
          details.querySelector("summary").click();
        }
        showComments();
      }
    } else {
      details.hidden = true;
    }
  };
  checkHash(undefined);
  window.addEventListener("hashchange", checkHash, false);

});

// detfindDet

Utils.initialize(".insert-table", function (element) {
  var id = element.getAttribute("data-id");
  var sizes = element.getAttribute("data-sizes") || "";
  var type = element.getAttribute("data-type") || "simple";

  var initialRows = 3;
  var initialCols = 3;
  var match = (/^(\d+)x(\d+)$/).exec(sizes);
  if (match != undefined) {
    initialRows = Number(match[1]);
    initialCols = Number(match[2]);
  }

  var state = undefined;
  var stateKey1 = id + "1";
    var historyState = window.history.state;
    if (historyState != null && historyState[stateKey1] != null) {
      state = historyState[stateKey1];
    }

  if (state == undefined) {
    state = {
      mode: undefined,
      inputValues: null,
      textareaValue: null,
      rows: initialRows,
      cols: initialCols,
      textareaStyleWidth: undefined,
      textareaStyleHeight: undefined
    };
  }
  //TODO: do we need a title attribute at insert-table and why if we have <legend> ?
  var x = new MatrixTable(id, initialRows, initialCols, type, element);
  //element.style.visibility = "hidden";
  var modeKey = "~" + window.location.pathname + "~" + id + "~" + "mode";
  var mode = keyStorage.getItem(modeKey);
  if (mode == undefined) {
    var initialMode = undefined;
    //use the mode from the last table:
    for (var tableName in MatrixTables) {
      if (Object.prototype.hasOwnProperty.call(MatrixTables, tableName)) {
        initialMode = MatrixTables[tableName].mode;
      }
    }
    if (initialMode == undefined) {
      //as table of inputs does not work well on mobile phones (on Android the virtual keyboard is swithed to the alphabetical on every focus change)
      initialMode = !window.matchMedia("(pointer: fine)").matches ? '' : 'cells';
    }
    mode = initialMode;
    //mode = x.mode;
  }
  MatrixTables[id] = x;
  x.mode = mode;
  x.insert(state);
  //element.style.visibility = "";
  x.onmodechange = function () {
    keyStorage.setItem(modeKey, x.mode);
  };
  x.onswapmode = function () {
    var newMode = x.mode === "cells" ? "" : "cells";
    RPNProxy.getElementsArray(x.getDataState(), function (result) {
      var elements = result.elements;
      var variableNames = result.variableNames;
      x.insert({
        inputValues: elements,
        mode: newMode,
        variableNames: variableNames
      });
    });
  };
  DnD.initializeDropZone(element);

});

  // TODO: save new tables to the history.state, don't restore old
    window.addEventListener(!canSaveStateOnPageHide() ? "beforeunload" : "pagehide", function (event) {
      var historyState = Object.assign({}, window.history.state);
      for (var tableName in MatrixTables) {
        if (Object.prototype.hasOwnProperty.call(MatrixTables, tableName)) {
          var stateKey1 = tableName + "1";
          historyState[stateKey1] = MatrixTables[tableName].getState();
        }
      }
      window.history.replaceState(historyState, document.title, window.location.href);
    }, !canSaveStateOnPageHide() ? {once: true, passive: true} : false);

Utils.on("click", ".expression-button", onExpressionClick);

Utils.on("click", ".expression-input-button", onExpressionClick);

Utils.initialize(".expression-input-container", function (element) {
  var input = element.querySelector("input");

  var form = element;
  addClickOnEnter(element);// focus is moved to button in IE 11 otherwise
  form.addEventListener('submit', function (event) {
    event.preventDefault();
  }, false);

  input.addEventListener("input", function (event) {
    event.target.style.width = ch(Math.max(38, event.target.value.length + 2 + 2) + "ch"); // + 2 as it has a list
  }, false);

  if (input.value === input.getAttribute("value")) { // autofill
    //input.disabled = true;
    var value = keyStorage.getItem("expression");
    if (value != undefined && value !== "") {
      //input.value = value;
      updateInputValue(input, value);
    }
    input.addEventListener("input", function (event) {
      var input = event.target;
      checkInput(input, "");
    }, false);
    checkInput(input, "");
    //input.disabled = false;
  }

  // transformation of multi-line form into single-line form
  input.addEventListener("drop", DnD.onDropOrPaste, false);
  input.addEventListener("paste", DnD.onDropOrPaste, false);
});

var encodeLocationHash = function (hash) {

  //var url = new URL('https://example.com/');
  //url.hash = hash;
  //return hash.slice('#'.length);

  // twitter.com does not support {} in hash, seems
  // comments systems, other software with "auto-link" feature may work not good with some characters ...
  // update: 2021-07-27: *, (, ) - not encoded
  // TODO: ^ - replace by ** - ?
  return encodeURIComponent(hash).replace(/[\!'\.~]/g, function (p) {
                                   return '%' + p.charCodeAt(0).toString(16);
                                 })
                                 // / - 2018-07-09
                                 // &, +, _ - 2020-08-02
                                 .replace(/%26|%2B|%2C|%2F|%3D/g, function (p) {
                                   return decodeURIComponent(p);
                                 });
};

// https://stackoverflow.com/questions/7449588/why-does-decodeuricomponent-lock-up-my-browser
function decodeURIComponentSafe(string) {
  var validPercentEncoding = /(?:%[0-7][0-9A-F]|%(?!C[0-1])[C-D][0-9A-F]%[8-9A-B][0-9A-F]|%(?!E0%[8-9])(?!ED%[A-B])E[0-9A-F](?:%[8-9A-B][0-9A-F]){2}|%(?!F0%8)(?!F4%[9A-B])F[0-4](?:%[8-9A-B][0-9A-F]){3}|[^%])+/gi;
  return string.replace(validPercentEncoding, function (p) {
    return decodeURIComponent(p);
  });
}

var decodeLocationHash = function (hash) {
  // determinant-Gauss%28%7B%7B0,z,y,u%7D,%7Bz,z,u%2By,u%2By%7D,%7Bu%2By,u%2By,z,z%7D,%7Bu,y,z,0%7D%7D%29
  return decodeURIComponentSafe(hash);
};

var lastHash = "";

var onHashChange = function (event) {
  var hash = decodeLocationHash(window.location.hash.slice(1));
  if (lastHash === hash) {
    return;
  }
  lastHash = hash;

  if (document.getElementById(hash) != undefined) {
    return;
  }
  //TODO: (?)
  if (/^hcm\=\d+$/.exec(hash) != undefined) { // || document.getElementById(hash) != undefined
    return;
  }
  if (/^[\-\da-zA-Z]*system_1$/.exec(hash) != undefined) { // || document.getElementById(hash) != undefined
    return;
  }
  if (hash.trim() === "") {
    return;
  }

  var actHistoryId = (actHistoryStorage.actHistoryId += 1);
  var printOptions = {idPrefix: "i" + actHistoryId.toString(), rounding: decimalRounding};
  //TODO: FIX!!!
  RPNProxy.runExpression(hash, undefined, undefined, undefined, printOptions, function (result) {
    var resultError = result.resultError;
    var details = result.details;
    var expressionString = result.expressionString;
    var resultHTML = result.resultHTML;
    var resultMatrix = result.resultMatrix;
    var detailsHTML = result.detailsHTML;
    if (resultError == undefined) {
      var previousItem = actHistoryStorage.getPreviousItem();
      //...
      // TODO: FIX!!! It is wrong to compare HTML here, as "Expression.id()" generates different HTML each time
      if (previousItem == undefined || (previousItem.resultHTML !== resultHTML && previousItem.expressionString !== expressionString)) {
        zInsAct(resultHTML, resultMatrix, details, expressionString, actHistoryId, detailsHTML, {isLoading: false, fromHashChange: true});
      }
    } else {
      //if (resultError.message.indexOf("UserError:") === 0) {
        //ignore
      //} else {
        var positionInfo = RPNProxy.getPositionInfo();
        handleError(hash, "location.hash", resultError, positionInfo);
      //}
    }
  });
};

Utils.initialize(".from-cookie", function (element) {

  if ((window.navigator.platform || '').indexOf('Mac') === 0) {
    document.body.classList.add('mac');
  }

  // TODO: insert after the <details> element expansion - ? and calculate - ?
  var examples = document.getElementById("examples");
  if (examples != undefined) {
    var list = examples.querySelectorAll("a");
    for (var i = 0; i < list.length; i += 1) {
      var code = list[i].querySelector("code");
      var s = code.textContent;
      var html = "";
      if (s === "{{11,3},{7,11}}*{{8,0,1},{0,3,5}}") {
        html = '<mrow><mrow><mo>(</mo><mtable rowspacing="0ex"><mtr><mtd><mn>11</mn></mtd><mtd><mn>3</mn></mtd></mtr><mtr><mtd><mn>7</mn></mtd><mtd><mn>11</mn></mtd></mtr></mtable><mo>)</mo></mrow><mo>&sdot;</mo><mrow><mo>(</mo><mtable rowspacing="0ex"><mtr><mtd><mn>8</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>1</mn></mtd></mtr><mtr><mtd><mn>0</mn></mtd><mtd><mn>3</mn></mtd><mtd><mn>5</mn></mtd></mtr></mtable><mo>)</mo></mrow></mrow>';
      } else if (s === "determinant({{1,2,3},{4,5,6},{7,2,9}})") {
        html = '<mrow><mo>|</mo><mtable rowspacing="0ex"><mtr><mtd><mn>1</mn></mtd><mtd><mn>2</mn></mtd><mtd><mn>3</mn></mtd></mtr><mtr><mtd><mn>4</mn></mtd><mtd><mn>5</mn></mtd><mtd><mn>6</mn></mtd></mtr><mtr><mtd><mn>7</mn></mtd><mtd><mn>2</mn></mtd><mtd><mn>9</mn></mtd></mtr></mtable><mo>|</mo></mrow>';
      } else if (s === "{{1,2},{3,4}}^-1") {
        html = '<msup><mrow><mo>(</mo><mtable rowspacing="0ex"><mtr><mtd><mn>1</mn></mtd><mtd><mn>2</mn></mtd></mtr><mtr><mtd><mn>3</mn></mtd><mtd><mn>4</mn></mtd></mtr></mtable><mo>)</mo></mrow><mrow><mo>(</mo><mrow><mo>&minus;</mo><mn>1</mn></mrow><mo>)</mo></mrow></msup>';
      } else if (s === "{{1,2,3},{4,5,6},{7,2,9}}^-1") {
        html = '<msup><mrow><mo>(</mo><mtable rowspacing="0ex"><mtr><mtd><mn>1</mn></mtd><mtd><mn>2</mn></mtd><mtd><mn>3</mn></mtd></mtr><mtr><mtd><mn>4</mn></mtd><mtd><mn>5</mn></mtd><mtd><mn>6</mn></mtd></mtr><mtr><mtd><mn>7</mn></mtd><mtd><mn>2</mn></mtd><mtd><mn>9</mn></mtd></mtr></mtable><mo>)</mo></mrow><mrow><mo>(</mo><mrow><mo>&minus;</mo><mn>1</mn></mrow><mo>)</mo></mrow></msup>';
      } else {
        html = Expression.p(s, {}, {idPrefix: "g", useMatrixContainer: false});
        //html = Expression.p(s);
      }
      html = html.replace(/\<mn>(\d+)<\/mn>/g, function (p, digits) {
        return '<mn>' + localeString(Number(digits)) + '</mn>';
      });
      var tmp = document.createElement("div");
      tmp.innerHTML = "<math>" + html + "</math>";
      code.parentNode.insertBefore(tmp.firstElementChild, code);
      code.parentNode.removeChild(code);
    }
  }

  actHistoryStorage.load(function (storedActHistory) {
  Utils.waitI18n(function () {
    var exampleAttribute = element.getAttribute("data-example");
    var needsExample = exampleAttribute != undefined;
    var oldVersion = ActHistoryItem.version;
    if (true) {
      for (var actHistoryId in storedActHistory) {
      if (Object.prototype.hasOwnProperty.call(storedActHistory, actHistoryId)) {
        var storedActHistoryItem = storedActHistory[actHistoryId].item;
        if (storedActHistoryItem != null) {//! some strange issue in Safari

        storedActHistoryItem.resultHTML = storedActHistoryItem.resultHTML;
        storedActHistoryItem.detailsHTML = storedActHistoryItem.detailsHTML;

        zInsAct(storedActHistoryItem.resultHTML,
                storedActHistoryItem.resultMatrix,
                storedActHistoryItem.details,
                storedActHistoryItem.expressionString,
                actHistoryId,
                storedActHistoryItem.detailsHTML,
                {isLoading: true});
        needsExample = false;
        oldVersion = Math.min(oldVersion, storedActHistoryItem.oldVersion);
        if (storedActHistoryItem.expressionString == undefined) {
          oldVersion = -1;
        }
        }
      }
      }
      //if (oldVersion !== ActHistoryItem.version) {
        //..
      //}
      if (storedActHistory.length !== 0) {
        hit({version: "version-" + oldVersion});
      }
    }
    window.addEventListener("hashchange", onHashChange, false);
    onHashChange(undefined);
    needsExample = needsExample && actHistoryStorage.size() === 0;
    if (needsExample) {
      var printOptions = {idPrefix: "g"};
      RPNProxy.runExpression("{{5,8,-4},{6,9,-5},{4,7,-2}}*{{2},{-3},{1}}", undefined, undefined, undefined, printOptions, function (result) {
        if (result.resultError == undefined) {
          // TODO: isLoading or not isLoading - ?
          var actHistoryId = "#" + result.resultMatrix;
          zInsAct(result.resultHTML, result.resultMatrix, result.details, result.expressionString, actHistoryId, result.detailsHTML, {isLoading: true});
          //! Note:
          //! No need to save the example
        } else {
          handleError("", "", result.resultError, {});
        }
      });
    }
  });
  });

  var pathname = window.location.pathname;
  var links = document.querySelector(".menu").querySelectorAll("a");
  for (var i = 0; i < links.length; i += 1) {
    if (links[i].pathname === pathname) {
      links[i].setAttribute('aria-current', 'page');
    }
  }

});

// --------------------------------------------- end ----------------------------------------------

//  Drag and Drop + Copy and Paste

var toggleValidDropTarget = function (force) {
  //document.body.classList.toggle("drop-target", force);
  var dropzones = document.querySelectorAll(".matrix-table");
  for (var i = 0; i < dropzones.length; i += 1) {
    dropzones[i].classList.toggle("valid-drop-target", force);
  }
  var expressionInput = document.getElementById("expression");
  if (expressionInput != undefined) {
    expressionInput.classList.toggle("valid-drop-target", force);
  }
  var addTableButton = document.querySelector(".add-table");
  if (addTableButton != null) {
    addTableButton.classList.toggle("valid-drop-target", force);
  }
};
DnD.hasInterestingData = function (dataTransfer) {
  // TODO: types is null in Safari 10
  // types returns null in IE 11
  var types = dataTransfer.types || ['text/plain'];
  for (var i = 0; i < types.length; i += 1) {
    var type = types[i];
    if (type === "text/plain" ||
        type === "application/mathml-presentation+xml" ||
        (typeof TextDetector !== "undefined" && type === "Files")) {//TODO: /^image\//.test(event.dataTransfer.items[i].type)
      return true;
    }
  }
  return false;
};
var onDragOverOrDragEnd = function (event) {
  if (!DnD.hasInterestingData(event.dataTransfer)) {
    return;
  }
  var key = "data-drop-target-timeout";
  var a = Number(document.body.getAttribute(key) || 0) || 0;
  if (a !== 0) {
    window.clearTimeout(a);
  } else {
    toggleValidDropTarget(true);
  }
  a = window.setTimeout(function () {
    toggleValidDropTarget(false);
    document.body.setAttribute(key, "0");
  }, event.type === "dragend" ? 0 : 600);
  document.body.setAttribute(key, a.toString());
};

document.addEventListener("dragover", onDragOverOrDragEnd, false);
document.addEventListener("dragend", onDragOverOrDragEnd, false);

//

var arrowWithLabelInitialize = function (arrowWithLabel) {
  var arrow = arrowWithLabel.querySelector(".arrow");
  var table = arrowWithLabel.previousElementSibling.querySelector("mtable");
  var start = Number(arrowWithLabel.getAttribute("data-start"));
  var end = Number(arrowWithLabel.getAttribute("data-end"));
  var n = 0;
  var row = table.firstElementChild;
  var startRow = undefined;
  var endRow = undefined;
  while (row != undefined) {
    if (n === start) {
      startRow = row;
    }
    if (n === end) {
      endRow = row;
    }
    n += 1;
    row = row.nextElementSibling;
  }
  var startRowRect = startRow.getBoundingClientRect();
  var endRowRect = endRow.getBoundingClientRect();
  var tableRect = table.getBoundingClientRect();
  if (end < start) {
    var tmp = endRowRect;
    endRowRect = startRowRect;
    startRowRect = tmp;
  }
  var arrowHeight = ((endRowRect.top + endRowRect.bottom) / 2 - (startRowRect.top + startRowRect.bottom) / 2);
  var arrowWithLabelVerticalAlign = ((tableRect.top + tableRect.bottom) / 2 - (startRowRect.top + endRowRect.bottom) / 2);
  window.requestAnimationFrame(function () {
    arrow.style.height = arrowHeight.toString() + "px";
    arrow.style.top = "50%";
    arrow.style.marginTop = (-arrowHeight / 2).toString() + "px";
    arrowWithLabel.style.verticalAlign = arrowWithLabelVerticalAlign.toString() + "px";
  });
};

document.addEventListener("custom-paint", function (event) {
  if (event.target.getAttribute("data-custom-paint") === "arrow-with-label") {
    arrowWithLabelInitialize(event.target);
  }
}, false);

if ("navigationMode" in window.history) {
  window.history.navigationMode = "fast"; // - Opera Presto
}

Utils.initialize(".ads-container", function (adsContainer) {

  var isConnectionOK = function () {
    // doNotTrack - 8%
    // "slow-2g" + "2g" - 2.5%
    // saveData - 18%
    return window.location.protocol !== "file:" &&
           window.location.hostname !== "127.0.0.1" &&
           window.navigator.doNotTrack !== "1" &&
           isConnectionFast();
  };

  if (isConnectionOK() && false) {
    window.setTimeout(function () {
      (window["yandex_metrika_callbacks"] = window["yandex_metrika_callbacks"] || []).push(function() {
        try {
          yaCounter = new Ya.Metrika({
            id: 29787732,
            clickmap: true,
            trackLinks: true,
            accurateTrackBounce: true,
            trackHash: true,
            webvisor: false,
            params: {}
          });
          window.yaCounter29787732 = yaCounter;
          if (yaCounter != undefined) {
            requestIdleCallback("sendHits", sendHits, 1000);
          }
        } catch (error) {
          console.log(error);
        }
      });
      Utils.$import("https://mc.yandex.ru/metrika/watch.js");
    }, 0);
  } else {
    hitQueue = undefined;
  }

  var element = adsContainer.querySelector(".adsbygoogle-container");
  var toggleAdsButton = adsContainer.querySelector(".toggle-ads-button");
  if (toggleAdsButton == null) { // TODO: remove
    toggleAdsButton = document.createElement("div");
    toggleAdsButton.appendChild(document.createElement("div"));
  }

  var browserIsOK = "ar bg gl zh mk vi tr".indexOf(document.documentElement.lang) === -1 &&
                    isConnectionOK() &&
                    window.opera == undefined; // loading indicator in Opera
  var showAds = false;
  var mediaIsOK = false;
  var prefersReducedMotion = false;

  var isInserted = false;
  var loadAds = function () {
    // https://stackoverflow.com/a/56248553
    function insertHTML(html, dest, append){
        // if no append is requested, clear the target element
        if(!append) dest.innerHTML = '';
        // create a temporary container and insert provided HTML code
        var container = document.createElement('div');
        container.innerHTML = html;
        // cache a reference to all the scripts in the container
        var scripts = container.querySelectorAll('script');
        // get all child elements and clone them in the target element
        var nodes = container.childNodes;
        for( var i=0; i< nodes.length; i++) dest.appendChild( nodes[i].cloneNode(true) );
        // force the found scripts to execute...
        for( var i=0; i< scripts.length; i++){
            var script = document.createElement('script');
            script.type = scripts[i].type || 'text/javascript';
            if( scripts[i].hasAttribute('src') ) script.src = scripts[i].src;
            script.innerHTML = scripts[i].innerHTML;
            document.head.appendChild(script);
            document.head.removeChild(script);
        }
        // done!
        return true;
    }
    if (browserIsOK && mediaIsOK && !prefersReducedMotion && showAds && window.fetch != null) {
      if (!isInserted) {
        isInserted = true;
        fetch((document.documentElement.lang === 'ru' ? '.' : '..') + '/ads.json').then(function (response) {
          return response.json();
        }).then(function (ads) {
          var x = undefined;
          var lang = document.documentElement.lang;
          var now = Date.now();
          for (var i = 0; i < ads.length; i += 1) {
            var j = Math.floor(Math.random() * ads.length);
            var item = ads[i];
            ads[i] = ads[j];
            ads[j] = item;
          }
          for (var i = 0; i < ads.length; i += 1) {
            var item = ads[i];
            if ((lang === item.lang || item.lang === "*") && Math.random() < item.probability && now < Date.parse(item.endTime)) {
              x = item;
            }
          }
          if (x != undefined) {
            if (x.videoId !== "") {
              element.innerHTML = "<div id=\"player\"></div>";
              window.onYouTubeIframeAPIReady = function () {
                var done = false;
                var player = new YT.Player("player", {
                  height: "200",
                  width: "200",
                  videoId: x.videoId,
                  events: {
                    onStateChange: function (event) {
                      if (event.data >= 0 && !done) {
                        hit({click: "youtube-click"});
                        done = true;
                      }
                    }
                  }
                });
              };
              Utils.$import("https://www.youtube.com/iframe_api");
            } else if (x.html !== "") {
              //element.innerHTML = x.html;
              insertHTML(x.html, x.placement === "big-ads" ? document.getElementById("big-ads") : element);
            }
          } else {
            if (Date.now() > Date.parse("2021-12-31T23:59:59.999Z")) {
            (window.adsbygoogle = window.adsbygoogle || []).push({});
            Utils.$import("https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js");
            }
          }
        });
      }
    }
    toggleAdsButton.hidden = !browserIsOK || !mediaIsOK || prefersReducedMotion;
  };

  if (browserIsOK) {
    window.requestAnimationFrame(function () {
      var updateUI = function () {
        toggleAdsButton.firstElementChild.hidden = !showAds;
        toggleAdsButton.lastElementChild.hidden = showAds;
        element.hidden = !showAds;
      };

      var value = keyStorage.getItem("show-ads");
      showAds = value == undefined || value === "true";
      updateUI();
      loadAds();
      toggleAdsButton.onclick = function () {
        showAds = !showAds;
        keyStorage.setItem("show-ads", showAds ? "true" : "false");
        updateUI();
        loadAds();
        hit({click: "show-ads-" + showAds});
      };

      var mediaQueryList = window.matchMedia("screen and (max-width: 800px)");  // see style.css
      var checkMedia = function () {
        if (!mediaQueryList.matches) {
          mediaQueryList.removeListener(checkMedia);
          mediaIsOK = true;
          loadAds();
        }
      };
      mediaQueryList.addListener(checkMedia);
      checkMedia();
    });
  } else {
    toggleAdsButton.hidden = true;
  }

  var elementAnimate = Element.prototype.animate;

  //TODO: move
    window.setTimeout(function () {
      var mediaQueryList = window.matchMedia("(prefers-reduced-motion)");
      var checkMedia = function () {
        if (mediaQueryList.matches) {
          prefersReducedMotion = true;
          Element.prototype.animate = undefined;
          hit({click: "prefers-reduced-motion"});
        } else {
          prefersReducedMotion = false;
          Element.prototype.animate = elementAnimate;
        }
        loadAds();
      };
      mediaQueryList.addListener(checkMedia);
      checkMedia();
    }, 0);

});

if (window.location.protocol !== "file:" && window.location.hostname !== "127.0.0.1") {
  var useAppCache = function () {
    document.addEventListener("DOMContentLoaded", function (event) {
      // https://www.youtube.com/watch?v=IgckqIjvR9U&t=1005s
      var iframe = document.createElement("iframe");
      iframe.style.display = "none";
      iframe.src = "load-appcache.html";
      document.body.appendChild(iframe);
    }, {once: true});
  };
  if (("serviceWorker" in window.navigator)) {
    var serviceWorker = undefined;
    try {
      serviceWorker = window.navigator.serviceWorker;
    } catch (error) {
      if (error.name !== "SecurityError") {
        throw error;
      }
    }
    if (serviceWorker != undefined) {
      var promise = serviceWorker.register("sw.js", {scope: "./"});
      if (promise.then != undefined) {
        promise.then(function (registration) {
          console.log("ServiceWorker registration succeeded:", registration);
          //TODO:
          // reload the page if the user has not interacted with the page yet and the major version is bigger (?)
          //registration.onupdatefound = function () {
          //  var installingWorker = registration.installing;
          //  installingWorker.onstatechange = function (event) {
          //    if (installingWorker.state === "activated") {
          //      window.location.reload();
          //    }
          //  };
          //};
        })["catch"](function (error) {
          useAppCache();
          console.log("ServiceWorker registration failed:", error);
        });
      }
    } else {
      useAppCache();
    }
  } else {
    useAppCache();
  }
}

window.addEventListener("beforeinstallprompt", function (event) {
  event.preventDefault(); // most of users do not accept it
  //if (event.userChoice != undefined) {
  //  event.userChoice.then(function (choiceResult) {
  //    hit({beforeinstallprompt: choiceResult.outcome});
  //  });
  //}
  hit({beforeinstallprompt: "show"});

  var installButton = document.getElementById('a2hs-button');
  if (installButton != null) {
    installButton.onclick = function (mouseEvent) {
      event.prompt();
    };
    installButton.hidden = false;
  }
}, false);

document.addEventListener("DOMContentLoaded", function (event) {
  if (window.navigator.share != undefined) {
    var shareButton = document.getElementById('share-button');
    if (shareButton != null) {
      shareButton.onclick = function (event) {
        window.navigator.share({
          title: decodeURIComponent(shareButton.getAttribute("data-text")),
          url: decodeURIComponent(shareButton.getAttribute("data-url"))
        });
      };
      shareButton.hidden = false;
    }
  }
}, {once: true});

Utils.on("click", ".share-item-button", function (event) {
  var actHistoryId = this.getAttribute("data-act-history-id");
  var item = actHistoryStorage.getItem(Number(actHistoryId));
  window.navigator.share({
    url: "#" + encodeLocationHash(item.expressionString)
  });
});

Utils.initialize(".more-button", function (button) {
  var container = button.previousElementSibling;
  button.onclick = function () {
    container.hidden = !container.hidden;
    button.setAttribute("aria-expanded", container.hidden ? "true" : "false");
  };
});

//! 2018-03-20
var onMatrixTable = function () {
  //!
  var matrixMenu = document.getElementById("matrix-menu");
  if (matrixMenu != undefined) {
    matrixMenu.parentNode.removeChild(matrixMenu);
  }
  var matrixMenuDialog = document.getElementById("matrix-menu-dialog");
  if (matrixMenuDialog != undefined) {
    matrixMenuDialog.parentNode.removeChild(matrixMenuDialog);
  }
};

var addTableTemplate = document.createElement('div');
addTableTemplate.innerHTML = '<div class="tdmatrix">' +
                             '<fieldset>' +
                             '<legend align="center"><span></span><button type="button" class="remove-table" data-id="X" title="">✗</button></legend>' +
                             '<div class="insert-table" data-id="X" data-sizes="3x3" data-type="simple"></div>' +
                             '</fieldset>' +
                             '</div>';

  function addTable(id) {
    var newNode = addTableTemplate.firstElementChild.cloneNode(true);
    newNode.querySelector("legend").querySelector("span").textContent = i18n.index.matrix + ' ' + id + i18n.colonSpacing + ': ';
    newNode.querySelector(".remove-table").setAttribute("data-id", id);
    newNode.querySelector(".remove-table").title = i18n.buttons.removeTable;
    newNode.querySelector(".insert-table").setAttribute("data-id", id);
    document.querySelector(".main").appendChild(newNode);
    Utils.check(newNode);
    onMatrixTable();
  }

function getNextTableId() {
  var id = undefined;
  for (var c = "A"; c <= "Z"; c = String.fromCharCode(c.charCodeAt(0) + 1)) {
    if (id == undefined && MatrixTables[c] == undefined) {
      id = c;
    }
  }
  return id;
}

//button
Utils.initialize(".add-table", function (element) {
  element.addEventListener("click", function (event) {
  hit({click: "add-table"});
  var id = getNextTableId();
  if (id == undefined) {
    throw new TypeError("Not implemented!");
  }
  addTable(id);
  }, false);

  //!new 2019-01-06
  // Note: "paste" event is not working in Chrome 71?
  DnD.initializeDropZone(element);

  Utils.waitI18n(function () {//TODO: ?
  var historyState = window.history.state;
  if (historyState != null) {
    for (var key in historyState) {
      if (Object.prototype.hasOwnProperty.call(historyState, key)) {
        if (/^[A-Z]1$/.test(key)) {//TODO: ?
          var id = key.slice(0, -1);
          if (MatrixTables[id] == undefined) {
            addTable(id);
          }
        }
      }
    }
  }
  }, 0);
});
//button
Utils.on("click", ".remove-table", function (event) {
  hit({click: "remove-table"});
  var id = event.target.getAttribute("data-id");
  MatrixTables[id]._resizeTable(-1 / 0, -1 / 0); //!new 2020-03-22 (To save hidden <input> elements)
  delete MatrixTables[id];
  var tables = document.querySelectorAll(".matrix-table");
  for (var i = 0; i < tables.length; i += 1) {
    var table = tables[i];
    if (table.getAttribute("data-id") === id) {
      var e = table.parentNode.parentNode;
      e.parentNode.removeChild(e);
    }
  }
  //TODO: update history state when hiding (?)
  //TODO: restore from the history state the table on back button click
  //TODO: set focus to the previous element (?)
  onMatrixTable();
});

  function makeContent(variableName) {
    var i = variableName.indexOf("_");
    if (i === -1) {
      return '<mi>${x}</mi>'.replace(/\$\{x\}/g, variableName);
    }
    var t = '<msub><mi>${x}</mi><mn>${i}</mn></msub>';
    return t.replace(/\$\{x\}/g, variableName.slice(0, i)).replace(/\$\{i\}/g, variableName.slice(i + 1));
  }

Utils.initialize(".editable-on-click", function (element) {
  element.innerHTML = '<button type="button"></button><input type="text" pattern="[a-z](?:_\d)?" autocapitalize="off" autocomplete="off" spellcheck="false" enterkeyhint="done" hidden />';
  var button = element.querySelector("button");
  var input = element.querySelector("input");
  input.value = element.getAttribute('data-value');
  button.innerHTML = '<math>' + makeContent(element.getAttribute('data-value')) + '</math>';
  // Firefox will not insert a new character into the <input> if to switch during "keypress"
  element.addEventListener("keydown", function (event) {
    if (!event.defaultPrevented && !event.ctrlKey && !event.shiftKey && !event.metaKey && !event.altKey) {
      var charCode = String.fromCharCode(event.keyCode).toLowerCase().charCodeAt(0);
      if (charCode >= "a".charCodeAt(0) && charCode <= "z".charCodeAt(0)) {
        if (!button.hidden) {
          button.click();
        }
      }
    }
  }, false);
  function updateValue() {
    var value = input.value.trim();
    element.setAttribute("data-value", value);
    button.innerHTML = '<math>' + makeContent(value) + '</math>';
    element.dispatchEvent(new Event('change-value'));
  }
  element.addEventListener("click", function (event) {
    if (!event.defaultPrevented) {
      event.preventDefault();
      button.hidden = true;
      input.hidden = false;
      input.focus();
      input.select();
      input.addEventListener("blur", function (event) {
        var value = input.value.trim();
        if (element.getAttribute("data-value") !== value && value !== "") {
          updateValue();
        }
        button.hidden = false;
        input.hidden = true;
      }, false);
      input.addEventListener("keydown", function (event) {
        var DOM_VK_RETURN = 13;
        var DOM_VK_ESCAPE = 27;
        if (event.keyCode === DOM_VK_ESCAPE) {
          updateInputValue(input, element.getAttribute("data-value"));
          event.preventDefault();
          button.hidden = false;
          button.focus();
          input.hidden = true;
        }
        if (event.keyCode === DOM_VK_RETURN) {
          if (input.value.trim() === "") {
            updateInputValue(input, element.getAttribute("data-value"));
          }
          event.preventDefault();
          updateValue();
          button.hidden = false;
          button.focus();
          input.hidden = true;
        }
      }, false);
      input.addEventListener("input", function (event) {
        input.style.width = ch((input.value.length + 2) + "ch");
      }, false);
    }
  }, false);
});

}());

/*global document, console, window*/

"use strict";

/* Spatial Navigation Polyfill
 *
 * It follows W3C official specification
 * https://drafts.csswg.org/css-nav-1/
 *
 * Copyright (c) 2018-2019 LG Electronics Inc.
 * https://github.com/WICG/spatial-navigation/polyfill
 *
 * Licensed under the MIT license (MIT)
 */
(function () {
  // The polyfill must not be executed, if it's already enabled via browser engine or browser extensions.
  if ('navigate' in window) {
    return;
  }

  var ARROW_KEY_CODE = {
    37: 'left',
    38: 'up',
    39: 'right',
    40: 'down'
  };
  var TAB_KEY_CODE = 9;
  var mapOfBoundRect = null;
  var startingPoint = null; // Saves spatial navigation starting point

  var savedSearchOrigin = {
    element: null,
    rect: null
  }; // Saves previous search origin

  var searchOriginRect = null; // Rect of current search origin

  /**
   * Initiate the spatial navigation features of the polyfill.
   * @function initiateSpatialNavigation
   */

  function initiateSpatialNavigation() {
    /*
     * Bind the standards APIs to be exposed to the window object for authors
     */
    window.navigate = navigate;
    window.Element.prototype.spatialNavigationSearch = spatialNavigationSearch;
    window.Element.prototype.focusableAreas = focusableAreas;
    window.Element.prototype.getSpatialNavigationContainer = getSpatialNavigationContainer;
    /*
     * CSS.registerProperty() from the Properties and Values API
     * Reference: https://drafts.css-houdini.org/css-properties-values-api/#the-registerproperty-function
     */

    if (window.CSS && CSS.registerProperty && false) { // SyntaxError: The given initial value does not parse for the given syntax. in  Mobile Safari 13.1
      if (window.getComputedStyle(document.documentElement).getPropertyValue('--spatial-navigation-contain') === '') {
        CSS.registerProperty({
          name: '--spatial-navigation-contain',
          syntax: 'auto | contain',
          inherits: false,
          initialValue: 'auto'
        });
      }

      if (window.getComputedStyle(document.documentElement).getPropertyValue('--spatial-navigation-action') === '') {
        CSS.registerProperty({
          name: '--spatial-navigation-action',
          syntax: 'auto | focus | scroll',
          inherits: false,
          initialValue: 'auto'
        });
      }

      if (window.getComputedStyle(document.documentElement).getPropertyValue('--spatial-navigation-function') === '') {
        CSS.registerProperty({
          name: '--spatial-navigation-function',
          syntax: 'normal | grid',
          inherits: false,
          initialValue: 'normal'
        });
      }
    }
  }
  /**
   * Add event handlers for the spatial navigation behavior.
   * This function defines which input methods trigger the spatial navigation behavior.
   * @function spatialNavigationHandler
   */


  function spatialNavigationHandler() {
    /*
     * keydown EventListener :
     * If arrow key pressed, get the next focusing element and send it to focusing controller
     */
    window.addEventListener('keydown', function (e) {
      var currentKeyMode = false && parent && parent.__spatialNavigation__.keyMode || window.__spatialNavigation__.keyMode;
      var eventTarget = document.activeElement;
      var dir = ARROW_KEY_CODE[e.keyCode];

      if (e.keyCode === TAB_KEY_CODE) {
        startingPoint = null;
      }

      if (!currentKeyMode || currentKeyMode === 'NONE' || currentKeyMode === 'SHIFTARROW' && !e.shiftKey || currentKeyMode === 'ARROW' && e.shiftKey || e.ctrlKey || e.metaKey || e.altKey) return;
      if (!window.getSelection().isCollapsed) return;//TODO: issue - ?
      var isEditable = eventTarget.nodeName === 'INPUT' || eventTarget.nodeName === 'TEXTAREA' || eventTarget.hasAttribute('contenteditable');
      if (!isEditable && document.activeElement.contains(window.getSelection().focusNode)) return; //TODO: issue - ?

      if (!e.defaultPrevented) {
        var focusNavigableArrowKey = {
          left: true,
          up: true,
          right: true,
          down: true
        }; // Edge case (text input, area) : Don't move focus, just navigate cursor in text area

        if (eventTarget.nodeName === 'INPUT' || eventTarget.nodeName === 'TEXTAREA' || eventTarget.hasAttribute('contenteditable')) {
          focusNavigableArrowKey = handlingEditableElement(e);
        }

        if (focusNavigableArrowKey[dir]) {
          e.preventDefault();
          mapOfBoundRect = typeof Map !== 'undefined' ? new Map() : null;
          navigate(dir);
          mapOfBoundRect = null;
          startingPoint = null;
        }
      }
    });
    /*
     * mouseup EventListener :
     * If the mouse click a point in the page, the point will be the starting point.
     * NOTE: Let UA set the spatial navigation starting point based on click
     */

    document.addEventListener('mouseup', function (e) {
      startingPoint = {
        x: e.clientX,
        y: e.clientY
      };
    });
    /*
     * focusin EventListener :
     * When the element get the focus, save it and its DOMRect for resetting the search origin
     * if it disappears.
     */

    // disable for better performance
    //window.addEventListener('focusin', function (e) {
    //  if (e.target !== window && e.target !== document) { // document in Opera 12
    //    savedSearchOrigin.element = e.target;
    //    savedSearchOrigin.rect = e.target.getBoundingClientRect();
    //  }
    //});
  }
  /**
   * Enable the author to trigger spatial navigation programmatically, as if the user had done so manually.
   * @see {@link https://drafts.csswg.org/css-nav-1/#dom-window-navigate}
   * @function navigate
   * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)
   */


  function navigate(dir) {
    // spatial navigation steps
    // 1
    var searchOrigin = findSearchOrigin();
    var eventTarget = searchOrigin;
    var elementFromPosition = null; // 2 Optional step, UA defined starting point

    if (startingPoint) {
      // if there is a starting point, set eventTarget as the element from position for getting the spatnav container
      elementFromPosition = document.elementFromPoint(startingPoint.x, startingPoint.y); // Use starting point if the starting point isn't inside the focusable element (but not container)
      // * Starting point is meaningfull when:
      // 1) starting point is inside the spatnav container
      // 2) starting point is inside the non-focusable element

      if (elementFromPosition === null) {
        elementFromPosition = document.body;
      }

      if (isFocusable(elementFromPosition) && !isContainer(elementFromPosition)) {
        startingPoint = null;
      } else if (isContainer(elementFromPosition)) {
        eventTarget = elementFromPosition;
      } else {
        eventTarget = elementFromPosition.getSpatialNavigationContainer();
      }
    } // 4


    if (eventTarget === document || eventTarget === document.documentElement) {
      eventTarget = document.body || document.documentElement;
    } // 5
    // At this point, spatialNavigationSearch can be applied.
    // If startingPoint is either a scroll container or the document,
    // find the best candidate within startingPoint


    var container = null;

    if ((isContainer(eventTarget) || eventTarget.nodeName === 'BODY') && !(eventTarget.nodeName === 'INPUT')) {
      if (eventTarget.nodeName === 'IFRAME') {
        eventTarget = eventTarget.contentDocument.documentElement;
      }

      container = eventTarget;
      var bestInsideCandidate = null; // 5-2

      if (document.activeElement === searchOrigin || document.activeElement === document.body && searchOrigin === document.documentElement) {
        if (getCSSSpatNavAction(eventTarget) === 'scroll') {
          if (scrollingController(eventTarget, dir)) return;
        } else if (getCSSSpatNavAction(eventTarget) === 'focus') {
          bestInsideCandidate = eventTarget.spatialNavigationSearch(dir, {
            container: eventTarget,
            candidates: getSpatialNavigationCandidates(eventTarget, {
              mode: 'all'
            })
          });
          if (focusingController(bestInsideCandidate, dir)) return;
        } else if (getCSSSpatNavAction(eventTarget) === 'auto') {
          bestInsideCandidate = eventTarget.spatialNavigationSearch(dir, {
            container: eventTarget
          });
          if (focusingController(bestInsideCandidate, dir) || scrollingController(eventTarget, dir)) return;
        }
      } else {
        // when the previous search origin became offscreen
        container = container.getSpatialNavigationContainer();
      }
    } // 6
    // Let container be the nearest ancestor of eventTarget


    container = eventTarget.getSpatialNavigationContainer();
    var parentContainer = container.parentElement ? container.getSpatialNavigationContainer() : null; // When the container is the viewport of a browsing context

    if (!parentContainer && window.location !== window.parent.location) {
      parentContainer = window.parent.document.documentElement;
    }

    if (getCSSSpatNavAction(container) === 'scroll') {
      if (scrollingController(container, dir)) return;
    } else if (getCSSSpatNavAction(container) === 'focus') {
      navigateChain(eventTarget, container, parentContainer, dir, 'all');
    } else if (getCSSSpatNavAction(container) === 'auto') {
      navigateChain(eventTarget, container, parentContainer, dir, 'visible');
    }
  }
  /**
   * Move the focus to the best candidate or do nothing.
   * @function focusingController
   * @param bestCandidate {Node} - The best candidate of the spatial navigation
   * @param dir {SpatialNavigationDirection}- The directional information for the spatial navigation (e.g. LRUD)
   * @returns {boolean}
   */


  function focusingController(bestCandidate, dir) {
    // 10 & 11
    // When bestCandidate is found
    if (bestCandidate) {
      // When bestCandidate is a focusable element and not a container : move focus

      /*
       * [event] navbeforefocus : Fired before spatial or sequential navigation changes the focus.
       */
      if (!createSpatNavEvents('beforefocus', bestCandidate, null, dir)) return true;
      var container = bestCandidate.getSpatialNavigationContainer();

      if (container !== window && getCSSSpatNavAction(container) === 'focus') {
        bestCandidate.focus();
      } else {
        bestCandidate.focus({
          preventScroll: true
        });
      }

      startingPoint = null;
      return true;
    } // When bestCandidate is not found within the scrollport of a container: Nothing


    return false;
  }
  /**
   * Directionally scroll the scrollable spatial navigation container if it can be manually scrolled more.
   * @function scrollingController
   * @param container {Node} - The spatial navigation container which can scroll
   * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)
   * @returns {boolean}
   */


  function scrollingController(container, dir) {
    // If there is any scrollable area among parent elements and it can be manually scrolled, scroll the document
    if (isScrollable(container, dir) && !isScrollBoundary(container, dir)) {
      moveScroll(container, dir);
      return true;
    } // If the spatnav container is document and it can be scrolled, scroll the document


    if (!container.parentElement && !isHTMLScrollBoundary(container, dir)) {
      moveScroll(container.ownerDocument.documentElement, dir);
      return true;
    }

    return false;
  }
  /**
   * Find the candidates within a spatial navigation container include delegable container.
   * This function does not search inside delegable container or focusable container.
   * In other words, this return candidates set is not included focusable elements inside delegable container or focusable container.
   *
   * @function getSpatialNavigationCandidates
   * @param container {Node} - The spatial navigation container
   * @param option {FocusableAreasOptions} - 'mode' attribute takes 'visible' or 'all' for searching the boundary of focusable elements.
   *                                          Default value is 'visible'.
   * @returns {sequence<Node>} candidate elements within the container
   */


  function getSpatialNavigationCandidates2(container, option) {
    if (option === void 0) {
      option = {
        mode: 'visible'
      };
    }

    var candidates = [];

    if (container.childElementCount > 0) {
      if (!container.parentElement) {
        container = container.getElementsByTagName('body')[0] || document.body;
      }

      for (var elem = container.firstElementChild; elem != null; elem = elem.nextElementSibling) {

        if (isDelegableContainer(elem)) {
          candidates.push(elem);
        } else if (isFocusable(elem)) {
          candidates.push(elem);

          if (!isContainer(elem) && elem.childElementCount) {
            candidates = candidates.concat(getSpatialNavigationCandidates2(elem, {
              mode: 'all'
            }));
          }
        } else if (elem.childElementCount) {
          candidates = candidates.concat(getSpatialNavigationCandidates2(elem, {
            mode: 'all'
          }));
        }
      }
    }

    return option.mode === 'all' ? candidates : candidates.filter(isVisible);
  }

  function getSpatialNavigationCandidates(container, option) {
    //console.debug('getSpatialNavigationCandidates', container, option);
    return getSpatialNavigationCandidates2(container, option);
  }

  /**
   * Find the candidates among focusable elements within a spatial navigation container from the search origin (currently focused element)
   * depending on the directional information.
   * @function getFilteredSpatialNavigationCandidates
   * @param element {Node} - The currently focused element which is defined as 'search origin' in the spec
   * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)
   * @param candidates {sequence<Node>} - The candidates for spatial navigation without the directional information
   * @param container {Node} - The spatial navigation container
   * @returns {Node} The candidates for spatial navigation considering the directional information
   */


  function getFilteredSpatialNavigationCandidates(element, dir, candidates, container) {
    var targetElement = element; // Removed below line due to a bug. (iframe body rect is sometime weird.)
    // const targetElement = (element.nodeName === 'IFRAME') ? element.contentDocument.body : element;
    // If the container is unknown, get the closest container from the element

    container = container || targetElement.getSpatialNavigationContainer(); // If the candidates is unknown, find candidates
    // 5-1

    candidates = !candidates || candidates.length <= 0 ? getSpatialNavigationCandidates(container) : candidates;
    return filteredCandidates(targetElement, candidates, dir, container);
  }
  /**
   * Find the best candidate among the candidates within the container from the search origin (currently focused element)
   * @see {@link https://drafts.csswg.org/css-nav-1/#dom-element-spatialnavigationsearch}
   * @function spatialNavigationSearch
   * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)
   * @param candidates {sequence<Node>} - The candidates for spatial navigation
   * @param container {Node} - The spatial navigation container
   * @returns {Node} The best candidate which will gain the focus
   */


  function spatialNavigationSearch(dir, args) {
    var targetElement = this;
    var internalCandidates = [];
    var externalCandidates = [];
    var insideOverlappedCandidates = getOverlappedCandidates(targetElement);
    var bestTarget; // Set default parameter value

    if (!args) args = {};
    var defaultContainer = targetElement.getSpatialNavigationContainer();
    var defaultCandidates = args.container === defaultContainer && args.candidates && args.candidates.length > 0 ? null : getSpatialNavigationCandidates(defaultContainer);
    var container = args.container || defaultContainer;

    if (args.container && defaultContainer.contains(args.container)) {
      defaultCandidates = container === defaultContainer ? defaultCandidates : defaultCandidates.concat(getSpatialNavigationCandidates(container));
    }

    var candidates = args.candidates && args.candidates.length > 0 ? args.candidates.filter(function (candidate) {
      return container.contains(candidate);
    }) : defaultCandidates.filter(function (candidate) {
      return container.contains(candidate) && container !== candidate;
    }); // Find the best candidate
    // 5
    // If startingPoint is either a scroll container or the document,
    // find the best candidate within startingPoint

    if (candidates && candidates.length > 0) {
      // Divide internal or external candidates
      candidates.forEach(function (candidate) {
        if (candidate !== targetElement) {
          (targetElement.contains(candidate) && targetElement !== candidate ? internalCandidates : externalCandidates).push(candidate);
        }
      }); // include overlapped element to the internalCandidates

      var fullyOverlapped = insideOverlappedCandidates.filter(function (candidate) {
        return !internalCandidates.includes(candidate);
      });
      var overlappedContainer = candidates.filter(function (candidate) {
        return isContainer(candidate) && isEntirelyVisible(targetElement, candidate);
      });
      var overlappedByParent = overlappedContainer.map(function (elm) {
        return elm.focusableAreas();
      }).flat().filter(function (candidate) {
        return candidate !== targetElement;
      });
      internalCandidates = internalCandidates.concat(fullyOverlapped).filter(function (candidate) {
        return container.contains(candidate);
      });
      externalCandidates = externalCandidates.concat(overlappedByParent).filter(function (candidate) {
        return container.contains(candidate);
      }); // Filter external Candidates

      if (externalCandidates.length > 0) {
        externalCandidates = getFilteredSpatialNavigationCandidates(targetElement, dir, externalCandidates, container);
      } // If there isn't search origin element but search orgin rect exist  (search origin isn't in the layout case)


      if (searchOriginRect) {
        bestTarget = selectBestCandidate(targetElement, getFilteredSpatialNavigationCandidates(targetElement, dir, internalCandidates, container), dir);
      }

      if (internalCandidates && internalCandidates.length > 0 && !(targetElement.nodeName === 'INPUT')) {
        bestTarget = selectBestCandidateFromEdge(targetElement, internalCandidates, dir);
      }

      bestTarget = bestTarget || selectBestCandidate(targetElement, externalCandidates, dir);

      if (bestTarget && isDelegableContainer(bestTarget)) {
        // if best target is delegable container, then find descendants candidate inside delegable container.
        var innerTarget = getSpatialNavigationCandidates(bestTarget, {
          mode: 'all'
        });
        var descendantsBest = innerTarget.length > 0 ? targetElement.spatialNavigationSearch(dir, {
          candidates: innerTarget,
          container: bestTarget
        }) : null;

        if (descendantsBest) {
          bestTarget = descendantsBest;
        } else if (!isFocusable(bestTarget)) {
          // if there is no target inside bestTarget and delegable container is not focusable,
          // then try to find another best target without curren best target.
          candidates.splice(candidates.indexOf(bestTarget), 1);
          bestTarget = candidates.length ? targetElement.spatialNavigationSearch(dir, {
            candidates: candidates,
            container: container
          }) : null;
        }
      }

      return bestTarget;
    }

    return null;
  }
  /**
   * Get the filtered candidate among candidates.
   * @see {@link https://drafts.csswg.org/css-nav-1/#select-the-best-candidate}
   * @function filteredCandidates
   * @param currentElm {Node} - The currently focused element which is defined as 'search origin' in the spec
   * @param candidates {sequence<Node>} - The candidates for spatial navigation
   * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)
   * @param container {Node} - The spatial navigation container
   * @returns {sequence<Node>} The filtered candidates which are not the search origin and not in the given spatial navigation direction from the search origin
   */
  // TODO: Need to fix filtering the candidates with more clean code


  function filteredCandidates(currentElm, candidates, dir, container) {
    var originalContainer = currentElm.getSpatialNavigationContainer();
    var eventTargetRect; // If D(dir) is null, let candidates be the same as visibles

    if (dir === undefined) return candidates; // Offscreen handling when originalContainer is not <HTML>

    if (originalContainer.parentElement && container !== originalContainer && !isVisible(currentElm)) {
      eventTargetRect = getBoundingClientRect(originalContainer);
    } else {
      eventTargetRect = searchOriginRect || getBoundingClientRect(currentElm);
    }
    /*
     * Else, let candidates be the subset of the elements in visibles
     * whose principal box’s geometric center is within the closed half plane
     * whose boundary goes through the geometric center of starting point and is perpendicular to D.
     */


    if ((isContainer(currentElm) || currentElm.nodeName === 'BODY') && !(currentElm.nodeName === 'INPUT')) {
      return candidates.filter(function (candidate) {
        var candidateRect = getBoundingClientRect(candidate);
        return container.contains(candidate) && (currentElm.contains(candidate) && isInside(eventTargetRect, candidateRect) && candidate !== currentElm || isOutside(candidateRect, eventTargetRect, dir));
      });
    } else {
      return candidates.filter(function (candidate) {
        var candidateRect = getBoundingClientRect(candidate);
        var candidateBody = candidate.nodeName === 'IFRAME' && candidate.contentDocument != null ? candidate.contentDocument.body : null;
        return container.contains(candidate) && candidate !== currentElm && candidateBody !== currentElm && isOutside(candidateRect, eventTargetRect, dir) && !isInside(eventTargetRect, candidateRect);
      });
    }
  }
  /**
   * Select the best candidate among given candidates.
   * @see {@link https://drafts.csswg.org/css-nav-1/#select-the-best-candidate}
   * @function selectBestCandidate
   * @param currentElm {Node} - The currently focused element which is defined as 'search origin' in the spec
   * @param candidates {sequence<Node>} - The candidates for spatial navigation
   * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)
   * @returns {Node} The best candidate which will gain the focus
   */


  function selectBestCandidate(currentElm, candidates, dir) {
    var container = currentElm.getSpatialNavigationContainer();
    var spatialNavigationFunction = getComputedStyle(container).getPropertyValue('--spatial-navigation-function');
    var currentTargetRect = searchOriginRect || getBoundingClientRect(currentElm);
    var distanceFunction;
    var alignedCandidates;

    switch (spatialNavigationFunction) {
      case 'grid':
        alignedCandidates = candidates.filter(function (elm) {
          return isAligned(currentTargetRect, getBoundingClientRect(elm), dir);
        });

        if (alignedCandidates.length > 0) {
          candidates = alignedCandidates;
        }

        distanceFunction = getAbsoluteDistance;
        break;

      default:
        distanceFunction = getDistance;
        break;
    }

    return getClosestElement(currentElm, candidates, dir, distanceFunction);
  }
  /**
   * Select the best candidate among candidates by finding the closet candidate from the edge of the currently focused element (search origin).
   * @see {@link https://drafts.csswg.org/css-nav-1/#select-the-best-candidate (Step 5)}
   * @function selectBestCandidateFromEdge
   * @param currentElm {Node} - The currently focused element which is defined as 'search origin' in the spec
   * @param candidates {sequence<Node>} - The candidates for spatial navigation
   * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)
   * @returns {Node} The best candidate which will gain the focus
   */


  function selectBestCandidateFromEdge(currentElm, candidates, dir) {
    if (startingPoint) return getClosestElement(currentElm, candidates, dir, getDistanceFromPoint);else return getClosestElement(currentElm, candidates, dir, getInnerDistance);
  }
  /**
   * Select the closest candidate from the currently focused element (search origin) among candidates by using the distance function.
   * @function getClosestElement
   * @param currentElm {Node} - The currently focused element which is defined as 'search origin' in the spec
   * @param candidates {sequence<Node>} - The candidates for spatial navigation
   * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)
   * @param distanceFunction {function} - The distance function which measures the distance from the search origin to each candidate
   * @returns {Node} The candidate which is the closest one from the search origin
   */


  function getClosestElement(currentElm, candidates, dir, distanceFunction) {
    var eventTargetRect = null;

    if (window.location !== window.parent.location && (currentElm.nodeName === 'BODY' || currentElm.nodeName === 'HTML')) {
      // If the eventTarget is iframe, then get rect of it based on its containing document
      // Set the iframe's position as (0,0) because the rects of elements inside the iframe don't know the real iframe's position.
      eventTargetRect = window.frameElement.getBoundingClientRect();
      eventTargetRect.x = 0;
      eventTargetRect.y = 0;
    } else {
      eventTargetRect = searchOriginRect || currentElm.getBoundingClientRect();
    }

    var minDistance = Number.POSITIVE_INFINITY;
    var minDistanceElements = [];

    if (candidates) {
      for (var i = 0; i < candidates.length; i++) {
        var distance = distanceFunction(eventTargetRect, getBoundingClientRect(candidates[i]), dir); // If the same distance, the candidate will be selected in the DOM order

        if (distance < minDistance) {
          minDistance = distance;
          minDistanceElements = [candidates[i]];
        } else if (distance === minDistance) {
          minDistanceElements.push(candidates[i]);
        }
      }
    }

    if (minDistanceElements.length === 0) return null;
    return minDistanceElements.length > 1 && distanceFunction === getAbsoluteDistance ? getClosestElement(currentElm, minDistanceElements, dir, getEuclideanDistance) : minDistanceElements[0];
  }
  /**
   * Get container of an element.
   * @see {@link https://drafts.csswg.org/css-nav-1/#dom-element-getspatialnavigationcontainer}
   * @module Element
   * @function getSpatialNavigationContainer
   * @returns {Node} The spatial navigation container
   */


  function getSpatialNavigationContainer() {
    var container = this;

    do {
      if (!container.parentElement) {
        if (window.location !== window.parent.location) {
          container = window.parent.document.documentElement;
        } else {
          container = window.document.documentElement;
        }

        break;
      } else {
        container = container.parentElement;
      }
    } while (!isContainer(container));

    return container;
  }
  /**
   * Get nearest scroll container of an element.
   * @function getScrollContainer
   * @param Element
   * @returns {Node} The spatial navigation container
   */


  function getScrollContainer(element) {
    var scrollContainer = element;

    do {
      if (!scrollContainer.parentElement) {
        if (window.location !== window.parent.location) {
          scrollContainer = window.parent.document.documentElement;
        } else {
          scrollContainer = window.document.documentElement;
        }

        break;
      } else {
        scrollContainer = scrollContainer.parentElement;
      }
    } while (!isScrollContainer(scrollContainer) || !isVisible(scrollContainer));

    if (scrollContainer === document || scrollContainer === document.documentElement) {
      scrollContainer = window;
    }

    return scrollContainer;
  }
  /**
   * Find focusable elements within the spatial navigation container.
   * @see {@link https://drafts.csswg.org/css-nav-1/#dom-element-focusableareas}
   * @function focusableAreas
   * @param option {FocusableAreasOptions} - 'mode' attribute takes 'visible' or 'all' for searching the boundary of focusable elements.
   *                                          Default value is 'visible'.
   * @returns {sequence<Node>} All focusable elements or only visible focusable elements within the container
   */


  function focusableAreas(option) {
    if (option === void 0) {
      option = {
        mode: 'visible'
      };
    }
    option.mode = 'all';//!!!TODO: ?

    var container = this.parentElement ? this : document.body;
    var focusables = Array.prototype.filter.call(container.getElementsByTagName('*'), isFocusable);
    return option.mode === 'all' ? focusables : focusables.filter(isVisible);
  }
  /**
   * Create the NavigationEvent: navbeforefocus, navnotarget
   * @see {@link https://drafts.csswg.org/css-nav-1/#events-navigationevent}
   * @function createSpatNavEvents
   * @param option {string} - Type of the navigation event (beforefocus, notarget)
   * @param element {Node} - The target element of the event
   * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)
   */


  function createSpatNavEvents(eventType, containerElement, currentElement, direction) {
    if (['beforefocus', 'notarget'].includes(eventType)) {
      var data = {
        causedTarget: currentElement,
        dir: direction
      };
      var triggeredEvent = new CustomEvent('nav' + eventType, {
        bubbles: true,
        cancelable: true,
        detail: data
      });
      return containerElement.dispatchEvent(triggeredEvent);
    }
  }
  /**
   * Get the value of the CSS custom property of the element
   * @function readCssVar
   * @param element {Node}
   * @param varName {string} - The name of the css custom property without '--'
   * @returns {string} The value of the css custom property
   */


  function readCssVar(element, varName) {
    return element.style.getPropertyValue("--" + varName).trim();
  }
  /**
   * Decide whether or not the 'contain' value is given to 'spatial-navigation-contain' css property of an element
   * @function isCSSSpatNavContain
   * @param element {Node}
   * @returns {boolean}
   */


  function isCSSSpatNavContain(element) {
    return readCssVar(element, 'spatial-navigation-contain') === 'contain';
  }
  /**
   * Return the value of 'spatial-navigation-action' css property of an element
   * @function getCSSSpatNavAction
   * @param element {Node} - would be the spatial navigation container
   * @returns {string} auto | focus | scroll
   */


  function getCSSSpatNavAction(element) {
    return readCssVar(element, 'spatial-navigation-action') || 'auto';
  }
  /**
   * Only move the focus with spatial navigation. Manually scrolling isn't available.
   * @function navigateChain
   * @param eventTarget {Node} - currently focused element
   * @param container {SpatialNavigationContainer} - container
   * @param parentContainer {SpatialNavigationContainer} - parent container
   * @param option - visible || all
   * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)
   */


  function navigateChain(eventTarget, container, parentContainer, dir, option) {
    var currentOption = {
      candidates: getSpatialNavigationCandidates(container, {
        mode: option
      }),
      container: container
    };

  if (parentContainer) {
    while (parentContainer) {
      if (focusingController(eventTarget.spatialNavigationSearch(dir, currentOption), dir)) {
        return;
      } else {
        if (option === 'visible' && scrollingController(container, dir)) return;else {
          if (!createSpatNavEvents('notarget', container, eventTarget, dir)) return; // find the container

          if (container === document || container === document.documentElement) {
            if (window.location !== window.parent.location) {
              // The page is in an iframe. eventTarget needs to be reset because the position of the element in the iframe
              eventTarget = window.frameElement;
              container = eventTarget.ownerDocument.documentElement;
            }
          } else {
            container = parentContainer;
          }

          currentOption = {
            candidates: getSpatialNavigationCandidates(container, {
              mode: option
            }),
            container: container
          };
          var nextContainer = container.getSpatialNavigationContainer();

          if (nextContainer !== container) {
            parentContainer = nextContainer;
          } else {
            parentContainer = null;
          }
        }
      }
    }

    currentOption = {
      candidates: getSpatialNavigationCandidates(container, {
        mode: option
      }),
      container: container
    }; // Behavior after 'navnotarget' - Getting out from the current spatnav container
  }

    if (!parentContainer && container && focusingController(eventTarget.spatialNavigationSearch(dir, currentOption), dir)) return;
    if (!createSpatNavEvents('notarget', currentOption.container, eventTarget, dir)) return;

    if (getCSSSpatNavAction(container) === 'auto' && option === 'visible') {
      if (scrollingController(container, dir)) return;
    }
  }
  /**
   * Find search origin
   * @see {@link https://drafts.csswg.org/css-nav-1/#nav}
   * @function findSearchOrigin
   * @returns {Node} The search origin for the spatial navigation
   */


  function findSearchOrigin() {
    var searchOrigin = document.activeElement;

    if (!searchOrigin || searchOrigin === document.body && !document.querySelector(':focus')) {
      // When the previous search origin lost its focus by blur: (1) disable attribute (2) visibility: hidden
      if (savedSearchOrigin.element && searchOrigin !== savedSearchOrigin.element) {
        var elementStyle = window.getComputedStyle(savedSearchOrigin.element, null);
        var invisibleStyle = ['hidden', 'collapse'];

        if (savedSearchOrigin.element.disabled || invisibleStyle.includes(elementStyle.getPropertyValue('visibility'))) {
          searchOrigin = savedSearchOrigin.element;
          return searchOrigin;
        }
      }

      searchOrigin = document.documentElement;
    } // When the previous search origin lost its focus by blur: (1) display:none () element size turned into zero


    if (savedSearchOrigin.element && (getBoundingClientRect(savedSearchOrigin.element).height === 0 || getBoundingClientRect(savedSearchOrigin.element).width === 0)) {
      searchOriginRect = savedSearchOrigin.rect;
    }

    if (!isVisibleInScroller(searchOrigin)) {
      var scroller = getScrollContainer(searchOrigin);
      if (scroller && (scroller === window || getCSSSpatNavAction(scroller) === 'auto')) return scroller;
    }

    return searchOrigin;
  }
  /**
   * Move the scroll of an element depending on the given spatial navigation directrion
   * (Assume that User Agent defined distance is '40px')
   * @see {@link https://drafts.csswg.org/css-nav-1/#directionally-scroll-an-element}
   * @function moveScroll
   * @param element {Node} - The scrollable element
   * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)
   * @param offset {Number} - The explicit amount of offset for scrolling. Default value is 0.
   */


  function moveScroll(element, dir, offset) {
    if (offset === void 0) {
      offset = 0;
    }

    if (element) {
      switch (dir) {
        case 'left':
          element.scrollLeft -= 40 + offset;
          break;

        case 'right':
          element.scrollLeft += 40 + offset;
          break;

        case 'up':
          element.scrollTop -= 40 + offset;
          break;

        case 'down':
          element.scrollTop += 40 + offset;
          break;
      }
    }
  }
  /**
   * Decide whether an element is container or not.
   * @function isContainer
   * @param element {Node} element
   * @returns {boolean}
   */


  function isContainer(element) {
    return !element.parentElement || element.nodeName === 'IFRAME' || isScrollContainer(element) || isCSSSpatNavContain(element);
  }
  /**
   * Decide whether an element is delegable container or not.
   * NOTE: THIS IS NON-NORMATIVE API. 
   * @function isDelegableContainer
   * @param element {Node} element
   * @returns {boolean}
   */


  function isDelegableContainer(element) {
    return readCssVar(element, 'spatial-navigation-contain') === 'delegable';
  }
  /**
   * Decide whether an element is a scrollable container or not.
   * @see {@link https://drafts.csswg.org/css-overflow-3/#scroll-container}
   * @function isScrollContainer
   * @param element {Node}
   * @returns {boolean}
   */


  function isScrollContainer(element) {
    var elementStyle = window.getComputedStyle(element, null);
    var overflowX = elementStyle.getPropertyValue('overflow-x');
    var overflowY = elementStyle.getPropertyValue('overflow-y');
    return overflowX !== 'visible' && overflowX !== 'clip' && isOverflow(element, 'left') || overflowY !== 'visible' && overflowY !== 'clip' && isOverflow(element, 'down') ? true : false;
  }
  /**
   * Decide whether this element is scrollable or not.
   * NOTE: If the value of 'overflow' is given to either 'visible', 'clip', or 'hidden', the element isn't scrollable.
   *       If the value is 'hidden', the element can be only programmically scrollable. (https://drafts.csswg.org/css-overflow-3/#valdef-overflow-hidden)
   * @function isScrollable
   * @param element {Node}
   * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)
   * @returns {boolean}
   */


  function isScrollable(element, dir) {
    // element, dir
    if (element && typeof element === 'object') {
      if (dir && typeof dir === 'string') {
        // parameter: dir, element
        if (isOverflow(element, dir)) {
          // style property
          var elementStyle = window.getComputedStyle(element, null);
          var overflowX = elementStyle.getPropertyValue('overflow-x');
          var overflowY = elementStyle.getPropertyValue('overflow-y');

          switch (dir) {
            case 'left':
            /* falls through */

            case 'right':
              return overflowX !== 'visible' && overflowX !== 'clip' && overflowX !== 'hidden';

            case 'up':
            /* falls through */

            case 'down':
              return overflowY !== 'visible' && overflowY !== 'clip' && overflowY !== 'hidden';
          }
        }

        return false;
      } else {
        // parameter: element
        return element.nodeName === 'HTML' || element.nodeName === 'BODY' || isScrollContainer(element) && isOverflow(element);
      }
    }
  }
  /**
   * Decide whether an element is overflow or not.
   * @function isOverflow
   * @param element {Node}
   * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)
   * @returns {boolean}
   */


  function isOverflow(element, dir) {
    if (element && typeof element === 'object') {
      if (dir && typeof dir === 'string') {
        // parameter: element, dir
        switch (dir) {
          case 'left':
          /* falls through */

          case 'right':
            return element.scrollWidth > element.clientWidth;

          case 'up':
          /* falls through */

          case 'down':
            return element.scrollHeight > element.clientHeight;
        }
      } else {
        // parameter: element
        return element.scrollWidth > element.clientWidth || element.scrollHeight > element.clientHeight;
      }

      return false;
    }
  }
  /**
   * Decide whether the scrollbar of the browsing context reaches to the end or not.
   * @function isHTMLScrollBoundary
   * @param element {Node} - The top browsing context
   * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)
   * @returns {boolean}
   */


  function isHTMLScrollBoundary(element, dir) {
    var result = false;

    switch (dir) {
      case 'left':
        result = element.scrollLeft === 0;
        break;

      case 'right':
        result = element.scrollWidth - element.scrollLeft - element.clientWidth === 0;
        break;

      case 'up':
        result = element.scrollTop === 0;
        break;

      case 'down':
        result = element.scrollHeight - element.scrollTop - element.clientHeight === 0;
        break;
    }

    return result;
  }
  /**
   * Decide whether the scrollbar of an element reaches to the end or not.
   * @function isScrollBoundary
   * @param element {Node}
   * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)
   * @returns {boolean}
   */


  function isScrollBoundary(element, dir) {
    if (isScrollable(element, dir)) {
      var winScrollY = element.scrollTop;
      var winScrollX = element.scrollLeft;
      var height = element.scrollHeight - element.clientHeight;
      var width = element.scrollWidth - element.clientWidth;

      switch (dir) {
        case 'left':
          return winScrollX === 0;

        case 'right':
          return Math.abs(winScrollX - width) <= 1;

        case 'up':
          return winScrollY === 0;

        case 'down':
          return Math.abs(winScrollY - height) <= 1;
      }
    }

    return false;
  }
  /**
   * Decide whether an element is inside the scorller viewport or not
   *
   * @function isVisibleInScroller
   * @param element {Node}
   * @returns {boolean}
   */


  function isVisibleInScroller(element) {
    var elementRect = element.getBoundingClientRect();
    var nearestScroller = getScrollContainer(element);
    var scrollerRect = null;

    if (nearestScroller !== window) {
      scrollerRect = getBoundingClientRect(nearestScroller);
    } else {
      scrollerRect = new DOMRect(0, 0, window.innerWidth, window.innerHeight);
    }

    if (isInside(scrollerRect, elementRect, 'left') && isInside(scrollerRect, elementRect, 'down')) return true;else return false;
  }
  /**
   * Decide whether an element is focusable for spatial navigation.
   * 1. If element is the browsing context (document, iframe), then it's focusable,
   * 2. If the element is scrollable container (regardless of scrollable axis), then it's focusable,
   * 3. The value of tabIndex >= 0, then it's focusable,
   * 4. If the element is disabled, it isn't focusable,
   * 5. If the element is expressly inert, it isn't focusable,
   * 6. Whether the element is being rendered or not.
   *
   * @function isFocusable
   * @param element {Node}
   * @returns {boolean}
   *
   * @see {@link https://html.spec.whatwg.org/multipage/interaction.html#focusable-area}
   */


  function isFocusable(element) {
    if (element.tagName.toLowerCase() === 'iframe') {
      return false;
    }
    if (element.tabIndex < 0 || isAtagWithoutHref(element) || isActuallyDisabled(element) || isExpresslyInert(element) || !isBeingRendered(element)) return false;else if (!element.parentElement || isScrollable(element) && isOverflow(element) || element.tabIndex >= 0) return true;
  }
  /**
   * Decide whether an element is a tag without href attribute or not.
   *
   * @function isAtagWithoutHref
   * @param element {Node}
   * @returns {boolean}
   */


  function isAtagWithoutHref(element) {
    return element.tagName === 'A' && element.getAttribute('href') === null && element.getAttribute('tabIndex') === null;
  }
  /**
   * Decide whether an element is actually disabled or not.
   *
   * @function isActuallyDisabled
   * @param element {Node}
   * @returns {boolean}
   *
   * @see {@link https://html.spec.whatwg.org/multipage/semantics-other.html#concept-element-disabled}
   */


  function isActuallyDisabled(element) {
    if (['BUTTON', 'INPUT', 'SELECT', 'TEXTAREA', 'OPTGROUP', 'OPTION', 'FIELDSET'].includes(element.tagName)) return element.disabled;else return false;
  }
  /**
   * Decide whether the element is expressly inert or not.
   * @see {@link https://html.spec.whatwg.org/multipage/interaction.html#expressly-inert}
   * @function isExpresslyInert
   * @param element {Node}
   * @returns {boolean}
   */


  function isExpresslyInert(element) {
    return element.inert && !element.ownerDocument.documentElement.inert;
  }
  /**
   * Decide whether the element is being rendered or not.
   * 1. If an element has the style as "visibility: hidden | collapse" or "display: none", it is not being rendered.
   * 2. If an element has the style as "opacity: 0", it is not being rendered.(that is, invisible).
   * 3. If width and height of an element are explicitly set to 0, it is not being rendered.
   * 4. If a parent element is hidden, an element itself is not being rendered.
   * (CSS visibility property and display property are inherited.)
   * @see {@link https://html.spec.whatwg.org/multipage/rendering.html#being-rendered}
   * @function isBeingRendered
   * @param element {Node}
   * @returns {boolean}
   */


  function isBeingRendered(element) {
    if (!isVisibleStyleProperty(element.parentElement)) return false;
    if (!isVisibleStyleProperty(element) || element.style.opacity === '0' || window.getComputedStyle(element).height === '0px' || window.getComputedStyle(element).width === '0px') return false;
    return true;
  }
  /**
   * Decide whether this element is partially or completely visible to user agent.
   * @function isVisible
   * @param element {Node}
   * @returns {boolean}
   */


  function isVisible(element) {
    return !element.parentElement || isVisibleStyleProperty(element) && hitTest(element);
  }
  /**
   * Decide whether this element is completely visible in this viewport for the arrow direction.
   * @function isEntirelyVisible
   * @param element {Node}
   * @returns {boolean}
   */


  function isEntirelyVisible(element, container) {
    var rect = getBoundingClientRect(element);
    var containerElm = container || element.getSpatialNavigationContainer();
    var containerRect = getBoundingClientRect(containerElm); // FIXME: when element is bigger than container?

    var entirelyVisible = !(rect.left < containerRect.left || rect.right > containerRect.right || rect.top < containerRect.top || rect.bottom > containerRect.bottom);
    return entirelyVisible;
  }
  /**
   * Decide the style property of this element is specified whether it's visible or not.
   * @function isVisibleStyleProperty
   * @param element {CSSStyleDeclaration}
   * @returns {boolean}
   */


  function isVisibleStyleProperty(element) {
    var elementStyle = window.getComputedStyle(element, null);
    var thisVisibility = elementStyle.getPropertyValue('visibility');
    var thisDisplay = elementStyle.getPropertyValue('display');
    var invisibleStyle = ['hidden', 'collapse'];
    return thisDisplay !== 'none' && !invisibleStyle.includes(thisVisibility);
  }
  /**
   * Decide whether this element is entirely or partially visible within the viewport.
   * @function hitTest
   * @param element {Node}
   * @returns {boolean}
   */


  function hitTest(element) {
    var elementRect = getBoundingClientRect(element);
    if (element.nodeName !== 'IFRAME' && (elementRect.top < 0 || elementRect.left < 0 || elementRect.top > element.ownerDocument.documentElement.clientHeight || elementRect.left > element.ownerDocument.documentElement.clientWidth)) return false;
    var offsetX = Math.floor(element.offsetWidth) / 10;
    var offsetY = Math.floor(element.offsetHeight) / 10;
    offsetX = isNaN(offsetX) ? 1 : offsetX;
    offsetY = isNaN(offsetY) ? 1 : offsetY;
    var hitTestPoint = {
      // For performance, just using the three point(middle, leftTop, rightBottom) of the element for hit testing
      middle: [(elementRect.left + elementRect.right) / 2, (elementRect.top + elementRect.bottom) / 2],
      leftTop: [elementRect.left + offsetX, elementRect.top + offsetY],
      rightBottom: [elementRect.right - offsetX, elementRect.bottom - offsetY]
    };

    for (var point in hitTestPoint) {
      var _element$ownerDocumen;

      var elemFromPoint = (_element$ownerDocumen = element.ownerDocument).elementFromPoint.apply(_element$ownerDocumen, hitTestPoint[point]);

      if (element === elemFromPoint || element.contains(elemFromPoint)) {
        return true;
      }
    }

    return false;
  }
  /**
   * Decide whether a child element is entirely or partially Included within container visually.
   * @function isInside
   * @param containerRect {DOMRect}
   * @param childRect {DOMRect}
   * @returns {boolean}
   */


  function isInside(containerRect, childRect) {
    var rightEdgeCheck = containerRect.left < childRect.right && containerRect.right >= childRect.right;
    var leftEdgeCheck = containerRect.left <= childRect.left && containerRect.right > childRect.left;
    var topEdgeCheck = containerRect.top <= childRect.top && containerRect.bottom > childRect.top;
    var bottomEdgeCheck = containerRect.top < childRect.bottom && containerRect.bottom >= childRect.bottom;
    return (rightEdgeCheck || leftEdgeCheck) && (topEdgeCheck || bottomEdgeCheck);
  }
  /**
   * Decide whether this element is entirely or partially visible within the viewport.
   * Note: rect1 is outside of rect2 for the dir
   * @function isOutside
   * @param rect1 {DOMRect}
   * @param rect2 {DOMRect}
   * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)
   * @returns {boolean}
   */


  function isOutside(rect1, rect2, dir) {
    switch (dir) {
      case 'left':
        return isRightSide(rect2, rect1);

      case 'right':
        return isRightSide(rect1, rect2);

      case 'up':
        return isBelow(rect2, rect1);

      case 'down':
        return isBelow(rect1, rect2);

      default:
        return false;
    }
  }
  /* rect1 is right of rect2 */


  function isRightSide(rect1, rect2) {
    return rect1.left >= rect2.right || rect1.left >= rect2.left && rect1.right > rect2.right && rect1.bottom > rect2.top && rect1.top < rect2.bottom;
  }
  /* rect1 is below of rect2 */


  function isBelow(rect1, rect2) {
    return rect1.top >= rect2.bottom || rect1.top >= rect2.top && rect1.bottom > rect2.bottom && rect1.left < rect2.right && rect1.right > rect2.left;
  }
  /* rect1 is completely aligned or partially aligned for the direction */


  function isAligned(rect1, rect2, dir) {
    switch (dir) {
      case 'left':
      /* falls through */

      case 'right':
        return rect1.bottom > rect2.top && rect1.top < rect2.bottom;

      case 'up':
      /* falls through */

      case 'down':
        return rect1.right > rect2.left && rect1.left < rect2.right;

      default:
        return false;
    }
  }
  /**
   * Get distance between the search origin and a candidate element along the direction when candidate element is inside the search origin.
   * @see {@link https://drafts.csswg.org/css-nav-1/#find-the-shortest-distance}
   * @function getDistanceFromPoint
   * @param point {Point} - The search origin
   * @param element {DOMRect} - A candidate element
   * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)
   * @returns {Number} The euclidian distance between the spatial navigation container and an element inside it
   */


  function getDistanceFromPoint(point, element, dir) {
    point = startingPoint; // Get exit point, entry point -> {x: '', y: ''};

    var points = getEntryAndExitPoints(dir, point, element); // Find the points P1 inside the border box of starting point and P2 inside the border box of candidate
    // that minimize the distance between these two points

    var P1 = Math.abs(points.entryPoint.x - points.exitPoint.x);
    var P2 = Math.abs(points.entryPoint.y - points.exitPoint.y); // The result is euclidian distance between P1 and P2.

    return Math.sqrt(Math.pow(P1, 2) + Math.pow(P2, 2));
  }
  /**
   * Get distance between the search origin and a candidate element along the direction when candidate element is inside the search origin.
   * @see {@link https://drafts.csswg.org/css-nav-1/#find-the-shortest-distance}
   * @function getInnerDistance
   * @param rect1 {DOMRect} - The search origin
   * @param rect2 {DOMRect} - A candidate element
   * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)
   * @returns {Number} The euclidean distance between the spatial navigation container and an element inside it
   */


  function getInnerDistance(rect1, rect2, dir) {
    var baseEdgeForEachDirection = {
      left: 'right',
      right: 'left',
      up: 'bottom',
      down: 'top'
    };
    var baseEdge = baseEdgeForEachDirection[dir];
    return Math.abs(rect1[baseEdge] - rect2[baseEdge]);
  }
  /**
   * Get the distance between the search origin and a candidate element considering the direction.
   * @see {@link https://drafts.csswg.org/css-nav-1/#calculating-the-distance}
   * @function getDistance
   * @param searchOrigin {DOMRect | Point} - The search origin
   * @param candidateRect {DOMRect} - A candidate element
   * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)
   * @returns {Number} The distance scoring between two elements
   */


  function getDistance(searchOrigin, candidateRect, dir) {
    var kOrthogonalWeightForLeftRight = 30;
    var kOrthogonalWeightForUpDown = 2;
    var orthogonalBias = 0;
    var alignBias = 0;
    var alignWeight = 5.0; // Get exit point, entry point -> {x: '', y: ''};

    var points = getEntryAndExitPoints(dir, searchOrigin, candidateRect); // Find the points P1 inside the border box of starting point and P2 inside the border box of candidate
    // that minimize the distance between these two points

    var P1 = Math.abs(points.entryPoint.x - points.exitPoint.x);
    var P2 = Math.abs(points.entryPoint.y - points.exitPoint.y); // A: The euclidean distance between P1 and P2.

    var A = Math.sqrt(Math.pow(P1, 2) + Math.pow(P2, 2));
    var B, C; // B: The absolute distance in the direction which is orthogonal to dir between P1 and P2, or 0 if dir is null.
    // C: The intersection edges between a candidate and the starting point.
    // D: The square root of the area of intersection between the border boxes of candidate and starting point

    var intersectionRect = getIntersectionRect(searchOrigin, candidateRect);
    var D = intersectionRect.area;

    switch (dir) {
      case 'left':
      /* falls through */

      case 'right':
        // If two elements are aligned, add align bias
        // else, add orthogonal bias
        if (isAligned(searchOrigin, candidateRect, dir)) alignBias = Math.min(intersectionRect.height / searchOrigin.height, 1);else orthogonalBias = searchOrigin.height / 2;
        B = (P2 + orthogonalBias) * kOrthogonalWeightForLeftRight;
        C = alignWeight * alignBias;
        break;

      case 'up':
      /* falls through */

      case 'down':
        // If two elements are aligned, add align bias
        // else, add orthogonal bias
        if (isAligned(searchOrigin, candidateRect, dir)) alignBias = Math.min(intersectionRect.width / searchOrigin.width, 1);else orthogonalBias = searchOrigin.width / 2;
        B = (P1 + orthogonalBias) * kOrthogonalWeightForUpDown;
        C = alignWeight * alignBias;
        break;

      default:
        B = 0;
        C = 0;
        break;
    }

    return A + B - C - D;
  }
  /**
   * Get the euclidean distance between the search origin and a candidate element considering the direction.
   * @function getEuclideanDistance
   * @param rect1 {DOMRect} - The search origin
   * @param rect2 {DOMRect} - A candidate element
   * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)
   * @returns {Number} The distance scoring between two elements
   */


  function getEuclideanDistance(rect1, rect2, dir) {
    // Get exit point, entry point
    var points = getEntryAndExitPoints(dir, rect1, rect2); // Find the points P1 inside the border box of starting point and P2 inside the border box of candidate
    // that minimize the distance between these two points

    var P1 = Math.abs(points.entryPoint.x - points.exitPoint.x);
    var P2 = Math.abs(points.entryPoint.y - points.exitPoint.y); // Return the euclidean distance between P1 and P2.

    return Math.sqrt(Math.pow(P1, 2) + Math.pow(P2, 2));
  }
  /**
   * Get the absolute distance between the search origin and a candidate element considering the direction.
   * @function getAbsoluteDistance
   * @param rect1 {DOMRect} - The search origin
   * @param rect2 {DOMRect} - A candidate element
   * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD)
   * @returns {Number} The distance scoring between two elements
   */


  function getAbsoluteDistance(rect1, rect2, dir) {
    // Get exit point, entry point
    var points = getEntryAndExitPoints(dir, rect1, rect2); // Return the absolute distance in the dir direction between P1 and P.

    return dir === 'left' || dir === 'right' ? Math.abs(points.entryPoint.x - points.exitPoint.x) : Math.abs(points.entryPoint.y - points.exitPoint.y);
  }
  /**
   * Get entry point and exit point of two elements considering the direction.
   * @function getEntryAndExitPoints
   * @param dir {SpatialNavigationDirection} - The directional information for the spatial navigation (e.g. LRUD). Default value for dir is 'down'.
   * @param searchOrigin {DOMRect | Point} - The search origin which contains the exit point
   * @param candidateRect {DOMRect} - One of candidates which contains the entry point
   * @returns {Points} The exit point from the search origin and the entry point from a candidate
   */


  function getEntryAndExitPoints(dir, searchOrigin, candidateRect) {
    if (dir === void 0) {
      dir = 'down';
    }

    /**
     * User type definition for Point
     * @typeof {Object} Points
     * @property {Point} Points.entryPoint
     * @property {Point} Points.exitPoint
     */
    var points = {
      entryPoint: {
        x: 0,
        y: 0
      },
      exitPoint: {
        x: 0,
        y: 0
      }
    };

    if (startingPoint) {
      points.exitPoint = searchOrigin;

      switch (dir) {
        case 'left':
          points.entryPoint.x = candidateRect.right;
          break;

        case 'up':
          points.entryPoint.y = candidateRect.bottom;
          break;

        case 'right':
          points.entryPoint.x = candidateRect.left;
          break;

        case 'down':
          points.entryPoint.y = candidateRect.top;
          break;
      } // Set orthogonal direction


      switch (dir) {
        case 'left':
        case 'right':
          if (startingPoint.y <= candidateRect.top) {
            points.entryPoint.y = candidateRect.top;
          } else if (startingPoint.y < candidateRect.bottom) {
            points.entryPoint.y = startingPoint.y;
          } else {
            points.entryPoint.y = candidateRect.bottom;
          }

          break;

        case 'up':
        case 'down':
          if (startingPoint.x <= candidateRect.left) {
            points.entryPoint.x = candidateRect.left;
          } else if (startingPoint.x < candidateRect.right) {
            points.entryPoint.x = startingPoint.x;
          } else {
            points.entryPoint.x = candidateRect.right;
          }

          break;
      }
    } else {
      // Set direction
      switch (dir) {
        case 'left':
          points.exitPoint.x = searchOrigin.left;
          points.entryPoint.x = candidateRect.right < searchOrigin.left ? candidateRect.right : searchOrigin.left;
          break;

        case 'up':
          points.exitPoint.y = searchOrigin.top;
          points.entryPoint.y = candidateRect.bottom < searchOrigin.top ? candidateRect.bottom : searchOrigin.top;
          break;

        case 'right':
          points.exitPoint.x = searchOrigin.right;
          points.entryPoint.x = candidateRect.left > searchOrigin.right ? candidateRect.left : searchOrigin.right;
          break;

        case 'down':
          points.exitPoint.y = searchOrigin.bottom;
          points.entryPoint.y = candidateRect.top > searchOrigin.bottom ? candidateRect.top : searchOrigin.bottom;
          break;
      } // Set orthogonal direction


      switch (dir) {
        case 'left':
        case 'right':
          if (isBelow(searchOrigin, candidateRect)) {
            points.exitPoint.y = searchOrigin.top;
            points.entryPoint.y = candidateRect.bottom < searchOrigin.top ? candidateRect.bottom : searchOrigin.top;
          } else if (isBelow(candidateRect, searchOrigin)) {
            points.exitPoint.y = searchOrigin.bottom;
            points.entryPoint.y = candidateRect.top > searchOrigin.bottom ? candidateRect.top : searchOrigin.bottom;
          } else {
            points.exitPoint.y = Math.max(searchOrigin.top, candidateRect.top);
            points.entryPoint.y = points.exitPoint.y;
          }

          break;

        case 'up':
        case 'down':
          if (isRightSide(searchOrigin, candidateRect)) {
            points.exitPoint.x = searchOrigin.left;
            points.entryPoint.x = candidateRect.right < searchOrigin.left ? candidateRect.right : searchOrigin.left;
          } else if (isRightSide(candidateRect, searchOrigin)) {
            points.exitPoint.x = searchOrigin.right;
            points.entryPoint.x = candidateRect.left > searchOrigin.right ? candidateRect.left : searchOrigin.right;
          } else {
            points.exitPoint.x = Math.max(searchOrigin.left, candidateRect.left);
            points.entryPoint.x = points.exitPoint.x;
          }

          break;
      }
    }

    return points;
  }
  /**
   * Find focusable elements within the container
   * @see {@link https://drafts.csswg.org/css-nav-1/#find-the-shortest-distance}
   * @function getIntersectionRect
   * @param rect1 {DOMRect} - The search origin which contains the exit point
   * @param rect2 {DOMRect} - One of candidates which contains the entry point
   * @returns {IntersectionArea} The intersection area between two elements.
   *
   * @typeof {Object} IntersectionArea
   * @property {Number} IntersectionArea.width
   * @property {Number} IntersectionArea.height
   */


  function getIntersectionRect(rect1, rect2) {
    var intersection_rect = {
      width: 0,
      height: 0,
      area: 0
    };
    var new_location = [Math.max(rect1.left, rect2.left), Math.max(rect1.top, rect2.top)];
    var new_max_point = [Math.min(rect1.right, rect2.right), Math.min(rect1.bottom, rect2.bottom)];
    intersection_rect.width = Math.abs(new_location[0] - new_max_point[0]);
    intersection_rect.height = Math.abs(new_location[1] - new_max_point[1]);

    if (!(new_location[0] >= new_max_point[0] || new_location[1] >= new_max_point[1])) {
      // intersecting-cases
      intersection_rect.area = Math.sqrt(intersection_rect.width * intersection_rect.height);
    }

    return intersection_rect;
  }


  /**
   * Find selectionStart/selectionEnd/textLength for contenteditable element
   * @function getTextSelection
   * @param contenteditable {Element} - The contenteditable element
   * @returns {TextSelection}
   *
   * @typeof {Object} TextSelection
   * @property {Number} TextSelection.selectionStart - 0 if at start, 1 if at end, NaN if between start and end
   * @property {Number} TextSelection.selectionEnd - 0 if at start, 1 if at end, NaN if between start and end
   * @property {Number} TextSelection.textLength - 0 if empty, 1 if not empty
   */
  function getTextSelection(contenteditable) {
    // The method is based on the Selection#modify
    var selection = window.getSelection();
    var compareCaretPositons = function (node1, offset1, node2, offset2) {
      var tmpRange1 = document.createRange();
      tmpRange1.setStart(node1, offset1);
      var tmpRange2 = document.createRange();
      tmpRange2.setStart(node2, offset2);
      return tmpRange1.compareBoundaryPoints(Range.START_TO_START, tmpRange2);
    };
    var anchorNode = selection.anchorNode;
    var anchorOffset = selection.anchorOffset;
    var focusNode = selection.focusNode;
    var focusOffset = selection.focusOffset;
    var forward = compareCaretPositons(anchorNode, anchorOffset, focusNode, focusOffset) < 0;
    var canMove = function (node, offset, direction) {
      selection.setBaseAndExtent(node, offset, node, offset);
      selection.modify('move', direction, 'character');
      return selection.anchorNode !== node ||
             selection.anchorOffset !== offset ||
             selection.focusNode !== node ||
             selection.focusOffset !== offset;
    };
    var atStart = !canMove(forward ? anchorNode : focusNode, forward ? anchorOffset : focusOffset, 'backward');
    var atEnd = !canMove(forward ? focusNode : anchorNode, forward ? focusOffset : anchorOffset, 'forward');
    var collapsed = anchorNode === focusNode && anchorOffset === focusOffset;
    selection.setBaseAndExtent(anchorNode, anchorOffset, focusNode, focusOffset);
    var textLength = atStart && atEnd && collapsed ? 0 : 1;
    if (textLength === 0) {
      return {
        selectionStart: 0,
        selectionEnd: 0,
        textLength: 0
      };
    }
    return {
      selectionStart: (atStart ? 0 : (atEnd && collapsed ? 1 : 0/0)),
      selectionEnd: (atEnd ? 1 : (atStart && collapsed ? 0 : 0/0)),
      textLength: 1
    };
  }


  /**
   * Handle the spatial navigation behavior for HTMLInputElement, HTMLTextAreaElement
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input|HTMLInputElement (MDN)}
   * @function handlingEditableElement
   * @param e {Event} - keydownEvent
   * @returns {boolean}
   */


  function handlingEditableElement(e) {
    var SPINNABLE_INPUT_TYPES = ['email', 'date', 'month', 'number', 'time', 'week'],
        TEXT_INPUT_TYPES = ['password', 'text', 'search', 'tel', 'url', null];
    var eventTarget = document.activeElement;
    var textSelection = eventTarget.hasAttribute('contenteditable') ? getTextSelection(eventTarget) : eventTarget;
    var startPosition = textSelection.selectionStart;
    var endPosition = textSelection.selectionEnd;
    var textLength  = 'textLength' in textSelection ? textSelection.textLength : eventTarget.value.length;
    var focusNavigableArrowKey = {
      left: false,
      up: false,
      right: false,
      down: false
    };
    var dir = ARROW_KEY_CODE[e.keyCode];

    if (dir === undefined) {
      return focusNavigableArrowKey;
    }

    if (SPINNABLE_INPUT_TYPES.includes(eventTarget.getAttribute('type')) && (dir === 'up' || dir === 'down')) {
      focusNavigableArrowKey[dir] = true;
    } else if (TEXT_INPUT_TYPES.includes(eventTarget.getAttribute('type')) || eventTarget.nodeName === 'TEXTAREA' || eventTarget.hasAttribute('contenteditable')) {
      if (startPosition === endPosition) {
        // if there isn't any selected text
        if (startPosition === 0) {
          focusNavigableArrowKey.left = true;
          focusNavigableArrowKey.up = true;
        }

        if (endPosition === textLength) {
          focusNavigableArrowKey.right = true;
          focusNavigableArrowKey.down = true;
        }
      }
    } else {
      // HTMLDataListElement, HTMLSelectElement, HTMLOptGroup
      focusNavigableArrowKey[dir] = true;
    }

    return focusNavigableArrowKey;
  }
  /**
   * Get the DOMRect of an element
   * @function getBoundingClientRect
   * @param {Node} element 
   * @returns {DOMRect}
   */


  function getBoundingClientRect(element) {
    var round = function (number) {
      return Math.floor(number * 100 + 0.5) / 100;
    };
    // memoization
    var rect = mapOfBoundRect && mapOfBoundRect.get(element);

    if (!rect) {
      var boundingClientRect = element.getBoundingClientRect();
      rect = {
        top: round(boundingClientRect.top),
        right: round(boundingClientRect.right),
        bottom: round(boundingClientRect.bottom),
        left: round(boundingClientRect.left),
        width: round(boundingClientRect.width),
        height: round(boundingClientRect.height)
      };
      mapOfBoundRect && mapOfBoundRect.set(element, rect);
    }

    return rect;
  }
  /**
   * Get the candidates which is fully inside the target element in visual
   * @param {Node} targetElement
   * @returns {sequence<Node>}  overlappedCandidates
   */


  function getOverlappedCandidates(targetElement) {
    var container = targetElement.getSpatialNavigationContainer();
    var candidates = container.focusableAreas();
    var overlappedCandidates = [];
    candidates.forEach(function (element) {
      if (targetElement !== element && isEntirelyVisible(element, targetElement)) {
        overlappedCandidates.push(element);
      }
    });
    return overlappedCandidates;
  }
  /**
   * Get the list of the experimental APIs
   * @function getExperimentalAPI
   */


  function getExperimentalAPI() {
    function canScroll(container, dir) {
      return isScrollable(container, dir) && !isScrollBoundary(container, dir) || !container.parentElement && !isHTMLScrollBoundary(container, dir);
    }

    function findTarget(findCandidate, element, dir, option) {
      var eventTarget = element;
      var bestNextTarget = null; // 4

      if (eventTarget === document || eventTarget === document.documentElement) {
        eventTarget = document.body || document.documentElement;
      } // 5
      // At this point, spatialNavigationSearch can be applied.
      // If startingPoint is either a scroll container or the document,
      // find the best candidate within startingPoint


      if ((isContainer(eventTarget) || eventTarget.nodeName === 'BODY') && !(eventTarget.nodeName === 'INPUT')) {
        if (eventTarget.nodeName === 'IFRAME') eventTarget = eventTarget.contentDocument.body;
        var candidates = getSpatialNavigationCandidates(eventTarget, option); // 5-2

        if (Array.isArray(candidates) && candidates.length > 0) {
          return findCandidate ? getFilteredSpatialNavigationCandidates(eventTarget, dir, candidates) : eventTarget.spatialNavigationSearch(dir, {
            candidates: candidates
          });
        }

        if (canScroll(eventTarget, dir)) {
          return findCandidate ? [] : eventTarget;
        }
      } // 6
      // Let container be the nearest ancestor of eventTarget


      var container = eventTarget.getSpatialNavigationContainer();
      var parentContainer = container.parentElement ? container.getSpatialNavigationContainer() : null; // When the container is the viewport of a browsing context

      if (!parentContainer && window.location !== window.parent.location) {
        parentContainer = window.parent.document.documentElement;
      } // 7


      while (parentContainer) {
        var _candidates = filteredCandidates(eventTarget, getSpatialNavigationCandidates(container, option), dir, container);

        if (Array.isArray(_candidates) && _candidates.length > 0) {
          bestNextTarget = eventTarget.spatialNavigationSearch(dir, {
            candidates: _candidates,
            container: container
          });

          if (bestNextTarget) {
            return findCandidate ? _candidates : bestNextTarget;
          }
        } // If there isn't any candidate and the best candidate among candidate:
        // 1) Scroll or 2) Find candidates of the ancestor container
        // 8 - if
        else if (canScroll(container, dir)) {
            return findCandidate ? [] : eventTarget;
          } else if (container === document || container === document.documentElement) {
            container = window.document.documentElement; // The page is in an iframe

            if (window.location !== window.parent.location) {
              // eventTarget needs to be reset because the position of the element in the IFRAME
              // is unuseful when the focus moves out of the iframe
              eventTarget = window.frameElement;
              container = window.parent.document.documentElement;
              if (container.parentElement) parentContainer = container.getSpatialNavigationContainer();else {
                parentContainer = null;
                break;
              }
            }
          } else {
            // avoiding when spatnav container with tabindex=-1
            if (isFocusable(container)) {
              eventTarget = container;
            }

            container = parentContainer;
            if (container.parentElement) parentContainer = container.getSpatialNavigationContainer();else {
              parentContainer = null;
              break;
            }
          }
      }

      if (!parentContainer && container) {
        // Getting out from the current spatnav container
        var _candidates2 = filteredCandidates(eventTarget, getSpatialNavigationCandidates(container, option), dir, container); // 9


        if (Array.isArray(_candidates2) && _candidates2.length > 0) {
          bestNextTarget = eventTarget.spatialNavigationSearch(dir, {
            candidates: _candidates2,
            container: container
          });

          if (bestNextTarget) {
            return findCandidate ? _candidates2 : bestNextTarget;
          }
        }
      }

      if (canScroll(container, dir)) {
        bestNextTarget = eventTarget;
        return bestNextTarget;
      }
    }

    return {
      isContainer: isContainer,
      isScrollContainer: isScrollContainer,
      isVisibleInScroller: isVisibleInScroller,
      findCandidates: findTarget.bind(null, true),
      findNextTarget: findTarget.bind(null, false),
      getDistanceFromTarget: function getDistanceFromTarget(element, candidateElement, dir) {
        if ((isContainer(element) || element.nodeName === 'BODY') && !(element.nodeName === 'INPUT')) {
          if (getSpatialNavigationCandidates(element).includes(candidateElement)) {
            return getInnerDistance(getBoundingClientRect(element), getBoundingClientRect(candidateElement), dir);
          }
        }

        return getDistance(getBoundingClientRect(element), getBoundingClientRect(candidateElement), dir);
      }
    };
  }
  /**
   * Makes to use the experimental APIs.
   * @function enableExperimentalAPIs
   * @param option {boolean} - If it is true, the experimental APIs can be used or it cannot.
   */


  function enableExperimentalAPIs(option) {
    var currentKeyMode = window.__spatialNavigation__ && window.__spatialNavigation__.keyMode;
    window.__spatialNavigation__ = option === false ? getInitialAPIs() : Object.assign(getInitialAPIs(), getExperimentalAPI());
    window.__spatialNavigation__.keyMode = currentKeyMode;
    Object.seal(window.__spatialNavigation__);
  }
  /**
   * Set the environment for using the spatial navigation polyfill.
   * @function getInitialAPIs
   */


  function getInitialAPIs() {
    return {
      enableExperimentalAPIs: enableExperimentalAPIs,

//      get keyMode() {
//        return this._keymode ? this._keymode : 'ARROW';
//      },

//      set keyMode(mode) {
//        this._keymode = ['SHIFTARROW', 'ARROW', 'NONE'].includes(mode) ? mode : 'ARROW';
//      },

      setStartingPoint: function setStartingPoint(x, y) {
        startingPoint = x && y ? {
          x: x,
          y: y
        } : null;
      }
    };
  }

  initiateSpatialNavigation();
  enableExperimentalAPIs(false);
  window.__spatialNavigation__.keyMode = "SHIFTARROW";
  window.addEventListener('load', function () {
    spatialNavigationHandler();
  }, {once: true});
})();

